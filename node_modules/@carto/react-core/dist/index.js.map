{"version":3,"file":"index.js","mappings":"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","sources":["webpack://cartoReactCore/webpack/universalModuleDefinition","webpack://cartoReactCore/external umd \"@turf/bbox-polygon\"","webpack://cartoReactCore/external umd \"@turf/boolean-intersects\"","webpack://cartoReactCore/external umd \"@turf/boolean-within\"","webpack://cartoReactCore/external umd \"@turf/intersect\"","webpack://cartoReactCore/webpack/bootstrap","webpack://cartoReactCore/webpack/runtime/compat get default export","webpack://cartoReactCore/webpack/runtime/define property getters","webpack://cartoReactCore/webpack/runtime/hasOwnProperty shorthand","webpack://cartoReactCore/webpack/runtime/make namespace object","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://cartoReactCore/./src/utils/requestsUtils.js","webpack://cartoReactCore/./src/utils/dateUtils.js","webpack://cartoReactCore/./src/utils/debounce.js","webpack://cartoReactCore/./src/utils/throttle.js","webpack://cartoReactCore/./src/utils/randomString.js","webpack://cartoReactCore/./src/utils/makeIntervalComplete.js","webpack://cartoReactCore/./src/operations/aggregation/AggregationTypes.js","webpack://cartoReactCore/./src/operations/aggregation/values.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://cartoReactCore/./src/operations/groupby.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://cartoReactCore/../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://cartoReactCore/./src/operations/histogram.js","webpack://cartoReactCore/./src/operations/scatterPlot.js","webpack://cartoReactCore/./src/filters/FilterTypes.js","webpack://cartoReactCore/./src/filters/FilterQueryBuilder.js","webpack://cartoReactCore/./src/filters/Filter.js","webpack://cartoReactCore/../../node_modules/@deck.gl/carto/dist/esm/api/maps-api-common.js","webpack://cartoReactCore/../../node_modules/@math.gl/web-mercator/dist/esm/assert.js","webpack://cartoReactCore/../../node_modules/@math.gl/web-mercator/dist/esm/math-utils.js","webpack://cartoReactCore/../../node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js","webpack://cartoReactCore/./src/utils/transformToTileCoords.js","webpack://cartoReactCore/../../node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js","webpack://cartoReactCore/./src/filters/tileFeatures.js","webpack://cartoReactCore/./src/filters/geojsonFeatures.js","webpack://cartoReactCore/./src/operations/GroupDateTypes.js","webpack://cartoReactCore/./src/operations/groupByDate.js","webpack://cartoReactCore/./src/utils/featureSelectionConstants.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@turf/bbox-polygon\"), require(\"@turf/boolean-intersects\"), require(\"@turf/boolean-within\"), require(\"@turf/intersect\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@turf/bbox-polygon\", \"@turf/boolean-intersects\", \"@turf/boolean-within\", \"@turf/intersect\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cartoReactCore\"] = factory(require(\"@turf/bbox-polygon\"), require(\"@turf/boolean-intersects\"), require(\"@turf/boolean-within\"), require(\"@turf/intersect\"));\n\telse\n\t\troot[\"cartoReactCore\"] = factory(root[\"@turf/bbox-polygon\"], root[\"@turf/boolean-intersects\"], root[\"@turf/boolean-within\"], root[\"@turf/intersect\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__855__, __WEBPACK_EXTERNAL_MODULE__97__, __WEBPACK_EXTERNAL_MODULE__55__, __WEBPACK_EXTERNAL_MODULE__956__) {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__855__;","module.exports = __WEBPACK_EXTERNAL_MODULE__97__;","module.exports = __WEBPACK_EXTERNAL_MODULE__55__;","module.exports = __WEBPACK_EXTERNAL_MODULE__956__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/**\n * Threshold to use GET requests, vs POST\n */\nexport const REQUEST_GET_MAX_URL_LENGTH = 2048;\n\n/**\n * Simple GET request\n */\nexport function getRequest(url, opts) {\n  return new Request(url, {\n    method: 'GET',\n    headers: {\n      Accept: 'application/json'\n    },\n    ...opts\n  });\n}\n\n/**\n * Simple POST request\n */\nexport function postRequest(url, payload, opts) {\n  return new Request(url, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload),\n    ...opts\n  });\n}\n\n/**\n * Simple encode parameter\n */\nexport function encodeParameter(name, value) {\n  return `${name}=${encodeURIComponent(value)}`;\n}\n","export function getMonday(date) {\n  const dateCp = new Date(date);\n  const day = dateCp.getDay();\n  const diff = dateCp.getDate() - day + (day ? 1 : -6); // adjust when day is sunday\n  dateCp.setDate(diff);\n  return Date.UTC(dateCp.getUTCFullYear(), dateCp.getUTCMonth(), dateCp.getUTCDate());\n}\n","export function debounce(fn, ms) {\n  let timer;\n  return (...args) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      timer = null;\n      fn.apply(this, args);\n    }, ms);\n    return timer;\n  };\n}\n","export function throttle(fn, ms) {\n  var lastTime = 0;\n  return function () {\n    var now = new Date();\n    if (now - lastTime >= ms) {\n      fn();\n      lastTime = now;\n    }\n  };\n}\n","export function randomString(length) {\n  let text = '';\n  const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  for (let i = 0; i < length; i++) {\n    text += possible.charAt(Math.floor(Math.random() * possible.length));\n  }\n  return text;\n}\n","export function makeIntervalComplete(values) {\n  return values.map((val) => {\n    if (val[0] === undefined) {\n      return [Number.MIN_SAFE_INTEGER, val[1]];\n    }\n\n    if (val[1] === undefined) {\n      return [val[0], Number.MAX_SAFE_INTEGER];\n    }\n\n    return val;\n  });\n}\n","/**\n * Enum for the different types of aggregations available for widgets\n * @enum {string}\n * @readonly\n */\nexport const AggregationTypes = Object.freeze({\n  /** Count */\n  COUNT: 'count',\n\n  /** Average */\n  AVG: 'avg',\n\n  /** Minimum */\n  MIN: 'min',\n\n  /** Maximum */\n  MAX: 'max',\n\n  /** Sum */\n  SUM: 'sum'\n});\n","import { AggregationTypes } from './AggregationTypes';\n\nconst sum = (values, key) => {\n  const fn = key ? (a, b) => a + b[key] : (a, b) => a + b;\n  return values.reduce(fn, 0);\n};\n\nconst min = (values, key) => {\n  const fn = key ? (a, b) => Math.min(a, b[key]) : (a, b) => Math.min(a, b);\n  return values.reduce(fn, Infinity);\n};\n\nconst max = (values, key) => {\n  const fn = key ? (a, b) => Math.max(a, b[key]) : (a, b) => Math.max(a, b);\n  return values.reduce(fn, -Infinity);\n};\n\nexport const aggregationFunctions = {\n  [AggregationTypes.COUNT]: (values) => values.length,\n  [AggregationTypes.MIN]: (values, key) => min(values, key),\n  [AggregationTypes.MAX]: (values, key) => max(values, key),\n  [AggregationTypes.SUM]: (values, key) => sum(values, key),\n  [AggregationTypes.AVG]: (values, key) => sum(values, key) / (values.length || 1)\n};\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { AggregationTypes } from './aggregation/AggregationTypes';\nimport { aggregationFunctions } from './aggregation/values';\n\nexport function groupValuesByColumn(data, valuesColumn, keysColumn, operation) {\n  if (Array.isArray(data) && data.length === 0) {\n    return null;\n  }\n\n  const groups = data.reduce((accumulator, item) => {\n    const group = item[keysColumn];\n\n    accumulator[group] = accumulator[group] || [];\n\n    const isValid =\n      (operation === AggregationTypes.COUNT ? true : item[valuesColumn] !== null) &&\n      item[valuesColumn] !== undefined;\n\n    if (isValid) {\n      accumulator[group].push(item[valuesColumn]);\n    }\n\n    return accumulator;\n  }, {});\n\n  const targetOperation = aggregationFunctions[operation];\n\n  if (targetOperation) {\n    return Object.entries(groups).map(([name, value]) => ({\n      name,\n      value: targetOperation(value)\n    }));\n  }\n\n  return [];\n}\n","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { aggregationFunctions } from './aggregation/values';\n\nexport function histogram(features, columnName, ticks, operation) {\n  if (Array.isArray(features) && features.length === 0) {\n    return [];\n  }\n\n  ticks = [Number.MIN_SAFE_INTEGER, ...ticks];\n\n  const binsContainer = ticks.map((tick, index, arr) => ({\n    bin: index,\n    start: tick,\n    end: index === arr.length - 1 ? Number.MAX_SAFE_INTEGER : arr[index + 1],\n    values: []\n  }));\n\n  features.forEach((feature) => {\n    const featureValue = feature[columnName];\n\n    const isValid = featureValue !== null && featureValue !== undefined;\n\n    if (!isValid) {\n      return;\n    }\n\n    const binContainer = binsContainer.find(\n      (bin) => bin.start <= featureValue && bin.end > featureValue\n    );\n\n    if (!binContainer) {\n      return;\n    }\n\n    binContainer.values.push(featureValue);\n  });\n\n  const targetOperation = aggregationFunctions[operation];\n\n  if (targetOperation) {\n    const transformedBins = binsContainer.map((binContainer) => binContainer.values);\n    return transformedBins.map((values) => (values.length ? targetOperation(values) : 0));\n  }\n\n  return [];\n}\n","/**\n * Filters invalid features and formats  data\n */\nexport const scatterPlot = (features, xAxisColumn, yAxisColumn) =>\n  features\n    .filter((feature) => {\n      const xValue = feature[xAxisColumn];\n      const xIsValid = xValue !== null && xValue !== undefined;\n      const yValue = feature[yAxisColumn];\n      const yIsValid = yValue !== null && yValue !== undefined;\n      return xIsValid && yIsValid;\n    })\n    .map((feature) => [feature[xAxisColumn], feature[yAxisColumn]]);\n","import { makeIntervalComplete } from '../utils/makeIntervalComplete';\n\nexport const FilterTypes = Object.freeze({\n  IN: 'in',\n  BETWEEN: 'between', // [a, b] both are included\n  CLOSED_OPEN: 'closed_open', // [a, b) a is included, b is not\n  TIME: 'time',\n  STRING_SEARCH: 'stringSearch'\n});\n\nexport const filterFunctions = {\n  [FilterTypes.IN](filterValues, featureValue) {\n    return filterValues.includes(featureValue);\n  },\n  [FilterTypes.BETWEEN]: between,\n  [FilterTypes.TIME](filterValues, featureValue) {\n    const featureValueAsTimestamp = new Date(featureValue).getTime();\n    if (isFinite(featureValueAsTimestamp)) {\n      return between(filterValues, featureValueAsTimestamp);\n    } else {\n      throw new Error(`Column used to filter by time isn't well formatted.`);\n    }\n  },\n  [FilterTypes.CLOSED_OPEN]: closedOpen,\n  [FilterTypes.STRING_SEARCH]: stringSearch\n};\n\n// FilterTypes.BETWEEN\nfunction between(filterValues, featureValue) {\n  const checkRange = (range) => {\n    const [lowerBound, upperBound] = range;\n    return featureValue >= lowerBound && featureValue <= upperBound;\n  };\n\n  return makeIntervalComplete(filterValues).some(checkRange);\n}\n\n// FilterTypes.CLOSED_OPEN\nfunction closedOpen(filterValues, featureValue) {\n  const checkRange = (range) => {\n    const [lowerBound, upperBound] = range;\n    return featureValue >= lowerBound && featureValue < upperBound;\n  };\n\n  return makeIntervalComplete(filterValues).some(checkRange);\n}\n\n// FilterTypes.STRING_SEARCH\nfunction stringSearch(filterValues, featureValue, params = {}) {\n  const normalizedFeatureValue = normalize(featureValue, params);\n  const stringRegExp = filterValues\n    .map((filterValue) => {\n      let stringRegExp = escapeRegExp(normalize(filterValue, params));\n\n      if (params.mustStart) stringRegExp = `^${stringRegExp}`;\n      if (params.mustEnd) stringRegExp = `${stringRegExp}$`;\n\n      return stringRegExp;\n    })\n    .join('|');\n\n  const regex = new RegExp(stringRegExp, 'g');\n  return !!normalizedFeatureValue.match(regex);\n}\n\n// Aux\nconst specialCharRegExp = /[.*+?^${}()|[\\]\\\\]/g;\nconst normalizeRegExp = /\\p{Diacritic}/gu;\n\nfunction escapeRegExp(value) {\n  return value.replace(specialCharRegExp, '\\\\$&');\n}\n\nfunction normalize(data, params) {\n  let normalizedData = '' + data;\n\n  if (!params.caseSensitive) normalizedData = normalizedData.toLocaleLowerCase();\n  if (!params.keepSpecialCharacters)\n    normalizedData = normalizedData.normalize('NFD').replace(normalizeRegExp, '');\n\n  return normalizedData;\n}\n","import { FilterTypes } from './FilterTypes';\n\nexport const getApplicableFilters = (filters = {}, owner) => {\n  const filtersCopy = {};\n  Object.entries(filters).forEach(([column, filter]) => {\n    const filterCopy = {};\n    Object.keys(filter)\n      .filter((operator) => filter[operator].owner !== owner)\n      .forEach((operator) => (filterCopy[operator] = { ...filter[operator] }));\n\n    if (Object.keys(filterCopy).length) {\n      filtersCopy[column] = filterCopy;\n    }\n  });\n\n  return filtersCopy;\n};\n\nexport const filtersToSQL = (filters = {}) => {\n  const result = [];\n\n  Object.entries(filters).forEach(([column, filter]) => {\n    Object.entries(filter).forEach(([operator, params]) => {\n      switch (operator) {\n        case FilterTypes.IN:\n          result.push(\n            `${column} ${operator}(${params.values\n              .map((v) => (isFinite(v) ? v : `'${v}'`))\n              .join(',')})`\n          );\n          break;\n        case FilterTypes.BETWEEN:\n          result.push(\n            `(${params.values\n              .map(\n                ([left, right]) =>\n                  `${left ? `${column} >= ${left}` : ``} ${\n                    left && right ? ' and ' : ''\n                  } ${right ? `${column} < ${right}` : ``}`\n              )\n              .join(') OR (')})`\n          );\n          break;\n        default:\n          throw new Error(`Not valid operator has provided: ${operator}`);\n      }\n    });\n  });\n\n  return result.length ? `WHERE (${result.join(') AND (')})` : '';\n};\n","import { filterFunctions } from './FilterTypes';\n\nfunction passesFilter(columns, filters, feature) {\n  return columns.every((column) => {\n    const columnFilters = filters[column];\n    const columnFilterTypes = Object.keys(columnFilters);\n\n    if (!feature || feature[column] === null || feature[column] === undefined) {\n      return false;\n    }\n\n    return columnFilterTypes.every((filter) => {\n      const filterFunction = filterFunctions[filter];\n\n      if (!filterFunction) {\n        throw new Error(`\"${filter}\" filter is not implemented.`);\n      }\n\n      return filterFunction(\n        columnFilters[filter].values,\n        feature[column],\n        columnFilters[filter].params\n      );\n    });\n  });\n}\n\nexport function buildFeatureFilter({ filters = {}, type = 'boolean' }) {\n  const columns = Object.keys(filters);\n\n  if (!columns.length) {\n    return () => (type === 'number' ? 1 : true);\n  }\n\n  return (feature) => {\n    const f = feature.properties || feature;\n    const featurePassesFilter = passesFilter(columns, filters, f);\n\n    return type === 'number' ? Number(featurePassesFilter) : featurePassesFilter;\n  };\n}\n\n// Apply certain filters to a collection of features\nexport function applyFilters(features, filters) {\n  return Object.keys(filters).length\n    ? features.filter(buildFeatureFilter({ filters }))\n    : features;\n}\n\n// Binary\nexport function buildBinaryFeatureFilter({ filters = {} }) {\n  const columns = Object.keys(filters);\n\n  if (!columns.length) {\n    return () => 1;\n  }\n\n  return (featureIdIdx, binaryData) =>\n    passesFilterUsingBinary(columns, filters, featureIdIdx, binaryData);\n}\n\nfunction getValueFromNumericProps(featureIdIdx, binaryData, { column }) {\n  return binaryData.numericProps[column]?.value[featureIdIdx];\n}\n\nfunction getValueFromProperties(featureIdIdx, binaryData, { column }) {\n  const propertyIdx = binaryData.featureIds.value[featureIdIdx];\n  return binaryData.properties[propertyIdx]?.[column];\n}\n\nconst GET_VALUE_BY_BINARY_PROP = {\n  properties: getValueFromProperties,\n  numericProps: getValueFromNumericProps\n};\n\nfunction getBinaryPropertyByFilterValues(filterValues) {\n  return typeof filterValues.flat()[0] === 'string' ? 'properties' : 'numericProps';\n}\n\nfunction getFeatureValue(featureIdIdx, binaryData, filter) {\n  const { column, values } = filter;\n  const binaryProp = getBinaryPropertyByFilterValues(values);\n  const getFeatureValueFn = GET_VALUE_BY_BINARY_PROP[binaryProp];\n  return getFeatureValueFn(featureIdIdx, binaryData, { column });\n}\n\nfunction passesFilterUsingBinary(columns, filters, featureIdIdx, binaryData) {\n  return columns.every((column) => {\n    const columnFilters = filters[column];\n\n    return Object.entries(columnFilters).every(([type, { values }]) => {\n      const filterFn = filterFunctions[type];\n      if (!filterFn) {\n        throw new Error(`\"${type}\" filter is not implemented.`);\n      }\n\n      if (!values) return 0;\n\n      const featureValue = getFeatureValue(featureIdIdx, binaryData, {\n        column,\n        type,\n        values\n      });\n\n      if (featureValue === undefined || featureValue === null) return 0;\n\n      return filterFn(values, featureValue);\n    });\n  });\n}\n","export const DEFAULT_USER_COMPONENT_IN_URL = '{user}';\nexport const DEFAULT_REGION_COMPONENT_IN_URL = '{region}';\nexport const API_VERSIONS = {\n  V1: 'v1',\n  V2: 'v2',\n  V3: 'v3'\n};\nexport const DEFAULT_MAPS_URL_FORMAT = {\n  [API_VERSIONS.V1]: \"https://\".concat(DEFAULT_USER_COMPONENT_IN_URL, \".carto.com/api/v1/map\"),\n  [API_VERSIONS.V2]: \"https://maps-api-v2.\".concat(DEFAULT_REGION_COMPONENT_IN_URL, \".carto.com/user/\").concat(DEFAULT_USER_COMPONENT_IN_URL)\n};\nexport const MAP_TYPES = {\n  QUERY: 'query',\n  TABLE: 'table',\n  TILESET: 'tileset'\n};\nexport const FORMATS = {\n  GEOJSON: 'geojson',\n  NDJSON: 'ndjson',\n  TILEJSON: 'tilejson',\n  JSON: 'json'\n};\nexport const TILE_FORMATS = {\n  MVT: 'mvt',\n  GEOJSON: 'geojson',\n  BINARY: 'binary'\n};\nexport let SchemaFieldType;\n\n(function (SchemaFieldType) {\n  SchemaFieldType[\"Number\"] = \"number\";\n  SchemaFieldType[\"Bigint\"] = \"bigint\";\n  SchemaFieldType[\"String\"] = \"string\";\n  SchemaFieldType[\"Geometry\"] = \"geometry\";\n  SchemaFieldType[\"Timestamp\"] = \"timestamp\";\n  SchemaFieldType[\"Object\"] = \"object\";\n  SchemaFieldType[\"Boolean\"] = \"boolean\";\n  SchemaFieldType[\"Variant\"] = \"variant\";\n  SchemaFieldType[\"Unknown\"] = \"unknown\";\n})(SchemaFieldType || (SchemaFieldType = {}));\n\nexport function encodeParameter(name, value) {\n  return \"\".concat(name, \"=\").concat(encodeURIComponent(value));\n}\n//# sourceMappingURL=maps-api-common.js.map","export default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || '@math.gl/web-mercator: assertion failed.');\n  }\n}\n//# sourceMappingURL=assert.js.map","import * as vec4 from 'gl-matrix/vec4';\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nexport function transformVector(matrix, vector) {\n  const result = vec4.transformMat4([], vector, matrix);\n  vec4.scale(result, result, 1 / result[3]);\n  return result;\n}\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\nexport function lerp(start, end, step) {\n  return step * end + (1 - step) * start;\n}\nexport function clamp(x, min, max) {\n  return x < min ? min : x > max ? max : x;\n}\n\nfunction ieLog2(x) {\n  return Math.log(x) * Math.LOG2E;\n}\n\nexport const log2 = Math.log2 || ieLog2;\n//# sourceMappingURL=math-utils.js.map","import { createMat4, transformVector, log2 } from './math-utils';\nimport * as mat4 from 'gl-matrix/mat4';\nimport * as vec2 from 'gl-matrix/vec2';\nimport * as vec3 from 'gl-matrix/vec3';\nimport assert from './assert';\nconst PI = Math.PI;\nconst PI_4 = PI / 4;\nconst DEGREES_TO_RADIANS = PI / 180;\nconst RADIANS_TO_DEGREES = 180 / PI;\nconst TILE_SIZE = 512;\nconst EARTH_CIRCUMFERENCE = 40.03e6;\nexport const MAX_LATITUDE = 85.051129;\nexport const DEFAULT_ALTITUDE = 1.5;\nexport function zoomToScale(zoom) {\n  return Math.pow(2, zoom);\n}\nexport function scaleToZoom(scale) {\n  return log2(scale);\n}\nexport function lngLatToWorld([lng, lat]) {\n  assert(Number.isFinite(lng));\n  assert(Number.isFinite(lat) && lat >= -90 && lat <= 90, 'invalid latitude');\n  const lambda2 = lng * DEGREES_TO_RADIANS;\n  const phi2 = lat * DEGREES_TO_RADIANS;\n  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);\n  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\nexport function worldToLngLat([x, y]) {\n  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;\n  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\nexport function getMeterZoom({\n  latitude\n}) {\n  assert(Number.isFinite(latitude));\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;\n}\nexport function getDistanceScales({\n  latitude,\n  longitude,\n  highPrecision = false\n}) {\n  assert(Number.isFinite(latitude) && Number.isFinite(longitude));\n  const result = {};\n  const worldSize = TILE_SIZE;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  const unitsPerDegreeX = worldSize / 360;\n  const unitsPerDegreeY = unitsPerDegreeX / latCosine;\n  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  result.unitsPerMeter = [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter];\n  result.metersPerUnit = [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter];\n  result.unitsPerDegree = [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter];\n  result.degreesPerUnit = [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter];\n\n  if (highPrecision) {\n    const latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;\n    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;\n    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];\n    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];\n  }\n\n  return result;\n}\nexport function addMetersToLngLat(lngLatZ, xyz) {\n  const [longitude, latitude, z0] = lngLatZ;\n  const [x, y, z] = xyz;\n  const {\n    unitsPerMeter,\n    unitsPerMeter2\n  } = getDistanceScales({\n    longitude,\n    latitude,\n    highPrecision: true\n  });\n  const worldspace = lngLatToWorld(lngLatZ);\n  worldspace[0] += x * (unitsPerMeter[0] + unitsPerMeter2[0] * y);\n  worldspace[1] += y * (unitsPerMeter[1] + unitsPerMeter2[1] * y);\n  const newLngLat = worldToLngLat(worldspace);\n  const newZ = (z0 || 0) + (z || 0);\n  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;\n}\nexport function getViewMatrix({\n  height,\n  pitch,\n  bearing,\n  altitude,\n  scale,\n  center = null\n}) {\n  const vm = createMat4();\n  mat4.translate(vm, vm, [0, 0, -altitude]);\n  mat4.rotateX(vm, vm, -pitch * DEGREES_TO_RADIANS);\n  mat4.rotateZ(vm, vm, bearing * DEGREES_TO_RADIANS);\n  scale /= height;\n  mat4.scale(vm, vm, [scale, scale, scale]);\n\n  if (center) {\n    mat4.translate(vm, vm, vec3.negate([], center));\n  }\n\n  return vm;\n}\nexport function getProjectionParameters({\n  width,\n  height,\n  fovy = altitudeToFovy(DEFAULT_ALTITUDE),\n  altitude,\n  pitch = 0,\n  nearZMultiplier = 1,\n  farZMultiplier = 1\n}) {\n  if (altitude !== undefined) {\n    fovy = altitudeToFovy(altitude);\n  }\n\n  const halfFov = 0.5 * fovy * DEGREES_TO_RADIANS;\n  const focalDistance = fovyToAltitude(fovy);\n  const pitchRadians = pitch * DEGREES_TO_RADIANS;\n  const topHalfSurfaceDistance = Math.sin(halfFov) * focalDistance / Math.sin(Math.min(Math.max(Math.PI / 2 - pitchRadians - halfFov, 0.01), Math.PI - 0.01));\n  const farZ = Math.sin(pitchRadians) * topHalfSurfaceDistance + focalDistance;\n  return {\n    fov: 2 * halfFov,\n    aspect: width / height,\n    focalDistance,\n    near: nearZMultiplier,\n    far: farZ * farZMultiplier\n  };\n}\nexport function getProjectionMatrix({\n  width,\n  height,\n  pitch,\n  altitude,\n  fovy,\n  nearZMultiplier,\n  farZMultiplier\n}) {\n  const {\n    fov,\n    aspect,\n    near,\n    far\n  } = getProjectionParameters({\n    width,\n    height,\n    altitude,\n    fovy,\n    pitch,\n    nearZMultiplier,\n    farZMultiplier\n  });\n  const projectionMatrix = mat4.perspective([], fov, aspect, near, far);\n  return projectionMatrix;\n}\nexport function altitudeToFovy(altitude) {\n  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES;\n}\nexport function fovyToAltitude(fovy) {\n  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS);\n}\nexport function worldToPixels(xyz, pixelProjectionMatrix) {\n  const [x, y, z = 0] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));\n  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);\n}\nexport function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {\n  const [x, y, z] = xyz;\n  assert(Number.isFinite(x) && Number.isFinite(y), 'invalid pixel coordinate');\n\n  if (Number.isFinite(z)) {\n    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);\n    return coord;\n  }\n\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);\n  const z0 = coord0[2];\n  const z1 = coord1[2];\n  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);\n  return vec2.lerp([], coord0, coord1, t);\n}\n//# sourceMappingURL=web-mercator-utils.js.map","import { lngLatToWorld } from '@math.gl/web-mercator';\n\n/**\n * Transform WGS84 coordinates to tile coords.\n * It's the inverse of deck.gl coordinate-transform (https://github.com/visgl/deck.gl/blob/master/modules/geo-layers/src/mvt-layer/coordinate-transform.js)\n *\n * @param {object} geometry - any valid geojson geometry\n * @param {{ west: number, east: number, north: number, south: number }} bbox - tile bbox as used in deck.gl\n * @returns {GeoJSON}\n */\nexport default function transformToTileCoords(geometry, bbox) {\n  const nw = projectFlat([bbox.west, bbox.north]);\n  const se = projectFlat([bbox.east, bbox.south]);\n  const projectedBbox = [nw, se];\n\n  const transformFn = availableTransformations[geometry.type];\n  if (!transformFn) {\n    throw new Error(`Unrecognized geometry type ${geometry.type}`);\n  }\n\n  return {\n    ...geometry,\n    coordinates: transformFn(geometry.coordinates, projectedBbox)\n  };\n}\n\nconst availableTransformations = {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n};\n\nfunction Point([pointX, pointY], [nw, se]) {\n  const x = inverseLerp(nw[0], se[0], pointX);\n  const y = inverseLerp(nw[1], se[1], pointY);\n\n  return [x, y];\n}\n\nfunction getPoints(geometry, bbox) {\n  return geometry.map((g) => Point(projectFlat(g), bbox));\n}\n\nfunction MultiPoint(multiPoint, bbox) {\n  return getPoints(multiPoint, bbox);\n}\n\nfunction LineString(line, bbox) {\n  return getPoints(line, bbox);\n}\n\nfunction MultiLineString(multiLineString, bbox) {\n  return multiLineString.map((lineString) => LineString(lineString, bbox));\n}\n\nfunction Polygon(polygon, bbox) {\n  return polygon.map((polygonRing) => getPoints(polygonRing, bbox));\n}\n\nfunction MultiPolygon(multiPolygon, bbox) {\n  return multiPolygon.map((polygon) => Polygon(polygon, bbox));\n}\n\nfunction projectFlat(xyz) {\n  return lngLatToWorld(xyz);\n}\n\nfunction inverseLerp(a, b, x) {\n  return (x - a) / (b - a);\n}\n","import { worldToLngLat } from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\nimport { transformVector } from './math-utils';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nexport default function getBounds(viewport, z = 0) {\n  const {\n    width,\n    height,\n    unproject\n  } = viewport;\n  const unprojectOps = {\n    targetZ: z\n  };\n  const bottomLeft = unproject([0, height], unprojectOps);\n  const bottomRight = unproject([width, height], unprojectOps);\n  let topLeft;\n  let topRight;\n  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS : Math.atan(0.5 / viewport.altitude);\n  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS;\n\n  if (halfFov > angleToGround - 0.01) {\n    topLeft = unprojectOnFarPlane(viewport, 0, z);\n    topRight = unprojectOnFarPlane(viewport, width, z);\n  } else {\n    topLeft = unproject([0, 0], unprojectOps);\n    topRight = unproject([width, 0], unprojectOps);\n  }\n\n  return [bottomLeft, bottomRight, topRight, topLeft];\n}\n\nfunction unprojectOnFarPlane(viewport, x, targetZ) {\n  const {\n    pixelUnprojectionMatrix\n  } = viewport;\n  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);\n  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);\n  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];\n  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);\n  const coord = vec2.lerp([], coord0, coord1, t);\n  const result = worldToLngLat(coord);\n  result[2] = targetZ;\n  return result;\n}\n//# sourceMappingURL=get-bounds.js.map","import { TILE_FORMATS } from '@deck.gl/carto';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport intersects from '@turf/boolean-intersects';\nimport booleanWithin from '@turf/boolean-within';\nimport intersect from '@turf/intersect';\nimport transformToTileCoords from '../utils/transformToTileCoords';\n\nconst GEOMETRY_TYPES = Object.freeze({\n  Point: 0,\n  LineString: 1,\n  Polygon: 2\n});\n\nfunction addIntersectedFeaturesInTile({\n  map,\n  data,\n  geometryIntersection,\n  type,\n  uniqueIdProperty\n}) {\n  const indices = getIndices(data);\n  const { positions } = data;\n\n  for (let i = 0; i < indices.length - 1; i++) {\n    const startIndex = indices[i];\n    const endIndex = indices[i + 1];\n\n    const tileProps = getPropertiesFromTile(data, startIndex);\n    const uniquePropertyValue = getUniquePropertyValue(tileProps, uniqueIdProperty, map);\n\n    if (uniquePropertyValue && !map.has(uniquePropertyValue)) {\n      const ringCoordinates = getRingCoordinatesFor(startIndex, endIndex, positions);\n      if (intersects(getFeatureByType(ringCoordinates, type), geometryIntersection)) {\n        map.set(uniquePropertyValue, parseProperties(tileProps));\n      }\n    }\n  }\n}\n\nfunction getIndices(data) {\n  const indices = data.primitivePolygonIndices || data.pathIndices || data.pointIndices;\n  return indices.value;\n}\n\nfunction getFeatureId(data, startIndex) {\n  return data.featureIds.value[startIndex];\n}\n\nfunction getPropertiesFromTile(data, startIndex) {\n  const featureId = getFeatureId(data, startIndex);\n  const { properties, numericProps } = data;\n  const result = {\n    properties: properties[featureId],\n    numericProps: {}\n  };\n\n  for (const key in numericProps) {\n    result.numericProps[key] = numericProps[key].value[startIndex];\n  }\n\n  return result;\n}\n\nfunction parseProperties(tileProps) {\n  const { properties, numericProps } = tileProps;\n  return Object.assign({}, properties, numericProps);\n}\n\nfunction getUniquePropertyValue(tileProps, uniqueIdProperty, map) {\n  if (uniqueIdProperty) {\n    return getValueFromTileProps(tileProps, uniqueIdProperty);\n  }\n\n  const artificialId = map.size + 1; // a counter, assumed as a valid new id\n  return (\n    getValueFromTileProps(tileProps, 'cartodb_id') ||\n    getValueFromTileProps(tileProps, 'geoid') ||\n    artificialId\n  );\n}\n\nfunction getValueFromTileProps(tileProps, propertyName) {\n  const { properties, numericProps } = tileProps;\n  return numericProps[propertyName] || properties[propertyName];\n}\n\nfunction getFeatureByType(coordinates, type) {\n  switch (type) {\n    case GEOMETRY_TYPES['Polygon']:\n      return { type: 'Polygon', coordinates: [coordinates] };\n    case GEOMETRY_TYPES['LineString']:\n      return { type: 'LineString', coordinates };\n    case GEOMETRY_TYPES['Point']:\n      return { type: 'Point', coordinates: coordinates[0] };\n    default:\n      throw new Error('Invalid geometry type');\n  }\n}\n\nfunction getRingCoordinatesFor(startIndex, endIndex, positions) {\n  const ringCoordinates = [];\n\n  for (let j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(\n      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))\n    );\n  }\n\n  return ringCoordinates;\n}\n\nfunction calculateFeatures({\n  map,\n  tileIsFullyVisible,\n  geometryIntersection,\n  data,\n  type,\n  uniqueIdProperty\n}) {\n  if (!data?.properties.length) {\n    return;\n  }\n\n  if (tileIsFullyVisible) {\n    addAllFeaturesInTile({ map, data, uniqueIdProperty });\n  } else {\n    addIntersectedFeaturesInTile({\n      map,\n      data,\n      geometryIntersection,\n      type,\n      uniqueIdProperty\n    });\n  }\n}\n\nfunction addAllFeaturesInTile({ map, data, uniqueIdProperty }) {\n  const indices = getIndices(data);\n\n  for (let i = 0; i < indices.length - 1; i++) {\n    const startIndex = indices[i];\n\n    const tileProps = getPropertiesFromTile(data, startIndex);\n    const uniquePropertyValue = getUniquePropertyValue(tileProps, uniqueIdProperty, map);\n\n    if (uniquePropertyValue && !map.has(uniquePropertyValue)) {\n      map.set(uniquePropertyValue, parseProperties(tileProps));\n    }\n  }\n}\n\nfunction createIndicesForPoints(data) {\n  const featureIds = data.featureIds.value;\n  const lastFeatureId = featureIds[featureIds.length - 1];\n\n  data.pointIndices = {\n    value: new featureIds.constructor(featureIds.length + 1),\n    size: 1\n  };\n  data.pointIndices.value.set(featureIds);\n  data.pointIndices.value.set([lastFeatureId + 1], featureIds.length);\n}\n\nexport function getGeometryToIntersect(viewport, geometry) {\n  return geometry ? intersect(bboxPolygon(viewport), geometry) : bboxPolygon(viewport);\n}\n\nexport function tileFeatures({\n  tiles,\n  viewport,\n  geometry,\n  uniqueIdProperty,\n  tileFormat\n}) {\n  const map = new Map();\n  const geometryToIntersect = getGeometryToIntersect(viewport, geometry);\n\n  if (!geometryToIntersect) {\n    return [];\n  }\n\n  for (const tile of tiles) {\n    // Discard if it's not a visible tile (only check false value, not undefined)\n    // or tile has not data\n    if (tile.isVisible === false || !tile.data) {\n      continue;\n    }\n\n    const { bbox } = tile;\n    const bboxToGeom = bboxPolygon([bbox.west, bbox.south, bbox.east, bbox.north]);\n    const tileIsFullyVisible = booleanWithin(bboxToGeom, geometryToIntersect);\n    // Clip the geometry to intersect with the tile\n    const clippedGeometryToIntersect = intersect(bboxToGeom, geometryToIntersect);\n\n    if (!clippedGeometryToIntersect) {\n      continue;\n    }\n    // We assume that MVT tileFormat uses local coordinates so we transform the geometry to intersect to tile coordinates [0..1],\n    // while in the case of 'geojson' or binary, the geometries are already in WGS84\n    const transformedGeomtryToIntersect = {\n      type: 'Feature',\n      geometry:\n        tileFormat === TILE_FORMATS.MVT\n          ? transformToTileCoords(clippedGeometryToIntersect.geometry, bbox)\n          : clippedGeometryToIntersect.geometry\n    };\n\n    createIndicesForPoints(tile.data.points);\n\n    calculateFeatures({\n      map,\n      tileIsFullyVisible,\n      geometryIntersection: transformedGeomtryToIntersect,\n      data: tile.data.points,\n      type: GEOMETRY_TYPES['Point'],\n      uniqueIdProperty\n    });\n    calculateFeatures({\n      map,\n      tileIsFullyVisible,\n      geometryIntersection: transformedGeomtryToIntersect,\n      data: tile.data.lines,\n      type: GEOMETRY_TYPES['LineString'],\n      uniqueIdProperty\n    });\n    calculateFeatures({\n      map,\n      tileIsFullyVisible,\n      geometryIntersection: transformedGeomtryToIntersect,\n      data: tile.data.polygons,\n      type: GEOMETRY_TYPES['Polygon'],\n      uniqueIdProperty\n    });\n  }\n  return Array.from(map.values());\n}\n","import intersects from '@turf/boolean-intersects';\nimport { getGeometryToIntersect } from './tileFeatures';\n\nexport function geojsonFeatures({ geojson, viewport, geometry, uniqueIdProperty }) {\n  let uniqueIdx = 0;\n  // Map is used to cache multi geometries. Only a sucessfull intersect by multipolygon\n  const map = new Map();\n  const geometryToIntersect = getGeometryToIntersect(viewport, geometry);\n\n  if (!geometryToIntersect) {\n    return [];\n  }\n\n  for (const feature of geojson.features) {\n    const uniqueId = uniqueIdProperty\n      ? feature.properties[uniqueIdProperty]\n      : ++uniqueIdx;\n    if (!map.has(uniqueId) && intersects(geometryToIntersect, feature)) {\n      map.set(uniqueId, feature.properties);\n    }\n  }\n\n  return Array.from(map.values());\n}\n","/**\n * Enum for the different types of group by date available for widgets\n * @enum {string}\n * @readonly\n */\nexport const GroupDateTypes = Object.freeze({\n  /** Years */\n  YEARS: 'years',\n\n  /** Months */\n  MONTHS: 'months',\n\n  /** Weeks */\n  WEEKS: 'weeks',\n\n  /** Days */\n  DAYS: 'days',\n\n  /** Hours */\n  HOURS: 'hours',\n\n  /** Minutes */\n  MINUTES: 'minutes'\n});\n","import { getMonday } from '../utils/dateUtils';\nimport { aggregationFunctions } from './aggregation/values';\nimport { GroupDateTypes } from './GroupDateTypes';\n\nconst GROUP_KEY_FN_MAPPING = {\n  // @ts-ignore\n  [GroupDateTypes.YEARS]: (date) => Date.UTC(date.getUTCFullYear()),\n  [GroupDateTypes.MONTHS]: (date) => Date.UTC(date.getUTCFullYear(), date.getUTCMonth()),\n  [GroupDateTypes.WEEKS]: (date) => getMonday(date),\n  [GroupDateTypes.DAYS]: (date) =>\n    Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()),\n  [GroupDateTypes.HOURS]: (date) =>\n    Date.UTC(\n      date.getUTCFullYear(),\n      date.getUTCMonth(),\n      date.getUTCDate(),\n      date.getUTCHours()\n    ),\n  [GroupDateTypes.MINUTES]: (date) =>\n    Date.UTC(\n      date.getUTCFullYear(),\n      date.getUTCMonth(),\n      date.getUTCDate(),\n      date.getUTCHours(),\n      date.getUTCMinutes()\n    )\n};\n\nexport function groupValuesByDateColumn(\n  data,\n  valuesColumn,\n  keysColumn,\n  groupType,\n  operation\n) {\n  if (Array.isArray(data) && data.length === 0) {\n    return null;\n  }\n\n  const groupKeyFn = GROUP_KEY_FN_MAPPING[groupType];\n\n  if (!groupKeyFn) {\n    return null;\n  }\n\n  const groups = data.reduce((acc, item) => {\n    const value = item[keysColumn];\n    const formattedValue = new Date(value);\n    const groupKey = groupKeyFn(formattedValue);\n\n    if (!isNaN(groupKey)) {\n      let groupedValues = acc.get(groupKey);\n      if (!groupedValues) {\n        groupedValues = [];\n        acc.set(groupKey, groupedValues);\n      }\n\n      const isValid = item[valuesColumn] !== null && item[valuesColumn] !== undefined;\n\n      if (isValid) {\n        groupedValues.push(item[valuesColumn]);\n        acc.set(groupKey, groupedValues);\n      }\n    }\n\n    return acc;\n  }, new Map());\n\n  const targetOperation = aggregationFunctions[operation];\n\n  if (targetOperation) {\n    return [...groups.entries()]\n      .map(([name, value]) => ({\n        name,\n        value: targetOperation(value)\n      }))\n      .sort((a, b) => a.name - b.name);\n  }\n\n  return [];\n}\n","// Don't rename values. These values come from nebula.\nexport const FEATURE_SELECTION_MODES = Object.freeze({\n  POLYGON: 'DrawPolygonMode',\n  RECTANGLE: 'DrawRectangleMode',\n  CIRCLE: 'DrawCircleFromCenterMode',\n  LASSO_TOOL: 'DrawPolygonByDraggingMode'\n});\n\nexport const EDIT_MODES = Object.freeze({\n  EDIT: 'edit'\n});\n\nexport const MASK_ID = 'feature_selection_mask';\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__855__","__WEBPACK_EXTERNAL_MODULE__97__","__WEBPACK_EXTERNAL_MODULE__55__","__WEBPACK_EXTERNAL_MODULE__956__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","_defineProperty","configurable","writable","REQUEST_GET_MAX_URL_LENGTH","getRequest","url","opts","Request","method","headers","Accept","postRequest","payload","body","JSON","stringify","encodeParameter","name","encodeURIComponent","getMonday","date","dateCp","Date","day","getDay","diff","getDate","setDate","UTC","getUTCFullYear","getUTCMonth","getUTCDate","debounce","fn","ms","timer","args","clearTimeout","setTimeout","apply","throttle","lastTime","now","randomString","length","text","possible","i","charAt","Math","floor","random","makeIntervalComplete","values","map","val","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","AggregationTypes","freeze","COUNT","AVG","MIN","MAX","SUM","sum","b","reduce","aggregationFunctions","min","Infinity","max","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","toString","slice","constructor","from","test","isArray","_i","iterator","_s","_e","_arr","_n","_d","next","done","push","err","TypeError","groupValuesByColumn","data","valuesColumn","keysColumn","operation","groups","accumulator","item","group","targetOperation","entries","_toConsumableArray","iter","histogram","features","columnName","ticks","binsContainer","tick","index","bin","start","end","forEach","feature","featureValue","binContainer","find","scatterPlot","xAxisColumn","yAxisColumn","filter","xIsValid","xValue","yValue","FilterTypes","IN","BETWEEN","CLOSED_OPEN","TIME","STRING_SEARCH","filterFunctions","filterValues","includes","between","featureValueAsTimestamp","getTime","isFinite","Error","some","range","lowerBound","upperBound","params","normalizedFeatureValue","normalize","stringRegExp","filterValue","escapeRegExp","mustStart","mustEnd","join","regex","RegExp","match","specialCharRegExp","normalizeRegExp","replace","normalizedData","caseSensitive","toLocaleLowerCase","keepSpecialCharacters","getApplicableFilters","filters","owner","filtersCopy","column","filterCopy","keys","operator","filtersToSQL","result","v","left","right","buildFeatureFilter","type","columns","f","properties","featurePassesFilter","every","columnFilters","columnFilterTypes","filterFunction","passesFilter","applyFilters","DEFAULT_USER_COMPONENT_IN_URL","TILE_FORMATS","concat","SchemaFieldType","condition","message","log2","PI","PI_4","DEGREES_TO_RADIANS","transformToTileCoords","geometry","bbox","projectedBbox","projectFlat","west","north","east","south","transformFn","availableTransformations","coordinates","Point","MultiPoint","multiPoint","getPoints","LineString","MultiLineString","multiLineString","lineString","Polygon","MultiPolygon","multiPolygon","polygon","pointX","pointY","nw","se","inverseLerp","g","line","polygonRing","xyz","lng","lat","phi2","log","tan","lngLatToWorld","x","GEOMETRY_TYPES","getIndices","primitivePolygonIndices","pathIndices","pointIndices","getPropertiesFromTile","startIndex","featureId","featureIds","getFeatureId","numericProps","parseProperties","tileProps","assign","getUniquePropertyValue","uniqueIdProperty","getValueFromTileProps","artificialId","size","propertyName","getFeatureByType","getRingCoordinatesFor","endIndex","positions","ringCoordinates","j","subarray","calculateFeatures","tileIsFullyVisible","geometryIntersection","indices","uniquePropertyValue","has","set","addAllFeaturesInTile","intersects","addIntersectedFeaturesInTile","getGeometryToIntersect","viewport","intersect","bboxPolygon","tileFeatures","tiles","tileFormat","Map","geometryToIntersect","lastFeatureId","tile","isVisible","bboxToGeom","booleanWithin","clippedGeometryToIntersect","transformedGeomtryToIntersect","points","lines","polygons","geojsonFeatures","geojson","uniqueIdx","uniqueId","GroupDateTypes","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","GROUP_KEY_FN_MAPPING","getUTCHours","getUTCMinutes","groupValuesByDateColumn","groupType","groupKeyFn","acc","formattedValue","groupKey","isNaN","groupedValues","sort","FEATURE_SELECTION_MODES","POLYGON","RECTANGLE","CIRCLE","LASSO_TOOL","EDIT_MODES","EDIT","MASK_ID"],"sourceRoot":""}