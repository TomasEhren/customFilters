{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(makeMeshPrimitiveIterator);\n\nimport { DracoLoader } from '@loaders.gl/draco';\nimport { sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { default as Scenegraph } from '../api/gltf-scenegraph';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nvar KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport var name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n  var scenegraph = new Scenegraph(gltfData);\n\n  var _iterator = _createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var primitive = _step.value;\n\n      if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {}\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function decode(_x, _x2, _x3) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData, options, context) {\n    var _options$gltf, scenegraph, promises, _iterator5, _step5, primitive;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            scenegraph = new Scenegraph(gltfData);\n            promises = [];\n            _iterator5 = _createForOfIteratorHelper(makeMeshPrimitiveIterator(scenegraph));\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                primitive = _step5.value;\n\n                if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n                  promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            _context2.next = 8;\n            return Promise.all(promises);\n\n          case 8:\n            scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nexport function encode(gltfData) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var scenegraph = new Scenegraph(gltfData);\n\n  var _iterator2 = _createForOfIteratorHelper(scenegraph.json.meshes || []),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var mesh = _step2.value;\n      compressMesh(mesh, options);\n      scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nfunction decompressPrimitive(_x4, _x5, _x6, _x7) {\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction _decompressPrimitive() {\n  _decompressPrimitive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(scenegraph, primitive, options, context) {\n    var dracoExtension, buffer, bufferCopy, parse, dracoOptions, decodedData, decodedAttributes, _i, _Object$entries, _Object$entries$_i, attributeName, decodedAttribute, accessorIndex, accessor;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n            if (dracoExtension) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 3:\n            buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n            bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);\n            parse = context.parse;\n            dracoOptions = _objectSpread({}, options);\n            delete dracoOptions['3d-tiles'];\n            _context3.next = 10;\n            return parse(bufferCopy, DracoLoader, dracoOptions, context);\n\n          case 10:\n            decodedData = _context3.sent;\n            decodedAttributes = getGLTFAccessors(decodedData.attributes);\n\n            for (_i = 0, _Object$entries = Object.entries(decodedAttributes); _i < _Object$entries.length; _i++) {\n              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), attributeName = _Object$entries$_i[0], decodedAttribute = _Object$entries$_i[1];\n\n              if (attributeName in primitive.attributes) {\n                accessorIndex = primitive.attributes[attributeName];\n                accessor = scenegraph.getAccessor(accessorIndex);\n\n                if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {\n                  decodedAttribute.min = accessor.min;\n                  decodedAttribute.max = accessor.max;\n                }\n              }\n            }\n\n            primitive.attributes = decodedAttributes;\n\n            if (decodedData.indices) {\n              primitive.indices = getGLTFAccessor(decodedData.indices);\n            }\n\n            checkPrimitive(primitive);\n\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decompressPrimitive.apply(this, arguments);\n}\n\nfunction compressMesh(attributes, indices) {\n  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  var options = arguments.length > 3 ? arguments[3] : undefined;\n  var context = arguments.length > 4 ? arguments[4] : undefined;\n\n  var _context$parseSync;\n\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  var compressedData = options.DracoWriter.encodeSync({\n    attributes: attributes\n  });\n  var decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {\n    attributes: attributes\n  });\n\n  var fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  var bufferViewIndex = options.addBufferView(compressedData);\n  var glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode: mode,\n      extensions: _defineProperty({}, KHR_DRACO_MESH_COMPRESSION, {\n        bufferView: bufferViewIndex,\n        attributes: fauxAccessors\n      })\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction makeMeshPrimitiveIterator(scenegraph) {\n  var _iterator3, _step3, mesh, _iterator4, _step4, primitive;\n\n  return _regeneratorRuntime.wrap(function makeMeshPrimitiveIterator$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator3 = _createForOfIteratorHelper(scenegraph.json.meshes || []);\n          _context.prev = 1;\n\n          _iterator3.s();\n\n        case 3:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 24;\n            break;\n          }\n\n          mesh = _step3.value;\n          _iterator4 = _createForOfIteratorHelper(mesh.primitives);\n          _context.prev = 6;\n\n          _iterator4.s();\n\n        case 8:\n          if ((_step4 = _iterator4.n()).done) {\n            _context.next = 14;\n            break;\n          }\n\n          primitive = _step4.value;\n          _context.next = 12;\n          return primitive;\n\n        case 12:\n          _context.next = 8;\n          break;\n\n        case 14:\n          _context.next = 19;\n          break;\n\n        case 16:\n          _context.prev = 16;\n          _context.t0 = _context[\"catch\"](6);\n\n          _iterator4.e(_context.t0);\n\n        case 19:\n          _context.prev = 19;\n\n          _iterator4.f();\n\n          return _context.finish(19);\n\n        case 22:\n          _context.next = 3;\n          break;\n\n        case 24:\n          _context.next = 29;\n          break;\n\n        case 26:\n          _context.prev = 26;\n          _context.t1 = _context[\"catch\"](1);\n\n          _iterator3.e(_context.t1);\n\n        case 29:\n          _context.prev = 29;\n\n          _iterator3.f();\n\n          return _context.finish(29);\n\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 26, 29, 32], [6, 16, 19, 22]]);\n}","map":{"version":3,"mappings":"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","names":["makeMeshPrimitiveIterator","DracoLoader","sliceArrayBuffer","default","Scenegraph","getGLTFAccessors","getGLTFAccessor","KHR_DRACO_MESH_COMPRESSION","name","preprocess","gltfData","options","context","scenegraph","primitive","getObjectExtension","decode","gltf","_options$gltf","decompressMeshes","promises","push","decompressPrimitive","Promise","all","removeExtension","encode","json","meshes","mesh","compressMesh","addRequiredExtension","dracoExtension","buffer","getTypedArrayForBufferView","bufferView","bufferCopy","byteOffset","parse","dracoOptions","decodedData","decodedAttributes","attributes","Object","entries","attributeName","decodedAttribute","accessorIndex","accessor","getAccessor","min","max","indices","checkPrimitive","mode","DracoWriter","Error","compressedData","encodeSync","parseSync","_context$parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","keys","length"],"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.ts"],"sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\n\n/* eslint-disable camelcase */\nimport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFMeshPrimitive,\n  GLTF_KHR_draco_mesh_compression\n} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMesh} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\n\nexport function preprocess(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): void {\n  const scenegraph = new Scenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\n\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension<GLTF_KHR_draco_mesh_compression>(\n    primitive,\n    KHR_DRACO_MESH_COMPRESSION\n  );\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(bufferCopy, DracoLoader, dracoOptions, context)) as DracoMesh;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}