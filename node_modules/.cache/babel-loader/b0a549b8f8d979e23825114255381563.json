{"ast":null,"code":"export default class LRUCache {\n  constructor() {\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    this.limit = limit;\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      this._deleteOrder(key);\n\n      this._appendOrder(key);\n    }\n\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    } else {\n      this.delete(key);\n      this._cache[key] = value;\n\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n\n    if (value) {\n      this._deleteCache(key);\n\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n\n}","map":{"version":3,"mappings":"AAOA,eAAe,MAAMA,QAAN,CAAe;EAC5BC,WAAW,GAAY;IAAA,IAAXC,KAAW,uEAAH,CAAG;IACrB,KAAKA,KAAL,GAAaA,KAAb;IAEA,KAAKC,KAAL;EACD;;EAEDA,KAAK,GAAG;IACN,KAAKC,MAAL,GAAc,EAAd;IAEA,KAAKC,MAAL,GAAc,EAAd;EACD;;EAEDC,GAAG,CAACC,GAAD,EAAM;IACP,MAAMC,KAAK,GAAG,KAAKJ,MAAL,CAAYG,GAAZ,CAAd;;IACA,IAAIC,KAAJ,EAAW;MAET,KAAKC,YAAL,CAAkBF,GAAlB;;MACA,KAAKG,YAAL,CAAkBH,GAAlB;IACD;;IACD,OAAOC,KAAP;EACD;;EAEDG,GAAG,CAACJ,GAAD,EAAMC,KAAN,EAAa;IACd,IAAI,CAAC,KAAKJ,MAAL,CAAYG,GAAZ,CAAL,EAAuB;MAErB,IAAIK,MAAM,CAACC,IAAPD,CAAY,KAAKR,MAAjBQ,EAAyBE,MAAzBF,KAAoC,KAAKV,KAA7C,EAAoD;QAClD,KAAKa,MAAL,CAAY,KAAKV,MAAL,CAAY,CAAZ,CAAZ;MACD;;MAED,KAAKD,MAAL,CAAYG,GAAZ,IAAmBC,KAAnB;;MACA,KAAKE,YAAL,CAAkBH,GAAlB;IAPF,OAQO;MAEL,KAAKQ,MAAL,CAAYR,GAAZ;MAEA,KAAKH,MAAL,CAAYG,GAAZ,IAAmBC,KAAnB;;MACA,KAAKE,YAAL,CAAkBH,GAAlB;IACD;EACF;;EAEDQ,MAAM,CAACR,GAAD,EAAM;IACV,MAAMC,KAAK,GAAG,KAAKJ,MAAL,CAAYG,GAAZ,CAAd;;IACA,IAAIC,KAAJ,EAAW;MACT,KAAKQ,YAAL,CAAkBT,GAAlB;;MACA,KAAKE,YAAL,CAAkBF,GAAlB;IACD;EACF;;EAEDS,YAAY,CAACT,GAAD,EAAM;IAChB,OAAO,KAAKH,MAAL,CAAYG,GAAZ,CAAP;EACD;;EAEDE,YAAY,CAACF,GAAD,EAAM;IAChB,MAAMU,KAAK,GAAG,KAAKZ,MAAL,CAAYa,SAAZ,CAAsBC,CAAC,IAAIA,CAAC,KAAKZ,GAAjC,CAAd;;IACA,IAAIU,KAAK,IAAI,CAAb,EAAgB;MACd,KAAKZ,MAAL,CAAYe,MAAZ,CAAmBH,KAAnB,EAA0B,CAA1B;IACD;EACF;;EAEDP,YAAY,CAACH,GAAD,EAAM;IAChB,KAAKF,MAAL,CAAYgB,IAAZ,CAAiBd,GAAjB;EACD;;AA9D2B","names":["LRUCache","constructor","limit","clear","_cache","_order","get","key","value","_deleteOrder","_appendOrder","set","Object","keys","length","delete","_deleteCache","index","findIndex","o","splice","push"],"sources":["../../../src/text-layer/lru-cache.js"],"sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n    if (value) {\n      this._deleteCache(key);\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}