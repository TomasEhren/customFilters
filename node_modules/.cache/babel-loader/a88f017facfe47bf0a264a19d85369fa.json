{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createPathMarkers;\n\nvar _math = require(\"math.gl\");\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  var lineLength = 0;\n\n  for (var i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n\n  return lineLength;\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar DEFAULT_DIRECTION = {\n  forward: true,\n  backward: false\n};\n\nfunction createPathMarkers(_ref) {\n  var data = _ref.data,\n      _ref$getPath = _ref.getPath,\n      getPath = _ref$getPath === void 0 ? function (x) {\n    return x.path;\n  } : _ref$getPath,\n      _ref$getDirection = _ref.getDirection,\n      getDirection = _ref$getDirection === void 0 ? function (x) {\n    return x.direction;\n  } : _ref$getDirection,\n      _ref$getColor = _ref.getColor,\n      getColor = _ref$getColor === void 0 ? function (x) {\n    return DEFAULT_COLOR;\n  } : _ref$getColor,\n      _ref$getMarkerPercent = _ref.getMarkerPercentages,\n      getMarkerPercentages = _ref$getMarkerPercent === void 0 ? function (x, info) {\n    return [0.5];\n  } : _ref$getMarkerPercent,\n      projectFlat = _ref.projectFlat;\n  var markers = [];\n\n  var _iterator = _createForOfIteratorHelper(data),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var object = _step.value;\n      var path = getPath(object);\n      var direction = getDirection(object) || DEFAULT_DIRECTION;\n      var color = getColor(object);\n      var vPoints = path.map(function (p) {\n        return new _math.Vector2(p);\n      });\n      var vPointsReverse = vPoints.slice(0).reverse(); // calculate total length\n\n      var lineLength = getLineLength(vPoints); // Ask for where to put markers\n      // @ts-ignore\n\n      var percentages = getMarkerPercentages(object, {\n        lineLength: lineLength\n      }); // Create the markers\n\n      var _iterator2 = _createForOfIteratorHelper(percentages),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var percentage = _step2.value;\n\n          if (direction.forward) {\n            var marker = createMarkerAlongPath({\n              path: vPoints,\n              percentage: percentage,\n              lineLength: lineLength,\n              color: color,\n              object: object,\n              projectFlat: projectFlat\n            });\n            markers.push(marker);\n          }\n\n          if (direction.backward) {\n            var _marker = createMarkerAlongPath({\n              path: vPointsReverse,\n              percentage: percentage,\n              lineLength: lineLength,\n              color: color,\n              object: object,\n              projectFlat: projectFlat\n            });\n\n            markers.push(_marker);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath(_ref2) {\n  var path = _ref2.path,\n      percentage = _ref2.percentage,\n      lineLength = _ref2.lineLength,\n      color = _ref2.color,\n      object = _ref2.object,\n      projectFlat = _ref2.projectFlat;\n  var distanceAlong = lineLength * percentage;\n  var currentDistance = 0;\n  var previousDistance = 0;\n  var i = 0;\n\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n\n    previousDistance = currentDistance;\n  } // If reached the end of the loop without exiting early,\n  // undo the final increment to avoid a null-pointer exception\n\n\n  if (i === path.length - 1) {\n    i -= 1;\n  }\n\n  var vDirection = path[i + 1].clone().subtract(path[i]).normalize();\n  var along = distanceAlong - previousDistance;\n  var vCenter = vDirection.clone().multiply(new _math.Vector2(along, along)).add(path[i]);\n  var vDirection2 = new _math.Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n  var angle = vDirection2.verticalAngle() * 180 / Math.PI;\n  return {\n    position: [vCenter.x, vCenter.y, 0],\n    angle: angle,\n    color: color,\n    object: object\n  };\n}","map":{"version":3,"mappings":"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","names":["getLineLength","vPoints","lineLength","i","length","distance","DEFAULT_COLOR","DEFAULT_DIRECTION","forward","backward","createPathMarkers","data","getPath","x","path","getDirection","direction","getColor","getMarkerPercentages","info","projectFlat","markers","object","color","map","p","Vector2","vPointsReverse","slice","reverse","percentages","percentage","marker","createMarkerAlongPath","push","_iterator2","_iterator","distanceAlong","currentDistance","previousDistance","vDirection","clone","subtract","normalize","along","vCenter","multiply","add","vDirection2","angle","verticalAngle","Math","PI","position","y"],"sources":["../../../src/layers/path-marker-layer/create-path-markers.ts"],"sourcesContent":["import { Vector2 } from 'math.gl';\n\nfunction getLineLength(vPoints) {\n  // calculate total length\n  let lineLength = 0;\n  for (let i = 0; i < vPoints.length - 1; i++) {\n    lineLength += vPoints[i].distance(vPoints[i + 1]);\n  }\n  return lineLength;\n}\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_DIRECTION = { forward: true, backward: false };\n\nexport default function createPathMarkers({\n  data,\n  getPath = (x) => x.path,\n  getDirection = (x) => x.direction,\n  getColor = (x) => DEFAULT_COLOR,\n  getMarkerPercentages = (x, info) => [0.5],\n  projectFlat,\n}) {\n  const markers = [];\n\n  for (const object of data) {\n    const path = getPath(object);\n    const direction = getDirection(object) || DEFAULT_DIRECTION;\n    const color = getColor(object);\n\n    const vPoints = path.map((p) => new Vector2(p));\n    const vPointsReverse = vPoints.slice(0).reverse();\n\n    // calculate total length\n    const lineLength = getLineLength(vPoints);\n\n    // Ask for where to put markers\n    // @ts-ignore\n    const percentages = getMarkerPercentages(object, { lineLength });\n\n    // Create the markers\n    for (const percentage of percentages) {\n      if (direction.forward) {\n        const marker = createMarkerAlongPath({\n          path: vPoints,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat,\n        });\n        markers.push(marker);\n      }\n\n      if (direction.backward) {\n        const marker = createMarkerAlongPath({\n          path: vPointsReverse,\n          percentage,\n          lineLength,\n          color,\n          object,\n          projectFlat,\n        });\n        markers.push(marker);\n      }\n    }\n  }\n\n  return markers;\n}\n\nfunction createMarkerAlongPath({ path, percentage, lineLength, color, object, projectFlat }) {\n  const distanceAlong = lineLength * percentage;\n  let currentDistance = 0;\n  let previousDistance = 0;\n  let i = 0;\n  for (i = 0; i < path.length - 1; i++) {\n    currentDistance += path[i].distance(path[i + 1]);\n    if (currentDistance > distanceAlong) {\n      break;\n    }\n    previousDistance = currentDistance;\n  }\n\n  // If reached the end of the loop without exiting early,\n  // undo the final increment to avoid a null-pointer exception\n  if (i === path.length - 1) {\n    i -= 1;\n  }\n\n  const vDirection = path[i + 1].clone().subtract(path[i]).normalize();\n  const along = distanceAlong - previousDistance;\n  const vCenter = vDirection.clone().multiply(new Vector2(along, along)).add(path[i]);\n\n  const vDirection2 = new Vector2(projectFlat(path[i + 1])).subtract(projectFlat(path[i]));\n\n  const angle = (vDirection2.verticalAngle() * 180) / Math.PI;\n\n  return { position: [vCenter.x, vCenter.y, 0], angle, color, object };\n}\n"]},"metadata":{},"sourceType":"script"}