{"ast":null,"code":"export default async function fetchProgress(response, onProgress) {\n  let onDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n  let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => {};\n  response = await response;\n\n  if (!response.ok) {\n    return response;\n  }\n\n  const body = response.body;\n\n  if (!body) {\n    return response;\n  }\n\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n\n  if (!(contentLength > 0)) {\n    return response;\n  }\n\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n\n  });\n  return new Response(progressStream);\n}\n\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {\n      done,\n      value\n    } = await reader.read();\n\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n\n    loadedBytes += value.byteLength;\n    const percent = Math.round(loadedBytes / totalBytes * 100);\n    onProgress(percent, {\n      loadedBytes,\n      totalBytes\n    });\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}","map":{"version":3,"mappings":"AAKA,eAAe,eAAeA,aAAf,CACbC,QADa,EAEbC,UAFa,EAKb;EAAA,IAFAC,MAEA,uEAFS,MAAM,CAHF,CAKb;EAAA,IADAC,OACA,uEADU,MAAM,CAJH,CAKb;EACAH,QAAQ,GAAG,MAAMA,QAAjBA;;EACA,IAAI,CAACA,QAAQ,CAACI,EAAd,EAAkB;IAEhB,OAAOJ,QAAP;EACD;;EACD,MAAMK,IAAI,GAAGL,QAAQ,CAACK,IAAtB;;EACA,IAAI,CAACA,IAAL,EAAW;IAET,OAAOL,QAAP;EACD;;EACD,MAAMM,aAAa,GAAGN,QAAQ,CAACO,OAATP,CAAiBQ,GAAjBR,CAAqB,gBAArBA,KAA0C,CAAhE;EACA,MAAMS,UAAU,GAAGH,aAAa,IAAII,QAAQ,CAACJ,aAAD,CAA5C;;EACA,IAAI,EAAEA,aAAa,GAAG,CAAlB,CAAJ,EAA0B;IACxB,OAAON,QAAP;EACD;;EAED,IAAI,OAAOW,cAAP,KAA0B,WAA1B,IAAyC,CAACN,IAAI,CAACO,SAAnD,EAA8D;IAC5D,OAAOZ,QAAP;EACD;;EAGD,MAAMa,cAAc,GAAG,IAAIF,cAAJ,CAAmB;IACxC,MAAMG,KAAN,CAAYC,UAAZ,EAAwB;MACtB,MAAMC,MAAM,GAAGX,IAAI,CAACO,SAALP,EAAf;MACA,MAAMY,IAAI,CAACF,UAAD,EAAaC,MAAb,EAAqB,CAArB,EAAwBP,UAAxB,EAAoCR,UAApC,EAAgDC,MAAhD,EAAwDC,OAAxD,CAAV;IACD;;EAJuC,CAAnB,CAAvB;EAOA,OAAO,IAAIe,QAAJ,CAAaL,cAAb,CAAP;AACD;;AAKD,eAAeI,IAAf,CAAoBF,UAApB,EAAgCC,MAAhC,EAAwCG,WAAxC,EAAqDV,UAArD,EAAiER,UAAjE,EAA6EC,MAA7E,EAAqFC,OAArF,EAA8F;EAC5F,IAAI;IACF,MAAM;MAACiB,IAAD;MAAOC;IAAP,IAAgB,MAAML,MAAM,CAACC,IAAPD,EAA5B;;IACA,IAAII,IAAJ,EAAU;MACRlB,MAAM;MACNa,UAAU,CAACO,KAAXP;MACA;IACD;;IACDI,WAAW,IAAIE,KAAK,CAACE,UAArBJ;IACA,MAAMK,OAAO,GAAGC,IAAI,CAACC,KAALD,CAAYN,WAAW,GAAGV,UAAdU,GAA4B,GAAxCM,CAAhB;IACAxB,UAAU,CAACuB,OAAD,EAAU;MAACL,WAAD;MAAcV;IAAd,CAAV,CAAVR;IACAc,UAAU,CAACY,OAAXZ,CAAmBM,KAAnBN;IACA,MAAME,IAAI,CAACF,UAAD,EAAaC,MAAb,EAAqBG,WAArB,EAAkCV,UAAlC,EAA8CR,UAA9C,EAA0DC,MAA1D,EAAkEC,OAAlE,CAAV;EAXF,EAYE,OAAOyB,KAAP,EAAc;IACdb,UAAU,CAACa,KAAXb,CAAiBa,KAAjBb;IACAZ,OAAO,CAACyB,KAAD,CAAPzB;EACD;AACF","names":["fetchProgress","response","onProgress","onDone","onError","ok","body","contentLength","headers","get","totalBytes","parseInt","ReadableStream","getReader","progressStream","start","controller","reader","read","Response","loadedBytes","done","value","close","byteLength","percent","Math","round","enqueue","error"],"sources":["../../../../src/lib/progress/fetch-progress.ts"],"sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport default async function fetchProgress(\n  response: Response | Promise<Response>,\n  onProgress: any, // TODO better callback types\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}