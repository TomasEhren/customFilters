{"ast":null,"code":"import { CompositeLayer, log } from '@deck.gl/core';\nimport CartoTileLayer from './carto-tile-layer';\nimport { MVTLayer } from '@deck.gl/geo-layers';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { fetchLayerData, getDataV2, API_VERSIONS } from '../api';\nimport { COLUMNS_SUPPORT, FORMATS, GEO_COLUMN_SUPPORT, MAP_TYPES, TILE_FORMATS } from '../api/maps-api-common';\nimport { getDefaultCredentials } from '../config';\nconst defaultProps = {\n  data: null,\n  type: null,\n  onDataLoad: {\n    type: 'function',\n    value: data => {},\n    compare: false\n  },\n  onDataError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  uniqueIdProperty: 'cartodb_id',\n  credentials: null,\n  connection: null,\n  format: null,\n  formatTiles: null,\n  clientId: null,\n  geoColumn: null,\n  columns: {\n    type: 'array',\n    value: null\n  }\n};\nexport default class CartoLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      data: null,\n      apiVersion: null\n    };\n  }\n\n  get isLoaded() {\n    return this.getSubLayers().length > 0 && super.isLoaded;\n  }\n\n  _checkProps(props) {\n    const {\n      type,\n      credentials,\n      connection,\n      geoColumn,\n      columns\n    } = props;\n    const localCreds = { ...getDefaultCredentials(),\n      ...credentials\n    };\n    const {\n      apiVersion\n    } = localCreds;\n    log.assert(Object.values(API_VERSIONS).includes(apiVersion), \"Invalid apiVersion \".concat(apiVersion, \". Use API_VERSIONS enum.\"));\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      log.assert(type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET, \"Invalid type \".concat(type, \". Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion \").concat(apiVersion));\n      log.assert(!connection, \"Connection prop is not supported for apiVersion \".concat(apiVersion));\n      log.assert(!geoColumn, \"geoColumn prop is not supported for apiVersion \".concat(apiVersion));\n      log.assert(!columns, \"columns prop is not supported for apiVersion \".concat(apiVersion));\n    } else if (apiVersion === API_VERSIONS.V3) {\n      log.assert(connection, 'Missing mandatory connection parameter');\n      log.assert(Object.values(MAP_TYPES).includes(type), \"Invalid type \".concat(type, \". Use MAP_TYPES enum.\"));\n\n      if (!COLUMNS_SUPPORT.includes(type)) {\n        log.assert(!columns, \"columns prop is only supported for types: \".concat(COLUMNS_SUPPORT.join()));\n      }\n\n      if (!GEO_COLUMN_SUPPORT.includes(type)) {\n        log.assert(!geoColumn, \"geoColumn prop is only supported for types: \".concat(GEO_COLUMN_SUPPORT.join()));\n      }\n\n      if (columns) {\n        log.assert(Array.isArray(columns), 'columns prop must be an Array');\n      }\n    }\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref;\n\n    this._checkProps(props);\n\n    const shouldUpdateData = changeFlags.dataChanged || props.connection !== oldProps.connection || props.geoColumn !== oldProps.geoColumn || props.format !== oldProps.format || props.formatTiles !== oldProps.formatTiles || props.type !== oldProps.type || JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) || JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n    if (shouldUpdateData) {\n      this.setState({\n        data: null,\n        apiVersion: null\n      });\n\n      this._updateData();\n    }\n  }\n\n  async _updateData() {\n    try {\n      const {\n        type,\n        data: source,\n        clientId,\n        credentials,\n        ...rest\n      } = this.props;\n      const localConfig = { ...getDefaultCredentials(),\n        ...credentials\n      };\n      const {\n        apiVersion\n      } = localConfig;\n      let result;\n\n      if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        result = {\n          data: await getDataV2({\n            type,\n            source,\n            credentials\n          })\n        };\n      } else {\n        result = await fetchLayerData({\n          type,\n          source,\n          clientId,\n          credentials,\n          ...rest\n        });\n      }\n\n      this.setState({ ...result,\n        apiVersion\n      });\n      this.props.onDataLoad(result.data);\n    } catch (err) {\n      if (this.props.onDataError) {\n        this.props.onDataError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _getSubLayerAndProps() {\n    const {\n      data,\n      format,\n      apiVersion\n    } = this.state;\n    const {\n      uniqueIdProperty\n    } = defaultProps;\n    const props = {\n      uniqueIdProperty,\n      ...this.props\n    };\n    delete props.data;\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      return [MVTLayer, props];\n    }\n\n    if (format === FORMATS.TILEJSON) {\n      const tileUrl = new URL(data.tiles[0]);\n      props.formatTiles = props.formatTiles || tileUrl.searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n      return props.formatTiles === TILE_FORMATS.MVT ? [MVTLayer, props] : [CartoTileLayer, props];\n    }\n\n    return [GeoJsonLayer, props];\n  }\n\n  renderLayers() {\n    const {\n      data\n    } = this.state;\n    if (!data) return null;\n    const {\n      updateTriggers\n    } = this.props;\n\n    const [layer, props] = this._getSubLayerAndProps();\n\n    return new layer(props, this.getSubLayerProps({\n      id: \"carto-\".concat(layer.layerName),\n      data,\n      updateTriggers\n    }));\n  }\n\n}\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["CompositeLayer","log","CartoTileLayer","MVTLayer","GeoJsonLayer","fetchLayerData","getDataV2","API_VERSIONS","COLUMNS_SUPPORT","FORMATS","GEO_COLUMN_SUPPORT","MAP_TYPES","TILE_FORMATS","getDefaultCredentials","defaultProps","data","type","onDataLoad","value","compare","onDataError","optional","uniqueIdProperty","credentials","connection","format","formatTiles","clientId","geoColumn","columns","CartoLayer","initializeState","state","apiVersion","isLoaded","getSubLayers","length","_checkProps","props","localCreds","assert","Object","values","includes","V1","V2","QUERY","TILESET","V3","join","Array","isArray","updateState","oldProps","changeFlags","shouldUpdateData","dataChanged","JSON","stringify","setState","_updateData","source","rest","localConfig","result","err","_getSubLayerAndProps","TILEJSON","tileUrl","URL","tiles","searchParams","get","MVT","renderLayers","updateTriggers","layer","getSubLayerProps","id","layerName"],"sources":["../../../src/layers/carto-layer.js"],"sourcesContent":["import {CompositeLayer, log} from '@deck.gl/core';\nimport CartoTileLayer from './carto-tile-layer';\nimport {MVTLayer} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {fetchLayerData, getDataV2, API_VERSIONS} from '../api';\nimport {\n  COLUMNS_SUPPORT,\n  FORMATS,\n  GEO_COLUMN_SUPPORT,\n  MAP_TYPES,\n  TILE_FORMATS\n} from '../api/maps-api-common';\nimport {getDefaultCredentials} from '../config';\n\nconst defaultProps = {\n  // (String, required): data resource to load. table name, sql query or tileset name.\n  data: null,\n  // (Enum (MAP_TYPES), required)\n  type: null,\n  onDataLoad: {type: 'function', value: data => {}, compare: false},\n  onDataError: {type: 'function', value: null, compare: false, optional: true},\n  uniqueIdProperty: 'cartodb_id',\n\n  // override carto credentials for the layer, set to null to read from default\n  credentials: null,\n\n  /*********************/\n  /* API v3 PARAMETERS */\n  /**********************/\n  // (String, required): connection name at CARTO platform\n  connection: null,\n\n  // (String, optional): format of data\n  format: null,\n\n  // (String, optional): force format of data for tiles\n  formatTiles: null,\n\n  // (String, optional): clientId identifier used for internal tracing, place here a string to identify the client who is doing the request.\n  clientId: null,\n\n  // (String, optional): name of the `geo_column` in the CARTO platform. Use this override the default column ('geom'), from which the geometry information should be fetched.\n  geoColumn: null,\n\n  // (Array<String>, optional): names of columns to fetch. By default, all columns are fetched.\n  columns: {type: 'array', value: null}\n};\n\nexport default class CartoLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      data: null,\n      apiVersion: null\n    };\n  }\n\n  get isLoaded() {\n    return this.getSubLayers().length > 0 && super.isLoaded;\n  }\n\n  _checkProps(props) {\n    const {type, credentials, connection, geoColumn, columns} = props;\n    const localCreds = {...getDefaultCredentials(), ...credentials};\n    const {apiVersion} = localCreds;\n\n    log.assert(\n      Object.values(API_VERSIONS).includes(apiVersion),\n      `Invalid apiVersion ${apiVersion}. Use API_VERSIONS enum.`\n    );\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      log.assert(\n        type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET,\n        `Invalid type ${type}. Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion ${apiVersion}`\n      );\n      log.assert(!connection, `Connection prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!geoColumn, `geoColumn prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!columns, `columns prop is not supported for apiVersion ${apiVersion}`);\n    } else if (apiVersion === API_VERSIONS.V3) {\n      log.assert(connection, 'Missing mandatory connection parameter');\n      log.assert(\n        Object.values(MAP_TYPES).includes(type),\n        `Invalid type ${type}. Use MAP_TYPES enum.`\n      );\n      if (!COLUMNS_SUPPORT.includes(type)) {\n        log.assert(!columns, `columns prop is only supported for types: ${COLUMNS_SUPPORT.join()}`);\n      }\n      if (!GEO_COLUMN_SUPPORT.includes(type)) {\n        log.assert(\n          !geoColumn,\n          `geoColumn prop is only supported for types: ${GEO_COLUMN_SUPPORT.join()}`\n        );\n      }\n      if (columns) {\n        log.assert(Array.isArray(columns), 'columns prop must be an Array');\n      }\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    this._checkProps(props);\n    const shouldUpdateData =\n      changeFlags.dataChanged ||\n      props.connection !== oldProps.connection ||\n      props.geoColumn !== oldProps.geoColumn ||\n      props.format !== oldProps.format ||\n      props.formatTiles !== oldProps.formatTiles ||\n      props.type !== oldProps.type ||\n      JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) ||\n      JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n    if (shouldUpdateData) {\n      this.setState({data: null, apiVersion: null});\n      this._updateData();\n    }\n  }\n\n  async _updateData() {\n    try {\n      const {type, data: source, clientId, credentials, ...rest} = this.props;\n      const localConfig = {...getDefaultCredentials(), ...credentials};\n      const {apiVersion} = localConfig;\n\n      let result;\n      if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        result = {data: await getDataV2({type, source, credentials})};\n      } else {\n        result = await fetchLayerData({type, source, clientId, credentials, ...rest});\n      }\n\n      this.setState({...result, apiVersion});\n      this.props.onDataLoad(result.data);\n    } catch (err) {\n      if (this.props.onDataError) {\n        this.props.onDataError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _getSubLayerAndProps() {\n    const {data, format, apiVersion} = this.state;\n\n    const {uniqueIdProperty} = defaultProps;\n    const props = {uniqueIdProperty, ...this.props};\n    delete props.data;\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      return [MVTLayer, props];\n    }\n\n    if (format === FORMATS.TILEJSON) {\n      /* global URL */\n      const tileUrl = new URL(data.tiles[0]);\n\n      props.formatTiles =\n        props.formatTiles || tileUrl.searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n\n      return props.formatTiles === TILE_FORMATS.MVT ? [MVTLayer, props] : [CartoTileLayer, props];\n    }\n\n    // It's a geojson layer\n    return [GeoJsonLayer, props];\n  }\n\n  renderLayers() {\n    const {data} = this.state;\n\n    if (!data) return null;\n\n    const {updateTriggers} = this.props;\n\n    const [layer, props] = this._getSubLayerAndProps();\n\n    // eslint-disable-next-line new-cap\n    return new layer(\n      props,\n      this.getSubLayerProps({\n        id: `carto-${layer.layerName}`,\n        data,\n        updateTriggers\n      })\n    );\n  }\n}\n\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}