{"ast":null,"code":"import Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport { assertWebGL2Context, withParameters, log } from '@luma.gl/gltools';\nimport { flipRows, scalePixels } from '../webgl-utils/typed-array-utils';\nimport { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../webgl-utils/typed-array-utils';\nimport { glFormatToComponents, glTypeToBytes } from '../webgl-utils/format-utils';\nimport { toFramebuffer } from '../webgl-utils/texture-utils';\nimport { assert } from '../utils/assert';\nexport function readPixelsToArray(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$sourceX = options.sourceX,\n      sourceX = _options$sourceX === void 0 ? 0 : _options$sourceX,\n      _options$sourceY = options.sourceY,\n      sourceY = _options$sourceY === void 0 ? 0 : _options$sourceY,\n      _options$sourceFormat = options.sourceFormat,\n      sourceFormat = _options$sourceFormat === void 0 ? 6408 : _options$sourceFormat;\n  var _options$sourceAttach = options.sourceAttachment,\n      sourceAttachment = _options$sourceAttach === void 0 ? 36064 : _options$sourceAttach,\n      _options$target = options.target,\n      target = _options$target === void 0 ? null : _options$target,\n      sourceWidth = options.sourceWidth,\n      sourceHeight = options.sourceHeight,\n      sourceType = options.sourceType;\n\n  var _getFramebuffer = getFramebuffer(source),\n      framebuffer = _getFramebuffer.framebuffer,\n      deleteFramebuffer = _getFramebuffer.deleteFramebuffer;\n\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n      handle = framebuffer.handle,\n      attachments = framebuffer.attachments;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  if (sourceAttachment === 36064 && handle === null) {\n    sourceAttachment = 1028;\n  }\n\n  assert(attachments[sourceAttachment]);\n  sourceType = sourceType || attachments[sourceAttachment].type;\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\nexport function readPixelsToBuffer(source, _ref) {\n  var _ref$sourceX = _ref.sourceX,\n      sourceX = _ref$sourceX === void 0 ? 0 : _ref$sourceX,\n      _ref$sourceY = _ref.sourceY,\n      sourceY = _ref$sourceY === void 0 ? 0 : _ref$sourceY,\n      _ref$sourceFormat = _ref.sourceFormat,\n      sourceFormat = _ref$sourceFormat === void 0 ? 6408 : _ref$sourceFormat,\n      _ref$target = _ref.target,\n      target = _ref$target === void 0 ? null : _ref$target,\n      _ref$targetByteOffset = _ref.targetByteOffset,\n      targetByteOffset = _ref$targetByteOffset === void 0 ? 0 : _ref$targetByteOffset,\n      sourceWidth = _ref.sourceWidth,\n      sourceHeight = _ref.sourceHeight,\n      sourceType = _ref.sourceType;\n\n  var _getFramebuffer2 = getFramebuffer(source),\n      framebuffer = _getFramebuffer2.framebuffer,\n      deleteFramebuffer = _getFramebuffer2.deleteFramebuffer;\n\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n  var gl2 = assertWebGL2Context(framebuffer.gl);\n  sourceType = sourceType || (target ? target.type : 5121);\n\n  if (!target) {\n    var components = glFormatToComponents(sourceFormat);\n    var byteCount = glTypeToBytes(sourceType);\n    var byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {\n      byteLength: byteLength,\n      accessor: {\n        type: sourceType,\n        size: components\n      }\n    });\n  }\n\n  target.bind({\n    target: 35051\n  });\n  withParameters(gl2, {\n    framebuffer: framebuffer\n  }, function () {\n    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);\n  });\n  target.unbind({\n    target: 35051\n  });\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\nexport function copyToDataUrl(source) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$sourceAttachmen = _ref2.sourceAttachment,\n      sourceAttachment = _ref2$sourceAttachmen === void 0 ? 36064 : _ref2$sourceAttachmen,\n      _ref2$targetMaxHeight = _ref2.targetMaxHeight,\n      targetMaxHeight = _ref2$targetMaxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref2$targetMaxHeight;\n\n  var data = readPixelsToArray(source, {\n    sourceAttachment: sourceAttachment\n  });\n  var width = source.width,\n      height = source.height;\n\n  while (height > targetMaxHeight) {\n    var _scalePixels = scalePixels({\n      data: data,\n      width: width,\n      height: height\n    });\n\n    data = _scalePixels.data;\n    width = _scalePixels.width;\n    height = _scalePixels.height;\n  }\n\n  flipRows({\n    data: data,\n    width: width,\n    height: height\n  });\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d');\n  var imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n  return canvas.toDataURL();\n}\nexport function copyToImage(source) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$sourceAttachmen = _ref3.sourceAttachment,\n      sourceAttachment = _ref3$sourceAttachmen === void 0 ? 36064 : _ref3$sourceAttachmen,\n      _ref3$targetImage = _ref3.targetImage,\n      targetImage = _ref3$targetImage === void 0 ? null : _ref3$targetImage;\n\n  var dataUrl = copyToDataUrl(source, {\n    sourceAttachment: sourceAttachment\n  });\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\nexport function copyToTexture(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX2 = options.sourceX,\n      sourceX = _options$sourceX2 === void 0 ? 0 : _options$sourceX2,\n      _options$sourceY2 = options.sourceY,\n      sourceY = _options$sourceY2 === void 0 ? 0 : _options$sourceY2,\n      _options$targetMipmap = options.targetMipmaplevel,\n      targetMipmaplevel = _options$targetMipmap === void 0 ? 0 : _options$targetMipmap,\n      _options$targetIntern = options.targetInternalFormat,\n      targetInternalFormat = _options$targetIntern === void 0 ? 6408 : _options$targetIntern;\n  var targetX = options.targetX,\n      targetY = options.targetY,\n      targetZ = options.targetZ,\n      width = options.width,\n      height = options.height;\n\n  var _getFramebuffer3 = getFramebuffer(source),\n      framebuffer = _getFramebuffer3.framebuffer,\n      deleteFramebuffer = _getFramebuffer3.deleteFramebuffer;\n\n  assert(framebuffer);\n  var gl = framebuffer.gl,\n      handle = framebuffer.handle;\n  var isSubCopy = typeof targetX !== 'undefined' || typeof targetY !== 'undefined' || typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  var prevHandle = gl.bindFramebuffer(36160, handle);\n  assert(target);\n  var texture = null;\n\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);\n  } else {\n    switch (target) {\n      case 3553:\n      case 34067:\n        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);\n        break;\n\n      case 35866:\n      case 32879:\n        var gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);\n        break;\n\n      default:\n    }\n  }\n\n  if (texture) {\n    texture.unbind();\n  }\n\n  gl.bindFramebuffer(36160, prevHandle || null);\n\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return texture;\n}\nexport function blit(source, target) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$sourceX3 = options.sourceX0,\n      sourceX0 = _options$sourceX3 === void 0 ? 0 : _options$sourceX3,\n      _options$sourceY3 = options.sourceY0,\n      sourceY0 = _options$sourceY3 === void 0 ? 0 : _options$sourceY3,\n      _options$targetX = options.targetX0,\n      targetX0 = _options$targetX === void 0 ? 0 : _options$targetX,\n      _options$targetY = options.targetY0,\n      targetY0 = _options$targetY === void 0 ? 0 : _options$targetY,\n      _options$color = options.color,\n      color = _options$color === void 0 ? true : _options$color,\n      _options$depth = options.depth,\n      depth = _options$depth === void 0 ? false : _options$depth,\n      _options$stencil = options.stencil,\n      stencil = _options$stencil === void 0 ? false : _options$stencil,\n      _options$filter = options.filter,\n      filter = _options$filter === void 0 ? 9728 : _options$filter;\n  var sourceX1 = options.sourceX1,\n      sourceY1 = options.sourceY1,\n      targetX1 = options.targetX1,\n      targetY1 = options.targetY1,\n      _options$sourceAttach2 = options.sourceAttachment,\n      sourceAttachment = _options$sourceAttach2 === void 0 ? 36064 : _options$sourceAttach2,\n      _options$mask = options.mask,\n      mask = _options$mask === void 0 ? 0 : _options$mask;\n\n  var _getFramebuffer4 = getFramebuffer(source),\n      srcFramebuffer = _getFramebuffer4.framebuffer,\n      deleteSrcFramebuffer = _getFramebuffer4.deleteFramebuffer;\n\n  var _getFramebuffer5 = getFramebuffer(target),\n      dstFramebuffer = _getFramebuffer5.framebuffer,\n      deleteDstFramebuffer = _getFramebuffer5.deleteFramebuffer;\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  var gl = dstFramebuffer.gl,\n      handle = dstFramebuffer.handle,\n      width = dstFramebuffer.width,\n      height = dstFramebuffer.height,\n      readBuffer = dstFramebuffer.readBuffer;\n  var gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === 36064) {\n    sourceAttachment = 1028;\n  }\n\n  if (color) {\n    mask |= 16384;\n  }\n\n  if (depth) {\n    mask |= 256;\n  }\n\n  if (stencil) {\n    mask |= 1024;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    if (mask & (256 | 1024)) {\n      mask = 16384;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n\n  assert(mask);\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n  var prevDrawHandle = gl.bindFramebuffer(36009, handle);\n  var prevReadHandle = gl.bindFramebuffer(36008, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(sourceX0, sourceY0, sourceX1, sourceY1, targetX0, targetY0, targetX1, targetY1, mask, filter);\n  gl2.readBuffer(readBuffer);\n  gl2.bindFramebuffer(36008, prevReadHandle || null);\n  gl2.bindFramebuffer(36009, prevDrawHandle || null);\n\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {\n      framebuffer: toFramebuffer(source),\n      deleteFramebuffer: true\n    };\n  }\n\n  return {\n    framebuffer: source,\n    deleteFramebuffer: false\n  };\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n\n  type = type || 5121;\n  var ArrayType = getTypedArrayFromGLType(type, {\n    clamped: false\n  });\n  var components = glFormatToComponents(format);\n  return new ArrayType(width * height * components);\n}","map":{"version":3,"mappings":"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","names":["Buffer","Framebuffer","Texture","assertWebGL2Context","withParameters","log","flipRows","scalePixels","getTypedArrayFromGLType","getGLTypeFromTypedArray","glFormatToComponents","glTypeToBytes","toFramebuffer","assert","readPixelsToArray","source","options","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","getFramebuffer","framebuffer","deleteFramebuffer","gl","handle","attachments","width","height","type","getPixelArray","prevHandle","bindFramebuffer","readPixels","delete","readPixelsToBuffer","targetByteOffset","gl2","components","byteCount","byteLength","accessor","size","bind","unbind","copyToDataUrl","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","targetImage","dataUrl","Image","src","copyToTexture","targetMipmaplevel","targetInternalFormat","targetX","targetY","targetZ","isSubCopy","texture","isFinite","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","blit","sourceX0","sourceY0","targetX0","targetY0","color","depth","stencil","filter","sourceX1","sourceY1","targetX1","targetY1","mask","srcFramebuffer","deleteSrcFramebuffer","dstFramebuffer","deleteDstFramebuffer","readBuffer","warn","undefined","prevDrawHandle","prevReadHandle","blitFramebuffer","pixelArray","format","ArrayType","clamped"],"sources":["../../../src/classes/copy-and-blit.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {assertWebGL2Context, withParameters, log} from '@luma.gl/gltools';\nimport {flipRows, scalePixels} from '../webgl-utils/typed-array-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils/assert';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(source, options = {}) {\n  const {sourceX = 0, sourceY = 0, sourceFormat = GL.RGBA} = options;\n  let {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  const gl2 = assertWebGL2Context(framebuffer.gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl2, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl2, {framebuffer}, () => {\n    gl2.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(source, target, options = {}) {\n  const {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA\n  } = options;\n  let {\n    targetX,\n    targetY,\n    targetZ,\n    width, // defaults to target width\n    height // defaults to target height\n  } = options;\n\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        const gl2 = assertWebGL2Context(gl);\n        gl2.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  // @ts-ignore\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(source, target, options = {}) {\n  const {\n    sourceX0 = 0,\n    sourceY0 = 0,\n    targetX0 = 0,\n    targetY0 = 0,\n    color = true,\n    depth = false,\n    stencil = false,\n    filter = GL.NEAREST\n  } = options;\n\n  let {\n    sourceX1,\n    sourceY1,\n    targetX1,\n    targetY1,\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    mask = 0\n  } = options;\n\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  // @ts-ignore\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  const gl2 = assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl2.readBuffer(sourceAttachment);\n  gl2.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl2.readBuffer(readBuffer);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  // @ts-ignore\n  gl2.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"]},"metadata":{},"sourceType":"module"}