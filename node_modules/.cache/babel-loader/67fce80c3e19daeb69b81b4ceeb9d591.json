{"ast":null,"code":"import { getBounds, boundsContain, packVertices, scaleToAspectRatio, getTextureCoordinates, getTextureParams } from './heatmap-layer-utils';\nimport { Buffer, Texture2D, Transform, getParameters, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { AttributeManager, COORDINATE_SYSTEM, log } from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer from '../aggregation-layer';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport weights_vs from './weights-vs.glsl';\nimport weights_fs from './weights-fs.glsl';\nimport vs_max from './max-vs.glsl';\nimport fs_max from './max-fs.glsl';\nconst RESOLUTION = 2;\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [10240]: 9729,\n    [10241]: 9729,\n    [10242]: 33071,\n    [10243]: 33071\n  },\n  dataFormat: 6408\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\nconst defaultProps = {\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  intensity: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusPixels: {\n    type: 'number',\n    min: 1,\n    max: 100,\n    value: 50\n  },\n  colorRange: defaultColorRange,\n  threshold: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0.05\n  },\n  colorDomain: {\n    type: 'array',\n    value: null,\n    optional: true\n  },\n  aggregation: 'SUM',\n  weightsTextureSize: {\n    type: 'number',\n    min: 128,\n    max: 2048,\n    value: 2048\n  },\n  debounceTimeout: {\n    type: 'number',\n    min: 0,\n    max: 1000,\n    value: 500\n  }\n};\nconst REQUIRED_FEATURES = [FEATURES.BLEND_EQUATION_MINMAX, FEATURES.TEXTURE_FLOAT];\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\nexport default class HeatmapLayer extends AggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"HeatmapLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeState(DIMENSIONS);\n    this.setState({\n      supported: true,\n      colorDomain: DEFAULT_COLOR_DOMAIN\n    });\n\n    this._setupTextureParams();\n\n    this._setupAttributes();\n\n    this._setupResources();\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    if (!this.state.supported) {\n      return;\n    }\n\n    super.updateState(opts);\n\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts) {\n    const {\n      props,\n      oldProps\n    } = opts;\n\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      clearTimeout(this.state.updateTimer);\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else if (changeFlags.viewportZoomChanged) {\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({\n      zoom: opts.context.viewport.zoom\n    });\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {\n      updateTriggers,\n      intensity,\n      threshold,\n      aggregation\n    } = this.props;\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n    return new TriangleLayerClass(this.getSubLayerProps({\n      id: 'triangle-layer',\n      updateTriggers\n    }), {\n      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n      data: {\n        attributes: {\n          positions: triPositionBuffer,\n          texCoords: triTexCoordBuffer\n        }\n      },\n      vertexCount: 4,\n      maxTexture: maxWeightsTexture,\n      colorTexture,\n      aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n      texture: weightsTexture,\n      intensity,\n      threshold,\n      colorDomain\n    });\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform === null || weightsTransform === void 0 ? void 0 : weightsTransform.delete();\n    weightsTexture === null || weightsTexture === void 0 ? void 0 : weightsTexture.delete();\n    maxWeightTransform === null || maxWeightTransform === void 0 ? void 0 : maxWeightTransform.delete();\n    maxWeightsTexture === null || maxWeightsTexture === void 0 ? void 0 : maxWeightsTexture.delete();\n    triPositionBuffer === null || triPositionBuffer === void 0 ? void 0 : triPositionBuffer.delete();\n    triTexCoordBuffer === null || triTexCoordBuffer === void 0 ? void 0 : triTexCoordBuffer.delete();\n    colorTexture === null || colorTexture === void 0 ? void 0 : colorTexture.delete();\n\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {\n      dimensions\n    } = this.state;\n    changeFlags.dataChanged = this.isAttributeChanged() || this.isAggregationDirty(opts, {\n      compareAll: true,\n      dimension: dimensions.data\n    });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n    const {\n      zoom\n    } = this.state;\n\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {\n      gl\n    } = this.context;\n    const {\n      textureSize,\n      format,\n      type\n    } = this.state;\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      })\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {\n        size: 3,\n        type: 5130,\n        accessor: 'getPosition'\n      },\n      weights: {\n        size: 1,\n        accessor: 'getWeight'\n      }\n    });\n    this.setState({\n      positionAttributeName: 'positions'\n    });\n  }\n\n  _setupTextureParams() {\n    const {\n      gl\n    } = this.context;\n    const {\n      weightsTextureSize\n    } = this.props;\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, 3379));\n    const floatTargetSupport = hasFeatures(gl, FEATURES.COLOR_ATTACHMENT_RGBA32F);\n    const {\n      format,\n      type\n    } = getTextureParams({\n      gl,\n      floatTargetSupport\n    });\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({\n      textureSize,\n      format,\n      type,\n      weightsScale\n    });\n\n    if (!floatTargetSupport) {\n      log.warn(\"HeatmapLayer: \".concat(this.id, \" rendering to float texture not supported, fallingback to low precession format\"))();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(type === 'max-weights-transform' ? {\n      vs: vs_max,\n      _fs: fs_max\n    } : {\n      vs: weights_vs,\n      _fs: weights_fs\n    });\n  }\n\n  _createWeightsTransform() {\n    let shaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _weightsTransform;\n\n    const {\n      gl\n    } = this.context;\n    let {\n      weightsTransform\n    } = this.state;\n    const {\n      weightsTexture\n    } = this.state;\n    (_weightsTransform = weightsTransform) === null || _weightsTransform === void 0 ? void 0 : _weightsTransform.delete();\n    weightsTransform = new Transform(gl, {\n      id: \"\".concat(this.id, \"-weights-transform\"),\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({\n      weightsTransform\n    });\n  }\n\n  _setupResources() {\n    const {\n      gl\n    } = this.context;\n\n    this._createTextures();\n\n    const {\n      textureSize,\n      weightsTexture,\n      maxWeightsTexture\n    } = this.state;\n    const weightsTransformShaders = this.getShaders('weights-transform');\n\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: \"\".concat(this.id, \"-max-weights-transform\"),\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {\n          size: 3\n        }\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {\n          size: 2\n        }\n      })\n    });\n  }\n\n  updateShaders(shaderOptions) {\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {\n      maxWeightTransform\n    } = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1],\n        blendEquation: 32776\n      }\n    });\n  }\n\n  _updateBounds() {\n    let forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const {\n      viewport\n    } = this.context;\n    const viewportCorners = [viewport.unproject([0, 0]), viewport.unproject([viewport.width, 0]), viewport.unproject([viewport.width, viewport.height]), viewport.unproject([0, viewport.height])].map(p => p.map(Math.fround));\n    const visibleWorldBounds = getBounds(viewportCorners);\n    const newState = {\n      visibleWorldBounds,\n      viewportCorners\n    };\n    let boundsChanged = false;\n\n    if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n      boundsChanged = true;\n    }\n\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    const {\n      triPositionBuffer,\n      triTexCoordBuffer,\n      normalizedCommonBounds,\n      viewportCorners\n    } = this.state;\n    const {\n      viewport\n    } = this.context;\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n    const textureBounds = viewportCorners.map(p => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds));\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {\n      colorRange\n    } = opts.props;\n    let {\n      colorTexture\n    } = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n\n    this.setState({\n      colorTexture\n    });\n  }\n\n  _updateWeightmap() {\n    const {\n      radiusPixels,\n      colorDomain,\n      aggregation\n    } = this.props;\n    const {\n      weightsTransform,\n      worldBounds,\n      textureSize,\n      weightsTexture,\n      weightsScale\n    } = this.state;\n    this.state.isWeightMapDirty = false;\n\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      const {\n        viewport\n      } = this.context;\n      const metersPerPixel = viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    weightsTransform.run({\n      uniforms,\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1],\n        blendEquation: 32774\n      },\n      clearRenderTarget: true,\n      attributes: this.getAttributes(),\n      moduleSettings: this.getModuleSettings()\n    });\n\n    this._updateMaxWeightValue();\n\n    weightsTexture.setParameters({\n      [10240]: 9729,\n      [10241]: 9729\n    });\n  }\n\n  _debouncedUpdateWeightmap() {\n    let fromTimer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let {\n      updateTimer\n    } = this.state;\n    const {\n      debounceTimeout\n    } = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n\n      this._updateBounds(true);\n\n      this._updateTextureRenderingBounds();\n\n      this.setState({\n        isWeightMapDirty: true\n      });\n    } else {\n      this.setState({\n        isWeightMapDirty: false\n      });\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({\n      updateTimer\n    });\n  }\n\n  _worldToCommonBounds(worldBounds) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      useLayerCoordinateSystem = false\n    } = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {\n      viewport\n    } = this.context;\n    const {\n      textureSize\n    } = this.state;\n    const {\n      coordinateSystem\n    } = this.props;\n    const offsetMode = useLayerCoordinateSystem && (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];\n    const size = textureSize * RESOLUTION / viewport.scale;\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n\n    return scaleToAspectRatio([bottomLeftCommon[0] - offsetOriginCommon[0], bottomLeftCommon[1] - offsetOriginCommon[1], topRightCommon[0] - offsetOriginCommon[0], topRightCommon[1] - offsetOriginCommon[1]], size, size);\n  }\n\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {\n      viewport\n    } = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n\n}\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["getBounds","boundsContain","packVertices","scaleToAspectRatio","getTextureCoordinates","getTextureParams","Buffer","Texture2D","Transform","getParameters","FEATURES","hasFeatures","AttributeManager","COORDINATE_SYSTEM","log","TriangleLayer","AggregationLayer","defaultColorRange","colorRangeToFlatArray","weights_vs","weights_fs","vs_max","fs_max","RESOLUTION","TEXTURE_OPTIONS","mipmaps","parameters","dataFormat","DEFAULT_COLOR_DOMAIN","AGGREGATION_MODE","SUM","MEAN","defaultProps","getPosition","type","value","x","position","getWeight","intensity","min","radiusPixels","max","colorRange","threshold","colorDomain","optional","aggregation","weightsTextureSize","debounceTimeout","REQUIRED_FEATURES","BLEND_EQUATION_MINMAX","TEXTURE_FLOAT","DIMENSIONS","data","props","HeatmapLayer","initializeState","gl","context","setState","supported","error","id","_setupTextureParams","_setupAttributes","_setupResources","shouldUpdateState","changeFlags","somethingChanged","updateState","opts","state","_updateHeatmapState","oldProps","_getChangeFlags","dataChanged","viewportChanged","boundsChanged","_updateBounds","_updateTextureRenderingBounds","clearTimeout","updateTimer","isWeightMapDirty","viewportZoomChanged","_debouncedUpdateWeightmap","_updateColorTexture","_updateWeightmap","zoom","viewport","renderLayers","weightsTexture","triPositionBuffer","triTexCoordBuffer","maxWeightsTexture","colorTexture","updateTriggers","TriangleLayerClass","getSubLayerClass","getSubLayerProps","coordinateSystem","DEFAULT","attributes","positions","texCoords","vertexCount","maxTexture","aggregationMode","texture","finalizeState","weightsTransform","maxWeightTransform","delete","_getAttributeManager","stats","dimensions","isAttributeChanged","isAggregationDirty","compareAll","dimension","_createTextures","textureSize","format","width","height","attributeManager","getAttributeManager","add","size","accessor","weights","positionAttributeName","Math","floatTargetSupport","COLOR_ATTACHMENT_RGBA32F","weightsScale","warn","getShaders","vs","_fs","_createWeightsTransform","shaders","elementCount","_targetTexture","_targetTextureVarying","weightsTransformShaders","maxWeightsTransformShaders","_sourceTextures","inTexture","byteLength","updateShaders","shaderOptions","_updateMaxWeightValue","run","blend","depthTest","blendFunc","blendEquation","forceUpdate","viewportCorners","unproject","map","p","fround","visibleWorldBounds","newState","worldBounds","scaledCommonBounds","_worldToCommonBounds","_commonToWorldBounds","LNGLAT","normalizedCommonBounds","subData","textureBounds","projectPosition","colors","Uint8Array","setImageData","length","commonBounds","useLayerCoordinateSystem","metersPerPixel","distanceScales","metersPerUnit","uniforms","textureWidth","update","getNumInstances","clearRenderTarget","getAttributes","moduleSettings","getModuleSettings","setParameters","fromTimer","setTimeout","bind","minLong","minLat","maxLong","maxLat","offsetMode","LNGLAT_OFFSETS","METER_OFFSETS","offsetOriginCommon","coordinateOrigin","scale","bottomLeftCommon","topRightCommon","xMin","yMin","xMax","yMax","bottomLeftWorld","unprojectPosition","topRightWorld","slice","concat","layerName"],"sources":["../../../src/heatmap-layer/heatmap-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global setTimeout clearTimeout */\nimport GL from '@luma.gl/constants';\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates,\n  getTextureParams\n} from './heatmap-layer-utils';\nimport {Buffer, Texture2D, Transform, getParameters, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {AttributeManager, COORDINATE_SYSTEM, log} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer from '../aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport weights_vs from './weights-vs.glsl';\nimport weights_fs from './weights-fs.glsl';\nimport vs_max from './max-vs.glsl';\nimport fs_max from './max-fs.glsl';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_OPTIONS = {\n  mipmaps: false,\n  parameters: {\n    [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n    [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n    [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n  },\n  dataFormat: GL.RGBA\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps = {\n  getPosition: {type: 'accessor', value: x => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.BLEND_EQUATION_MINMAX, // max weight calculation\n  FEATURES.TEXTURE_FLOAT // weight-map as texture\n  // FEATURES.FLOAT_BLEND, // implictly supported when TEXTURE_FLOAT is supported\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport default class HeatmapLayer extends AggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!hasFeatures(gl, REQUIRED_FEATURES)) {\n      this.setState({supported: false});\n      log.error(`HeatmapLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState(DIMENSIONS);\n    this.setState({supported: true, colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts) {\n    if (!this.state.supported) {\n      return;\n    }\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        texture: weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.delete();\n    weightsTexture?.delete();\n    maxWeightTransform?.delete();\n    maxWeightsTexture?.delete();\n    triPositionBuffer?.delete();\n    triTexCoordBuffer?.delete();\n    colorTexture?.delete();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.gl, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts) {\n    const changeFlags = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      this.isAttributeChanged() || // if any attribute is changed\n      this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      });\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {gl} = this.context;\n    const {textureSize, format, type} = this.state;\n\n    this.setState({\n      weightsTexture: new Texture2D(gl, {\n        width: textureSize,\n        height: textureSize,\n        format,\n        type,\n        ...TEXTURE_OPTIONS\n      }),\n      maxWeightsTexture: new Texture2D(gl, {format, type, ...TEXTURE_OPTIONS}) // 1 X 1 texture,\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      positions: {size: 3, type: GL.DOUBLE, accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {gl} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, getParameters(gl, gl.MAX_TEXTURE_SIZE));\n    const floatTargetSupport = hasFeatures(gl, FEATURES.COLOR_ATTACHMENT_RGBA32F);\n    const {format, type} = getTextureParams({gl, floatTargetSupport});\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, type, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, fallingback to low precession format`\n      )();\n    }\n  }\n\n  getShaders(type) {\n    return super.getShaders(\n      type === 'max-weights-transform'\n        ? {\n            vs: vs_max,\n            _fs: fs_max\n          }\n        : {\n            vs: weights_vs,\n            _fs: weights_fs\n          }\n    );\n  }\n\n  _createWeightsTransform(shaders = {}) {\n    const {gl} = this.context;\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    weightsTransform?.delete();\n\n    weightsTransform = new Transform(gl, {\n      id: `${this.id}-weights-transform`,\n      elementCount: 1,\n      _targetTexture: weightsTexture,\n      _targetTextureVarying: 'weightsTexture',\n      ...shaders\n    });\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    const {gl} = this.context;\n    this._createTextures();\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders('weights-transform');\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders('max-weights-transform');\n    const maxWeightTransform = new Transform(gl, {\n      id: `${this.id}-max-weights-transform`,\n      _sourceTextures: {\n        inTexture: weightsTexture\n      },\n      _targetTexture: maxWeightsTexture,\n      _targetTextureVarying: 'outTexture',\n      ...maxWeightsTransformShaders,\n      elementCount: textureSize * textureSize\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 3}\n      }),\n      triTexCoordBuffer: new Buffer(gl, {\n        byteLength: 48,\n        accessor: {size: 2}\n      })\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // sahder params (modules, injects) changed, update model object\n    this._createWeightsTransform(shaderOptions);\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n    maxWeightTransform.run({\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.MAX\n      }\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate = false) {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([viewport.width, viewport.height]),\n      viewport.unproject([0, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\n      this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer.subData(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds)\n    );\n    triTexCoordBuffer.subData(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n    if (colorTexture) {\n      colorTexture.setImageData({\n        data: colors,\n        width: colorRange.length\n      });\n    } else {\n      colorTexture = new Texture2D(this.context.gl, {\n        data: colors,\n        width: colorRange.length,\n        height: 1,\n        ...TEXTURE_OPTIONS\n      });\n    }\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {weightsTransform, worldBounds, textureSize, weightsTexture, weightsScale} = this.state;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const uniforms = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale\n    };\n    // Attribute manager sets data array count as instaceCount on model\n    // we need to set that as elementCount on 'weightsTransform'\n    weightsTransform.update({\n      elementCount: this.getNumInstances()\n    });\n    weightsTransform.run({\n      uniforms,\n      parameters: {\n        blend: true,\n        depthTest: false,\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: GL.FUNC_ADD\n      },\n      clearRenderTarget: true,\n      attributes: this.getAttributes(),\n      moduleSettings: this.getModuleSettings()\n    });\n    this._updateMaxWeightValue();\n\n    // reset filtering parameters (TODO: remove once luma issue#1193 is fixed)\n    weightsTexture.setParameters({\n      [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n      [GL.TEXTURE_MIN_FILTER]: GL.LINEAR\n    });\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(worldBounds, opts = {}) {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n\nHeatmapLayer.layerName = 'HeatmapLayer';\nHeatmapLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}