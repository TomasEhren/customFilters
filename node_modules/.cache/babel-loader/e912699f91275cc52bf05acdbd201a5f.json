{"ast":null,"code":"export const EMPTY = [];\nexport const FULL = [[0, Infinity]];\nexport function add(rangeList, range) {\n  if (rangeList === FULL) {\n    return rangeList;\n  }\n\n  if (range[0] < 0) {\n    range[0] = 0;\n  }\n\n  if (range[0] >= range[1]) {\n    return rangeList;\n  }\n\n  const newRangeList = [];\n  const len = rangeList.length;\n  let insertPosition = 0;\n\n  for (let i = 0; i < len; i++) {\n    const range0 = rangeList[i];\n\n    if (range0[1] < range[0]) {\n      newRangeList.push(range0);\n      insertPosition = i + 1;\n    } else if (range0[0] > range[1]) {\n      newRangeList.push(range0);\n    } else {\n      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];\n    }\n  }\n\n  newRangeList.splice(insertPosition, 0, range);\n  return newRangeList;\n}","map":{"version":3,"mappings":"AAMA,OAAO,MAAMA,KAAK,GAAG,EAAd;AACP,OAAO,MAAMC,IAAI,GAAG,CAAC,CAAC,CAAD,EAAIC,QAAJ,CAAD,CAAb;AAGP,OAAO,SAASC,GAAT,CAAaC,SAAb,EAAwBC,KAAxB,EAA+B;EAEpC,IAAID,SAAS,KAAKH,IAAlB,EAAwB;IACtB,OAAOG,SAAP;EACD;;EAGD,IAAIC,KAAK,CAAC,CAAD,CAALA,GAAW,CAAf,EAAkB;IAChBA,KAAK,CAAC,CAAD,CAALA,GAAW,CAAXA;EACD;;EACD,IAAIA,KAAK,CAAC,CAAD,CAALA,IAAYA,KAAK,CAAC,CAAD,CAArB,EAA0B;IACxB,OAAOD,SAAP;EACD;;EAGD,MAAME,YAAsB,GAAG,EAA/B;EACA,MAAMC,GAAG,GAAGH,SAAS,CAACI,MAAtB;EACA,IAAIC,cAAc,GAAG,CAArB;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,GAApB,EAAyBG,CAAC,EAA1B,EAA8B;IAC5B,MAAMC,MAAM,GAAGP,SAAS,CAACM,CAAD,CAAxB;;IAEA,IAAIC,MAAM,CAAC,CAAD,CAANA,GAAYN,KAAK,CAAC,CAAD,CAArB,EAA0B;MAExBC,YAAY,CAACM,IAAbN,CAAkBK,MAAlBL;MACAG,cAAc,GAAGC,CAAC,GAAG,CAArBD;IAHF,OAIO,IAAIE,MAAM,CAAC,CAAD,CAANA,GAAYN,KAAK,CAAC,CAAD,CAArB,EAA0B;MAE/BC,YAAY,CAACM,IAAbN,CAAkBK,MAAlBL;IAFK,OAGA;MACLD,KAAK,GAAG,CAACQ,IAAI,CAACC,GAALD,CAASF,MAAM,CAAC,CAAD,CAAfE,EAAoBR,KAAK,CAAC,CAAD,CAAzBQ,CAAD,EAAgCA,IAAI,CAACE,GAALF,CAASF,MAAM,CAAC,CAAD,CAAfE,EAAoBR,KAAK,CAAC,CAAD,CAAzBQ,CAAhC,CAARR;IACD;EACF;;EACDC,YAAY,CAACU,MAAbV,CAAoBG,cAApBH,EAAoC,CAApCA,EAAuCD,KAAvCC;EACA,OAAOA,YAAP;AACD","names":["EMPTY","FULL","Infinity","add","rangeList","range","newRangeList","len","length","insertPosition","i","range0","push","Math","min","max","splice"],"sources":["../../../src/utils/range.ts"],"sourcesContent":["/*\n * range (Array)\n *   + start (Number) - the start index (incl.)\n *   + end (Number) - the end index (excl.)\n * rangeList (Array) - array of sorted, combined ranges\n */\nexport const EMPTY = [];\nexport const FULL = [[0, Infinity]];\n\n// Insert a range into a range collection\nexport function add(rangeList, range) {\n  // Noop if range collection already covers all\n  if (rangeList === FULL) {\n    return rangeList;\n  }\n\n  // Validate the input range\n  if (range[0] < 0) {\n    range[0] = 0;\n  }\n  if (range[0] >= range[1]) {\n    return rangeList;\n  }\n\n  // TODO - split off to tree-shakable Range class\n  const newRangeList: number[] = [];\n  const len = rangeList.length;\n  let insertPosition = 0;\n\n  for (let i = 0; i < len; i++) {\n    const range0 = rangeList[i];\n\n    if (range0[1] < range[0]) {\n      // the current range is to the left of the new range\n      newRangeList.push(range0);\n      insertPosition = i + 1;\n    } else if (range0[0] > range[1]) {\n      // the current range is to the right of the new range\n      newRangeList.push(range0);\n    } else {\n      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];\n    }\n  }\n  newRangeList.splice(insertPosition, 0, range);\n  return newRangeList;\n}\n"]},"metadata":{},"sourceType":"module"}