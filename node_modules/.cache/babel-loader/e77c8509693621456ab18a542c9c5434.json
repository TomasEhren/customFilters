{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScaleMode = void 0;\n\nvar _bbox = _interopRequireDefault(require(\"@turf/bbox\"));\n\nvar _centroid = _interopRequireDefault(require(\"@turf/centroid\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _bboxPolygon = _interopRequireDefault(require(\"@turf/bbox-polygon\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _polygonToLine = _interopRequireDefault(require(\"@turf/polygon-to-line\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _transformScale = _interopRequireDefault(require(\"@turf/transform-scale\"));\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ScaleMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ScaleMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ScaleMode);\n\n  function ScaleMode() {\n    var _this;\n\n    _classCallCheck(this, ScaleMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_geometryBeingScaled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_cornerGuidePoints\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_cursor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isScaling\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isSinglePointGeometrySelected\", function (geometry) {\n      var _ref = geometry || {},\n          features = _ref.features;\n\n      if (Array.isArray(features) && features.length === 1) {\n        // @ts-ignore\n        var _getGeom = (0, _invariant.getGeom)(features[0]),\n            type = _getGeom.type;\n\n        return type === 'Point';\n      }\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_getOppositeScaleHandle\", function (selectedHandle) {\n      var selectedHandleIndex = selectedHandle && selectedHandle.properties && Array.isArray(selectedHandle.properties.positionIndexes) && selectedHandle.properties.positionIndexes[0];\n\n      if (typeof selectedHandleIndex !== 'number') {\n        return null;\n      }\n\n      var guidePointCount = _this._cornerGuidePoints.length;\n      var oppositeIndex = (selectedHandleIndex + guidePointCount / 2) % guidePointCount;\n      return _this._cornerGuidePoints.find(function (p) {\n        if (!Array.isArray(p.properties.positionIndexes)) {\n          return false;\n        }\n\n        return p.properties.positionIndexes[0] === oppositeIndex;\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_getUpdatedData\", function (props, editedData) {\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n      var selectedIndexes = props.selectedIndexes;\n\n      for (var i = 0; i < selectedIndexes.length; i++) {\n        var selectedIndex = selectedIndexes[i];\n        var movedFeature = editedData.features[i];\n        updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n      }\n\n      return updatedData.getObject();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isEditHandleSelected\", function () {\n      return Boolean(_this._selectedEditHandle);\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getScaleAction\", function (startDragPoint, currentPoint, editType, props) {\n      if (!_this._selectedEditHandle) {\n        return null;\n      }\n\n      var oppositeHandle = _this._getOppositeScaleHandle(_this._selectedEditHandle);\n\n      var origin = (0, _invariant.getCoord)(oppositeHandle); // @ts-ignore\n\n      var scaleFactor = getScaleFactor(origin, startDragPoint, currentPoint); // @ts-ignore\n\n      var scaledFeatures = (0, _transformScale[\"default\"])( // @ts-ignore\n      _this._geometryBeingScaled, scaleFactor, {\n        origin: origin\n      });\n      return {\n        updatedData: _this._getUpdatedData(props, scaledFeatures),\n        editType: editType,\n        editContext: {\n          featureIndexes: props.selectedIndexes\n        }\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"updateCursor\", function (props) {\n      if (_this._selectedEditHandle) {\n        if (_this._cursor) {\n          props.onUpdateCursor(_this._cursor);\n        }\n\n        var cursorGeometry = _this.getSelectedFeaturesAsFeatureCollection(props); // Get resize cursor direction from the hovered scale editHandle (e.g. nesw or nwse)\n\n\n        var centroid = (0, _centroid[\"default\"])(cursorGeometry);\n        var bearing = (0, _bearing[\"default\"])(centroid, _this._selectedEditHandle);\n        var positiveBearing = bearing < 0 ? bearing + 180 : bearing;\n\n        if (positiveBearing >= 0 && positiveBearing <= 90 || positiveBearing >= 180 && positiveBearing <= 270) {\n          _this._cursor = 'nesw-resize';\n          props.onUpdateCursor('nesw-resize');\n        } else {\n          _this._cursor = 'nwse-resize';\n          props.onUpdateCursor('nwse-resize');\n        }\n      } else {\n        props.onUpdateCursor(null);\n        _this._cursor = null;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(ScaleMode, [{\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isScaling) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'scale' ? selectedEditHandle : null;\n        this.updateCursor(props);\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isScaling = true;\n        this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);\n      }\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      if (!this._isScaling) {\n        return;\n      }\n\n      props.onUpdateCursor(this._cursor);\n      var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, 'scaling', props);\n\n      if (scaleAction) {\n        props.onEdit(scaleAction);\n      }\n\n      event.cancelPan();\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isScaling) {\n        // Scale the geometry\n        var scaleAction = this.getScaleAction(event.pointerDownMapCoords, event.mapCoords, 'scaled', props);\n\n        if (scaleAction) {\n          props.onEdit(scaleAction);\n        }\n\n        props.onUpdateCursor(null);\n        this._geometryBeingScaled = null;\n        this._selectedEditHandle = null;\n        this._cursor = null;\n        this._isScaling = false;\n      }\n    }\n  }, {\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      this._cornerGuidePoints = [];\n      var selectedGeometry = this.getSelectedFeaturesAsFeatureCollection(props); // Add buffer to the enveloping box if a single Point feature is selected\n\n      if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n        return {\n          type: 'FeatureCollection',\n          features: []\n        };\n      }\n\n      var boundingBox = (0, _bboxPolygon[\"default\"])((0, _bbox[\"default\"])(selectedGeometry));\n      boundingBox.properties.mode = 'scale';\n      var cornerGuidePoints = [];\n      (0, _meta.coordEach)(boundingBox, function (coord, coordIndex) {\n        if (coordIndex < 4) {\n          // Get corner midpoint guides from the enveloping box\n          var cornerPoint = (0, _helpers.point)(coord, {\n            guideType: 'editHandle',\n            editHandleType: 'scale',\n            positionIndexes: [coordIndex]\n          });\n          cornerGuidePoints.push(cornerPoint);\n        }\n      });\n      this._cornerGuidePoints = cornerGuidePoints; // @ts-ignore\n\n      return (0, _helpers.featureCollection)([(0, _polygonToLine[\"default\"])(boundingBox)].concat(_toConsumableArray(this._cornerGuidePoints)));\n    }\n  }]);\n\n  return ScaleMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ScaleMode = ScaleMode;\n\nfunction getScaleFactor(centroid, startDragPoint, currentPoint) {\n  var startDistance = (0, _distance[\"default\"])(centroid, startDragPoint);\n  var endDistance = (0, _distance[\"default\"])(centroid, currentPoint);\n  return endDistance / startDistance;\n}","map":{"version":3,"mappings":";;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAWA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEaA,S;;;;;;;;;;;;;;;;;;;;;;;;iEAKE;;qFAEoB,UAACC,QAAD,EAA6D;MAAA,WACvEA,QAAQ,IAAI,EAD2D;MAAA,IACpFC,QADoF,QACpFA,QADoF;;MAE5F,IAAIC,KAAK,CAACC,OAAND,CAAcD,QAAdC,KAA2BD,QAAQ,CAACG,MAATH,KAAoB,CAAnD,EAAsD;QACpD;QADoD,eAEnC,wBAAQA,QAAQ,CAAC,CAAD,CAAhB,CAFmC;QAAA,IAE5CI,IAF4C,YAE5CA,IAF4C;;QAGpD,OAAOA,IAAI,KAAK,OAAhB;MACD;;MACD,OAAO,KAAP;;;8EAGwB,UAACC,cAAD,EAAuC;MAC/D,IAAMC,mBAAmB,GACvBD,cAAc,IACdA,cAAc,CAACE,UADfF,IAEAJ,KAAK,CAACC,OAAND,CAAcI,cAAc,CAACE,UAAfF,CAA0BG,eAAxCP,CAFAI,IAGAA,cAAc,CAACE,UAAfF,CAA0BG,eAA1BH,CAA0C,CAA1CA,CAJF;;MAMA,IAAI,OAAOC,mBAAP,KAA+B,QAAnC,EAA6C;QAC3C,OAAO,IAAP;MACD;;MACD,IAAMG,eAAe,GAAGC,MAAKC,kBAAL,CAAwBR,MAAhD;MACA,IAAMS,aAAa,GAAG,CAACN,mBAAmB,GAAGG,eAAe,GAAG,CAAzC,IAA8CA,eAApE;MACA,OAAOC,MAAKC,kBAAL,CAAwBE,IAAxB,CAA6B,UAACC,CAAD,EAAO;QACzC,IAAI,CAACb,KAAK,CAACC,OAAND,CAAca,CAAC,CAACP,UAAFO,CAAaN,eAA3BP,CAAL,EAAkD;UAChD,OAAO,KAAP;QACD;;QACD,OAAOa,CAAC,CAACP,UAAFO,CAAaN,eAAbM,CAA6B,CAA7BA,MAAoCF,aAA3C;MAJK,EAAP;;;sEAQgB,UAACG,KAAD,EAAsCC,UAAtC,EAAwE;MACxF,IAAIC,WAAW,GAAG,IAAIC,sDAAJ,CAA+BH,KAAK,CAACI,IAArC,CAAlB;MACA,IAAMC,eAAe,GAAGL,KAAK,CAACK,eAA9B;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,eAAe,CAACjB,MAApC,EAA4CkB,CAAC,EAA7C,EAAiD;QAC/C,IAAMC,aAAa,GAAGF,eAAe,CAACC,CAAD,CAArC;QACA,IAAME,YAAY,GAAGP,UAAU,CAAChB,QAAXgB,CAAoBK,CAApBL,CAArB;QACAC,WAAW,GAAGA,WAAW,CAACO,eAAZP,CAA4BK,aAA5BL,EAA2CM,YAAY,CAACxB,QAAxDkB,CAAdA;MACD;;MACD,OAAOA,WAAW,CAACQ,SAAZR,EAAP;;;2EAGqB;MAAA,OAAeS,OAAO,CAAChB,MAAKiB,mBAAN,CAAtB;;;qEAEN,UACfC,cADe,EAEfC,YAFe,EAGfC,QAHe,EAIff,KAJe,EAKZ;MACH,IAAI,CAACL,MAAKiB,mBAAV,EAA+B;QAC7B,OAAO,IAAP;MACD;;MAED,IAAMI,cAAc,GAAGrB,MAAKsB,uBAAL,CAA6BtB,MAAKiB,mBAAlC,CAAvB;;MACA,IAAMM,MAAM,GAAG,yBAASF,cAAT,CAAf,CANG,CAOH;;MACA,IAAMG,WAAW,GAAGC,cAAc,CAACF,MAAD,EAASL,cAAT,EAAyBC,YAAzB,CAAlC,CARG,CASH;;MACA,IAAMO,cAAiC,GAAG,iCACxC;MACA1B,MAAK2B,oBAFmC,EAGxCH,WAHwC,EAIxC;QAAED,MAAM,EAANA;MAAF,CAJwC,CAA1C;MAOA,OAAO;QACLhB,WAAW,EAAEP,MAAK4B,eAAL,CAAqBvB,KAArB,EAA4BqB,cAA5B,CADR;QAELN,QAAQ,EAARA,QAFK;QAGLS,WAAW,EAAE;UACXC,cAAc,EAAEzB,KAAK,CAACK;QADX;MAHR,CAAP;;;mEASa,UAACL,KAAD,EAAyC;MACtD,IAAIL,MAAKiB,mBAAT,EAA8B;QAC5B,IAAIjB,MAAK+B,OAAT,EAAkB;UAChB1B,KAAK,CAAC2B,cAAN3B,CAAqBL,MAAK+B,OAA1B1B;QACD;;QACD,IAAM4B,cAAc,GAAGjC,MAAKkC,sCAAL,CAA4C7B,KAA5C,CAAvB,CAJ4B,CAM5B;;;QACA,IAAM8B,QAAQ,GAAG,0BAAaF,cAAb,CAAjB;QACA,IAAMG,OAAO,GAAG,yBAAYD,QAAZ,EAAsBnC,MAAKiB,mBAA3B,CAAhB;QACA,IAAMoB,eAAe,GAAGD,OAAO,GAAG,CAAVA,GAAcA,OAAO,GAAG,GAAxBA,GAA8BA,OAAtD;;QACA,IACGC,eAAe,IAAI,CAAnBA,IAAwBA,eAAe,IAAI,EAA3CA,IACAA,eAAe,IAAI,GAAnBA,IAA0BA,eAAe,IAAI,GAFhD,EAGE;UACArC,MAAK+B,OAAL,GAAe,aAAf;UACA1B,KAAK,CAAC2B,cAAN3B,CAAqB,aAArBA;QALF,OAMO;UACLL,MAAK+B,OAAL,GAAe,aAAf;UACA1B,KAAK,CAAC2B,cAAN3B,CAAqB,aAArBA;QACD;MAnBH,OAoBO;QACLA,KAAK,CAAC2B,cAAN3B,CAAqB,IAArBA;QACAL,MAAK+B,OAAL,GAAe,IAAf;MACD;;;;;;;;sCAGeO,OAAyBjC,OAAqC;MAC9E,IAAI,CAAC,KAAKkC,UAAV,EAAsB;QACpB,IAAMC,kBAAkB,GAAG,gCAAoBF,KAAK,CAACG,KAA1B,CAA3B;QACA,KAAKxB,mBAAL,GACEuB,kBAAkB,IAAIA,kBAAkB,CAAC3C,UAAnB2C,CAA8BE,cAA9BF,KAAiD,OAAvEA,GACIA,kBADJA,GAEI,IAHN;QAKA,KAAKG,YAAL,CAAkBtC,KAAlB;MACD;IACF;;;wCAEmBiC,OAA2BjC,OAAqC;MAClF,IAAI,KAAKY,mBAAT,EAA8B;QAC5B,KAAKsB,UAAL,GAAkB,IAAlB;QACA,KAAKZ,oBAAL,GAA4B,KAAKO,sCAAL,CAA4C7B,KAA5C,CAA5B;MACD;IACF;;;mCAEciC,OAAsBjC,OAAqC;MACxE,IAAI,CAAC,KAAKkC,UAAV,EAAsB;QACpB;MACD;;MAEDlC,KAAK,CAAC2B,cAAN3B,CAAqB,KAAK0B,OAA1B1B;MAEA,IAAMuC,WAAW,GAAG,KAAKC,cAAL,CAClBP,KAAK,CAACQ,oBADY,EAElBR,KAAK,CAACS,SAFY,EAGlB,SAHkB,EAIlB1C,KAJkB,CAApB;;MAMA,IAAIuC,WAAJ,EAAiB;QACfvC,KAAK,CAAC2C,MAAN3C,CAAauC,WAAbvC;MACD;;MAEDiC,KAAK,CAACW,SAANX;IACD;;;uCAEkBA,OAA0BjC,OAAqC;MAChF,IAAI,KAAKkC,UAAT,EAAqB;QACnB;QACA,IAAMK,WAAW,GAAG,KAAKC,cAAL,CAClBP,KAAK,CAACQ,oBADY,EAElBR,KAAK,CAACS,SAFY,EAGlB,QAHkB,EAIlB1C,KAJkB,CAApB;;QAMA,IAAIuC,WAAJ,EAAiB;UACfvC,KAAK,CAAC2C,MAAN3C,CAAauC,WAAbvC;QACD;;QAEDA,KAAK,CAAC2B,cAAN3B,CAAqB,IAArBA;QAEA,KAAKsB,oBAAL,GAA4B,IAA5B;QACA,KAAKV,mBAAL,GAA2B,IAA3B;QACA,KAAKc,OAAL,GAAe,IAAf;QACA,KAAKQ,UAAL,GAAkB,KAAlB;MACD;IACF;;;8BAESlC,OAA6D;MACrE,KAAKJ,kBAAL,GAA0B,EAA1B;MACA,IAAMiD,gBAAgB,GAAG,KAAKhB,sCAAL,CAA4C7B,KAA5C,CAAzB,CAFqE,CAIrE;;MACA,IAAI,KAAK8C,8BAAL,CAAoCD,gBAApC,CAAJ,EAA2D;QACzD,OAAO;UAAExD,IAAI,EAAE,mBAAR;UAA6BJ,QAAQ,EAAE;QAAvC,CAAP;MACD;;MAED,IAAM8D,WAAW,GAAG,6BAAY,sBAAKF,gBAAL,CAAZ,CAApB;MACAE,WAAW,CAACvD,UAAZuD,CAAuBC,IAAvBD,GAA8B,OAA9BA;MACA,IAAME,iBAAiB,GAAG,EAA1B;MAEA,qBAAUF,WAAV,EAAuB,UAACG,KAAD,EAAQC,UAAR,EAAuB;QAC5C,IAAIA,UAAU,GAAG,CAAjB,EAAoB;UAClB;UACA,IAAMC,WAAW,GAAG,oBAAMF,KAAN,EAAa;YAC/BG,SAAS,EAAE,YADoB;YAE/BhB,cAAc,EAAE,OAFe;YAG/B5C,eAAe,EAAE,CAAC0D,UAAD;UAHc,CAAb,CAApB;UAKAF,iBAAiB,CAACK,IAAlBL,CAAuBG,WAAvBH;QACD;MATH;MAYA,KAAKrD,kBAAL,GAA0BqD,iBAA1B,CAzBqE,CA0BrE;;MACA,OAAO,iCAAmB,+BAAcF,WAAd,CAAnB,4BAAkD,KAAKnD,kBAAvD,GAAP;IACD;;;;EArM4B2D,gC;;;;AAwM/B,SAASnC,cAAT,CAAwBU,QAAxB,EAA4CjB,cAA5C,EAAsEC,YAAtE,EAA8F;EAC5F,IAAM0C,aAAa,GAAG,0BAAa1B,QAAb,EAAuBjB,cAAvB,CAAtB;EACA,IAAM4C,WAAW,GAAG,0BAAa3B,QAAb,EAAuBhB,YAAvB,CAApB;EACA,OAAO2C,WAAW,GAAGD,aAArB;AACD","names":["ScaleMode","geometry","features","Array","isArray","length","type","selectedHandle","selectedHandleIndex","properties","positionIndexes","guidePointCount","_this","_cornerGuidePoints","oppositeIndex","find","p","props","editedData","updatedData","ImmutableFeatureCollection","data","selectedIndexes","i","selectedIndex","movedFeature","replaceGeometry","getObject","Boolean","_selectedEditHandle","startDragPoint","currentPoint","editType","oppositeHandle","_getOppositeScaleHandle","origin","scaleFactor","getScaleFactor","scaledFeatures","_geometryBeingScaled","_getUpdatedData","editContext","featureIndexes","_cursor","onUpdateCursor","cursorGeometry","getSelectedFeaturesAsFeatureCollection","centroid","bearing","positiveBearing","event","_isScaling","selectedEditHandle","picks","editHandleType","updateCursor","scaleAction","getScaleAction","pointerDownMapCoords","mapCoords","onEdit","cancelPan","selectedGeometry","_isSinglePointGeometrySelected","boundingBox","mode","cornerGuidePoints","coord","coordIndex","cornerPoint","guideType","push","GeoJsonEditMode","startDistance","endDistance"],"sources":["../../src/lib/scale-mode.ts"],"sourcesContent":["/* eslint-disable prettier/prettier */\nimport bbox from '@turf/bbox';\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport { point, featureCollection } from '@turf/helpers';\nimport polygonToLine from '@turf/polygon-to-line';\nimport { coordEach } from '@turf/meta';\nimport turfDistance from '@turf/distance';\nimport turfTransformScale from '@turf/transform-scale';\nimport { getCoord, getGeom } from '@turf/invariant';\nimport { FeatureCollection, Position } from '../geojson-types';\nimport {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { getPickedEditHandle } from '../utils';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ScaleMode extends GeoJsonEditMode {\n  _geometryBeingScaled: FeatureCollection | null | undefined;\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _cornerGuidePoints: Array<EditHandleFeature>;\n  _cursor: string | null | undefined;\n  _isScaling = false;\n\n  _isSinglePointGeometrySelected = (geometry: FeatureCollection | null | undefined): boolean => {\n    const { features } = geometry || {};\n    if (Array.isArray(features) && features.length === 1) {\n      // @ts-ignore\n      const { type } = getGeom(features[0]);\n      return type === 'Point';\n    }\n    return false;\n  };\n\n  _getOppositeScaleHandle = (selectedHandle: EditHandleFeature) => {\n    const selectedHandleIndex =\n      selectedHandle &&\n      selectedHandle.properties &&\n      Array.isArray(selectedHandle.properties.positionIndexes) &&\n      selectedHandle.properties.positionIndexes[0];\n\n    if (typeof selectedHandleIndex !== 'number') {\n      return null;\n    }\n    const guidePointCount = this._cornerGuidePoints.length;\n    const oppositeIndex = (selectedHandleIndex + guidePointCount / 2) % guidePointCount;\n    return this._cornerGuidePoints.find((p) => {\n      if (!Array.isArray(p.properties.positionIndexes)) {\n        return false;\n      }\n      return p.properties.positionIndexes[0] === oppositeIndex;\n    });\n  };\n\n  _getUpdatedData = (props: ModeProps<FeatureCollection>, editedData: FeatureCollection) => {\n    let updatedData = new ImmutableFeatureCollection(props.data);\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = editedData.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n    return updatedData.getObject();\n  };\n\n  isEditHandleSelected = (): boolean => Boolean(this._selectedEditHandle);\n\n  getScaleAction = (\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ) => {\n    if (!this._selectedEditHandle) {\n      return null;\n    }\n\n    const oppositeHandle = this._getOppositeScaleHandle(this._selectedEditHandle);\n    const origin = getCoord(oppositeHandle);\n    // @ts-ignore\n    const scaleFactor = getScaleFactor(origin, startDragPoint, currentPoint);\n    // @ts-ignore\n    const scaledFeatures: FeatureCollection = turfTransformScale(\n      // @ts-ignore\n      this._geometryBeingScaled,\n      scaleFactor,\n      { origin }\n    );\n\n    return {\n      updatedData: this._getUpdatedData(props, scaledFeatures),\n      editType,\n      editContext: {\n        featureIndexes: props.selectedIndexes,\n      },\n    };\n  };\n\n  updateCursor = (props: ModeProps<FeatureCollection>) => {\n    if (this._selectedEditHandle) {\n      if (this._cursor) {\n        props.onUpdateCursor(this._cursor);\n      }\n      const cursorGeometry = this.getSelectedFeaturesAsFeatureCollection(props);\n\n      // Get resize cursor direction from the hovered scale editHandle (e.g. nesw or nwse)\n      const centroid = turfCentroid(cursorGeometry);\n      const bearing = turfBearing(centroid, this._selectedEditHandle);\n      const positiveBearing = bearing < 0 ? bearing + 180 : bearing;\n      if (\n        (positiveBearing >= 0 && positiveBearing <= 90) ||\n        (positiveBearing >= 180 && positiveBearing <= 270)\n      ) {\n        this._cursor = 'nesw-resize';\n        props.onUpdateCursor('nesw-resize');\n      } else {\n        this._cursor = 'nwse-resize';\n        props.onUpdateCursor('nwse-resize');\n      }\n    } else {\n      props.onUpdateCursor(null);\n      this._cursor = null;\n    }\n  };\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isScaling) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'scale'\n          ? selectedEditHandle\n          : null;\n\n      this.updateCursor(props);\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isScaling = true;\n      this._geometryBeingScaled = this.getSelectedFeaturesAsFeatureCollection(props);\n    }\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isScaling) {\n      return;\n    }\n\n    props.onUpdateCursor(this._cursor);\n\n    const scaleAction = this.getScaleAction(\n      event.pointerDownMapCoords,\n      event.mapCoords,\n      'scaling',\n      props\n    );\n    if (scaleAction) {\n      props.onEdit(scaleAction);\n    }\n\n    event.cancelPan();\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isScaling) {\n      // Scale the geometry\n      const scaleAction = this.getScaleAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'scaled',\n        props\n      );\n      if (scaleAction) {\n        props.onEdit(scaleAction);\n      }\n\n      props.onUpdateCursor(null);\n\n      this._geometryBeingScaled = null;\n      this._selectedEditHandle = null;\n      this._cursor = null;\n      this._isScaling = false;\n    }\n  }\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    this._cornerGuidePoints = [];\n    const selectedGeometry = this.getSelectedFeaturesAsFeatureCollection(props);\n\n    // Add buffer to the enveloping box if a single Point feature is selected\n    if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n      return { type: 'FeatureCollection', features: [] };\n    }\n\n    const boundingBox = bboxPolygon(bbox(selectedGeometry));\n    boundingBox.properties.mode = 'scale';\n    const cornerGuidePoints = [];\n\n    coordEach(boundingBox, (coord, coordIndex) => {\n      if (coordIndex < 4) {\n        // Get corner midpoint guides from the enveloping box\n        const cornerPoint = point(coord, {\n          guideType: 'editHandle',\n          editHandleType: 'scale',\n          positionIndexes: [coordIndex],\n        });\n        cornerGuidePoints.push(cornerPoint);\n      }\n    });\n\n    this._cornerGuidePoints = cornerGuidePoints;\n    // @ts-ignore\n    return featureCollection([polygonToLine(boundingBox), ...this._cornerGuidePoints]);\n  }\n}\n\nfunction getScaleFactor(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const startDistance = turfDistance(centroid, startDragPoint);\n  const endDistance = turfDistance(centroid, currentPoint);\n  return endDistance / startDistance;\n}\n"]},"metadata":{},"sourceType":"script"}