{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Deck } from '@deck.gl/core';\nimport { Matrix4, Vector2 } from '@math.gl/core';\nvar MAX_LATITUDE = 85.05113;\nexport function createDeckInstance(map, overlay, deck, props) {\n  if (deck) {\n    if (deck.props.userData._googleMap === map) {\n      return deck;\n    }\n\n    destroyDeckInstance(deck);\n  }\n\n  var eventListeners = {\n    click: null,\n    dblclick: null,\n    mousemove: null,\n    mouseout: null\n  };\n  deck = new Deck(_objectSpread(_objectSpread({}, props), {}, {\n    style: props.interleaved ? null : {\n      pointerEvents: 'none'\n    },\n    parent: getContainer(overlay, props.style),\n    initialViewState: {\n      longitude: 0,\n      latitude: 0,\n      zoom: 1\n    },\n    controller: false,\n    userData: {\n      _googleMap: map,\n      _eventListeners: eventListeners\n    }\n  }));\n\n  var _loop = function _loop(eventType) {\n    eventListeners[eventType] = map.addListener(eventType, function (evt) {\n      return handleMouseEvent(deck, eventType, evt);\n    });\n  };\n\n  for (var eventType in eventListeners) {\n    _loop(eventType);\n  }\n\n  return deck;\n}\n\nfunction getContainer(overlay, style) {\n  var container = document.createElement('div');\n  container.style.position = 'absolute';\n  Object.assign(container.style, style);\n\n  if (overlay.getPanes) {\n    overlay.getPanes().overlayLayer.appendChild(container);\n  } else {\n    overlay.getMap().getDiv().appendChild(container);\n  }\n\n  return container;\n}\n\nexport function destroyDeckInstance(deck) {\n  var eventListeners = deck.props.userData._eventListeners;\n\n  for (var eventType in eventListeners) {\n    eventListeners[eventType].remove();\n  }\n\n  deck.finalize();\n}\nexport function getViewPropsFromOverlay(map, overlay) {\n  var _getMapSize = getMapSize(map),\n      width = _getMapSize.width,\n      height = _getMapSize.height;\n\n  var projection = overlay.getProjection();\n  var bounds = map.getBounds();\n  var ne = bounds.getNorthEast();\n  var sw = bounds.getSouthWest();\n  var topRight = projection.fromLatLngToDivPixel(ne);\n  var bottomLeft = projection.fromLatLngToDivPixel(sw);\n  var nwContainerPx = new google.maps.Point(0, 0);\n  var nw = projection.fromContainerPixelToLatLng(nwContainerPx);\n  var nwDivPx = projection.fromLatLngToDivPixel(nw);\n  var leftOffset = nwDivPx.x;\n  var topOffset = nwDivPx.y;\n  var mapWidth = projection.getWorldWidth();\n  var mapCount = Math.ceil(width / mapWidth);\n  leftOffset -= Math.floor(mapCount / 2) * mapWidth;\n  var topLngLat = pixelToLngLat(projection, width / 2, 0);\n  var centerLngLat = pixelToLngLat(projection, width / 2, height / 2);\n  var bottomLngLat = pixelToLngLat(projection, width / 2, height);\n  var latitude = centerLngLat[1];\n  var longitude = centerLngLat[0];\n\n  if (Math.abs(latitude) > MAX_LATITUDE) {\n    latitude = latitude > 0 ? MAX_LATITUDE : -MAX_LATITUDE;\n    var center = new google.maps.LatLng(latitude, longitude);\n    var centerPx = projection.fromLatLngToContainerPixel(center);\n    topOffset += centerPx.y - height / 2;\n  }\n\n  var delta = new Vector2(topLngLat).sub(bottomLngLat);\n  var bearing = 180 * delta.verticalAngle() / Math.PI;\n  if (bearing < 0) bearing += 360;\n  var heading = map.getHeading() || 0;\n  var zoom = map.getZoom() - 1;\n  var scale;\n\n  if (bearing === 0) {\n    scale = height ? (bottomLeft.y - topRight.y) / height : 1;\n  } else if (bearing === heading) {\n    var viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();\n    var mapDiagonal = new Vector2([width, -height]).len();\n    scale = mapDiagonal ? viewDiagonal / mapDiagonal : 1;\n  }\n\n  zoom += Math.log2(scale || 1);\n  return {\n    width: width,\n    height: height,\n    left: leftOffset,\n    top: topOffset,\n    zoom: zoom,\n    bearing: bearing,\n    pitch: map.getTilt(),\n    latitude: latitude,\n    longitude: longitude\n  };\n}\nexport function getViewPropsFromCoordinateTransformer(map, transformer) {\n  var _getMapSize2 = getMapSize(map),\n      width = _getMapSize2.width,\n      height = _getMapSize2.height;\n\n  var _transformer$getCamer = transformer.getCameraParams(),\n      center = _transformer$getCamer.center,\n      bearing = _transformer$getCamer.heading,\n      pitch = _transformer$getCamer.tilt,\n      zoom = _transformer$getCamer.zoom;\n\n  var fovy = 25;\n  var aspect = height ? width / height : 1;\n  var near = 0.75;\n  var far = 300000000000000;\n  var projectionMatrix = new Matrix4().perspective({\n    fovy: fovy * Math.PI / 180,\n    aspect: aspect,\n    near: near,\n    far: far\n  });\n  var focalDistance = 0.5 * projectionMatrix[5];\n  return {\n    width: width,\n    height: height,\n    viewState: {\n      altitude: focalDistance,\n      bearing: bearing,\n      latitude: center.lat(),\n      longitude: center.lng(),\n      pitch: pitch,\n      projectionMatrix: projectionMatrix,\n      repeat: true,\n      zoom: zoom - 1\n    }\n  };\n}\n\nfunction getMapSize(map) {\n  var container = map.getDiv().firstChild;\n  return {\n    width: container.offsetWidth,\n    height: container.offsetHeight\n  };\n}\n\nfunction pixelToLngLat(projection, x, y) {\n  var point = new google.maps.Point(x, y);\n  var latLng = projection.fromContainerPixelToLatLng(point);\n  return [latLng.lng(), latLng.lat()];\n}\n\nfunction getEventPixel(event, deck) {\n  if (event.pixel) {\n    return event.pixel;\n  }\n\n  var point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);\n  return {\n    x: point[0],\n    y: point[1]\n  };\n}\n\nfunction handleMouseEvent(deck, type, event) {\n  var mockEvent = {\n    type: type,\n    offsetCenter: getEventPixel(event, deck),\n    srcEvent: event\n  };\n\n  switch (type) {\n    case 'click':\n      deck._lastPointerDownInfo = deck.pickObject(_objectSpread(_objectSpread({}, mockEvent.offsetCenter), {}, {\n        radius: deck.props.pickingRadius\n      }));\n      mockEvent.tapCount = 1;\n\n      deck._onEvent(mockEvent);\n\n      break;\n\n    case 'dblclick':\n      mockEvent.type = 'click';\n      mockEvent.tapCount = 2;\n\n      deck._onEvent(mockEvent);\n\n      break;\n\n    case 'mousemove':\n      mockEvent.type = 'pointermove';\n\n      deck._onPointerMove(mockEvent);\n\n      break;\n\n    case 'mouseout':\n      mockEvent.type = 'pointerleave';\n\n      deck._onPointerMove(mockEvent);\n\n      break;\n\n    default:\n      return;\n  }\n}","map":{"version":3,"mappings":"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","names":["Deck","Matrix4","Vector2","MAX_LATITUDE","createDeckInstance","map","overlay","deck","props","userData","_googleMap","destroyDeckInstance","eventListeners","click","dblclick","mousemove","mouseout","style","interleaved","pointerEvents","parent","getContainer","initialViewState","longitude","latitude","zoom","controller","_eventListeners","eventType","addListener","evt","handleMouseEvent","container","document","createElement","position","Object","assign","getPanes","overlayLayer","appendChild","getMap","getDiv","remove","finalize","getViewPropsFromOverlay","getMapSize","width","height","projection","getProjection","bounds","getBounds","ne","getNorthEast","sw","getSouthWest","topRight","fromLatLngToDivPixel","bottomLeft","nwContainerPx","google","maps","Point","nw","fromContainerPixelToLatLng","nwDivPx","leftOffset","x","topOffset","y","mapWidth","getWorldWidth","mapCount","Math","ceil","floor","topLngLat","pixelToLngLat","centerLngLat","bottomLngLat","abs","center","LatLng","centerPx","fromLatLngToContainerPixel","delta","sub","bearing","verticalAngle","PI","heading","getHeading","getZoom","scale","viewDiagonal","len","mapDiagonal","log2","left","top","pitch","getTilt","getViewPropsFromCoordinateTransformer","transformer","getCameraParams","tilt","fovy","aspect","near","far","projectionMatrix","perspective","focalDistance","viewState","altitude","lat","lng","repeat","firstChild","offsetWidth","offsetHeight","point","latLng","getEventPixel","event","pixel","getViewports","project","type","mockEvent","offsetCenter","srcEvent","_lastPointerDownInfo","pickObject","radius","pickingRadius","tapCount","_onEvent","_onPointerMove"],"sources":["../../src/utils.js"],"sourcesContent":["/* global google, document */\nimport {Deck} from '@deck.gl/core';\nimport {Matrix4, Vector2} from '@math.gl/core';\n\n// https://en.wikipedia.org/wiki/Web_Mercator_projection#Formulas\nconst MAX_LATITUDE = 85.05113;\n\n/**\n * Get a new deck instance\n * @param map (google.maps.Map) - The parent Map instance\n * @param overlay (google.maps.OverlayView) - A maps Overlay instance\n * @param [deck] (Deck) - a previously created instances\n */\nexport function createDeckInstance(map, overlay, deck, props) {\n  if (deck) {\n    if (deck.props.userData._googleMap === map) {\n      return deck;\n    }\n    // deck instance was created for a different map\n    destroyDeckInstance(deck);\n  }\n\n  const eventListeners = {\n    click: null,\n    dblclick: null,\n    mousemove: null,\n    mouseout: null\n  };\n\n  deck = new Deck({\n    ...props,\n    style: props.interleaved ? null : {pointerEvents: 'none'},\n    parent: getContainer(overlay, props.style),\n    initialViewState: {\n      longitude: 0,\n      latitude: 0,\n      zoom: 1\n    },\n    controller: false,\n    userData: {\n      _googleMap: map,\n      _eventListeners: eventListeners\n    }\n  });\n\n  // Register event listeners\n  for (const eventType in eventListeners) {\n    eventListeners[eventType] = map.addListener(eventType, evt =>\n      handleMouseEvent(deck, eventType, evt)\n    );\n  }\n\n  return deck;\n}\n\n// Create a container that will host the deck canvas and tooltip\nfunction getContainer(overlay, style) {\n  const container = document.createElement('div');\n  container.style.position = 'absolute';\n  Object.assign(container.style, style);\n\n  // The DOM structure has a different structure depending on whether\n  // the Google map is rendered as vector or raster\n  if (overlay.getPanes) {\n    overlay.getPanes().overlayLayer.appendChild(container);\n  } else {\n    overlay.getMap().getDiv().appendChild(container);\n  }\n  return container;\n}\n\n/**\n * Safely remove a deck instance\n * @param deck (Deck) - a previously created instances\n */\nexport function destroyDeckInstance(deck) {\n  const {_eventListeners: eventListeners} = deck.props.userData;\n\n  // Unregister event listeners\n  for (const eventType in eventListeners) {\n    eventListeners[eventType].remove();\n  }\n\n  deck.finalize();\n}\n\n/* eslint-disable max-statements */\n/**\n * Get the current view state\n * @param map (google.maps.Map) - The parent Map instance\n * @param overlay (google.maps.OverlayView) - A maps Overlay instance\n */\nexport function getViewPropsFromOverlay(map, overlay) {\n  const {width, height} = getMapSize(map);\n\n  // Canvas position relative to draggable map's container depends on\n  // overlayView's projection, not the map's. Have to use the center of the\n  // map for this, not the top left, for the same reason as above.\n  const projection = overlay.getProjection();\n\n  const bounds = map.getBounds();\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  const topRight = projection.fromLatLngToDivPixel(ne);\n  const bottomLeft = projection.fromLatLngToDivPixel(sw);\n\n  // google maps places overlays in a container anchored at the map center.\n  // the container CSS is manipulated during dragging.\n  // We need to update left/top of the deck canvas to match the base map.\n  const nwContainerPx = new google.maps.Point(0, 0);\n  const nw = projection.fromContainerPixelToLatLng(nwContainerPx);\n  const nwDivPx = projection.fromLatLngToDivPixel(nw);\n  let leftOffset = nwDivPx.x;\n  let topOffset = nwDivPx.y;\n\n  // Adjust horizontal offset - position the viewport at the map in the center\n  const mapWidth = projection.getWorldWidth();\n  const mapCount = Math.ceil(width / mapWidth);\n  leftOffset -= Math.floor(mapCount / 2) * mapWidth;\n\n  const topLngLat = pixelToLngLat(projection, width / 2, 0);\n  const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);\n  const bottomLngLat = pixelToLngLat(projection, width / 2, height);\n\n  // Compute fractional center.\n  let latitude = centerLngLat[1];\n  const longitude = centerLngLat[0];\n\n  // Adjust vertical offset - limit latitude\n  if (Math.abs(latitude) > MAX_LATITUDE) {\n    latitude = latitude > 0 ? MAX_LATITUDE : -MAX_LATITUDE;\n    const center = new google.maps.LatLng(latitude, longitude);\n    const centerPx = projection.fromLatLngToContainerPixel(center);\n    topOffset += centerPx.y - height / 2;\n  }\n\n  // Compute fractional bearing\n  const delta = new Vector2(topLngLat).sub(bottomLngLat);\n  let bearing = (180 * delta.verticalAngle()) / Math.PI;\n  if (bearing < 0) bearing += 360;\n\n  // Maps sometimes returns undefined instead of 0\n  const heading = map.getHeading() || 0;\n\n  let zoom = map.getZoom() - 1;\n  let scale;\n\n  if (bearing === 0) {\n    // At full world view (always unrotated) simply compare height, as diagonal\n    // is incorrect due to multiple world copies\n    scale = height ? (bottomLeft.y - topRight.y) / height : 1;\n  } else if (bearing === heading) {\n    // Fractional zoom calculation only correct when bearing is not animating\n    const viewDiagonal = new Vector2([topRight.x, topRight.y])\n      .sub([bottomLeft.x, bottomLeft.y])\n      .len();\n    const mapDiagonal = new Vector2([width, -height]).len();\n    scale = mapDiagonal ? viewDiagonal / mapDiagonal : 1;\n  }\n\n  // When resizing aggressively, occasionally ne and sw are the same points\n  // See https://github.com/visgl/deck.gl/issues/4218\n  zoom += Math.log2(scale || 1);\n\n  return {\n    width,\n    height,\n    left: leftOffset,\n    top: topOffset,\n    zoom,\n    bearing,\n    pitch: map.getTilt(),\n    latitude,\n    longitude\n  };\n}\n\n/* eslint-enable max-statements */\n\n/**\n * Get the current view state\n * @param map (google.maps.Map) - The parent Map instance\n * @param transformer (google.maps.CoordinateTransformer) - A CoordinateTransformer instance\n */\nexport function getViewPropsFromCoordinateTransformer(map, transformer) {\n  const {width, height} = getMapSize(map);\n  const {center, heading: bearing, tilt: pitch, zoom} = transformer.getCameraParams();\n\n  // Match Google projection matrix\n  const fovy = 25;\n  const aspect = height ? width / height : 1;\n\n  // Match depth range (crucial for correct z-sorting)\n  const near = 0.75;\n  const far = 300000000000000;\n  // const far = Infinity;\n\n  const projectionMatrix = new Matrix4().perspective({\n    fovy: (fovy * Math.PI) / 180,\n    aspect,\n    near,\n    far\n  });\n  const focalDistance = 0.5 * projectionMatrix[5];\n\n  return {\n    width,\n    height,\n    viewState: {\n      altitude: focalDistance,\n      bearing,\n      latitude: center.lat(),\n      longitude: center.lng(),\n      pitch,\n      projectionMatrix,\n      repeat: true,\n      zoom: zoom - 1\n    }\n  };\n}\n\nfunction getMapSize(map) {\n  // The map fills the container div unless it's in fullscreen mode\n  // at which point the first child of the container is promoted\n  const container = map.getDiv().firstChild;\n  return {\n    width: container.offsetWidth,\n    height: container.offsetHeight\n  };\n}\n\nfunction pixelToLngLat(projection, x, y) {\n  const point = new google.maps.Point(x, y);\n  const latLng = projection.fromContainerPixelToLatLng(point);\n  return [latLng.lng(), latLng.lat()];\n}\n\nfunction getEventPixel(event, deck) {\n  if (event.pixel) {\n    return event.pixel;\n  }\n  // event.pixel may not exist when clicking on a POI\n  // https://developers.google.com/maps/documentation/javascript/reference/map#MouseEvent\n  const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);\n  return {\n    x: point[0],\n    y: point[1]\n  };\n}\n\n// Triggers picking on a mouse event\nfunction handleMouseEvent(deck, type, event) {\n  const mockEvent = {\n    type,\n    offsetCenter: getEventPixel(event, deck),\n    srcEvent: event\n  };\n\n  switch (type) {\n    case 'click':\n      // Hack: because we do not listen to pointer down, perform picking now\n      deck._lastPointerDownInfo = deck.pickObject({\n        ...mockEvent.offsetCenter,\n        radius: deck.props.pickingRadius\n      });\n      mockEvent.tapCount = 1;\n      deck._onEvent(mockEvent);\n      break;\n\n    case 'dblclick':\n      mockEvent.type = 'click';\n      mockEvent.tapCount = 2;\n      deck._onEvent(mockEvent);\n      break;\n\n    case 'mousemove':\n      mockEvent.type = 'pointermove';\n      deck._onPointerMove(mockEvent);\n      break;\n\n    case 'mouseout':\n      mockEvent.type = 'pointerleave';\n      deck._onPointerMove(mockEvent);\n      break;\n\n    default:\n      return;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}