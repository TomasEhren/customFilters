{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtrudeMode = void 0;\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _utils = require(\"../utils\");\n\nvar _modifyMode = require(\"./modify-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ExtrudeMode = /*#__PURE__*/function (_ModifyMode) {\n  _inherits(ExtrudeMode, _ModifyMode);\n\n  var _super = _createSuper(ExtrudeMode);\n\n  function ExtrudeMode() {\n    var _this;\n\n    _classCallCheck(this, ExtrudeMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"isPointAdded\", false);\n\n    return _this;\n  }\n\n  _createClass(ExtrudeMode, [{\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for moving (extruding) edge\n          var _generatePointsParall = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall2 = _slicedToArray(_generatePointsParall, 2),\n              p3 = _generatePointsParall2[0],\n              p4 = _generatePointsParall2[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: this.nextPositionIndexes(positionIndexes, size),\n              position: p3\n            }\n          });\n          event.cancelPan();\n        }\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var _editHandle$propertie = editHandle.properties,\n            positionIndexes = _editHandle$propertie.positionIndexes,\n            featureIndex = _editHandle$propertie.featureIndex;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data); // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n\n          if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);\n          }\n\n          if (!this.isOrthogonal(this.prevPositionIndexes(positionIndexes, size), featureIndex, size, props.data)) {\n            updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);\n            this.isPointAdded = true;\n          }\n\n          props.onEdit({\n            updatedData: updatedData.getObject(),\n            editType: 'startExtruding',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p1\n            }\n          });\n        }\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var featureIndex = editHandle.properties.featureIndex;\n        var positionIndexes = editHandle.properties.positionIndexes;\n        var size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n        positionIndexes = this.isPointAdded ? this.nextPositionIndexes(positionIndexes, size) : positionIndexes; // p1 and p1 are end points for edge\n\n        var p1 = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, props.data);\n        var p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n        if (p1 && p2) {\n          // p3 and p4 are end points for new moved (extruded) edge\n          var _generatePointsParall3 = (0, _utils.generatePointsParallelToLinePoints)(p1, p2, event.mapCoords),\n              _generatePointsParall4 = _slicedToArray(_generatePointsParall3, 2),\n              p3 = _generatePointsParall4[0],\n              p4 = _generatePointsParall4[1];\n\n          var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4).replacePosition(featureIndex, positionIndexes, p3).getObject();\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'extruded',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: p3\n            }\n          });\n        }\n      }\n\n      this.isPointAdded = false;\n    }\n  }, {\n    key: \"coordinatesSize\",\n    value: function coordinatesSize(positionIndexes, featureIndex, _ref) {\n      var features = _ref.features;\n      var size = 0;\n\n      if (Array.isArray(positionIndexes)) {\n        var feature = features[featureIndex];\n        var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n        if (positionIndexes.length === 3) {\n          var _positionIndexes = _slicedToArray(positionIndexes, 2),\n              a = _positionIndexes[0],\n              b = _positionIndexes[1];\n\n          if (coordinates.length && coordinates[a].length) {\n            size = coordinates[a][b].length;\n          }\n        } else {\n          var _positionIndexes2 = _slicedToArray(positionIndexes, 1),\n              _b = _positionIndexes2[0];\n\n          if (coordinates.length && coordinates[_b].length) {\n            size = coordinates[_b].length;\n          }\n        }\n      }\n\n      return size;\n    }\n  }, {\n    key: \"getBearing\",\n    value: function getBearing(p1, p2) {\n      var angle = (0, _bearing[\"default\"])(p1, p2);\n\n      if (angle < 0) {\n        return Math.floor(360 + angle);\n      }\n\n      return Math.floor(angle);\n    }\n  }, {\n    key: \"isOrthogonal\",\n    value: function isOrthogonal(positionIndexes, featureIndex, size, features) {\n      if (!Array.isArray(positionIndexes)) {\n        return false;\n      }\n\n      if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n        positionIndexes[positionIndexes.length - 1] = 0;\n      }\n\n      var prevPoint = this.getPointForPositionIndexes(this.prevPositionIndexes(positionIndexes, size), featureIndex, features);\n      var nextPoint = this.getPointForPositionIndexes(this.nextPositionIndexes(positionIndexes, size), featureIndex, features);\n      var currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n      var prevAngle = this.getBearing(currentPoint, prevPoint);\n      var nextAngle = this.getBearing(currentPoint, nextPoint);\n      return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n    }\n  }, {\n    key: \"nextPositionIndexes\",\n    value: function nextPositionIndexes(positionIndexes, size) {\n      if (!Array.isArray(positionIndexes)) {\n        return [];\n      }\n\n      var next = _toConsumableArray(positionIndexes);\n\n      if (next.length) {\n        next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n      }\n\n      return next;\n    }\n  }, {\n    key: \"prevPositionIndexes\",\n    value: function prevPositionIndexes(positionIndexes, size) {\n      if (!Array.isArray(positionIndexes)) {\n        return [];\n      }\n\n      var prev = _toConsumableArray(positionIndexes);\n\n      if (prev.length) {\n        prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n      }\n\n      return prev;\n    }\n  }, {\n    key: \"getPointForPositionIndexes\",\n    value: function getPointForPositionIndexes(positionIndexes, featureIndex, _ref2) {\n      var features = _ref2.features;\n      var p1;\n\n      if (Array.isArray(positionIndexes)) {\n        var feature = features[featureIndex];\n        var coordinates = feature.geometry.coordinates; // for Multi polygons, length will be 3\n\n        if (positionIndexes.length === 3) {\n          var _positionIndexes3 = _slicedToArray(positionIndexes, 3),\n              a = _positionIndexes3[0],\n              b = _positionIndexes3[1],\n              c = _positionIndexes3[2];\n\n          if (coordinates.length && coordinates[a].length) {\n            p1 = coordinates[a][b][c];\n          }\n        } else {\n          var _positionIndexes4 = _slicedToArray(positionIndexes, 2),\n              _b2 = _positionIndexes4[0],\n              _c = _positionIndexes4[1];\n\n          if (coordinates.length && coordinates[_b2].length) {\n            p1 = coordinates[_b2][_c];\n          }\n        }\n      }\n\n      return p1;\n    }\n  }]);\n\n  return ExtrudeMode;\n}(_modifyMode.ModifyMode);\n\nexports.ExtrudeMode = ExtrudeMode;","map":{"version":3,"mappings":"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","names":["ExtrudeMode","event","props","editHandle","pointerDownPicks","featureIndex","properties","positionIndexes","size","coordinatesSize","data","isPointAdded","nextPositionIndexes","p1","getPointForPositionIndexes","prevPositionIndexes","p2","mapCoords","p3","p4","updatedData","ImmutableFeatureCollection","replacePosition","getObject","onEdit","editType","editContext","featureIndexes","position","cancelPan","selectedFeatureIndexes","selectedIndexes","picks","length","isOrthogonal","addPosition","features","Array","isArray","feature","coordinates","geometry","a","b","angle","Math","floor","prevPoint","nextPoint","currentPoint","prevAngle","getBearing","nextAngle","includes","abs","next","prev","c","ModifyMode"],"sources":["../../src/lib/extrude-mode.ts"],"sourcesContent":["import bearing from '@turf/bearing';\nimport {\n  generatePointsParallelToLinePoints,\n  getPickedEditHandle,\n  getPickedIntermediateEditHandle,\n} from '../utils';\nimport { FeatureCollection } from '../geojson-types';\nimport { ModeProps, StartDraggingEvent, StopDraggingEvent, DraggingEvent } from '../types';\nimport { ModifyMode } from './modify-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ExtrudeMode extends ModifyMode {\n  // this mode is busted =(\n\n  isPointAdded = false;\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      const { featureIndex } = editHandle.properties;\n      let { positionIndexes } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(positionIndexes, size)\n        : positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n      if (p1 && p2) {\n        // p3 and p4 are end points for moving (extruding) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4)\n          .replacePosition(featureIndex, positionIndexes, p3)\n          .getObject();\n\n        props.onEdit({\n          updatedData,\n          editType: 'extruding',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes: this.nextPositionIndexes(positionIndexes, size),\n            position: p3,\n          },\n        });\n\n        event.cancelPan();\n      }\n    }\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedIntermediateEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const { positionIndexes, featureIndex } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n      if (p1 && p2) {\n        let updatedData = new ImmutableFeatureCollection(props.data);\n        if (!this.isOrthogonal(positionIndexes, featureIndex, size, props.data)) {\n          updatedData = updatedData.addPosition(featureIndex, positionIndexes, p2);\n        }\n        if (\n          !this.isOrthogonal(\n            this.prevPositionIndexes(positionIndexes, size),\n            featureIndex,\n            size,\n            props.data\n          )\n        ) {\n          updatedData = updatedData.addPosition(featureIndex, positionIndexes, p1);\n          this.isPointAdded = true;\n        }\n\n        props.onEdit({\n          updatedData: updatedData.getObject(),\n          editType: 'startExtruding',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: p1,\n          },\n        });\n      }\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const { featureIndex } = editHandle.properties;\n      let { positionIndexes } = editHandle.properties;\n\n      const size = this.coordinatesSize(positionIndexes, featureIndex, props.data);\n      positionIndexes = this.isPointAdded\n        ? this.nextPositionIndexes(positionIndexes, size)\n        : positionIndexes;\n      // p1 and p1 are end points for edge\n      const p1 = this.getPointForPositionIndexes(\n        this.prevPositionIndexes(positionIndexes, size),\n        featureIndex,\n        props.data\n      );\n      const p2 = this.getPointForPositionIndexes(positionIndexes, featureIndex, props.data);\n\n      if (p1 && p2) {\n        // p3 and p4 are end points for new moved (extruded) edge\n        const [p3, p4] = generatePointsParallelToLinePoints(p1, p2, event.mapCoords);\n\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .replacePosition(featureIndex, this.prevPositionIndexes(positionIndexes, size), p4)\n          .replacePosition(featureIndex, positionIndexes, p3)\n          .getObject();\n\n        props.onEdit({\n          updatedData,\n          editType: 'extruded',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: p3,\n          },\n        });\n      }\n    }\n    this.isPointAdded = false;\n  }\n\n  coordinatesSize(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let size = 0;\n    if (Array.isArray(positionIndexes)) {\n      const feature = features[featureIndex];\n      const coordinates: any = feature.geometry.coordinates;\n      // for Multi polygons, length will be 3\n      if (positionIndexes.length === 3) {\n        const [a, b] = positionIndexes;\n        if (coordinates.length && coordinates[a].length) {\n          size = coordinates[a][b].length;\n        }\n      } else {\n        const [b] = positionIndexes;\n        if (coordinates.length && coordinates[b].length) {\n          size = coordinates[b].length;\n        }\n      }\n    }\n    return size;\n  }\n\n  getBearing(p1: any, p2: any) {\n    const angle = bearing(p1, p2);\n    if (angle < 0) {\n      return Math.floor(360 + angle);\n    }\n    return Math.floor(angle);\n  }\n\n  isOrthogonal(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    size: number,\n    features: FeatureCollection\n  ) {\n    if (!Array.isArray(positionIndexes)) {\n      return false;\n    }\n    if (positionIndexes[positionIndexes.length - 1] === size - 1) {\n      positionIndexes[positionIndexes.length - 1] = 0;\n    }\n    const prevPoint = this.getPointForPositionIndexes(\n      this.prevPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const nextPoint = this.getPointForPositionIndexes(\n      this.nextPositionIndexes(positionIndexes, size),\n      featureIndex,\n      features\n    );\n    const currentPoint = this.getPointForPositionIndexes(positionIndexes, featureIndex, features);\n    const prevAngle = this.getBearing(currentPoint, prevPoint);\n    const nextAngle = this.getBearing(currentPoint, nextPoint);\n    return [89, 90, 91, 269, 270, 271].includes(Math.abs(prevAngle - nextAngle));\n  }\n\n  nextPositionIndexes(positionIndexes: number[] | null | undefined, size: number): number[] {\n    if (!Array.isArray(positionIndexes)) {\n      return [];\n    }\n    const next = [...positionIndexes];\n    if (next.length) {\n      next[next.length - 1] = next[next.length - 1] === size - 1 ? 0 : next[next.length - 1] + 1;\n    }\n    return next;\n  }\n\n  prevPositionIndexes(positionIndexes: number[] | null | undefined, size: number): number[] {\n    if (!Array.isArray(positionIndexes)) {\n      return [];\n    }\n    const prev = [...positionIndexes];\n    if (prev.length) {\n      prev[prev.length - 1] = prev[prev.length - 1] === 0 ? size - 2 : prev[prev.length - 1] - 1;\n    }\n    return prev;\n  }\n\n  getPointForPositionIndexes(\n    positionIndexes: number[] | null | undefined,\n    featureIndex: number,\n    { features }: FeatureCollection\n  ) {\n    let p1;\n    if (Array.isArray(positionIndexes)) {\n      const feature = features[featureIndex];\n      const coordinates: any = feature.geometry.coordinates;\n      // for Multi polygons, length will be 3\n      if (positionIndexes.length === 3) {\n        const [a, b, c] = positionIndexes;\n        if (coordinates.length && coordinates[a].length) {\n          p1 = coordinates[a][b][c];\n        }\n      } else {\n        const [b, c] = positionIndexes;\n        if (coordinates.length && coordinates[b].length) {\n          p1 = coordinates[b][c];\n        }\n      }\n    }\n    return p1;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}