{"ast":null,"code":"import Tile2DHeader from './tile-2d-header';\nimport { getTileIndices, tileToBoundingBox } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4 } from '@math.gl/core';\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nexport default class Tileset2D {\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n    this.setOptions(opts);\n  }\n\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload() {\n    return this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n\n    this._cache.clear();\n\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  update(viewport) {\n    let {\n      zRange,\n      modelMatrix\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        this._rebuildTree();\n      }\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile({\n        x: tile.x,\n        y: tile.y,\n        z: tile.z\n      }));\n    }\n\n    const changed = this.updateTileStates();\n\n    this._pruneRequests();\n\n    if (this._dirty) {\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  getTileIndices(_ref) {\n    let {\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      modelMatrix,\n      modelMatrixInverse\n    } = _ref;\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  getTileMetadata(_ref2) {\n    let {\n      x,\n      y,\n      z\n    } = _ref2;\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)\n    };\n  }\n\n  getParentIndex(tileIndex) {\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n\n    for (const tile of this._cache.values()) {\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _pruneRequests() {\n    const {\n      maxRequests\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n\n      tile.parent = parent;\n\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n          _cache.delete(tileId);\n\n          this.opts.onTileUnload(tile);\n        }\n\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n\n      this._rebuildTree();\n\n      this._dirty = true;\n    }\n\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.z - t2.z);\n      this._dirty = false;\n    }\n  }\n\n  _getTile(_ref3, create) {\n    let {\n      x,\n      y,\n      z\n    } = _ref3;\n    const tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n\n    let tile = this._cache.get(tileId);\n\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({\n        x,\n        y,\n        z\n      });\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n\n      this._cache.set(tileId, tile);\n\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = {\n      x,\n      y,\n      z\n    };\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n\n      const parent = this._getTile(index);\n\n      if (parent) {\n        return parent;\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.z - t2.z);\n\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n    if (tile.isVisible || tile.state & TILE_STATE_VISITED) {\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n\n    tile = tile.parent;\n  }\n\n  return false;\n}\n\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Tile2DHeader","getTileIndices","tileToBoundingBox","RequestScheduler","Matrix4","TILE_STATE_VISITED","TILE_STATE_VISIBLE","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","STRATEGIES","updateTileStateDefault","updateTileStateReplace","Tileset2D","constructor","opts","onTileLoad","tile","maxCacheByteSize","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","_modelMatrix","_modelMatrixInverse","setOptions","tiles","selectedTiles","isLoaded","every","needsReload","some","Object","assign","Number","isFinite","maxZoom","_maxZoom","Math","floor","minZoom","_minZoom","ceil","finalize","values","isLoading","abort","clear","reloadAll","tileId","keys","get","includes","delete","setNeedsReload","update","viewport","zRange","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","equals","clone","invert","tileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","x","y","z","changed","updateTileStates","_pruneRequests","tileSize","extent","zoomOffset","getTileMetadata","bbox","getParentIndex","tileIndex","refinementStrategy","visibilities","Array","size","i","isVisible","isSelected","from","abortCandidates","ongoingRequestCount","push","length","shift","parent","children","_getNearestAncestor","maxCacheSize","Infinity","overflown","onTileUnload","sort","t1","t2","create","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","onTileError","allTiles","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","sortedTiles","child","content"],"sources":["../../../src/tile-layer/tileset-2d.js"],"sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4} from '@math.gl/core';\n\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload() {\n    return this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   * @param {*} modelMatrix\n   */\n  update(viewport, {zRange, modelMatrix} = {}) {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile =>\n        this._getTile({x: tile.x, y: tile.y, z: tile.z})\n      );\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse}) {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    const {tileSize} = this.opts;\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function'\n      ? refinementStrategy\n      : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Private methods */\n\n  _pruneRequests() {\n    const {maxRequests} = this.opts;\n\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n          this.opts.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({x, y, z});\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.z - t2.z);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n    if (tile.isVisible || tile.state & TILE_STATE_VISITED) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}