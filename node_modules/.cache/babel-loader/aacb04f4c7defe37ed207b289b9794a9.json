{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _constants = _interopRequireDefault(require(\"@luma.gl/constants\"));\n\nvar _core = require(\"@luma.gl/core\");\n\nvar _outline = _interopRequireDefault(require(\"../../shaderlib/outline/outline\"));\n\nvar _constants2 = require(\"../../constants\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // TODO - this should be built into assembleShaders\n\n\nfunction injectShaderCode(_ref) {\n  var source = _ref.source,\n      _ref$code = _ref.code,\n      code = _ref$code === void 0 ? '' : _ref$code;\n  var INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nvar VS_CODE = \"  outline_setUV(gl_Position);\\n  outline_setZLevel(instanceZLevel);\\n\";\nvar FS_CODE = \"  gl_FragColor = outline_filterColor(gl_FragColor);\\n\";\nvar defaultProps = {\n  getZLevel: function getZLevel() {\n    return 0;\n  }\n};\n\nvar PathOutlineLayer = /*#__PURE__*/function (_PathLayer) {\n  _inherits(PathOutlineLayer, _PathLayer);\n\n  var _super = _createSuper(PathOutlineLayer);\n\n  function PathOutlineLayer() {\n    _classCallCheck(this, PathOutlineLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathOutlineLayer, [{\n    key: \"getShaders\",\n    // Override getShaders to inject the outline module\n    value: function getShaders() {\n      var shaders = _get(_getPrototypeOf(PathOutlineLayer.prototype), \"getShaders\", this).call(this);\n\n      return Object.assign({}, shaders, {\n        modules: shaders.modules.concat([_outline[\"default\"]]),\n        vs: injectShaderCode({\n          source: shaders.vs,\n          code: VS_CODE\n        }),\n        fs: injectShaderCode({\n          source: shaders.fs,\n          code: FS_CODE\n        })\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context) {\n      _get(_getPrototypeOf(PathOutlineLayer.prototype), \"initializeState\", this).call(this, context); // Create an outline \"shadow\" map\n      // TODO - we should create a single outlineMap for all layers\n\n\n      this.setState({\n        outlineFramebuffer: new _core.Framebuffer(context.gl),\n        dummyTexture: new _core.Texture2D(context.gl)\n      }); // Create an attribute manager\n\n      this.state.attributeManager.addInstanced({\n        instanceZLevel: {\n          size: 1,\n          type: _constants[\"default\"].UNSIGNED_BYTE,\n          accessor: 'getZLevel'\n        }\n      });\n    } // Override draw to add render module\n\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var _ref2$moduleParameter = _ref2.moduleParameters,\n          moduleParameters = _ref2$moduleParameter === void 0 ? {} : _ref2$moduleParameter,\n          parameters = _ref2.parameters,\n          uniforms = _ref2.uniforms,\n          context = _ref2.context; // Need to calculate same uniforms as base layer\n\n      var _this$props = this.props,\n          jointRounded = _this$props.jointRounded,\n          capRounded = _this$props.capRounded,\n          billboard = _this$props.billboard,\n          miterLimit = _this$props.miterLimit,\n          widthUnits = _this$props.widthUnits,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels;\n      uniforms = Object.assign({}, uniforms, {\n        jointType: Number(jointRounded),\n        capType: Number(capRounded),\n        billboard: billboard,\n        widthUnits: _constants2.UNIT[widthUnits],\n        widthScale: widthScale,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      }); // Render the outline shadowmap (based on segment z orders)\n\n      var _this$state = this.state,\n          outlineFramebuffer = _this$state.outlineFramebuffer,\n          dummyTexture = _this$state.dummyTexture;\n      outlineFramebuffer.resize();\n      outlineFramebuffer.clear({\n        color: true,\n        depth: true\n      });\n      this.state.model.updateModuleSettings({\n        outlineEnabled: true,\n        outlineRenderShadowmap: true,\n        outlineShadowmap: dummyTexture\n      });\n      this.state.model.draw({\n        uniforms: Object.assign({}, uniforms, {\n          jointType: 0,\n          widthScale: this.props.widthScale * 1.3\n        }),\n        parameters: {\n          depthTest: false,\n          // Biggest value needs to go into buffer\n          blendEquation: _constants[\"default\"].MAX\n        },\n        framebuffer: outlineFramebuffer\n      }); // Now use the outline shadowmap to render the lines (with outlines)\n\n      this.state.model.updateModuleSettings({\n        outlineEnabled: true,\n        outlineRenderShadowmap: false,\n        outlineShadowmap: outlineFramebuffer\n      });\n      this.state.model.draw({\n        uniforms: Object.assign({}, uniforms, {\n          jointType: Number(jointRounded),\n          capType: Number(capRounded),\n          widthScale: this.props.widthScale\n        }),\n        parameters: {\n          depthTest: false\n        }\n      });\n    }\n  }]);\n\n  return PathOutlineLayer;\n}(_layers.PathLayer);\n\nexports[\"default\"] = PathOutlineLayer;\n\n_defineProperty(PathOutlineLayer, \"layerName\", 'PathOutlineLayer');\n\n_defineProperty(PathOutlineLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["injectShaderCode","source","code","INJECT_CODE","replace","concat","VS_CODE","FS_CODE","defaultProps","getZLevel","PathOutlineLayer","shaders","Object","assign","modules","outline","vs","fs","context","_get","setState","outlineFramebuffer","Framebuffer","gl","dummyTexture","Texture2D","state","attributeManager","addInstanced","instanceZLevel","size","type","GL","UNSIGNED_BYTE","accessor","moduleParameters","parameters","uniforms","props","jointRounded","capRounded","billboard","miterLimit","widthUnits","widthScale","widthMinPixels","widthMaxPixels","jointType","Number","capType","UNIT","resize","clear","color","depth","model","updateModuleSettings","outlineEnabled","outlineRenderShadowmap","outlineShadowmap","draw","depthTest","blendEquation","MAX","framebuffer","PathLayer"],"sources":["../../../src/layers/path-outline-layer/path-outline-layer.ts"],"sourcesContent":["import { PathLayer } from '@deck.gl/layers';\nimport { PathLayerProps } from '@deck.gl/layers/path-layer/path-layer';\nimport GL from '@luma.gl/constants';\nimport { Framebuffer, Texture2D } from '@luma.gl/core';\nimport outline from '../../shaderlib/outline/outline';\nimport { UNIT } from '../../constants';\n\n// TODO - this should be built into assembleShaders\nfunction injectShaderCode({ source, code = '' }) {\n  const INJECT_CODE = /}[^{}]*$/;\n  return source.replace(INJECT_CODE, code.concat('\\n}\\n'));\n}\n\nconst VS_CODE = `\\\n  outline_setUV(gl_Position);\n  outline_setZLevel(instanceZLevel);\n`;\n\nconst FS_CODE = `\\\n  gl_FragColor = outline_filterColor(gl_FragColor);\n`;\n\nexport interface PathOutlineLayerProps<D> extends PathLayerProps<D> {\n  dashJustified?: boolean;\n  getDashArray?: [number, number] | ((d: D) => [number, number] | null);\n  getZLevel?: (d: D, index: number) => number;\n}\n\nconst defaultProps: PathOutlineLayerProps<any> = {\n  getZLevel: () => 0,\n};\n\nexport default class PathOutlineLayer<\n  D,\n  P extends PathOutlineLayerProps<D> = PathOutlineLayerProps<D>\n> extends PathLayer<D, P> {\n  static layerName = 'PathOutlineLayer';\n  static defaultProps = defaultProps;\n\n  // Override getShaders to inject the outline module\n  getShaders() {\n    const shaders = super.getShaders();\n    return Object.assign({}, shaders, {\n      modules: shaders.modules.concat([outline]),\n      vs: injectShaderCode({ source: shaders.vs, code: VS_CODE }),\n      fs: injectShaderCode({ source: shaders.fs, code: FS_CODE }),\n    });\n  }\n\n  initializeState(context: any) {\n    super.initializeState(context);\n\n    // Create an outline \"shadow\" map\n    // TODO - we should create a single outlineMap for all layers\n    this.setState({\n      outlineFramebuffer: new Framebuffer(context.gl),\n      dummyTexture: new Texture2D(context.gl),\n    });\n\n    // Create an attribute manager\n    this.state.attributeManager.addInstanced({\n      instanceZLevel: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getZLevel',\n      },\n    });\n  }\n\n  // Override draw to add render module\n  draw({ moduleParameters = {}, parameters, uniforms, context }) {\n    // Need to calculate same uniforms as base layer\n    const {\n      jointRounded,\n      capRounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels,\n    } = this.props;\n\n    uniforms = Object.assign({}, uniforms, {\n      jointType: Number(jointRounded),\n      capType: Number(capRounded),\n      billboard,\n      widthUnits: UNIT[widthUnits],\n      widthScale,\n      miterLimit,\n      widthMinPixels,\n      widthMaxPixels,\n    });\n\n    // Render the outline shadowmap (based on segment z orders)\n    const { outlineFramebuffer, dummyTexture } = this.state;\n    outlineFramebuffer.resize();\n    outlineFramebuffer.clear({ color: true, depth: true });\n\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: true,\n      outlineShadowmap: dummyTexture,\n    });\n\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: 0,\n        widthScale: this.props.widthScale * 1.3,\n      }),\n      parameters: {\n        depthTest: false,\n        // Biggest value needs to go into buffer\n        blendEquation: GL.MAX,\n      },\n      framebuffer: outlineFramebuffer,\n    });\n\n    // Now use the outline shadowmap to render the lines (with outlines)\n    this.state.model.updateModuleSettings({\n      outlineEnabled: true,\n      outlineRenderShadowmap: false,\n      outlineShadowmap: outlineFramebuffer,\n    });\n    this.state.model.draw({\n      uniforms: Object.assign({}, uniforms, {\n        jointType: Number(jointRounded),\n        capType: Number(capRounded),\n        widthScale: this.props.widthScale,\n      }),\n      parameters: {\n        depthTest: false,\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}