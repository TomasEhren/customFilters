{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { h3ToGeoBoundary, h3GetResolution, h3ToGeo, geoToH3, h3IsPentagon, h3Distance, edgeLength, UNITS } from 'h3-js';\nimport { lerp } from '@math.gl/core';\nimport { CompositeLayer, createIterable } from '@deck.gl/core';\nimport { ColumnLayer, PolygonLayer } from '@deck.gl/layers';\nvar UPDATE_THRESHOLD_KM = 10;\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n\n  var _iterator = _createForOfIteratorHelper(vertices),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pt = _step.value;\n      var deltaLng = pt[0] - refLng;\n\n      if (deltaLng > 180) {\n        pt[0] -= 360;\n      } else if (deltaLng < -180) {\n        pt[0] += 360;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport function scalePolygon(hexId, vertices, factor) {\n  var _h3ToGeo = h3ToGeo(hexId),\n      _h3ToGeo2 = _slicedToArray(_h3ToGeo, 2),\n      lat = _h3ToGeo2[0],\n      lng = _h3ToGeo2[1];\n\n  var actualCount = vertices.length;\n  normalizeLongitudes(vertices, lng);\n  var vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n\n  for (var i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  var hexagonId = getHexagon(object, objectInfo);\n\n  var _h3ToGeo3 = h3ToGeo(hexagonId),\n      _h3ToGeo4 = _slicedToArray(_h3ToGeo3, 2),\n      lat = _h3ToGeo4[0],\n      lng = _h3ToGeo4[1];\n\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId) {\n  var coverage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var flatten = arguments.length > 2 ? arguments[2] : undefined;\n  var vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    var positions = new Float64Array(vertices.length * 2);\n    var i = 0;\n\n    var _iterator2 = _createForOfIteratorHelper(vertices),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var pt = _step2.value;\n        positions[i++] = pt[0];\n        positions[i++] = pt[1];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  var trigger;\n\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = _objectSpread(_objectSpread({}, getHexagon), {}, {\n      coverage: coverage\n    });\n  } else {\n    trigger = {\n      getHexagon: getHexagon,\n      coverage: coverage\n    };\n  }\n\n  return trigger;\n}\n\nvar defaultProps = _objectSpread(_objectSpread({}, PolygonLayer.defaultProps), {}, {\n  highPrecision: 'auto',\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  centerHexagon: null,\n  getHexagon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.hexagon;\n    }\n  },\n  extruded: true\n});\n\ndelete defaultProps.getLineDashArray;\n\nvar H3HexagonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(H3HexagonLayer, _CompositeLayer);\n\n  var _super = _createSuper(H3HexagonLayer);\n\n  function H3HexagonLayer() {\n    _classCallCheck(this, H3HexagonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(H3HexagonLayer, [{\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon)) {\n        var dataProps = this._calculateH3DataProps(props);\n\n        this.setState(dataProps);\n      }\n\n      this._updateVertices(this.context.viewport);\n    }\n  }, {\n    key: \"_calculateH3DataProps\",\n    value: function _calculateH3DataProps(props) {\n      var resolution = -1;\n      var hasPentagon = false;\n      var hasMultipleRes = false;\n\n      var _createIterable = createIterable(props.data),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var hexId = props.getHexagon(object, objectInfo);\n          var hexResolution = h3GetResolution(hexId);\n\n          if (resolution < 0) {\n            resolution = hexResolution;\n            if (!props.highPrecision) break;\n          } else if (resolution !== hexResolution) {\n            hasMultipleRes = true;\n            break;\n          }\n\n          if (h3IsPentagon(hexId)) {\n            hasPentagon = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return {\n        resolution: resolution,\n        edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n        hasMultipleRes: hasMultipleRes,\n        hasPentagon: hasPentagon\n      };\n    }\n  }, {\n    key: \"_shouldUseHighPrecision\",\n    value: function _shouldUseHighPrecision() {\n      if (this.props.highPrecision === 'auto') {\n        var _this$state = this.state,\n            resolution = _this$state.resolution,\n            hasPentagon = _this$state.hasPentagon,\n            hasMultipleRes = _this$state.hasMultipleRes;\n        var viewport = this.context.viewport;\n        return viewport.resolution || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;\n      }\n\n      return this.props.highPrecision;\n    }\n  }, {\n    key: \"_updateVertices\",\n    value: function _updateVertices(viewport) {\n      if (this._shouldUseHighPrecision()) {\n        return;\n      }\n\n      var _this$state2 = this.state,\n          resolution = _this$state2.resolution,\n          edgeLengthKM = _this$state2.edgeLengthKM,\n          centerHex = _this$state2.centerHex;\n\n      if (resolution < 0) {\n        return;\n      }\n\n      var hex = this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n\n      if (centerHex === hex) {\n        return;\n      }\n\n      if (centerHex) {\n        var distance = h3Distance(centerHex, hex);\n\n        if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n          return;\n        }\n      }\n\n      var unitsPerMeter = viewport.distanceScales.unitsPerMeter;\n      var vertices = h3ToPolygon(hex);\n\n      var _h3ToGeo5 = h3ToGeo(hex),\n          _h3ToGeo6 = _slicedToArray(_h3ToGeo5, 2),\n          centerLat = _h3ToGeo6[0],\n          centerLng = _h3ToGeo6[1];\n\n      var _viewport$projectFlat = viewport.projectFlat([centerLng, centerLat]),\n          _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n          centerX = _viewport$projectFlat2[0],\n          centerY = _viewport$projectFlat2[1];\n\n      vertices = vertices.map(function (p) {\n        var worldPosition = viewport.projectFlat(p);\n        return [(worldPosition[0] - centerX) / unitsPerMeter[0], (worldPosition[1] - centerY) / unitsPerMeter[1]];\n      });\n      this.setState({\n        centerHex: hex,\n        vertices: vertices\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n    }\n  }, {\n    key: \"_getForwardProps\",\n    value: function _getForwardProps() {\n      var _this$props = this.props,\n          elevationScale = _this$props.elevationScale,\n          material = _this$props.material,\n          coverage = _this$props.coverage,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          lineWidthUnits = _this$props.lineWidthUnits,\n          lineWidthScale = _this$props.lineWidthScale,\n          lineWidthMinPixels = _this$props.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props.lineWidthMaxPixels,\n          getFillColor = _this$props.getFillColor,\n          getElevation = _this$props.getElevation,\n          getLineColor = _this$props.getLineColor,\n          getLineWidth = _this$props.getLineWidth,\n          transitions = _this$props.transitions,\n          updateTriggers = _this$props.updateTriggers;\n      return {\n        elevationScale: elevationScale,\n        extruded: extruded,\n        coverage: coverage,\n        wireframe: wireframe,\n        stroked: stroked,\n        filled: filled,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        material: material,\n        getElevation: getElevation,\n        getFillColor: getFillColor,\n        getLineColor: getLineColor,\n        getLineWidth: getLineWidth,\n        transitions: transitions,\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getElevation: updateTriggers.getElevation,\n          getLineColor: updateTriggers.getLineColor,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      };\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getHexagon = _this$props2.getHexagon,\n          updateTriggers = _this$props2.updateTriggers,\n          coverage = _this$props2.coverage;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: function getPolygon(object, objectInfo) {\n          var hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      });\n    }\n  }, {\n    key: \"_renderColumnLayer\",\n    value: function _renderColumnLayer() {\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getHexagon = _this$props3.getHexagon,\n          updateTriggers = _this$props3.updateTriggers;\n      var SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n\n      var forwardProps = this._getForwardProps();\n\n      forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n      return new SubLayerClass(forwardProps, this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }), {\n        data: data,\n        diskResolution: 6,\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      });\n    }\n  }]);\n\n  return H3HexagonLayer;\n}(CompositeLayer);\n\nexport { H3HexagonLayer as default };\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';","map":{"version":3,"mappings":";;;;;;;AAAA,SACEA,eADF,EAEEC,eAFF,EAGEC,OAHF,EAIEC,OAJF,EAKEC,YALF,EAMEC,UANF,EAOEC,UAPF,EAQEC,KARF,QASO,OATP;AAUA,SAAQC,IAAR,QAAmB,eAAnB;AACA,SAAQC,cAAR,EAAwBC,cAAxB,QAA6C,eAA7C;AACA,SAAQC,WAAR,EAAqBC,YAArB,QAAwC,iBAAxC;AAKA,IAAMC,mBAAmB,GAAG,EAA5B;AAGA,OAAO,SAASC,mBAAT,CAA6BC,QAA7B,EAAuCC,MAAvC,EAA+C;EACpDA,MAAM,GAAGA,MAAM,KAAKC,SAAXD,GAAuBD,QAAQ,CAAC,CAAD,CAARA,CAAY,CAAZA,CAAvBC,GAAwCA,MAAjDA;;EADoD,2CAEnCD,QAFmC;EAAA;;EAAA;IAEpD,oDAA2B;MAAA,IAAhBG,EAAgB;MACzB,IAAMC,QAAQ,GAAGD,EAAE,CAAC,CAAD,CAAFA,GAAQF,MAAzB;;MACA,IAAIG,QAAQ,GAAG,GAAf,EAAoB;QAClBD,EAAE,CAAC,CAAD,CAAFA,IAAS,GAATA;MADF,OAEO,IAAIC,QAAQ,GAAG,CAAC,GAAhB,EAAqB;QAC1BD,EAAE,CAAC,CAAD,CAAFA,IAAS,GAATA;MACD;IACF;EATmD;IAAA;EAAA;IAAA;EAAA;AAUrD;AAGD,OAAO,SAASE,YAAT,CAAsBC,KAAtB,EAA6BN,QAA7B,EAAuCO,MAAvC,EAA+C;EACpD,eAAmBpB,OAAO,CAACmB,KAAD,CAA1B;EAAA;EAAA,IAAOE,GAAP;EAAA,IAAYC,GAAZ;;EACA,IAAMC,WAAW,GAAGV,QAAQ,CAACW,MAA7B;EAGAZ,mBAAmB,CAACC,QAAD,EAAWS,GAAX,CAAnBV;EAIA,IAAMa,WAAW,GAAGZ,QAAQ,CAAC,CAAD,CAARA,KAAgBA,QAAQ,CAACU,WAAW,GAAG,CAAf,CAAxBV,GAA4CU,WAAW,GAAG,CAA1DV,GAA8DU,WAAlF;;EACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,WAApB,EAAiCC,CAAC,EAAlC,EAAsC;IACpCb,QAAQ,CAACa,CAAD,CAARb,CAAY,CAAZA,IAAiBP,IAAI,CAACgB,GAAD,EAAMT,QAAQ,CAACa,CAAD,CAARb,CAAY,CAAZA,CAAN,EAAsBO,MAAtB,CAArBP;IACAA,QAAQ,CAACa,CAAD,CAARb,CAAY,CAAZA,IAAiBP,IAAI,CAACe,GAAD,EAAMR,QAAQ,CAACa,CAAD,CAARb,CAAY,CAAZA,CAAN,EAAsBO,MAAtB,CAArBP;EACD;AACF;;AAED,SAASc,kBAAT,CAA4BC,UAA5B,EAAwCC,MAAxC,EAAgDC,UAAhD,EAA4D;EAC1D,IAAMC,SAAS,GAAGH,UAAU,CAACC,MAAD,EAASC,UAAT,CAA5B;;EACA,gBAAmB9B,OAAO,CAAC+B,SAAD,CAA1B;EAAA;EAAA,IAAOV,GAAP;EAAA,IAAYC,GAAZ;;EACA,OAAO,CAACA,GAAD,EAAMD,GAAN,CAAP;AACD;;AAED,SAASW,WAAT,CAAqBb,KAArB,EAAmD;EAAA,IAAvBc,QAAuB,uEAAZ,CAAY;EAAA,IAATC,OAAS;EACjD,IAAMrB,QAAQ,GAAGf,eAAe,CAACqB,KAAD,EAAQ,IAAR,CAAhC;;EAEA,IAAIc,QAAQ,KAAK,CAAjB,EAAoB;IAElBf,YAAY,CAACC,KAAD,EAAQN,QAAR,EAAkBoB,QAAlB,CAAZf;EAFF,OAGO;IAELN,mBAAmB,CAACC,QAAD,CAAnBD;EACD;;EAED,IAAIsB,OAAJ,EAAa;IACX,IAAMC,SAAS,GAAG,IAAIC,YAAJ,CAAiBvB,QAAQ,CAACW,MAATX,GAAkB,CAAnC,CAAlB;IACA,IAAIa,CAAC,GAAG,CAAR;;IAFW,4CAGMb,QAHN;IAAA;;IAAA;MAGX,uDAA2B;QAAA,IAAhBG,EAAgB;QACzBmB,SAAS,CAACT,CAAC,EAAF,CAATS,GAAiBnB,EAAE,CAAC,CAAD,CAAnBmB;QACAA,SAAS,CAACT,CAAC,EAAF,CAATS,GAAiBnB,EAAE,CAAC,CAAD,CAAnBmB;MACD;IANU;MAAA;IAAA;MAAA;IAAA;;IAOX,OAAOA,SAAP;EACD;;EAED,OAAOtB,QAAP;AACD;;AAED,SAASwB,aAAT,CAAuBT,UAAvB,EAAmCK,QAAnC,EAA6C;EAC3C,IAAIK,OAAJ;;EACA,IAAIV,UAAU,KAAKb,SAAfa,IAA4BA,UAAU,KAAK,IAA/C,EAAqD;IACnDU,OAAO,GAAGL,QAAVK;EADF,OAEO,IAAI,OAAOV,UAAP,KAAsB,QAA1B,EAAoC;IACzCU,OAAO,mCAAOV,UAAP;MAAmBK;IAAnB,EAAPK;EADK,OAEA;IACLA,OAAO,GAAG;MAACV,UAAD,EAACA,UAAD;MAAaK;IAAb,CAAVK;EACD;;EACD,OAAOA,OAAP;AACD;;AAED,IAAMC,YAAY,mCACb7B,YAAY,CAAC6B,YADA;EAEhBC,aAAa,EAAE,MAFC;EAGhBP,QAAQ,EAAE;IAACQ,IAAI,EAAE,QAAP;IAAiBC,GAAG,EAAE,CAAtB;IAAyBC,GAAG,EAAE,CAA9B;IAAiCC,KAAK,EAAE;EAAxC,CAHM;EAIhBC,aAAa,EAAE,IAJC;EAKhBjB,UAAU,EAAE;IAACa,IAAI,EAAE,UAAP;IAAmBG,KAAK,EAAEE,gBAAC;MAAA,OAAIA,CAAC,CAACC,OAAN;IAAA;EAA3B,CALI;EAMhBC,QAAQ,EAAE;AANM,EAAlB;;AAUA,OAAOT,YAAY,CAACU,gBAApB;;IAaqBC,c;;;;;;;;;;;;;WACnBC,iCAAiC;MAAA,IAAdC,WAAc,QAAdA,WAAc;MAC/B,OAAO,KAAKC,uBAAL,KACHD,WAAW,CAACE,kBADT,GAEHF,WAAW,CAACG,gBAFhB;IAGD;;;WAEDC,4BAA4C;MAAA,IAA/BC,KAA+B,SAA/BA,KAA+B;MAAA,IAAxBC,QAAwB,SAAxBA,QAAwB;MAAA,IAAdN,WAAc,SAAdA,WAAc;;MAC1C,IACEK,KAAK,CAACjB,aAANiB,KAAwB,IAAxBA,KACCL,WAAW,CAACO,WAAZP,IACEA,WAAW,CAACQ,cAAZR,IAA8BA,WAAW,CAACQ,cAAZR,CAA2BxB,UAF5D6B,CADF,EAIE;QACA,IAAMI,SAAS,GAAG,KAAKC,qBAAL,CAA2BL,KAA3B,CAAlB;;QACA,KAAKM,QAAL,CAAcF,SAAd;MACD;;MAED,KAAKG,eAAL,CAAqB,KAAKC,OAAL,CAAaC,QAAlC;IACD;;;WAEDJ,+BAAsBL,KAAtBK,EAA6B;MAC3B,IAAIK,UAAU,GAAG,CAAC,CAAlB;MACA,IAAIC,WAAW,GAAG,KAAlB;MACA,IAAIC,cAAc,GAAG,KAArB;;MAEA,sBAA+B7D,cAAc,CAACiD,KAAK,CAACa,IAAP,CAA7C;MAAA,IAAOC,QAAP,mBAAOA,QAAP;MAAA,IAAiBzC,UAAjB,mBAAiBA,UAAjB;;MAL2B,4CAMNyC,QANM;MAAA;;MAAA;QAM3B,uDAA+B;UAAA,IAApB1C,MAAoB;UAC7BC,UAAU,CAAC0C,KAAX1C;UACA,IAAMX,KAAK,GAAGsC,KAAK,CAAC7B,UAAN6B,CAAiB5B,MAAjB4B,EAAyB3B,UAAzB2B,CAAd;UAEA,IAAMgB,aAAa,GAAG1E,eAAe,CAACoB,KAAD,CAArC;;UACA,IAAIgD,UAAU,GAAG,CAAjB,EAAoB;YAClBA,UAAU,GAAGM,aAAbN;YACA,IAAI,CAACV,KAAK,CAACjB,aAAX,EAA0B;UAF5B,OAGO,IAAI2B,UAAU,KAAKM,aAAnB,EAAkC;YACvCJ,cAAc,GAAG,IAAjBA;YACA;UACD;;UACD,IAAInE,YAAY,CAACiB,KAAD,CAAhB,EAAyB;YACvBiD,WAAW,GAAG,IAAdA;YACA;UACD;QACF;MAtB0B;QAAA;MAAA;QAAA;MAAA;;MAwB3B,OAAO;QACLD,UADK,EACLA,UADK;QAELO,YAAY,EAAEP,UAAU,IAAI,CAAdA,GAAkB/D,UAAU,CAAC+D,UAAD,EAAa9D,KAAK,CAACsE,EAAnB,CAA5BR,GAAqD,CAF9D;QAGLE,cAHK,EAGLA,cAHK;QAILD;MAJK,CAAP;IAMD;;;WAEDf,mCAA0B;MACxB,IAAI,KAAKI,KAAL,CAAWjB,aAAX,KAA6B,MAAjC,EAAyC;QACvC,kBAAkD,KAAKoC,KAAvD;QAAA,IAAOT,UAAP,eAAOA,UAAP;QAAA,IAAmBC,WAAnB,eAAmBA,WAAnB;QAAA,IAAgCC,cAAhC,eAAgCA,cAAhC;QACA,IAAOH,QAAP,GAAmB,KAAKD,OAAxB,CAAOC,QAAP;QACA,OACEA,QAAQ,CAACC,UAATD,IAAuBG,cAAvBH,IAAyCE,WAAzCF,IAAyDC,UAAU,IAAI,CAAdA,IAAmBA,UAAU,IAAI,CAD5F;MAGD;;MAED,OAAO,KAAKV,KAAL,CAAWjB,aAAlB;IACD;;;WAEDwB,yBAAgBE,QAAhBF,EAA0B;MACxB,IAAI,KAAKX,uBAAL,EAAJ,EAAoC;QAClC;MACD;;MACD,mBAA8C,KAAKuB,KAAnD;MAAA,IAAOT,UAAP,gBAAOA,UAAP;MAAA,IAAmBO,YAAnB,gBAAmBA,YAAnB;MAAA,IAAiCG,SAAjC,gBAAiCA,SAAjC;;MACA,IAAIV,UAAU,GAAG,CAAjB,EAAoB;QAClB;MACD;;MACD,IAAMW,GAAG,GACP,KAAKrB,KAAL,CAAWZ,aAAX,IAA4B5C,OAAO,CAACiE,QAAQ,CAACa,QAAV,EAAoBb,QAAQ,CAACc,SAA7B,EAAwCb,UAAxC,CADrC;;MAEA,IAAIU,SAAS,KAAKC,GAAlB,EAAuB;QACrB;MACD;;MACD,IAAID,SAAJ,EAAe;QACb,IAAMI,QAAQ,GAAG9E,UAAU,CAAC0E,SAAD,EAAYC,GAAZ,CAA3B;;QAGA,IAAIG,QAAQ,IAAI,CAAZA,IAAiBA,QAAQ,GAAGP,YAAXO,GAA0BtE,mBAA/C,EAAoE;UAClE;QACD;MACF;;MAED,IAAOuE,aAAP,GAAwBhB,QAAQ,CAACiB,cAAjC,CAAOD,aAAP;MAEA,IAAIrE,QAAQ,GAAGmB,WAAW,CAAC8C,GAAD,CAA1B;;MACA,gBAA+B9E,OAAO,CAAC8E,GAAD,CAAtC;MAAA;MAAA,IAAOM,SAAP;MAAA,IAAkBC,SAAlB;;MAEA,4BAA2BnB,QAAQ,CAACoB,WAATpB,CAAqB,CAACmB,SAAD,EAAYD,SAAZ,CAArBlB,CAA3B;MAAA;MAAA,IAAOqB,OAAP;MAAA,IAAgBC,OAAhB;;MACA3E,QAAQ,GAAGA,QAAQ,CAAC4E,GAAT5E,CAAa6E,WAAC,EAAI;QAC3B,IAAMC,aAAa,GAAGzB,QAAQ,CAACoB,WAATpB,CAAqBwB,CAArBxB,CAAtB;QACA,OAAO,CACL,CAACyB,aAAa,CAAC,CAAD,CAAbA,GAAmBJ,OAApB,IAA+BL,aAAa,CAAC,CAAD,CADvC,EAEL,CAACS,aAAa,CAAC,CAAD,CAAbA,GAAmBH,OAApB,IAA+BN,aAAa,CAAC,CAAD,CAFvC,CAAP;MAFS,EAAXrE;MAQA,KAAKkD,QAAL,CAAc;QAACc,SAAS,EAAEC,GAAZ;QAAiBjE;MAAjB,CAAd;IACD;;;WAED+E,wBAAe;MACb,OAAO,KAAKvC,uBAAL,KAAiC,KAAKwC,mBAAL,EAAjC,GAA8D,KAAKC,kBAAL,EAArE;IACD;;;WAEDC,4BAAmB;MACjB,kBAkBI,KAAKtC,KAlBT;MAAA,IACEuC,cADF,eACEA,cADF;MAAA,IAEEC,QAFF,eAEEA,QAFF;MAAA,IAGEhE,QAHF,eAGEA,QAHF;MAAA,IAIEe,QAJF,eAIEA,QAJF;MAAA,IAKEkD,SALF,eAKEA,SALF;MAAA,IAMEC,OANF,eAMEA,OANF;MAAA,IAOEC,MAPF,eAOEA,MAPF;MAAA,IAQEC,cARF,eAQEA,cARF;MAAA,IASEC,cATF,eASEA,cATF;MAAA,IAUEC,kBAVF,eAUEA,kBAVF;MAAA,IAWEC,kBAXF,eAWEA,kBAXF;MAAA,IAYEC,YAZF,eAYEA,YAZF;MAAA,IAaEC,YAbF,eAaEA,YAbF;MAAA,IAcEC,YAdF,eAcEA,YAdF;MAAA,IAeEC,YAfF,eAeEA,YAfF;MAAA,IAgBEC,WAhBF,eAgBEA,WAhBF;MAAA,IAiBEjD,cAjBF,eAiBEA,cAjBF;MAoBA,OAAO;QACLoC,cADK,EACLA,cADK;QAELhD,QAFK,EAELA,QAFK;QAGLf,QAHK,EAGLA,QAHK;QAILiE,SAJK,EAILA,SAJK;QAKLC,OALK,EAKLA,OALK;QAMLC,MANK,EAMLA,MANK;QAOLC,cAPK,EAOLA,cAPK;QAQLC,cARK,EAQLA,cARK;QASLC,kBATK,EASLA,kBATK;QAULC,kBAVK,EAULA,kBAVK;QAWLP,QAXK,EAWLA,QAXK;QAYLS,YAZK,EAYLA,YAZK;QAaLD,YAbK,EAaLA,YAbK;QAcLE,YAdK,EAcLA,YAdK;QAeLC,YAfK,EAeLA,YAfK;QAgBLC,WAhBK,EAgBLA,WAhBK;QAiBLjD,cAAc,EAAE;UACd6C,YAAY,EAAE7C,cAAc,CAAC6C,YADf;UAEdC,YAAY,EAAE9C,cAAc,CAAC8C,YAFf;UAGdC,YAAY,EAAE/C,cAAc,CAAC+C,YAHf;UAIdC,YAAY,EAAEhD,cAAc,CAACgD;QAJf;MAjBX,CAAP;IAwBD;;;WAEDf,+BAAsB;MACpB,mBAAqD,KAAKpC,KAA1D;MAAA,IAAOa,IAAP,gBAAOA,IAAP;MAAA,IAAa1C,UAAb,gBAAaA,UAAb;MAAA,IAAyBgC,cAAzB,gBAAyBA,cAAzB;MAAA,IAAyC3B,QAAzC,gBAAyCA,QAAzC;MAEA,IAAM6E,aAAa,GAAG,KAAKC,gBAAL,CAAsB,mBAAtB,EAA2CrG,YAA3C,CAAtB;;MACA,IAAMsG,YAAY,GAAG,KAAKjB,gBAAL,EAArB;;MAEAiB,YAAY,CAACpD,cAAboD,CAA4BC,UAA5BD,GAAyC3E,aAAa,CAACuB,cAAc,CAAChC,UAAhB,EAA4BK,QAA5B,CAAtD+E;MAEA,OAAO,IAAIF,aAAJ,CACLE,YADK,EAEL,KAAKE,gBAAL,CAAsB;QACpBC,EAAE,EAAE,mBADgB;QAEpBvD,cAAc,EAAEoD,YAAY,CAACpD;MAFT,CAAtB,CAFK,EAML;QACEU,IADF,EACEA,IADF;QAEE8C,UAAU,EAAE,KAFd;QAGEC,aAAa,EAAE,KAHjB;QAIEC,cAAc,EAAE,IAJlB;QAKEL,UAAU,EAAE,oBAACpF,MAAD,EAASC,UAAT,EAAwB;UAClC,IAAMC,SAAS,GAAGH,UAAU,CAACC,MAAD,EAASC,UAAT,CAA5B;UACA,OAAOE,WAAW,CAACD,SAAD,EAAYE,QAAZ,EAAsB,IAAtB,CAAlB;QACD;MARH,CANK,CAAP;IAiBD;;;WAED6D,8BAAqB;MACnB,mBAA2C,KAAKrC,KAAhD;MAAA,IAAOa,IAAP,gBAAOA,IAAP;MAAA,IAAa1C,UAAb,gBAAaA,UAAb;MAAA,IAAyBgC,cAAzB,gBAAyBA,cAAzB;MAEA,IAAMkD,aAAa,GAAG,KAAKC,gBAAL,CAAsB,cAAtB,EAAsCtG,WAAtC,CAAtB;;MACA,IAAMuG,YAAY,GAAG,KAAKjB,gBAAL,EAArB;;MACAiB,YAAY,CAACpD,cAAboD,CAA4BO,WAA5BP,GAA0CpD,cAAc,CAAChC,UAAzDoF;MAEA,OAAO,IAAIF,aAAJ,CACLE,YADK,EAEL,KAAKE,gBAAL,CAAsB;QACpBC,EAAE,EAAE,cADgB;QAEpBK,WAAW,EAAE,IAFO;QAGpB5D,cAAc,EAAEoD,YAAY,CAACpD;MAHT,CAAtB,CAFK,EAOL;QACEU,IADF,EACEA,IADF;QAEEmD,cAAc,EAAE,CAFlB;QAGEC,MAAM,EAAE,CAHV;QAIE7G,QAAQ,EAAE,KAAK+D,KAAL,CAAW/D,QAJvB;QAKE0G,WAAW,EAAE5F,kBAAkB,CAACgG,IAAnBhG,CAAwB,IAAxBA,EAA8BC,UAA9BD;MALf,CAPK,CAAP;IAeD;;;;EA3MyCpB,c;;SAAvB2C,c;AA8MrBA,cAAc,CAACX,YAAfW,GAA8BX,YAA9BW;AACAA,cAAc,CAAC0E,SAAf1E,GAA2B,gBAA3BA","names":["h3ToGeoBoundary","h3GetResolution","h3ToGeo","geoToH3","h3IsPentagon","h3Distance","edgeLength","UNITS","lerp","CompositeLayer","createIterable","ColumnLayer","PolygonLayer","UPDATE_THRESHOLD_KM","normalizeLongitudes","vertices","refLng","undefined","pt","deltaLng","scalePolygon","hexId","factor","lat","lng","actualCount","length","vertexCount","i","getHexagonCentroid","getHexagon","object","objectInfo","hexagonId","h3ToPolygon","coverage","flatten","positions","Float64Array","mergeTriggers","trigger","defaultProps","highPrecision","type","min","max","value","centerHexagon","x","hexagon","extruded","getLineDashArray","H3HexagonLayer","shouldUpdateState","changeFlags","_shouldUseHighPrecision","propsOrDataChanged","somethingChanged","updateState","props","oldProps","dataChanged","updateTriggers","dataProps","_calculateH3DataProps","setState","_updateVertices","context","viewport","resolution","hasPentagon","hasMultipleRes","data","iterable","index","hexResolution","edgeLengthKM","km","state","centerHex","hex","latitude","longitude","distance","unitsPerMeter","distanceScales","centerLat","centerLng","projectFlat","centerX","centerY","map","p","worldPosition","renderLayers","_renderPolygonLayer","_renderColumnLayer","_getForwardProps","elevationScale","material","wireframe","stroked","filled","lineWidthUnits","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","getFillColor","getElevation","getLineColor","getLineWidth","transitions","SubLayerClass","getSubLayerClass","forwardProps","getPolygon","getSubLayerProps","id","_normalize","_windingOrder","positionFormat","getPosition","flatShading","diskResolution","radius","bind","layerName"],"sources":["../../../src/h3-layers/h3-hexagon-layer.js"],"sourcesContent":["import {\n  h3ToGeoBoundary,\n  h3GetResolution,\n  h3ToGeo,\n  geoToH3,\n  h3IsPentagon,\n  h3Distance,\n  edgeLength,\n  UNITS\n} from 'h3-js';\nimport {lerp} from '@math.gl/core';\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport {ColumnLayer, PolygonLayer} from '@deck.gl/layers';\n\n// There is a cost to updating the instanced geometries when using highPrecision: false\n// This constant defines the distance between two hexagons that leads to \"significant\n// distortion.\" Smaller value makes the column layer more sensitive to viewport change.\nconst UPDATE_THRESHOLD_KM = 10;\n\n// normalize longitudes w.r.t center (refLng), when not provided first vertex\nexport function normalizeLongitudes(vertices, refLng) {\n  refLng = refLng === undefined ? vertices[0][0] : refLng;\n  for (const pt of vertices) {\n    const deltaLng = pt[0] - refLng;\n    if (deltaLng > 180) {\n      pt[0] -= 360;\n    } else if (deltaLng < -180) {\n      pt[0] += 360;\n    }\n  }\n}\n\n// scale polygon vertices w.r.t center (hexId)\nexport function scalePolygon(hexId, vertices, factor) {\n  const [lat, lng] = h3ToGeo(hexId);\n  const actualCount = vertices.length;\n\n  // normalize with respect to center\n  normalizeLongitudes(vertices, lng);\n\n  // `h3ToGeoBoundary` returns same array object for first and last vertex (closed polygon),\n  // if so skip scaling the last vertex\n  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;\n  for (let i = 0; i < vertexCount; i++) {\n    vertices[i][0] = lerp(lng, vertices[i][0], factor);\n    vertices[i][1] = lerp(lat, vertices[i][1], factor);\n  }\n}\n\nfunction getHexagonCentroid(getHexagon, object, objectInfo) {\n  const hexagonId = getHexagon(object, objectInfo);\n  const [lat, lng] = h3ToGeo(hexagonId);\n  return [lng, lat];\n}\n\nfunction h3ToPolygon(hexId, coverage = 1, flatten) {\n  const vertices = h3ToGeoBoundary(hexId, true);\n\n  if (coverage !== 1) {\n    // scale and normalize vertices w.r.t to center\n    scalePolygon(hexId, vertices, coverage);\n  } else {\n    // normalize w.r.t to start vertex\n    normalizeLongitudes(vertices);\n  }\n\n  if (flatten) {\n    const positions = new Float64Array(vertices.length * 2);\n    let i = 0;\n    for (const pt of vertices) {\n      positions[i++] = pt[0];\n      positions[i++] = pt[1];\n    }\n    return positions;\n  }\n\n  return vertices;\n}\n\nfunction mergeTriggers(getHexagon, coverage) {\n  let trigger;\n  if (getHexagon === undefined || getHexagon === null) {\n    trigger = coverage;\n  } else if (typeof getHexagon === 'object') {\n    trigger = {...getHexagon, coverage};\n  } else {\n    trigger = {getHexagon, coverage};\n  }\n  return trigger;\n}\n\nconst defaultProps = {\n  ...PolygonLayer.defaultProps,\n  highPrecision: 'auto',\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  centerHexagon: null,\n  getHexagon: {type: 'accessor', value: x => x.hexagon},\n  extruded: true\n};\n\n// not supported\ndelete defaultProps.getLineDashArray;\n\n/**\n * A subclass of HexagonLayer that uses H3 hexagonIds in data objects\n * rather than centroid lat/longs. The shape of each hexagon is determined\n * based on a single \"center\" hexagon, which can be selected by passing in\n * a center lat/lon pair. If not provided, the map center will be used.\n *\n * Also sets the `hexagonId` field in the onHover/onClick callback's info\n * objects. Since this is calculated using math, hexagonId will be present\n * even when no corresponding hexagon is in the data set. You can check\n * index !== -1 to see if picking matches an actual object.\n */\nexport default class H3HexagonLayer extends CompositeLayer {\n  shouldUpdateState({changeFlags}) {\n    return this._shouldUseHighPrecision()\n      ? changeFlags.propsOrDataChanged\n      : changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (\n      props.highPrecision !== true &&\n      (changeFlags.dataChanged ||\n        (changeFlags.updateTriggers && changeFlags.updateTriggers.getHexagon))\n    ) {\n      const dataProps = this._calculateH3DataProps(props);\n      this.setState(dataProps);\n    }\n\n    this._updateVertices(this.context.viewport);\n  }\n\n  _calculateH3DataProps(props) {\n    let resolution = -1;\n    let hasPentagon = false;\n    let hasMultipleRes = false;\n\n    const {iterable, objectInfo} = createIterable(props.data);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const hexId = props.getHexagon(object, objectInfo);\n      // Take the resolution of the first hex\n      const hexResolution = h3GetResolution(hexId);\n      if (resolution < 0) {\n        resolution = hexResolution;\n        if (!props.highPrecision) break;\n      } else if (resolution !== hexResolution) {\n        hasMultipleRes = true;\n        break;\n      }\n      if (h3IsPentagon(hexId)) {\n        hasPentagon = true;\n        break;\n      }\n    }\n\n    return {\n      resolution,\n      edgeLengthKM: resolution >= 0 ? edgeLength(resolution, UNITS.km) : 0,\n      hasMultipleRes,\n      hasPentagon\n    };\n  }\n\n  _shouldUseHighPrecision() {\n    if (this.props.highPrecision === 'auto') {\n      const {resolution, hasPentagon, hasMultipleRes} = this.state;\n      const {viewport} = this.context;\n      return (\n        viewport.resolution || hasMultipleRes || hasPentagon || (resolution >= 0 && resolution <= 5)\n      );\n    }\n\n    return this.props.highPrecision;\n  }\n\n  _updateVertices(viewport) {\n    if (this._shouldUseHighPrecision()) {\n      return;\n    }\n    const {resolution, edgeLengthKM, centerHex} = this.state;\n    if (resolution < 0) {\n      return;\n    }\n    const hex =\n      this.props.centerHexagon || geoToH3(viewport.latitude, viewport.longitude, resolution);\n    if (centerHex === hex) {\n      return;\n    }\n    if (centerHex) {\n      const distance = h3Distance(centerHex, hex);\n      // h3Distance returns a negative number if the distance could not be computed\n      // due to the two indexes very far apart or on opposite sides of a pentagon.\n      if (distance >= 0 && distance * edgeLengthKM < UPDATE_THRESHOLD_KM) {\n        return;\n      }\n    }\n\n    const {unitsPerMeter} = viewport.distanceScales;\n\n    let vertices = h3ToPolygon(hex);\n    const [centerLat, centerLng] = h3ToGeo(hex);\n\n    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);\n    vertices = vertices.map(p => {\n      const worldPosition = viewport.projectFlat(p);\n      return [\n        (worldPosition[0] - centerX) / unitsPerMeter[0],\n        (worldPosition[1] - centerY) / unitsPerMeter[1]\n      ];\n    });\n\n    this.setState({centerHex: hex, vertices});\n  }\n\n  renderLayers() {\n    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();\n  }\n\n  _getForwardProps() {\n    const {\n      elevationScale,\n      material,\n      coverage,\n      extruded,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      getFillColor,\n      getElevation,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    return {\n      elevationScale,\n      extruded,\n      coverage,\n      wireframe,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      material,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      transitions,\n      updateTriggers: {\n        getFillColor: updateTriggers.getFillColor,\n        getElevation: updateTriggers.getElevation,\n        getLineColor: updateTriggers.getLineColor,\n        getLineWidth: updateTriggers.getLineWidth\n      }\n    };\n  }\n\n  _renderPolygonLayer() {\n    const {data, getHexagon, updateTriggers, coverage} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell-hifi', PolygonLayer);\n    const forwardProps = this._getForwardProps();\n\n    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell-hifi',\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        _normalize: false,\n        _windingOrder: 'CCW',\n        positionFormat: 'XY',\n        getPolygon: (object, objectInfo) => {\n          const hexagonId = getHexagon(object, objectInfo);\n          return h3ToPolygon(hexagonId, coverage, true);\n        }\n      }\n    );\n  }\n\n  _renderColumnLayer() {\n    const {data, getHexagon, updateTriggers} = this.props;\n\n    const SubLayerClass = this.getSubLayerClass('hexagon-cell', ColumnLayer);\n    const forwardProps = this._getForwardProps();\n    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;\n\n    return new SubLayerClass(\n      forwardProps,\n      this.getSubLayerProps({\n        id: 'hexagon-cell',\n        flatShading: true,\n        updateTriggers: forwardProps.updateTriggers\n      }),\n      {\n        data,\n        diskResolution: 6, // generate an extruded hexagon as the base geometry\n        radius: 1,\n        vertices: this.state.vertices,\n        getPosition: getHexagonCentroid.bind(null, getHexagon)\n      }\n    );\n  }\n}\n\nH3HexagonLayer.defaultProps = defaultProps;\nH3HexagonLayer.layerName = 'H3HexagonLayer';\n"]},"metadata":{},"sourceType":"module"}