{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '@loaders.gl/loader-utils';\nimport { createTypedArrayFromAccessor } from './helpers/tile-3d-accessor-utils';\nimport { initializeHierarchy, traverseHierarchy } from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true,\n  extensions: true,\n  extras: true\n};\nexport default class Tile3DBatchTableParser {\n  constructor(json, binary, featureCount) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    var _this$json;\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"binary\", void 0);\n\n    _defineProperty(this, \"featureCount\", void 0);\n\n    _defineProperty(this, \"_extensions\", void 0);\n\n    _defineProperty(this, \"_properties\", void 0);\n\n    _defineProperty(this, \"_binaryProperties\", void 0);\n\n    _defineProperty(this, \"_hierarchy\", void 0);\n\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n    this._extensions = ((_this$json = this.json) === null || _this$json === void 0 ? void 0 : _this$json.extensions) || {};\n    this._properties = {};\n\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes() {\n    return 0;\n  }\n\n  isClass(batchId, className) {\n    this._checkBatchId(batchId);\n\n    assert(typeof className === 'string', className);\n\n    if (this._hierarchy) {\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n\n        return;\n      }\n    }\n\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n\n    if (!defined(propertyValues)) {\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties = null;\n\n    for (const name in this._properties) {\n      const property = this._properties[name];\n\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      const tile3DAccessor = property;\n      assert(this.binary, \"Property \".concat(name, \" requires a batch table binary.\"));\n      assert(tile3DAccessor.type, \"Property \".concat(name, \" requires a type.\"));\n      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n\n        return clone(propertyValues[indexInClass], true);\n      }\n\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, \"Inherited property \\\"\".concat(name, \"\\\" is read-only.\"));\n\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n    return defined(result);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["assert","createTypedArrayFromAccessor","initializeHierarchy","traverseHierarchy","defined","x","undefined","clone","y","IGNORED_PROPERTY_FIELDS","HIERARCHY","extensions","extras","Tile3DBatchTableParser","constructor","json","binary","featureCount","options","_defineProperty","_extensions","_properties","propertyName","_binaryProperties","_initializeBinaryProperties","_hierarchy","getExtension","extensionName","memorySizeInBytes","isClass","batchId","className","_checkBatchId","result","hierarchy","instanceIndex","classId","classIds","instanceClass","classes","name","isExactClass","getExactClassName","hasProperty","_hasPropertyInHierarchy","getPropertyNames","results","length","propertyNames","Object","keys","push","_getPropertyNamesInHierarchy","getProperty","binaryProperty","_getBinaryProperty","propertyValues","hierarchyProperty","_getHierarchyProperty","setProperty","value","_setBinaryProperty","_setHierarchyProperty","Array","valid","Error","index","unpack","typedArray","pack","binaryProperties","property","_initializeBinaryProperty","tile3DAccessor","type","accessor","buffer","byteOffset","values","componentCount","size","unpacker","packer","instances","hasOwnProperty","indexOf","indexInClass","classIndexes","batchTable"],"sources":["../../../../src/lib/classes/tile-3d-batch-table.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\nimport {createTypedArrayFromAccessor} from './helpers/tile-3d-accessor-utils';\nimport {initializeHierarchy, traverseHierarchy} from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true, // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  json;\n  binary;\n  featureCount;\n  _extensions;\n  // Copy all top-level property fields from the json object, ignoring special fields\n  _properties;\n  _binaryProperties;\n  // TODO: hierarchy support is only partially implemented and not tested\n  _hierarchy;\n\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n\n    this._extensions = this.json?.extensions || {};\n\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes(): number {\n    return 0;\n  }\n\n  isClass(batchId, className: string): boolean {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  // PRIVATE METHODS\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties: Record<string, any> | null = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n\n      const accessor = createTypedArrayFromAccessor(\n        tile3DAccessor,\n        this.binary.buffer,\n        this.binary.byteOffset | 0,\n        this.featureCount\n      );\n\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}