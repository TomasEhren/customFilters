{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\nclass GLTFV1Normalizer {\n  constructor() {\n    _defineProperty(this, \"idToIndexMap\", {\n      animations: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      images: {},\n      materials: {},\n      meshes: {},\n      nodes: {},\n      samplers: {},\n      scenes: {},\n      skins: {},\n      textures: {}\n    });\n\n    _defineProperty(this, \"json\", void 0);\n  }\n\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    switch (json.asset && json.asset.version) {\n      case '2.0':\n        return;\n\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        console.warn(\"glTF: Unknown version \".concat(json.asset.version));\n        return;\n    }\n\n    if (!options.normalize) {\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    this._convertTopLevelObjectsToArrays(json);\n\n    KHR_binary_glTF.preprocess(gltf);\n\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    json[mapName] = [];\n\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id;\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {\n        attributes,\n        indices,\n        material\n      } = primitive;\n\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));\n    }\n\n    if (node.meshes) {\n      node.meshes = node.meshes.map(mesh => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(\"gltf v1: json doesn't contain attribute \".concat(topLevelArrayName));\n      json[topLevelArrayName] = [];\n    }\n\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n\n        const index = this._convertIdToIndex(id, key);\n\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n\n      if (!Number.isFinite(index)) {\n        throw new Error(\"gltf v1: failed to resolve \".concat(key, \" with id \").concat(id));\n      }\n\n      return index;\n    }\n\n    return id;\n  }\n\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      delete buffer.type;\n    }\n  }\n\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex(texture => texture.id === textureId);\n\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {\n          index: textureIndex\n        };\n      }\n    }\n  }\n\n}\n\nexport function normalizeGLTFV1(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}","map":{"version":3,"mappings":"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","names":["KHR_binary_glTF","GLTF_ARRAYS","accessors","animations","buffers","bufferViews","images","materials","meshes","nodes","samplers","scenes","skins","textures","GLTF_KEYS","accessor","buffer","bufferView","image","material","mesh","node","sampler","scene","skin","texture","GLTFV1Normalizer","constructor","_defineProperty","normalize","gltf","options","json","asset","version","undefined","console","warn","Error","_addAsset","_convertTopLevelObjectsToArrays","preprocess","_convertObjectIdsToArrayIndices","_updateObjects","_updateMaterial","generator","arrayName","_convertTopLevelObjectToArray","mapName","objectMap","Array","isArray","id","object","index","length","push","idToIndexMap","_convertIdsToIndices","_convertIdToIndex","_convertTextureIds","_convertMeshIds","_convertNodeIds","_convertSceneIds","source","primitive","primitives","attributes","indices","attributeName","children","map","child","topLevelArrayName","key","Number","isFinite","type","pbrMetallicRoughness","baseColorFactor","metallicFactor","roughnessFactor","textureId","values","tex","textureIndex","findIndex","baseColorTexture","normalizeGLTFV1"],"sources":["../../../../src/lib/api/normalize-gltf-v1.ts"],"sourcesContent":["/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n\n  json;\n\n  // constructor() {}\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId = material.values && material.values.tex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}