{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { getDefaultCredentials, buildMapsUrlFromBase } from '../config';\nimport { API_VERSIONS, COLUMNS_SUPPORT, encodeParameter, FORMATS, GEO_COLUMN_SUPPORT, MAP_TYPES, TILE_FORMATS } from './maps-api-common';\nimport { parseMap } from './parseMap';\nimport { log } from '@deck.gl/core';\nimport { assert } from '../utils';\nvar MAX_GET_LENGTH = 2048;\nvar DEFAULT_CLIENT = 'deck-gl-carto';\n\nfunction request(_x) {\n  return _request.apply(this, arguments);\n}\n\nfunction _request() {\n  _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var method, url, accessToken, body, headers;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            method = _ref.method, url = _ref.url, accessToken = _ref.accessToken, body = _ref.body;\n            headers = {\n              Accept: 'application/json'\n            };\n\n            if (accessToken) {\n              headers.Authorization = \"Bearer \".concat(accessToken);\n            }\n\n            if (method === 'POST') {\n              headers['Content-Type'] = 'application/json';\n            }\n\n            _context.prev = 4;\n            _context.next = 7;\n            return fetch(url, {\n              method: method,\n              headers: headers,\n              body: body\n            });\n\n          case 7:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](4);\n            throw new Error(\"Failed to connect to Maps API: \".concat(_context.t0));\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 10]]);\n  }));\n  return _request.apply(this, arguments);\n}\n\nfunction requestJson(_x2) {\n  return _requestJson.apply(this, arguments);\n}\n\nfunction _requestJson() {\n  _requestJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var method, url, accessToken, body, response, json;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            method = _ref2.method, url = _ref2.url, accessToken = _ref2.accessToken, body = _ref2.body;\n            _context2.next = 3;\n            return request({\n              method: method,\n              url: url,\n              accessToken: accessToken,\n              body: body\n            });\n\n          case 3:\n            response = _context2.sent;\n            _context2.next = 6;\n            return response.json();\n\n          case 6:\n            json = _context2.sent;\n\n            if (!response.ok) {\n              dealWithError({\n                response: response,\n                error: json.error\n              });\n            }\n\n            return _context2.abrupt(\"return\", json);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _requestJson.apply(this, arguments);\n}\n\nfunction requestData(_x3) {\n  return _requestData.apply(this, arguments);\n}\n\nfunction _requestData() {\n  _requestData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n    var method, url, accessToken, format, body, data;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            method = _ref3.method, url = _ref3.url, accessToken = _ref3.accessToken, format = _ref3.format, body = _ref3.body;\n\n            if (!(format === FORMATS.NDJSON)) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", request({\n              method: method,\n              url: url,\n              accessToken: accessToken,\n              body: body\n            }));\n\n          case 3:\n            _context3.next = 5;\n            return requestJson({\n              method: method,\n              url: url,\n              accessToken: accessToken,\n              body: body\n            });\n\n          case 5:\n            data = _context3.sent;\n            return _context3.abrupt(\"return\", data.rows ? data.rows : data);\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _requestData.apply(this, arguments);\n}\n\nfunction dealWithError(_ref4) {\n  var response = _ref4.response,\n      error = _ref4.error;\n\n  switch (response.status) {\n    case 400:\n      throw new Error(\"Bad request. \".concat(error));\n\n    case 401:\n    case 403:\n      throw new Error(\"Unauthorized access. \".concat(error));\n\n    default:\n      throw new Error(error);\n  }\n}\n\nfunction getParameters(_ref5) {\n  var type = _ref5.type,\n      source = _ref5.source,\n      geoColumn = _ref5.geoColumn,\n      columns = _ref5.columns,\n      schema = _ref5.schema,\n      clientId = _ref5.clientId;\n  var parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  var sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (GEO_COLUMN_SUPPORT.includes(type) && geoColumn) {\n    parameters.push(encodeParameter('geo_column', geoColumn));\n  }\n\n  if (COLUMNS_SUPPORT.includes(type) && columns) {\n    parameters.push(encodeParameter('columns', columns.join(',')));\n  }\n\n  return parameters.join('&');\n}\n\nexport function mapInstantiation(_x4) {\n  return _mapInstantiation.apply(this, arguments);\n}\n\nfunction _mapInstantiation() {\n  _mapInstantiation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref6) {\n    var type, source, connection, credentials, geoColumn, columns, schema, clientId, baseUrl, url, accessToken, body;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            type = _ref6.type, source = _ref6.source, connection = _ref6.connection, credentials = _ref6.credentials, geoColumn = _ref6.geoColumn, columns = _ref6.columns, schema = _ref6.schema, clientId = _ref6.clientId;\n            baseUrl = \"\".concat(credentials.mapsUrl, \"/\").concat(connection, \"/\").concat(type);\n            url = \"\".concat(baseUrl, \"?\").concat(getParameters({\n              type: type,\n              source: source,\n              geoColumn: geoColumn,\n              columns: columns,\n              schema: schema,\n              clientId: clientId\n            }));\n            accessToken = credentials.accessToken;\n\n            if (!(url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY)) {\n              _context4.next = 9;\n              break;\n            }\n\n            body = JSON.stringify({\n              q: source,\n              client: clientId || DEFAULT_CLIENT\n            });\n            _context4.next = 8;\n            return requestJson({\n              method: 'POST',\n              url: baseUrl,\n              accessToken: accessToken,\n              body: body\n            });\n\n          case 8:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 9:\n            _context4.next = 11;\n            return requestJson({\n              url: url,\n              accessToken: accessToken\n            });\n\n          case 11:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _mapInstantiation.apply(this, arguments);\n}\n\nfunction getUrlFromMetadata(metadata, format) {\n  var m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters(_ref7) {\n  var type = _ref7.type,\n      source = _ref7.source,\n      connection = _ref7.connection,\n      credentials = _ref7.credentials;\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport function fetchLayerData(_x5) {\n  return _fetchLayerData.apply(this, arguments);\n}\n\nfunction _fetchLayerData() {\n  _fetchLayerData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref8) {\n    var type, source, connection, credentials, geoColumn, columns, format, formatTiles, schema, clientId, _yield$_fetchDataUrl, url, accessToken, mapFormat, metadata, data, result;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            type = _ref8.type, source = _ref8.source, connection = _ref8.connection, credentials = _ref8.credentials, geoColumn = _ref8.geoColumn, columns = _ref8.columns, format = _ref8.format, formatTiles = _ref8.formatTiles, schema = _ref8.schema, clientId = _ref8.clientId;\n            _context5.next = 3;\n            return _fetchDataUrl({\n              type: type,\n              source: source,\n              connection: connection,\n              credentials: credentials,\n              geoColumn: geoColumn,\n              columns: columns,\n              format: format,\n              formatTiles: formatTiles,\n              schema: schema,\n              clientId: clientId\n            });\n\n          case 3:\n            _yield$_fetchDataUrl = _context5.sent;\n            url = _yield$_fetchDataUrl.url;\n            accessToken = _yield$_fetchDataUrl.accessToken;\n            mapFormat = _yield$_fetchDataUrl.mapFormat;\n            metadata = _yield$_fetchDataUrl.metadata;\n            _context5.next = 10;\n            return requestData({\n              url: url,\n              format: mapFormat,\n              accessToken: accessToken\n            });\n\n          case 10:\n            data = _context5.sent;\n            result = {\n              data: data,\n              format: mapFormat\n            };\n\n            if (schema) {\n              result.schema = metadata.schema;\n            }\n\n            return _context5.abrupt(\"return\", result);\n\n          case 14:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _fetchLayerData.apply(this, arguments);\n}\n\nfunction _fetchDataUrl(_x6) {\n  return _fetchDataUrl2.apply(this, arguments);\n}\n\nfunction _fetchDataUrl2() {\n  _fetchDataUrl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref9) {\n    var type, source, connection, credentials, geoColumn, columns, format, formatTiles, schema, clientId, defaultCredentials, localCreds, metadata, url, mapFormat, prioritizedFormats, _i, _prioritizedFormats, f, accessToken;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            type = _ref9.type, source = _ref9.source, connection = _ref9.connection, credentials = _ref9.credentials, geoColumn = _ref9.geoColumn, columns = _ref9.columns, format = _ref9.format, formatTiles = _ref9.formatTiles, schema = _ref9.schema, clientId = _ref9.clientId;\n            defaultCredentials = getDefaultCredentials();\n            localCreds = _objectSpread(_objectSpread({}, defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials), credentials);\n            checkFetchLayerDataParameters({\n              type: type,\n              source: source,\n              connection: connection,\n              credentials: localCreds\n            });\n\n            if (!localCreds.mapsUrl) {\n              localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n            }\n\n            _context6.next = 7;\n            return mapInstantiation({\n              type: type,\n              source: source,\n              connection: connection,\n              credentials: localCreds,\n              geoColumn: geoColumn,\n              columns: columns,\n              schema: schema,\n              clientId: clientId\n            });\n\n          case 7:\n            metadata = _context6.sent;\n            url = null;\n\n            if (!format) {\n              _context6.next = 15;\n              break;\n            }\n\n            mapFormat = format;\n            url = getUrlFromMetadata(metadata, format);\n            assert(url, \"Format \".concat(format, \" not available\"));\n            _context6.next = 27;\n            break;\n\n          case 15:\n            prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n            _i = 0, _prioritizedFormats = prioritizedFormats;\n\n          case 17:\n            if (!(_i < _prioritizedFormats.length)) {\n              _context6.next = 26;\n              break;\n            }\n\n            f = _prioritizedFormats[_i];\n            url = getUrlFromMetadata(metadata, f);\n\n            if (!url) {\n              _context6.next = 23;\n              break;\n            }\n\n            mapFormat = f;\n            return _context6.abrupt(\"break\", 26);\n\n          case 23:\n            _i++;\n            _context6.next = 17;\n            break;\n\n          case 26:\n            assert(url && mapFormat, 'Unsupported data formats received from backend.');\n\n          case 27:\n            if (format === FORMATS.TILEJSON && formatTiles) {\n              log.assert(Object.values(TILE_FORMATS).includes(formatTiles), \"Invalid value for formatTiles: \".concat(formatTiles, \". Use value from TILE_FORMATS\"));\n              url += \"&\".concat(encodeParameter('formatTiles', formatTiles));\n            }\n\n            accessToken = localCreds.accessToken;\n            return _context6.abrupt(\"return\", {\n              url: url,\n              accessToken: accessToken,\n              mapFormat: mapFormat,\n              metadata: metadata\n            });\n\n          case 30:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _fetchDataUrl2.apply(this, arguments);\n}\n\nexport function getData(_x7) {\n  return _getData.apply(this, arguments);\n}\n\nfunction _getData() {\n  _getData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref10) {\n    var type, source, connection, credentials, geoColumn, columns, format, clientId, layerData;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            type = _ref10.type, source = _ref10.source, connection = _ref10.connection, credentials = _ref10.credentials, geoColumn = _ref10.geoColumn, columns = _ref10.columns, format = _ref10.format, clientId = _ref10.clientId;\n            log.deprecated('getData', 'fetchLayerData')();\n            _context7.next = 4;\n            return fetchLayerData({\n              type: type,\n              source: source,\n              connection: connection,\n              credentials: credentials,\n              geoColumn: geoColumn,\n              columns: columns,\n              format: format,\n              schema: false,\n              clientId: clientId\n            });\n\n          case 4:\n            layerData = _context7.sent;\n            return _context7.abrupt(\"return\", layerData.data);\n\n          case 6:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _getData.apply(this, arguments);\n}\n\nfunction _fetchMapDataset(_x8, _x9, _x10, _x11) {\n  return _fetchMapDataset2.apply(this, arguments);\n}\n\nfunction _fetchMapDataset2() {\n  _fetchMapDataset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(dataset, accessToken, credentials, clientId) {\n    var connection, columns, format, geoColumn, source, type, _yield$_fetchDataUrl2, url, mapFormat, cache;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            connection = dataset.connectionName, columns = dataset.columns, format = dataset.format, geoColumn = dataset.geoColumn, source = dataset.source, type = dataset.type;\n            _context8.next = 3;\n            return _fetchDataUrl({\n              clientId: clientId,\n              credentials: _objectSpread(_objectSpread({}, credentials), {}, {\n                accessToken: accessToken\n              }),\n              connection: connection,\n              columns: columns,\n              format: format,\n              geoColumn: geoColumn,\n              source: source,\n              type: type\n            });\n\n          case 3:\n            _yield$_fetchDataUrl2 = _context8.sent;\n            url = _yield$_fetchDataUrl2.url;\n            mapFormat = _yield$_fetchDataUrl2.mapFormat;\n            cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n\n            if (!(cache && dataset.cache === cache)) {\n              _context8.next = 9;\n              break;\n            }\n\n            return _context8.abrupt(\"return\", false);\n\n          case 9:\n            dataset.cache = cache;\n            _context8.next = 12;\n            return requestData({\n              url: url,\n              format: mapFormat,\n              accessToken: accessToken\n            });\n\n          case 12:\n            dataset.data = _context8.sent;\n            return _context8.abrupt(\"return\", true);\n\n          case 14:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return _fetchMapDataset2.apply(this, arguments);\n}\n\nfunction fillInMapDatasets(_x12, _x13, _x14) {\n  return _fillInMapDatasets.apply(this, arguments);\n}\n\nfunction _fillInMapDatasets() {\n  _fillInMapDatasets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(_ref11, clientId, credentials) {\n    var datasets, token, promises;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            datasets = _ref11.datasets, token = _ref11.token;\n            promises = datasets.map(function (dataset) {\n              return _fetchMapDataset(dataset, token, credentials, clientId);\n            });\n            _context9.next = 4;\n            return Promise.all(promises);\n\n          case 4:\n            return _context9.abrupt(\"return\", _context9.sent);\n\n          case 5:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return _fillInMapDatasets.apply(this, arguments);\n}\n\nexport function fetchMap(_x15) {\n  return _fetchMap.apply(this, arguments);\n}\n\nfunction _fetchMap() {\n  _fetchMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(_ref12) {\n    var cartoMapId, clientId, credentials, autoRefresh, onNewData, defaultCredentials, localCreds, accessToken, url, map, stopAutoRefresh, intervalId, geojsonLayers, geojsonDatasetIds;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            cartoMapId = _ref12.cartoMapId, clientId = _ref12.clientId, credentials = _ref12.credentials, autoRefresh = _ref12.autoRefresh, onNewData = _ref12.onNewData;\n            defaultCredentials = getDefaultCredentials();\n            localCreds = _objectSpread(_objectSpread({}, defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials), credentials);\n            accessToken = localCreds.accessToken;\n            assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n            assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n            assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n\n            if (!localCreds.mapsUrl) {\n              localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n            }\n\n            if (autoRefresh || onNewData) {\n              assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n              assert(typeof onNewData === 'function', '`onNewData` must be a function');\n              assert(typeof autoRefresh === 'number' && autoRefresh > 0, '`autoRefresh` must be a positive number');\n            }\n\n            url = \"\".concat(localCreds.mapsUrl, \"/public/\").concat(cartoMapId);\n            _context11.next = 12;\n            return requestJson({\n              url: url,\n              accessToken: accessToken\n            });\n\n          case 12:\n            map = _context11.sent;\n\n            if (autoRefresh) {\n              intervalId = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n                var changed;\n                return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n                  while (1) {\n                    switch (_context10.prev = _context10.next) {\n                      case 0:\n                        _context10.next = 2;\n                        return fillInMapDatasets(map, clientId, localCreds);\n\n                      case 2:\n                        changed = _context10.sent;\n\n                        if (onNewData && changed.some(function (v) {\n                          return v === true;\n                        })) {\n                          onNewData(parseMap(map));\n                        }\n\n                      case 4:\n                      case \"end\":\n                        return _context10.stop();\n                    }\n                  }\n                }, _callee10);\n              })), autoRefresh * 1000);\n\n              stopAutoRefresh = function stopAutoRefresh() {\n                clearInterval(intervalId);\n              };\n            }\n\n            geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(function (_ref14) {\n              var type = _ref14.type;\n              return type === 'geojson' || type === 'point';\n            });\n            geojsonDatasetIds = geojsonLayers.map(function (_ref15) {\n              var config = _ref15.config;\n              return config.dataId;\n            });\n            map.datasets.forEach(function (dataset) {\n              if (geojsonDatasetIds.includes(dataset.id)) {\n                dataset.format = 'geojson';\n              }\n            });\n            _context11.next = 19;\n            return fillInMapDatasets(map, clientId, localCreds);\n\n          case 19:\n            return _context11.abrupt(\"return\", _objectSpread(_objectSpread({}, parseMap(map)), {\n              stopAutoRefresh: stopAutoRefresh\n            }));\n\n          case 20:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _fetchMap.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["getDefaultCredentials","buildMapsUrlFromBase","API_VERSIONS","COLUMNS_SUPPORT","encodeParameter","FORMATS","GEO_COLUMN_SUPPORT","MAP_TYPES","TILE_FORMATS","parseMap","log","assert","MAX_GET_LENGTH","DEFAULT_CLIENT","request","method","url","accessToken","body","headers","Accept","Authorization","fetch","Error","requestJson","response","json","ok","dealWithError","error","requestData","format","NDJSON","data","rows","status","getParameters","type","source","geoColumn","columns","schema","clientId","parameters","push","sourceName","QUERY","includes","join","mapInstantiation","connection","credentials","baseUrl","mapsUrl","length","JSON","stringify","q","client","getUrlFromMetadata","metadata","m","checkFetchLayerDataParameters","apiVersion","V3","apiBaseUrl","fetchLayerData","formatTiles","_fetchDataUrl","mapFormat","result","defaultCredentials","localCreds","prioritizedFormats","GEOJSON","TILEJSON","f","Object","values","getData","deprecated","layerData","_fetchMapDataset","dataset","connectionName","cache","parseInt","URL","searchParams","get","fillInMapDatasets","datasets","token","promises","map","Promise","all","fetchMap","cartoMapId","autoRefresh","onNewData","intervalId","setInterval","changed","some","v","stopAutoRefresh","clearInterval","geojsonLayers","keplerMapConfig","config","visState","layers","filter","geojsonDatasetIds","dataId","forEach","id"],"sources":["../../../src/api/maps-v3-client.ts"],"sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {getDefaultCredentials, buildMapsUrlFromBase, CloudNativeCredentials} from '../config';\nimport {\n  API_VERSIONS,\n  COLUMNS_SUPPORT,\n  encodeParameter,\n  Format,\n  FORMATS,\n  GEO_COLUMN_SUPPORT,\n  MapInstantiation,\n  MapType,\n  MAP_TYPES,\n  SchemaField,\n  TileFormat,\n  TILE_FORMATS\n} from './maps-api-common';\nimport {parseMap} from './parseMap';\nimport {log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nconst MAX_GET_LENGTH = 2048;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\n\ninterface RequestParams {\n  method?: string;\n  url: string;\n  accessToken?: string;\n  body?: any;\n}\n\n/**\n * Request against Maps API\n */\nasync function request({method, url, accessToken, body}: RequestParams): Promise<Response> {\n  const headers: Record<string, string> = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(`Failed to connect to Maps API: ${error}`);\n  }\n}\n\nasync function requestJson<T = unknown>({\n  method,\n  url,\n  accessToken,\n  body\n}: RequestParams): Promise<T> {\n  const response = await request({method, url, accessToken, body});\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({response, error: json.error});\n  }\n  return json as T;\n}\n\nasync function requestData({\n  method,\n  url,\n  accessToken,\n  format,\n  body\n}: RequestParams & {\n  format: Format;\n}): Promise<Response | unknown> {\n  if (format === FORMATS.NDJSON) {\n    return request({method, url, accessToken, body});\n  }\n\n  const data = await requestJson<any>({method, url, accessToken, body});\n  return data.rows ? data.rows : data;\n}\n\n/**\n * Display proper message from Maps API error\n */\nfunction dealWithError({response, error}: {response: Response; error?: string}): never {\n  switch (response.status) {\n    case 400:\n      throw new Error(`Bad request. ${error}`);\n    case 401:\n    case 403:\n      throw new Error(`Unauthorized access. ${error}`);\n    default:\n      throw new Error(error);\n  }\n}\n\ntype FetchLayerDataParams = {\n  type: MapType;\n  source: string;\n  connection: string;\n  credentials: CloudNativeCredentials;\n  geoColumn?: string;\n  columns?: string[];\n  schema?: boolean;\n  clientId?: string;\n  format?: Format;\n  formatTiles?: TileFormat;\n};\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({\n  type,\n  source,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: Omit<FetchLayerDataParams, 'connection' | 'credentials'>) {\n  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (GEO_COLUMN_SUPPORT.includes(type) && geoColumn) {\n    parameters.push(encodeParameter('geo_column', geoColumn));\n  }\n  if (COLUMNS_SUPPORT.includes(type) && columns) {\n    parameters.push(encodeParameter('columns', columns.join(',')));\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<MapInstantiation> {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const url = `${baseUrl}?${getParameters({type, source, geoColumn, columns, schema, clientId})}`;\n  const {accessToken} = credentials;\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    // need to be a POST request\n    const body = JSON.stringify({\n      q: source,\n      client: clientId || DEFAULT_CLIENT\n    });\n    return await requestJson({method: 'POST', url: baseUrl, accessToken, body});\n  }\n\n  return await requestJson({url, accessToken});\n}\n\nfunction getUrlFromMetadata(metadata: MapInstantiation, format: Format): string | null {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters({\n  type,\n  source,\n  connection,\n  credentials\n}: FetchLayerDataParams) {\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport interface FetchLayerDataResult {\n  data: any;\n  format: Format;\n  schema?: SchemaField[];\n}\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<FetchLayerDataResult> {\n  // Internally we split data fetching into two parts to allow us to\n  // conditionally fetch the actual data, depending on the metadata state\n  const {url, accessToken, mapFormat, metadata} = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  });\n\n  const data = await requestData({url, format: mapFormat, accessToken});\n  const result: FetchLayerDataResult = {data, format: mapFormat};\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nasync function _fetchDataUrl({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({type, source, connection, credentials: localCreds});\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  });\n  let url: string | null = null;\n  let mapFormat: Format | undefined;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(\n      Object.values(TILE_FORMATS).includes(formatTiles),\n      `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n    );\n    url += `&${encodeParameter('formatTiles', formatTiles)}`;\n  }\n\n  const {accessToken} = localCreds;\n  return {url, accessToken, mapFormat, metadata};\n}\n\nexport async function getData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  clientId\n}: FetchLayerDataParams) {\n  log.deprecated('getData', 'fetchLayerData')();\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false,\n    clientId\n  });\n  return layerData.data;\n}\n\n/* global clearInterval, setInterval, URL */\nasync function _fetchMapDataset(\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials,\n  clientId?: string\n) {\n  const {connectionName: connection, columns, format, geoColumn, source, type} = dataset;\n  // First fetch metadata\n  const {url, mapFormat} = await _fetchDataUrl({\n    clientId,\n    credentials: {...credentials, accessToken},\n    connection,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type\n  });\n\n  // Extract the last time the data changed\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n  dataset.cache = cache;\n\n  // Only fetch if the data has changed\n  dataset.data = await requestData({url, format: mapFormat, accessToken});\n\n  return true;\n}\n\nasync function fillInMapDatasets(\n  {datasets, token},\n  clientId: string,\n  credentials: CloudNativeCredentials\n) {\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId));\n  return await Promise.all(promises);\n}\n\nexport async function fetchMap({\n  cartoMapId,\n  clientId,\n  credentials,\n  autoRefresh,\n  onNewData\n}: {\n  cartoMapId: string;\n  clientId: string;\n  credentials?: CloudNativeCredentials;\n  autoRefresh?: number;\n  onNewData?: (map: any) => void;\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  } as CloudNativeCredentials;\n  const {accessToken} = localCreds;\n\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const url = `${localCreds.mapsUrl}/public/${cartoMapId}`;\n  const map = await requestJson<any>({url, accessToken});\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds);\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(\n    ({type}) => type === 'geojson' || type === 'point'\n  );\n  const geojsonDatasetIds = geojsonLayers.map(({config}) => config.dataId);\n  map.datasets.forEach(dataset => {\n    if (geojsonDatasetIds.includes(dataset.id)) {\n      dataset.format = 'geojson';\n    }\n  });\n\n  // Mutates map.datasets so that dataset.data contains data\n  await fillInMapDatasets(map, clientId, localCreds);\n  return {\n    ...parseMap(map),\n    ...{stopAutoRefresh}\n  };\n}\n"]},"metadata":{},"sourceType":"module"}