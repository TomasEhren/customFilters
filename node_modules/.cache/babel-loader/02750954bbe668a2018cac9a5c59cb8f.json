{"ast":null,"code":"import { Buffer, Transform, Framebuffer, Texture2D, readPixelsToArray } from '@luma.gl/core';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Attribute from '../lib/attribute/attribute';\nimport Transition from './transition';\nexport default class GPUSpringTransition {\n  constructor(_ref) {\n    let {\n      gl,\n      attribute,\n      timeline\n    } = _ref;\n    this.gl = gl;\n    this.type = 'spring';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, { ...attribute.settings,\n      normalized: false\n    });\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.texture = getTexture(gl);\n    this.framebuffer = getFramebuffer(gl, this.texture);\n    this.transform = getTransform(gl, attribute, this.framebuffer);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  start(transitionSettings, numInstances) {\n    const {\n      gl,\n      buffers,\n      attribute\n    } = this;\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({\n        buffer,\n        ...padBufferOpts\n      });\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      value: attribute.value\n    });\n    this.transition.start(transitionSettings);\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aTo: getSourceBufferAttribute(gl, attribute)\n      }\n    });\n  }\n\n  update() {\n    const {\n      buffers,\n      transform,\n      framebuffer,\n      transition\n    } = this;\n    const updated = transition.update();\n\n    if (!updated) {\n      return false;\n    }\n\n    transform.update({\n      sourceBuffers: {\n        aPrev: buffers[0],\n        aCur: buffers[1]\n      },\n      feedbackBuffers: {\n        vNext: buffers[2]\n      }\n    });\n    transform.run({\n      framebuffer,\n      discard: false,\n      clearRenderTarget: true,\n      uniforms: {\n        stiffness: transition.settings.stiffness,\n        damping: transition.settings.damping\n      },\n      parameters: {\n        depthTest: false,\n        blend: true,\n        viewport: [0, 0, 1, 1],\n        blendFunc: [1, 1],\n        blendEquation: [32776, 32776]\n      }\n    });\n    cycleBuffers(buffers);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      value: this.attribute.value\n    });\n    const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;\n\n    if (!isTransitioning) {\n      transition.end();\n    }\n\n    return true;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n\n    this.texture.delete();\n    this.texture = null;\n    this.framebuffer.delete();\n    this.framebuffer = null;\n  }\n\n}\n\nfunction getTransform(gl, attribute, framebuffer) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    framebuffer,\n    vs: \"\\n#define SHADER_NAME spring-transition-vertex-shader\\n\\n#define EPSILON 0.00001\\n\\nuniform float stiffness;\\nuniform float damping;\\nattribute ATTRIBUTE_TYPE aPrev;\\nattribute ATTRIBUTE_TYPE aCur;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vNext;\\nvarying float vIsTransitioningFlag;\\n\\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\\n  ATTRIBUTE_TYPE velocity = cur - prev;\\n  ATTRIBUTE_TYPE delta = dest - cur;\\n  ATTRIBUTE_TYPE spring = delta * stiffness;\\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\\n  return spring + damper + velocity + cur;\\n}\\n\\nvoid main(void) {\\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\\n\\n  vNext = getNextValue(aCur, aPrev, aTo);\\n  gl_Position = vec4(0, 0, 0, 1);\\n  gl_PointSize = 100.0;\\n}\\n\",\n    fs: \"\\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\\n\\nvarying float vIsTransitioningFlag;\\n\\nvoid main(void) {\\n  if (vIsTransitioningFlag == 0.0) {\\n    discard;\\n  }\\n  gl_FragColor = vec4(1.0);\\n}\",\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vNext']\n  });\n}\n\nfunction getTexture(gl) {\n  return new Texture2D(gl, {\n    data: new Uint8Array(4),\n    format: 6408,\n    type: 5121,\n    border: 0,\n    mipmaps: false,\n    dataFormat: 6408,\n    width: 1,\n    height: 1\n  });\n}\n\nfunction getFramebuffer(gl, texture) {\n  return new Framebuffer(gl, {\n    id: 'spring-transition-is-transitioning-framebuffer',\n    width: 1,\n    height: 1,\n    attachments: {\n      [36064]: texture\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["Buffer","Transform","Framebuffer","Texture2D","readPixelsToArray","padBuffer","getAttributeTypeFromSize","getSourceBufferAttribute","getAttributeBufferLength","cycleBuffers","Attribute","Transition","GPUSpringTransition","constructor","gl","attribute","timeline","type","transition","attributeInTransition","settings","normalized","currentStartIndices","startIndices","currentLength","texture","getTexture","framebuffer","getFramebuffer","transform","getTransform","bufferOpts","byteLength","usage","buffers","inProgress","start","transitionSettings","numInstances","padBufferOpts","fromLength","fromStartIndices","getData","enter","buffer","update","value","elementCount","Math","floor","size","sourceBuffers","aTo","updated","aPrev","aCur","feedbackBuffers","vNext","run","discard","clearRenderTarget","uniforms","stiffness","damping","parameters","depthTest","blend","viewport","blendFunc","blendEquation","isTransitioning","end","cancel","delete","length","pop","attributeType","vs","fs","defines","ATTRIBUTE_TYPE","varyings","data","Uint8Array","format","border","mipmaps","dataFormat","width","height","id","attachments"],"sources":["../../../src/transitions/gpu-spring-transition.js"],"sourcesContent":["/* eslint-disable complexity, max-statements, max-params */\nimport GL from '@luma.gl/constants';\nimport {Buffer, Transform, Framebuffer, Texture2D, readPixelsToArray} from '@luma.gl/core';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers\n} from '../lib/attribute/attribute-transition-utils';\nimport Attribute from '../lib/attribute/attribute';\nimport Transition from './transition';\n\nexport default class GPUSpringTransition {\n  constructor({gl, attribute, timeline}) {\n    this.gl = gl;\n    this.type = 'spring';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, {...attribute.settings, normalized: false});\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.texture = getTexture(gl);\n    this.framebuffer = getFramebuffer(gl, this.texture);\n    this.transform = getTransform(gl, attribute, this.framebuffer);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // previous\n      new Buffer(gl, bufferOpts), // current\n      new Buffer(gl, bufferOpts) // next\n    ];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings, numInstances) {\n    const {gl, buffers, attribute} = this;\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value\n    });\n\n    // when an attribute changes values, a new transition is started. These\n    // are properties that we have to store on this.transition but can change\n    // when new transitions are started, so we have to keep them up-to-date.\n    // this.transition.start() takes the latest settings and updates them.\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aTo: getSourceBufferAttribute(gl, attribute)\n      }\n    });\n  }\n\n  update() {\n    const {buffers, transform, framebuffer, transition} = this;\n    const updated = transition.update();\n    if (!updated) {\n      return false;\n    }\n\n    transform.update({\n      sourceBuffers: {\n        aPrev: buffers[0],\n        aCur: buffers[1]\n      },\n      feedbackBuffers: {\n        vNext: buffers[2]\n      }\n    });\n    transform.run({\n      framebuffer,\n      discard: false,\n      clearRenderTarget: true,\n      uniforms: {\n        stiffness: transition.settings.stiffness,\n        damping: transition.settings.damping\n      },\n      parameters: {\n        depthTest: false,\n        blend: true,\n        viewport: [0, 0, 1, 1],\n        blendFunc: [GL.ONE, GL.ONE],\n        blendEquation: [GL.MAX, GL.MAX]\n      }\n    });\n\n    cycleBuffers(buffers);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: this.attribute.value\n    });\n\n    const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;\n\n    if (!isTransitioning) {\n      transition.end();\n    }\n\n    return true;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n    this.texture.delete();\n    this.texture = null;\n    this.framebuffer.delete();\n    this.framebuffer = null;\n  }\n}\n\nfunction getTransform(gl, attribute, framebuffer) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    framebuffer,\n    vs: `\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n`,\n    fs: `\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}`,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vNext']\n  });\n}\n\nfunction getTexture(gl) {\n  return new Texture2D(gl, {\n    data: new Uint8Array(4),\n    format: GL.RGBA,\n    type: GL.UNSIGNED_BYTE,\n    border: 0,\n    mipmaps: false,\n    dataFormat: GL.RGBA,\n    width: 1,\n    height: 1\n  });\n}\n\nfunction getFramebuffer(gl, texture) {\n  return new Framebuffer(gl, {\n    id: 'spring-transition-is-transitioning-framebuffer',\n    width: 1,\n    height: 1,\n    attachments: {\n      [GL.COLOR_ATTACHMENT0]: texture\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}