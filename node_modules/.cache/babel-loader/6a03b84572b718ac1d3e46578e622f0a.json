{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { LayerExtension, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { dashShaders, offsetShaders } from './shaders.glsl';\nimport { dist } from 'gl-matrix/vec3';\nvar defaultProps = {\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getOffset: {\n    type: 'accessor',\n    value: 0\n  },\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nvar PathStyleExtension = /*#__PURE__*/function (_LayerExtension) {\n  _inherits(PathStyleExtension, _LayerExtension);\n\n  var _super = _createSuper(PathStyleExtension);\n\n  function PathStyleExtension() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$dash = _ref.dash,\n        dash = _ref$dash === void 0 ? false : _ref$dash,\n        _ref$offset = _ref.offset,\n        offset = _ref$offset === void 0 ? false : _ref$offset,\n        _ref$highPrecisionDas = _ref.highPrecisionDash,\n        highPrecisionDash = _ref$highPrecisionDas === void 0 ? false : _ref$highPrecisionDas;\n\n    _classCallCheck(this, PathStyleExtension);\n\n    return _super.call(this, {\n      dash: dash || highPrecisionDash,\n      offset: offset,\n      highPrecisionDash: highPrecisionDash\n    });\n  }\n\n  _createClass(PathStyleExtension, [{\n    key: \"isEnabled\",\n    value: function isEnabled(layer) {\n      return layer.state.pathTesselator;\n    }\n  }, {\n    key: \"getShaders\",\n    value: function getShaders(extension) {\n      if (!extension.isEnabled(this)) {\n        return null;\n      }\n\n      var result = {};\n\n      if (extension.opts.dash) {\n        result = mergeShaders(result, dashShaders);\n      }\n\n      if (extension.opts.offset) {\n        result = mergeShaders(result, offsetShaders);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState(context, extension) {\n      var attributeManager = this.getAttributeManager();\n\n      if (!attributeManager || !extension.isEnabled(this)) {\n        return;\n      }\n\n      extension.enabled = true;\n\n      if (extension.opts.dash) {\n        attributeManager.addInstanced({\n          instanceDashArrays: {\n            size: 2,\n            accessor: 'getDashArray'\n          }\n        });\n      }\n\n      if (extension.opts.highPrecisionDash) {\n        attributeManager.addInstanced({\n          instanceDashOffsets: {\n            size: 1,\n            accessor: 'getPath',\n            transform: extension.getDashOffsets.bind(this)\n          }\n        });\n      }\n\n      if (extension.opts.offset) {\n        attributeManager.addInstanced({\n          instanceOffsets: {\n            size: 1,\n            accessor: 'getOffset'\n          }\n        });\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(params, extension) {\n      if (!extension.isEnabled(this)) {\n        return;\n      }\n\n      var uniforms = {};\n\n      if (extension.opts.dash) {\n        uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n        uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n      }\n\n      this.state.model.setUniforms(uniforms);\n    }\n  }, {\n    key: \"getDashOffsets\",\n    value: function getDashOffsets(path) {\n      var result = [0];\n      var positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n      var isNested = Array.isArray(path[0]);\n      var geometrySize = isNested ? path.length : path.length / positionSize;\n      var p;\n      var prevP;\n\n      for (var i = 0; i < geometrySize - 1; i++) {\n        p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n        p = this.projectPosition(p);\n\n        if (i > 0) {\n          result[i] = result[i - 1] + dist(prevP, p);\n        }\n\n        prevP = p;\n      }\n\n      return result;\n    }\n  }]);\n\n  return PathStyleExtension;\n}(LayerExtension);\n\nexport { PathStyleExtension as default };\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;","map":{"version":3,"mappings":";;;;AAoBA,SAAQA,cAAR,EAAwBC,aAAa,IAAIC,YAAzC,QAA4D,eAA5D;AACA,SAAQC,WAAR,EAAqBC,aAArB,QAAyC,gBAAzC;AACA,SAAQC,IAAR,QAAmB,gBAAnB;AAEA,IAAMC,YAAY,GAAG;EACnBC,YAAY,EAAE;IAACC,IAAI,EAAE,UAAP;IAAmBC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ;EAA1B,CADK;EAEnBC,SAAS,EAAE;IAACF,IAAI,EAAE,UAAP;IAAmBC,KAAK,EAAE;EAA1B,CAFQ;EAGnBE,aAAa,EAAE,KAHI;EAInBC,eAAe,EAAE;AAJE,CAArB;;IAOqBC,kB;;;;;EACnBC,8BAA4E;IAAA,+EAAJ,EAAI;IAAA,qBAA/DC,IAA+D;IAAA,IAA/DA,IAA+D,0BAAxD,KAAwD;IAAA,uBAAjDC,MAAiD;IAAA,IAAjDA,MAAiD,4BAAxC,KAAwC;IAAA,iCAAjCC,iBAAiC;IAAA,IAAjCA,iBAAiC,sCAAb,KAAa;;IAAA;;IAAA,yBACpE;MAACF,IAAI,EAAEA,IAAI,IAAIE,iBAAf;MAAkCD,MAAlC,EAAkCA,MAAlC;MAA0CC;IAA1C,CADoE;EAE3E;;;;WAEDC,mBAAUC,KAAVD,EAAiB;MACf,OAAOC,KAAK,CAACC,KAAND,CAAYE,cAAnB;IACD;;;WAEDC,oBAAWC,SAAXD,EAAsB;MACpB,IAAI,CAACC,SAAS,CAACL,SAAVK,CAAoB,IAApBA,CAAL,EAAgC;QAC9B,OAAO,IAAP;MACD;;MAGD,IAAIC,MAAM,GAAG,EAAb;;MACA,IAAID,SAAS,CAACE,IAAVF,CAAeR,IAAnB,EAAyB;QACvBS,MAAM,GAAGtB,YAAY,CAACsB,MAAD,EAASrB,WAAT,CAArBqB;MACD;;MACD,IAAID,SAAS,CAACE,IAAVF,CAAeP,MAAnB,EAA2B;QACzBQ,MAAM,GAAGtB,YAAY,CAACsB,MAAD,EAASpB,aAAT,CAArBoB;MACD;;MAED,OAAOA,MAAP;IACD;;;WAEDE,yBAAgBC,OAAhBD,EAAyBH,SAAzBG,EAAoC;MAClC,IAAME,gBAAgB,GAAG,KAAKC,mBAAL,EAAzB;;MACA,IAAI,CAACD,gBAAD,IAAqB,CAACL,SAAS,CAACL,SAAVK,CAAoB,IAApBA,CAA1B,EAAqD;QAEnD;MACD;;MAEDA,SAAS,CAACO,OAAVP,GAAoB,IAApBA;;MAEA,IAAIA,SAAS,CAACE,IAAVF,CAAeR,IAAnB,EAAyB;QACvBa,gBAAgB,CAACG,YAAjBH,CAA8B;UAC5BI,kBAAkB,EAAE;YAACC,IAAI,EAAE,CAAP;YAAUC,QAAQ,EAAE;UAApB;QADQ,CAA9BN;MAGD;;MACD,IAAIL,SAAS,CAACE,IAAVF,CAAeN,iBAAnB,EAAsC;QACpCW,gBAAgB,CAACG,YAAjBH,CAA8B;UAC5BO,mBAAmB,EAAE;YACnBF,IAAI,EAAE,CADa;YAEnBC,QAAQ,EAAE,SAFS;YAGnBE,SAAS,EAAEb,SAAS,CAACc,cAAVd,CAAyBe,IAAzBf,CAA8B,IAA9BA;UAHQ;QADO,CAA9BK;MAOD;;MACD,IAAIL,SAAS,CAACE,IAAVF,CAAeP,MAAnB,EAA2B;QACzBY,gBAAgB,CAACG,YAAjBH,CAA8B;UAC5BW,eAAe,EAAE;YAACN,IAAI,EAAE,CAAP;YAAUC,QAAQ,EAAE;UAApB;QADW,CAA9BN;MAGD;IACF;;;WAEDY,qBAAYC,MAAZD,EAAoBjB,SAApBiB,EAA+B;MAC7B,IAAI,CAACjB,SAAS,CAACL,SAAVK,CAAoB,IAApBA,CAAL,EAAgC;QAC9B;MACD;;MAED,IAAMmB,QAAQ,GAAG,EAAjB;;MAEA,IAAInB,SAAS,CAACE,IAAVF,CAAeR,IAAnB,EAAyB;QACvB2B,QAAQ,CAACC,aAATD,GAAyB,KAAKE,KAAL,CAAWjC,aAAX,GAA2B,CAA3B,GAA+B,CAAxD+B;QACAA,QAAQ,CAAC9B,eAAT8B,GAA2BG,OAAO,CAAC,KAAKD,KAAL,CAAWhC,eAAZ,CAAlC8B;MACD;;MAED,KAAKtB,KAAL,CAAW0B,KAAX,CAAiBC,WAAjB,CAA6BL,QAA7B;IACD;;;WAEDL,wBAAeW,IAAfX,EAAqB;MACnB,IAAMb,MAAM,GAAG,CAAC,CAAD,CAAf;MACA,IAAMyB,YAAY,GAAG,KAAKL,KAAL,CAAWM,cAAX,KAA8B,IAA9B,GAAqC,CAArC,GAAyC,CAA9D;MACA,IAAMC,QAAQ,GAAGC,KAAK,CAACC,OAAND,CAAcJ,IAAI,CAAC,CAAD,CAAlBI,CAAjB;MACA,IAAME,YAAY,GAAGH,QAAQ,GAAGH,IAAI,CAACO,MAAR,GAAiBP,IAAI,CAACO,MAALP,GAAcC,YAA5D;MAEA,IAAIO,CAAJ;MACA,IAAIC,KAAJ;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,YAAY,GAAG,CAAnC,EAAsCI,CAAC,EAAvC,EAA2C;QACzCF,CAAC,GAAGL,QAAQ,GAAGH,IAAI,CAACU,CAAD,CAAP,GAAaV,IAAI,CAACW,KAALX,CAAWU,CAAC,GAAGT,YAAfD,EAA6BU,CAAC,GAAGT,YAAJS,GAAmBT,YAAhDD,CAAzBQ;QACAA,CAAC,GAAG,KAAKI,eAAL,CAAqBJ,CAArB,CAAJA;;QAEA,IAAIE,CAAC,GAAG,CAAR,EAAW;UACTlC,MAAM,CAACkC,CAAD,CAANlC,GAAYA,MAAM,CAACkC,CAAC,GAAG,CAAL,CAANlC,GAAgBnB,IAAI,CAACoD,KAAD,EAAQD,CAAR,CAAhChC;QACD;;QAEDiC,KAAK,GAAGD,CAARC;MACD;;MACD,OAAOjC,MAAP;IACD;;;;EA1F6CxB,c;;SAA3Ba,kB;AA6FrBA,kBAAkB,CAACgD,aAAnBhD,GAAmC,oBAAnCA;AACAA,kBAAkB,CAACP,YAAnBO,GAAkCP,YAAlCO","names":["LayerExtension","_mergeShaders","mergeShaders","dashShaders","offsetShaders","dist","defaultProps","getDashArray","type","value","getOffset","dashJustified","dashGapPickable","PathStyleExtension","constructor","dash","offset","highPrecisionDash","isEnabled","layer","state","pathTesselator","getShaders","extension","result","opts","initializeState","context","attributeManager","getAttributeManager","enabled","addInstanced","instanceDashArrays","size","accessor","instanceDashOffsets","transform","getDashOffsets","bind","instanceOffsets","updateState","params","uniforms","dashAlignMode","props","Boolean","model","setUniforms","path","positionSize","positionFormat","isNested","Array","isArray","geometrySize","length","p","prevP","i","slice","projectPosition","extensionName"],"sources":["../../../src/path-style/path-style.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\nimport {dist} from 'gl-matrix/vec3';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false,\n  dashGapPickable: false\n};\n\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({dash = false, offset = false, highPrecisionDash = false} = {}) {\n    super({dash: dash || highPrecisionDash, offset, highPrecisionDash});\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.highPrecisionDash) {\n      attributeManager.addInstanced({\n        instanceDashOffsets: {\n          size: 1,\n          accessor: 'getPath',\n          transform: extension.getDashOffsets.bind(this)\n        }\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n      uniforms.dashGapPickable = Boolean(this.props.dashGapPickable);\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n\n  getDashOffsets(path) {\n    const result = [0];\n    const positionSize = this.props.positionFormat === 'XY' ? 2 : 3;\n    const isNested = Array.isArray(path[0]);\n    const geometrySize = isNested ? path.length : path.length / positionSize;\n\n    let p;\n    let prevP;\n    for (let i = 0; i < geometrySize - 1; i++) {\n      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);\n      p = this.projectPosition(p);\n\n      if (i > 0) {\n        result[i] = result[i - 1] + dist(prevP, p);\n      }\n\n      prevP = p;\n    }\n    return result;\n  }\n}\n\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}