{"ast":null,"code":"import { GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS } from './webgl-parameter-tables';\nimport { setParameters, getParameters } from './unified-parameter-api';\nimport { assert } from '../utils/assert';\nimport { deepArrayEqual } from '../utils/utils';\n\nfunction installGetterOverride(gl, functionName) {\n  const originalGetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function get() {\n    const pname = arguments.length <= 0 ? undefined : arguments[0];\n\n    if (!(pname in gl.state.cache)) {\n      return originalGetterFunc(...arguments);\n    }\n\n    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n\nfunction installSetterSpy(gl, functionName, setter) {\n  const originalSetterFunc = gl[functionName].bind(gl);\n\n  gl[functionName] = function set() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    const {\n      valueChanged,\n      oldValue\n    } = setter(gl.state._updateCache, ...params);\n\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n\n    return oldValue;\n  };\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    if (gl.state.program !== handle) {\n      originalUseProgram(handle);\n      gl.state.program = handle;\n    }\n  };\n}\n\nclass GLState {\n  constructor(gl) {\n    let {\n      copyState = false,\n      log = () => {}\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.gl = gl;\n    this.program = null;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  push() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.stateStack.push({});\n  }\n\n  pop() {\n    assert(this.stateStack.length > 0);\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setParameters(this.gl, oldValues);\n    this.stateStack.pop();\n  }\n\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue;\n    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n    for (const key in values) {\n      assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n\n        this.cache[key] = value;\n      }\n    }\n\n    return {\n      valueChanged,\n      oldValue\n    };\n  }\n\n}\n\nexport function trackContextState(gl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    enable = true,\n    copyState\n  } = options;\n  assert(copyState !== undefined);\n\n  if (!gl.state) {\n    const global_ = typeof global !== 'undefined' ? global : window;\n    const {\n      polyfillContext\n    } = global_;\n\n    if (polyfillContext) {\n      polyfillContext(gl);\n    }\n\n    gl.state = new GLState(gl, {\n      copyState\n    });\n    installProgramSpy(gl);\n\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n  return gl;\n}\nexport function pushContextState(gl) {\n  if (!gl.state) {\n    trackContextState(gl, {\n      copyState: false\n    });\n  }\n\n  gl.state.push();\n}\nexport function popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}","map":{"version":3,"mappings":"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","names":["GL_PARAMETER_DEFAULTS","GL_HOOKED_SETTERS","setParameters","getParameters","assert","deepArrayEqual","installGetterOverride","gl","functionName","originalGetterFunc","bind","get","pname","state","cache","enable","Object","defineProperty","value","configurable","installSetterSpy","setter","originalSetterFunc","set","params","valueChanged","oldValue","_updateCache","installProgramSpy","originalUseProgram","useProgram","useProgramLuma","handle","program","GLState","constructor","copyState","log","stateStack","assign","seal","push","values","pop","length","oldValues","key","undefined","cached","trackContextState","options","global_","global","window","polyfillContext","pushContextState","popContextState"],"sources":["../../../src/state-tracker/track-context-state.js"],"sourcesContent":["// Support for listening to context state changes and intercepting state queries\n// NOTE: this system does not handle buffer bindings\n/** @typedef {import('./track-context-state')} types */\n\nimport {GL_PARAMETER_DEFAULTS, GL_HOOKED_SETTERS} from './webgl-parameter-tables';\nimport {setParameters, getParameters} from './unified-parameter-api';\nimport {assert} from '../utils/assert';\nimport {deepArrayEqual} from '../utils/utils';\n\n// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n\n// Overrides a WebGLRenderingContext state \"getter\" function\n// to return values directly from cache\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGLRenderingContext\n  const originalGetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function get(...params) {\n    const pname = params[0];\n\n    // WebGL limits are not prepopulated in the cache, it's neither undefined in GL_PARAMETER_DEFAULTS\n    // nor intercepted by GL_HOOKED_SETTERS. Query the original getter.\n    if (!(pname in gl.state.cache)) {\n      return originalGetterFunc(...params);\n    }\n\n    // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n    return gl.state.enable\n      ? // Call the getter the params so that it can e.g. serve from a cache\n        gl.state.cache[pname]\n      : // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n        originalGetterFunc(...params);\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-from-cache`,\n    configurable: false\n  });\n}\n\n// Overrides a WebGLRenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\nfunction installSetterSpy(gl, functionName, setter) {\n  // Get the original function from the WebGLRenderingContext\n  const originalSetterFunc = gl[functionName].bind(gl);\n\n  // Wrap it with a spy so that we can update our state cache when it gets called\n  gl[functionName] = function set(...params) {\n    // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n    const {valueChanged, oldValue} = setter(gl.state._updateCache, ...params);\n\n    // Call the original WebGLRenderingContext func to make sure the context actually gets updated\n    if (valueChanged) {\n      originalSetterFunc(...params);\n    }\n\n    // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n\n    return oldValue;\n  };\n\n  // Set the name of this anonymous function to help in debugging and profiling\n  Object.defineProperty(gl[functionName], 'name', {\n    value: `${functionName}-to-cache`,\n    configurable: false\n  });\n}\n\nfunction installProgramSpy(gl) {\n  const originalUseProgram = gl.useProgram.bind(gl);\n\n  gl.useProgram = function useProgramLuma(handle) {\n    if (gl.state.program !== handle) {\n      originalUseProgram(handle);\n      gl.state.program = handle;\n    }\n  };\n}\n\n// HELPER CLASS - GLState\n\n/* eslint-disable no-shadow */\nclass GLState {\n  constructor(\n    gl,\n    {\n      copyState = false, // Copy cache from params (slow) or initialize from WebGL defaults (fast)\n      log = () => {} // Logging function, called when gl parameter change calls are actually issued\n    } = {}\n  ) {\n    this.gl = gl;\n    this.program = null;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  push(values = {}) {\n    this.stateStack.push({});\n  }\n\n  pop() {\n    assert(this.stateStack.length > 0);\n    // Use the saved values in the state stack to restore parameters\n    const oldValues = this.stateStack[this.stateStack.length - 1];\n    setParameters(this.gl, oldValues);\n    // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n    this.stateStack.pop();\n  }\n\n  // interceptor for context set functions - update our cache and our stack\n  // values (Object) - the key values for this setter\n  _updateCache(values) {\n    let valueChanged = false;\n    let oldValue; // = undefined\n\n    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n    for (const key in values) {\n      assert(key !== undefined);\n      const value = values[key];\n      const cached = this.cache[key];\n      // Check that value hasn't already been shadowed\n      if (!deepArrayEqual(value, cached)) {\n        valueChanged = true;\n        oldValue = cached;\n\n        // First, save current value being shadowed\n        // If a state stack frame is active, save the current parameter values for pop\n        // but first check that value hasn't already been shadowed and saved\n        if (oldValues && !(key in oldValues)) {\n          oldValues[key] = cached;\n        }\n\n        // Save current value being shadowed\n        this.cache[key] = value;\n      }\n    }\n\n    return {valueChanged, oldValue};\n  }\n}\n\n// PUBLIC API\n\n/**\n * Initialize WebGL state caching on a context\n * @type {types['trackContextState']}\n */\n// After calling this function, context state will be cached\n// gl.state.push() and gl.state.pop() will be available for saving,\n// temporarily modifying, and then restoring state.\nexport function trackContextState(gl, options = {}) {\n  const {enable = true, copyState} = options;\n  assert(copyState !== undefined);\n  // @ts-ignore\n  if (!gl.state) {\n    const global_ = typeof global !== 'undefined' ? global : window;\n    // @ts-ignore\n    const {polyfillContext} = global_;\n    if (polyfillContext) {\n      polyfillContext(gl);\n    }\n\n    // Create a state cache\n    // @ts-ignore\n    gl.state = new GLState(gl, {copyState});\n\n    installProgramSpy(gl);\n\n    // intercept all setter functions in the table\n    for (const key in GL_HOOKED_SETTERS) {\n      const setter = GL_HOOKED_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    }\n\n    // intercept all getter functions in the table\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  // @ts-ignore\n  gl.state.enable = enable;\n\n  return gl;\n}\n\n/**\n * Initialize WebGL state caching on a context\n * @type {types['pushContextState']}\n */\nexport function pushContextState(gl) {\n  // @ts-ignore\n  if (!gl.state) {\n    trackContextState(gl, {copyState: false});\n  }\n  // @ts-ignore\n  gl.state.push();\n}\n\n/**\n * Initialize WebGL state caching on a context\n * @type {types['popContextState']}\n */\nexport function popContextState(gl) {\n  // @ts-ignore\n  assert(gl.state);\n  // @ts-ignore\n  gl.state.pop();\n}\n"]},"metadata":{},"sourceType":"module"}