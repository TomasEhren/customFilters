{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { ImageLoader } from '@loaders.gl/images';\nimport { getImageUrls } from './load-image';\nimport { deepLoad } from './deep-load';\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nvar GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\nvar CUBE_FACES = [{\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_X,\n  direction: 'right',\n  axis: 'x',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X,\n  direction: 'left',\n  axis: 'x',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y,\n  direction: 'top',\n  axis: 'y',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,\n  direction: 'bottom',\n  axis: 'y',\n  sign: 'negative'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z,\n  direction: 'front',\n  axis: 'z',\n  sign: 'positive'\n}, {\n  face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z,\n  direction: 'back',\n  axis: 'z',\n  sign: 'negative'\n}];\nexport function getImageCubeUrls(_x, _x2) {\n  return _getImageCubeUrls.apply(this, arguments);\n}\n\nfunction _getImageCubeUrls() {\n  _getImageCubeUrls = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(getUrl, options) {\n    var urls, promises, index, _loop, i;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            urls = {};\n            promises = [];\n            index = 0;\n\n            _loop = function _loop(i) {\n              var face = CUBE_FACES[index];\n              var promise = getImageUrls(getUrl, options, _objectSpread(_objectSpread({}, face), {}, {\n                index: index++\n              })).then(function (url) {\n                urls[face.face] = url;\n              });\n              promises.push(promise);\n            };\n\n            for (i = 0; i < CUBE_FACES.length; ++i) {\n              _loop(i);\n            }\n\n            _context.next = 7;\n            return Promise.all(promises);\n\n          case 7:\n            return _context.abrupt(\"return\", urls);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getImageCubeUrls.apply(this, arguments);\n}\n\nexport function loadImageTextureCube(_x3) {\n  return _loadImageTextureCube.apply(this, arguments);\n}\n\nfunction _loadImageTextureCube() {\n  _loadImageTextureCube = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(getUrl) {\n    var options,\n        urls,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _context2.next = 3;\n            return getImageCubeUrls(getUrl, options);\n\n          case 3:\n            urls = _context2.sent;\n            _context2.next = 6;\n            return deepLoad(urls, ImageLoader.parse, options);\n\n          case 6:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadImageTextureCube.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;AACA,SAAQA,WAAR,QAA0B,oBAA1B;AAEA,SAAQC,YAAR,QAA2B,cAA3B;AACA,SAAQC,QAAR,QAAuB,aAAvB;AAGA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AACA,IAAMC,8BAA8B,GAAG,MAAvC;AAEA,IAAMC,UAAU,GAAG,CACjB;EAACC,IAAI,EAAEP,8BAAP;EAAuCQ,SAAS,EAAE,OAAlD;EAA2DC,IAAI,EAAE,GAAjE;EAAsEC,IAAI,EAAE;AAA5E,CADiB,EAEjB;EAACH,IAAI,EAAEN,8BAAP;EAAuCO,SAAS,EAAE,MAAlD;EAA0DC,IAAI,EAAE,GAAhE;EAAqEC,IAAI,EAAE;AAA3E,CAFiB,EAGjB;EAACH,IAAI,EAAEL,8BAAP;EAAuCM,SAAS,EAAE,KAAlD;EAAyDC,IAAI,EAAE,GAA/D;EAAoEC,IAAI,EAAE;AAA1E,CAHiB,EAIjB;EAACH,IAAI,EAAEJ,8BAAP;EAAuCK,SAAS,EAAE,QAAlD;EAA4DC,IAAI,EAAE,GAAlE;EAAuEC,IAAI,EAAE;AAA7E,CAJiB,EAKjB;EAACH,IAAI,EAAEH,8BAAP;EAAuCI,SAAS,EAAE,OAAlD;EAA2DC,IAAI,EAAE,GAAjE;EAAsEC,IAAI,EAAE;AAA5E,CALiB,EAMjB;EAACH,IAAI,EAAEF,8BAAP;EAAuCG,SAAS,EAAE,MAAlD;EAA0DC,IAAI,EAAE,GAAhE;EAAqEC,IAAI,EAAE;AAA3E,CANiB,CAAnB;AAoBA,gBAAsBC,gBAAtB;EAAA;AAAA;;;+EAAO,iBAAgCC,MAAhC,EAAgDC,OAAhD;IAAA;;IAAA;MAAA;QAAA;UAAA;YAECC,IAFD,GAE2C,EAF3C;YAGCC,QAHD,GAG4B,EAH5B;YAKDC,KALC,GAKO,CALP;;YAAA,uBAMIC,CANJ;cAOH,IAAMV,IAAI,GAAGD,UAAU,CAACU,KAAD,CAAvB;cACA,IAAME,OAAO,GAAGpB,YAAY,CAACc,MAAD,EAASC,OAAT,kCAAsBN,IAAtB;gBAA4BS,KAAK,EAAEA,KAAK;cAAxC,GAAZlB,CAAyDqB,IAAzDrB,CAA+DsB,aAAD,EAAS;gBACrFN,IAAI,CAACP,IAAI,CAACA,IAAN,CAAJO,GAAkBM,GAAlBN;cADc,EAAhB;cAGAC,QAAQ,CAACM,IAATN,CAAcG,OAAdH;YAXG;;YAML,KAASE,CAAT,GAAa,CAAb,EAAgBA,CAAC,GAAGX,UAAU,CAACgB,MAA/B,EAAuC,EAAEL,CAAzC,EAA4C;cAAA,MAAnCA,CAAmC;YAM3C;;YAZI;YAAA,OAcCM,OAAO,CAACC,GAARD,CAAYR,QAAZQ,CAdD;;UAAA;YAAA,iCAgBET,IAhBF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;AAqBP,gBAAsBW,oBAAtB;EAAA;AAAA;;;mFAAO,kBACLb,MADK;IAAA;IAAA;IAAA;IAAA;MAAA;QAAA;UAAA;YAELC,OAFK,8DAEK,EAFL;YAAA;YAAA,OAIcF,gBAAgB,CAACC,MAAD,EAASC,OAAT,CAJ9B;;UAAA;YAICC,IAJD;YAAA;YAAA,OAKSf,QAAQ,CAACe,IAAD,EAAOjB,WAAW,CAAC6B,KAAnB,EAA0Bb,OAA1B,CALjB;;UAAA;YAAA;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["ImageLoader","getImageUrls","deepLoad","GL_TEXTURE_CUBE_MAP_POSITIVE_X","GL_TEXTURE_CUBE_MAP_NEGATIVE_X","GL_TEXTURE_CUBE_MAP_POSITIVE_Y","GL_TEXTURE_CUBE_MAP_NEGATIVE_Y","GL_TEXTURE_CUBE_MAP_POSITIVE_Z","GL_TEXTURE_CUBE_MAP_NEGATIVE_Z","CUBE_FACES","face","direction","axis","sign","getImageCubeUrls","getUrl","options","urls","promises","index","i","promise","then","url","push","length","Promise","all","loadImageTextureCube","parse"],"sources":["../../../../src/lib/texture-api/load-image-cube.ts"],"sourcesContent":["// loaders.gl, MIT license\nimport {ImageLoader} from '@loaders.gl/images';\nimport type {GetUrl, UrlOptions} from './texture-api-types';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\n// Returned map will be have keys corresponding to GL cubemap constants\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\n\nconst CUBE_FACES = [\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}\n];\n\nexport type ImageCubeTexture = {\n  GL_TEXTURE_CUBE_MAP_POSITIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_X: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y: any;\n  GL_TEXTURE_CUBE_MAP_POSITIVE_Z: any;\n  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z: any;\n};\n\n// Returns an object with six key-value pairs containing the urls (or url mip arrays)\n// for each cube face\nexport async function getImageCubeUrls(getUrl: GetUrl, options: UrlOptions) {\n  // Calculate URLs\n  const urls: Record<number, string | string[]> = {};\n  const promises: Promise<any>[] = [];\n\n  let index = 0;\n  for (let i = 0; i < CUBE_FACES.length; ++i) {\n    const face = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, {...face, index: index++}).then((url) => {\n      urls[face.face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return urls;\n}\n\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function loadImageTextureCube(\n  getUrl: GetUrl,\n  options = {}\n): Promise<ImageCubeTexture> {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return (await deepLoad(urls, ImageLoader.parse, options)) as ImageCubeTexture;\n}\n"]},"metadata":{},"sourceType":"module"}