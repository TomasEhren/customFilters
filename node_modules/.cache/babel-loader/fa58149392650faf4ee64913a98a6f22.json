{"ast":null,"code":"export function getMeshSize(attributes) {\n  var size = 0;\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n\n    if (ArrayBuffer.isView(attribute)) {\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n\n  return size;\n}\nexport function getMeshBoundingBox(attributes) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var minZ = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n  var maxZ = -Infinity;\n  var positions = attributes.POSITION ? attributes.POSITION.value : [];\n  var len = positions && positions.length;\n\n  for (var i = 0; i < len; i += 3) {\n    var x = positions[i];\n    var y = positions[i + 1];\n    var z = positions[i + 2];\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n\n  return [[minX, minY, minZ], [maxX, maxY, maxZ]];\n}","map":{"version":3,"mappings":"AAiBA,OAAO,SAASA,WAAT,CAAqBC,UAArB,EAAsD;EAC3D,IAAIC,IAAI,GAAG,CAAX;;EACA,KAAK,IAAMC,aAAX,IAA4BF,UAA5B,EAAwC;IACtC,IAAMG,SAAS,GAAGH,UAAU,CAACE,aAAD,CAA5B;;IACA,IAAIE,WAAW,CAACC,MAAZD,CAAmBD,SAAnBC,CAAJ,EAAmC;MAEjCH,IAAI,IAAIE,SAAS,CAACG,UAAVH,GAAuBA,SAAS,CAACI,iBAAzCN;IACD;EACF;;EACD,OAAOA,IAAP;AACD;AAQD,OAAO,SAASO,kBAAT,CAA4BR,UAA5B,EAAqE;EAC1E,IAAIS,IAAI,GAAGC,QAAX;EACA,IAAIC,IAAI,GAAGD,QAAX;EACA,IAAIE,IAAI,GAAGF,QAAX;EACA,IAAIG,IAAI,GAAG,CAACH,QAAZ;EACA,IAAII,IAAI,GAAG,CAACJ,QAAZ;EACA,IAAIK,IAAI,GAAG,CAACL,QAAZ;EAEA,IAAMM,SAAS,GAAGhB,UAAU,CAACiB,QAAXjB,GAAsBA,UAAU,CAACiB,QAAXjB,CAAoBkB,KAA1ClB,GAAkD,EAApE;EACA,IAAMmB,GAAG,GAAGH,SAAS,IAAIA,SAAS,CAACI,MAAnC;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,IAAI,CAA9B,EAAiC;IAC/B,IAAMC,CAAC,GAAGN,SAAS,CAACK,CAAD,CAAnB;IACA,IAAME,CAAC,GAAGP,SAAS,CAACK,CAAC,GAAG,CAAL,CAAnB;IACA,IAAMG,CAAC,GAAGR,SAAS,CAACK,CAAC,GAAG,CAAL,CAAnB;IAEAZ,IAAI,GAAGa,CAAC,GAAGb,IAAJa,GAAWA,CAAXA,GAAeb,IAAtBA;IACAE,IAAI,GAAGY,CAAC,GAAGZ,IAAJY,GAAWA,CAAXA,GAAeZ,IAAtBA;IACAC,IAAI,GAAGY,CAAC,GAAGZ,IAAJY,GAAWA,CAAXA,GAAeZ,IAAtBA;IAEAC,IAAI,GAAGS,CAAC,GAAGT,IAAJS,GAAWA,CAAXA,GAAeT,IAAtBA;IACAC,IAAI,GAAGS,CAAC,GAAGT,IAAJS,GAAWA,CAAXA,GAAeT,IAAtBA;IACAC,IAAI,GAAGS,CAAC,GAAGT,IAAJS,GAAWA,CAAXA,GAAeT,IAAtBA;EACD;;EACD,OAAO,CACL,CAACN,IAAD,EAAOE,IAAP,EAAaC,IAAb,CADK,EAEL,CAACC,IAAD,EAAOC,IAAP,EAAaC,IAAb,CAFK,CAAP;AAID","names":["getMeshSize","attributes","size","attributeName","attribute","ArrayBuffer","isView","byteLength","BYTES_PER_ELEMENT","getMeshBoundingBox","minX","Infinity","minY","minZ","maxX","maxY","maxZ","positions","POSITION","value","len","length","i","x","y","z"],"sources":["../../../../src/category/mesh/mesh-utils.ts"],"sourcesContent":["// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\nimport {MeshAttributes} from './mesh-types';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}