{"ast":null,"code":"import { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\nexport default class Tesselator {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      attributes = {}\n    } = opts;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    if (geometryBuffer) {\n      assert(data.startIndices);\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        buffers.positions = geometryBuffer;\n      }\n    }\n\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry(_ref) {\n    let {\n      startRow,\n      endRow\n    } = _ref;\n\n    this._rebuildGeometry({\n      startRow,\n      endRow\n    });\n  }\n\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value));\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  _allocate(instanceCount, copy) {\n    const {\n      attributes,\n      buffers,\n      _attributeDefs,\n      typedArrayManager\n    } = this;\n\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        def.copy = copy;\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {\n      data,\n      getGeometry\n    } = this;\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {\n      indexStarts,\n      vertexStarts,\n      instanceCount\n    } = this;\n    const {\n      data,\n      geometryBuffer\n    } = this;\n    const {\n      startRow = 0,\n      endRow = Infinity\n    } = dataRange || {};\n    const normalizedData = {};\n\n    if (!dataRange) {\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry((geometry, dataIndex) => {\n        geometry = this.normalizeGeometry(geometry);\n        normalizedData[dataIndex] = geometry;\n        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n      }, startRow, endRow);\n\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n    const context = {};\n\n    this._forEachGeometry((geometry, dataIndex) => {\n      geometry = normalizedData[dataIndex] || geometry;\n      context.vertexStart = vertexStarts[dataIndex];\n      context.indexStart = indexStarts[dataIndex];\n      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n      context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n      context.geometryIndex = dataIndex;\n      this.updateGeometryAttributes(geometry, context);\n    }, startRow, endRow);\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","normalizeGeometry","geometry","updateGeometryAttributes","startIndex","Error","getGeometrySize","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","dataIndex","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex"],"sources":["../../../src/utils/tesselator.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value)); // invalid binary geometries\n\n    // @ts-expect-error\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}