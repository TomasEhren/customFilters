{"ast":null,"code":"import { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\n\nconst DRAW_PARAMS = {};\nexport default class Model {\n  constructor(gl) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id = uid('model')\n    } = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n    this.userData = {};\n    this.needsRedraw = true;\n    this._attributes = {};\n    this.attributes = {};\n    this.uniforms = {};\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n    this.vertexCount = props.vertexCount || 0;\n    this.geometryBuffers = {};\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    this.geometry = {};\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes() {\n    let attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  setUniforms() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.assign(this.uniforms, uniforms);\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {\n      isInstanced,\n      instanceCount\n    } = this;\n    const {\n      onBeforeRender = NOOP,\n      onAfterRender = NOOP\n    } = this.props;\n    onBeforeRender();\n    this.program.setUniforms(this.uniforms);\n    const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n      logPriority,\n      uniforms: null,\n      framebuffer,\n      parameters,\n      drawMode: this.getDrawMode(),\n      vertexCount: this.getVertexCount(),\n      vertexArray,\n      transformFeedback,\n      isIndexed,\n      indexType,\n      isInstanced,\n      instanceCount,\n      offset: isIndexed ? indexOffset : 0\n    }));\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  transform() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      discard = true,\n      feedbackBuffers,\n      unbindModels = []\n    } = opts;\n    let {\n      parameters\n    } = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {\n        [35977]: discard\n      });\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n\n    try {\n      this.draw(Object.assign({}, opts, {\n        parameters\n      }));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  render() {\n    let uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {\n      program\n    } = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      this.vertexArray.setProps({\n        program: this.program,\n        attributes: this.vertexArray.attributes\n      });\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      });\n    }\n\n    this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n    }\n  }\n\n  _setFeedbackBuffers() {\n    let feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {\n      gl\n    } = this.program;\n    this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n      program: this.program\n    });\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {\n      collapsed: log.level <= 2\n    })();\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      attributes: this._attributes\n    });\n    const {\n      table: uniformTable,\n      unusedTable,\n      unusedCount\n    } = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n    const {\n      table: missingTable,\n      count: missingCount\n    } = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n    }\n\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n    log.table(logLevel, attributeTable)();\n    log.table(logLevel, uniformTable)();\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({\n        logLevel: LOG_DRAW_PRIORITY,\n        message: `Rendered to ${framebuffer.id}`\n      });\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n\n}","map":{"version":3,"mappings":"AAGA,SAAQA,OAAR,QAAsB,kBAAtB;AACA,OAAOC,cAAP,MAA2B,mBAA3B;AACA,SACEC,OADF,EAEEC,WAFF,EAGEC,KAHF,EAIEC,iBAJF,EAKEC,MALF,EAMEC,GANF,EAOEC,aAPF,EAQEC,GARF,EASEC,MATF,QAUO,gBAVP;AAWA,SACEC,wBADF,EAEEC,2BAFF,EAGEC,oCAHF,QAIO,gBAJP;AAKA,SAAQC,sBAAR,QAAqC,eAArC;AAEA,MAAMC,iBAAiB,GAAG,CAA1B;AACA,MAAMC,gBAAgB,GAAG,KAAzB;AAEA,MAAMC,gBAAgB,GAAG,sCAAzB;;AAEA,MAAMC,IAAI,GAAG,MAAM,CAAnB;;AACA,MAAMC,WAAW,GAAG,EAApB;AAEA,eAAe,MAAMC,KAAN,CAAY;EACzBC,WAAW,CAACC,EAAD,EAAiB;IAAA,IAAZC,KAAY,uEAAJ,EAAI;IAE1B,MAAM;MAACC,EAAE,GAAGf,GAAG,CAAC,OAAD;IAAT,IAAsBc,KAA5B;IACAb,MAAM,CAACV,OAAO,CAACsB,EAAD,CAAR,CAANZ;IACA,KAAKc,EAAL,GAAUA,EAAV;IACA,KAAKF,EAAL,GAAUA,EAAV;IACA,KAAKE,EAAL,GAAUD,KAAK,CAACC,EAAND,IAAYd,GAAG,CAAC,OAAD,CAAzB;IACA,KAAKgB,WAAL,GAAmB,CAAnB;IACA,KAAKC,QAAL,GAAgB,KAAhB;IACA,KAAKC,UAAL,CAAgBJ,KAAhB;EACD;;EAEDI,UAAU,CAACJ,KAAD,EAAQ;IAChB,KAAKA,KAAL,GAAa,EAAb;IAEA,KAAKK,cAAL,GAAsBL,KAAK,CAACK,cAANL,IAAwBtB,cAAc,CAAC4B,wBAAf5B,CAAwC,KAAKqB,EAA7CrB,CAA9C;IACA,KAAK6B,oBAAL,GAA4B,CAAC,CAA7B;IACA,KAAKC,eAAL,GAAuB,KAAvB;IAEA,MAAM;MACJC,OAAO,GAAG,IADN;MAEJC,EAFI;MAGJC,EAHI;MAIJC,OAJI;MAKJC,OALI;MAMJC,MANI;MAOJC,QAPI;MAQJC,UARI;MASJC;IATI,IAUFjB,KAVJ;IAYA,KAAKkB,YAAL,GAAoB;MAClBT,OADkB;MAElBC,EAFkB;MAGlBC,EAHkB;MAIlBC,OAJkB;MAKlBC,OALkB;MAMlBC,MANkB;MAOlBC,QAPkB;MAQlBC,UARkB;MASlBC;IATkB,CAApB;IAWA,KAAKR,OAAL,GAAe,IAAf;IACA,KAAKU,WAAL,GAAmB,IAAnB;IACA,KAAKC,aAAL,GAAqB,IAArB;IAGA,KAAKC,QAAL,GAAgB,EAAhB;IACA,KAAKC,WAAL,GAAmB,IAAnB;IAIA,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,UAAL,GAAkB,EAAlB;IAGA,KAAKC,QAAL,GAAgB,EAAhB;IAGA,KAAKC,QAAL,GAAgB,IAAhB;;IAEA,KAAKC,aAAL;;IAEA,KAAKC,WAAL,CACEC,MAAM,CAACC,MAAPD,CACE,EADFA,EAEE,KAAKE,iBAAL,CAAuB/B,KAAK,CAACgC,cAA7B,CAFFH,CADF;IAOA,KAAKI,QAAL,GAAgBjC,KAAK,CAACiC,QAANjC,KAAmBkC,SAAnBlC,GAA+BA,KAAK,CAACiC,QAArCjC,IAAhB;IACA,KAAKmC,WAAL,GAAmBnC,KAAK,CAACmC,WAANnC,IAAqB,CAAxC;IAGA,KAAKoC,eAAL,GAAuB,EAAvB;IAGA,KAAKC,WAAL,GAAmBrC,KAAK,CAACqC,WAANrC,IAAqBA,KAAK,CAACsC,SAA3BtC,IAAwCA,KAAK,CAACuC,aAANvC,GAAsB,CAAjF;;IAEA,KAAKwC,cAAL,CAAoBxC,KAApB;;IAGA,KAAKyC,QAAL,GAAgB,EAAhB;IAGAtD,MAAM,CAAC,KAAK8C,QAAL,KAAkBC,SAAlB,IAA+BQ,MAAM,CAACC,QAAPD,CAAgB,KAAKP,WAArBO,CAAhC,EAAmEhD,gBAAnE,CAANP;EACD;;EAEDyD,QAAQ,CAAC5C,KAAD,EAAQ;IACd,KAAKwC,cAAL,CAAoBxC,KAApB;EACD;;EAED6C,MAAM,GAAG;IAGP,KAAK,MAAMC,GAAX,IAAkB,KAAKvB,WAAvB,EAAoC;MAClC,IAAI,KAAKA,WAAL,CAAiBuB,GAAjB,MAA0B,KAAKtB,UAAL,CAAgBsB,GAAhB,CAA9B,EAAoD;QAClD,KAAKvB,WAAL,CAAiBuB,GAAjB,EAAsBD,MAAtB;MACD;IACF;;IAED,IAAI,KAAKrC,eAAT,EAA0B;MACxB,KAAKH,cAAL,CAAoB0C,OAApB,CAA4B,KAAKtC,OAAjC;MACA,KAAKD,eAAL,GAAuB,KAAvB;IACD;;IAED,KAAKW,WAAL,CAAiB0B,MAAjB;;IAEA,KAAKG,sBAAL;EACD;;EAIDC,WAAW,GAAG;IACZ,OAAO,KAAKhB,QAAZ;EACD;;EAEDiB,cAAc,GAAG;IACf,OAAO,KAAKf,WAAZ;EACD;;EAEDgB,gBAAgB,GAAG;IACjB,OAAO,KAAKZ,aAAZ;EACD;;EAEDa,aAAa,GAAG;IACd,OAAO,KAAK5B,UAAZ;EACD;;EAED6B,UAAU,GAAG;IACX,OAAO,KAAK5C,OAAZ;EACD;;EAED6C,UAAU,CAACtD,KAAD,EAAQ;IAChB,MAAM;MACJS,OADI;MAEJC,EAFI;MAGJC,EAHI;MAIJC,OAJI;MAKJC,OALI;MAMJC,MANI;MAOJC,QAPI;MAQJC,UARI;MASJC;IATI,IAUFjB,KAVJ;IAWA,KAAKkB,YAAL,GAAoB;MAClBT,OADkB;MAElBC,EAFkB;MAGlBC,EAHkB;MAIlBC,OAJkB;MAKlBC,OALkB;MAMlBC,MANkB;MAOlBC,QAPkB;MAQlBC,UARkB;MASlBC;IATkB,CAApB;IAWA,KAAKG,aAAL,GAAqB,IAArB;EACD;;EAEDmC,WAAW,GAAG;IACZ,OAAO,KAAK9B,QAAZ;EACD;;EAID+B,WAAW,CAACvB,QAAD,EAAW;IACpB,KAAKA,QAAL,GAAgBA,QAAhB;IACA,OAAO,IAAP;EACD;;EAEDwB,cAAc,CAACtB,WAAD,EAAc;IAC1BhD,MAAM,CAACuD,MAAM,CAACC,QAAPD,CAAgBP,WAAhBO,CAAD,CAANvD;IACA,KAAKgD,WAAL,GAAmBA,WAAnB;IACA,OAAO,IAAP;EACD;;EAEDuB,gBAAgB,CAACnB,aAAD,EAAgB;IAC9BpD,MAAM,CAACuD,MAAM,CAACC,QAAPD,CAAgBH,aAAhBG,CAAD,CAANvD;IACA,KAAKoD,aAAL,GAAqBA,aAArB;IACA,OAAO,IAAP;EACD;;EAEDoB,WAAW,CAAClB,QAAD,EAAW;IACpB,KAAKR,QAAL,GAAgBQ,QAAQ,CAACR,QAAzB;IACA,KAAKE,WAAL,GAAmBM,QAAQ,CAACS,cAATT,EAAnB;;IAEA,KAAKO,sBAAL;;IAEA,KAAKZ,eAAL,GAAuB7C,sBAAsB,CAAC,KAAKQ,EAAN,EAAU0C,QAAV,CAA7C;IACA,KAAKtB,WAAL,CAAiByC,aAAjB,CAA+B,KAAKxB,eAApC;IACA,OAAO,IAAP;EACD;;EAEDwB,aAAa,GAAkB;IAAA,IAAjBpC,UAAiB,uEAAJ,EAAI;;IAE7B,IAAIvC,aAAa,CAACuC,UAAD,CAAjB,EAA+B;MAC7B,OAAO,IAAP;IACD;;IAED,MAAMqC,oBAAoB,GAAG,EAA7B;;IACA,KAAK,MAAMC,IAAX,IAAmBtC,UAAnB,EAA+B;MAC7B,MAAMuC,SAAS,GAAGvC,UAAU,CAACsC,IAAD,CAA5B;MAGAD,oBAAoB,CAACC,IAAD,CAApBD,GAA6BE,SAAS,CAACC,QAAVD,GAAqBA,SAAS,CAACC,QAAVD,EAArBA,GAA4CA,SAAzEF;IACD;;IAED,KAAK1C,WAAL,CAAiByC,aAAjB,CAA+BC,oBAA/B;IACA,OAAO,IAAP;EACD;;EAGDjC,WAAW,GAAgB;IAAA,IAAfH,QAAe,uEAAJ,EAAI;IACzBI,MAAM,CAACC,MAAPD,CAAc,KAAKJ,QAAnBI,EAA6BJ,QAA7BI;IAEA,OAAO,IAAP;EACD;;EAEDE,iBAAiB,CAACkC,IAAD,EAAO;IACtB,KAAKtC,aAAL;;IAEA,MAAM4B,WAAW,GAAG,KAAKlD,cAAL,CAAoBkD,WAApB,CAAgC,KAAK9C,OAArC,CAApB;;IAEA,IAAI8C,WAAJ,EAAiB;MACf,OAAOA,WAAW,CAACU,IAAD,CAAlB;IACD;;IAED,OAAO,EAAP;EACD;;EAEDC,oBAAoB,CAACD,IAAD,EAAO;IACzB,MAAMxC,QAAQ,GAAG,KAAKM,iBAAL,CAAuBkC,IAAI,IAAI,EAA/B,CAAjB;IACA,OAAO,KAAKrC,WAAL,CAAiBH,QAAjB,CAAP;EACD;;EAID5C,KAAK,CAACoF,IAAD,EAAO;IACVpF,KAAK,CAAC,KAAK4B,OAAL,CAAaV,EAAd,EAAkBkE,IAAlB,CAALpF;IACA,OAAO,IAAP;EACD;;EAEDsF,IAAI,GAAY;IAAA,IAAXF,IAAW,uEAAJ,EAAI;;IAEd,KAAKtC,aAAL;;IAEA,MAAM;MACJK,cAAc,GAAG,IADb;MAEJoC,WAFI;MAGJ3C,QAAQ,GAAG,EAHP;MAIJD,UAAU,GAAG,EAJT;MAKJ6C,iBAAiB,GAAG,KAAKA,iBALrB;MAMJC,UAAU,GAAG,EANT;MAOJnD,WAAW,GAAG,KAAKA;IAPf,IAQF8C,IARJ;IAWA,KAAKL,aAAL,CAAmBpC,UAAnB;IACA,KAAK0C,oBAAL,CAA0BlC,cAA1B;IACA,KAAKJ,WAAL,CAAiBH,QAAjB;IAEA,IAAI8C,WAAJ;;IAEA,IAAIvF,GAAG,CAACwF,QAAJxF,IAAgBQ,iBAApB,EAAuC;MACrC+E,WAAW,GAAG,KAAKE,iBAAL,CAAuBjF,iBAAvB,CAAd+E;IACD;;IAED,MAAMG,UAAU,GAAG,KAAKvD,WAAL,CAAiBwD,aAAjB,EAAnB;IACA,MAAM;MACJC,SAAS,GAAGF,UAAU,CAACE,SADnB;MAEJC,SAAS,GAAGH,UAAU,CAACG,SAFnB;MAGJC,WAAW,GAAGJ,UAAU,CAACI,WAHrB;MAIJC,oBAAoB,GAAGL,UAAU,CAACrC;IAJ9B,IAKF,KAAKrC,KALT;;IAOA,IAAI+E,oBAAoB,IAAI,CAAC,KAAK1C,WAAlC,EAA+C;MAC7CrD,GAAG,CAACgG,IAAJhG,CAAS,mDAATA,EAA8D,KAAKiB,EAAnEjB;IACD;;IAED,MAAM;MAACqD,WAAD;MAAcE;IAAd,IAA+B,IAArC;IAEA,MAAM;MAAC0C,cAAc,GAAGtF,IAAlB;MAAwBuF,aAAa,GAAGvF;IAAxC,IAAgD,KAAKK,KAA3D;IAEAiF,cAAc;IAEd,KAAKxE,OAAL,CAAamB,WAAb,CAAyB,KAAKH,QAA9B;IAEA,MAAM0D,OAAO,GAAG,KAAK1E,OAAL,CAAa0D,IAAb,CACdtC,MAAM,CAACC,MAAPD,CAAcjC,WAAdiC,EAA2BoC,IAA3BpC,EAAiC;MAC/B0C,WAD+B;MAE/B9C,QAAQ,EAAE,IAFqB;MAG/B2C,WAH+B;MAI/BE,UAJ+B;MAK/BrC,QAAQ,EAAE,KAAKgB,WAAL,EALqB;MAM/Bd,WAAW,EAAE,KAAKe,cAAL,EANkB;MAO/B/B,WAP+B;MAQ/BkD,iBAR+B;MAS/BO,SAT+B;MAU/BC,SAV+B;MAW/BxC,WAX+B;MAY/BE,aAZ+B;MAa/B6C,MAAM,EAAER,SAAS,GAAGE,WAAH,GAAiB;IAbH,CAAjCjD,CADc,CAAhB;IAkBAqD,aAAa;;IAEb,IAAIlG,GAAG,CAACwF,QAAJxF,IAAgBQ,iBAApB,EAAuC;MACrC,KAAK6F,eAAL,CAAqBd,WAArB,EAAkCpD,WAAlC,EAA+CiD,WAA/C;IACD;;IAED,OAAOe,OAAP;EACD;;EAGDG,SAAS,GAAY;IAAA,IAAXrB,IAAW,uEAAJ,EAAI;IACnB,MAAM;MAACsB,OAAO,GAAG,IAAX;MAAiBC,eAAjB;MAAkCC,YAAY,GAAG;IAAjD,IAAuDxB,IAA7D;IAEA,IAAI;MAACK;IAAD,IAAeL,IAAnB;;IAEA,IAAIuB,eAAJ,EAAqB;MACnB,KAAKE,mBAAL,CAAyBF,eAAzB;IACD;;IAED,IAAID,OAAJ,EAAa;MACXjB,UAAU,GAAGzC,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkByC,UAAlBzC,EAA8B;QAAC,SAAyB0D;MAA1B,CAA9B1D,CAAbyC;IACD;;IAEDmB,YAAY,CAACE,OAAbF,CAAqBG,KAAK,IAAIA,KAAK,CAACzE,WAANyE,CAAkBC,aAAlBD,EAA9BH;;IACA,IAAI;MACF,KAAKtB,IAAL,CAAUtC,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkBoC,IAAlBpC,EAAwB;QAACyC;MAAD,CAAxBzC,CAAV;IADF,UAEU;MACR4D,YAAY,CAACE,OAAbF,CAAqBG,KAAK,IAAIA,KAAK,CAACzE,WAANyE,CAAkBE,WAAlBF,EAA9BH;IACD;;IAED,OAAO,IAAP;EACD;;EAIDM,MAAM,GAAgB;IAAA,IAAftE,QAAe,uEAAJ,EAAI;IACpBzC,GAAG,CAACgG,IAAJhG,CAAS,wEAATA;IACA,OAAO,KAAK4C,WAAL,CAAiBH,QAAjB,EAA2B0C,IAA3B,EAAP;EACD;;EAID3B,cAAc,CAACxC,KAAD,EAAQ;IACpB6B,MAAM,CAACC,MAAPD,CAAc,KAAK7B,KAAnB6B,EAA0B7B,KAA1B6B;;IAEA,IAAI,cAAc7B,KAAlB,EAAyB;MACvB,KAAK4B,WAAL,CAAiB5B,KAAK,CAACyB,QAAvB;IACD;;IAED,IAAI,cAAczB,KAAlB,EAAyB;MACvB,KAAK0B,QAAL,GAAgB1B,KAAK,CAAC0B,QAAtB;IACD;;IAED,IAAI,mBAAmB1B,KAAvB,EAA8B;MAC5B,KAAKuC,aAAL,GAAqBvC,KAAK,CAACuC,aAA3B;IACD;;IACD,IAAI,cAAcvC,KAAlB,EAAyB;MACvB,KAAK2D,WAAL,CAAiB3D,KAAK,CAACyC,QAAvB;IACD;;IAGD,IAAI,gBAAgBzC,KAApB,EAA2B;MACzB,KAAK4D,aAAL,CAAmB5D,KAAK,CAACwB,UAAzB;IACD;;IACD,IAAI,sBAAsBxB,KAA1B,EAAiC;MAC/B,KAAK0F,mBAAL,CAAyB1F,KAAK,CAACgG,gBAA/B;IACD;EACF;;EAEDrE,aAAa,GAAG;IACd,MAAMsE,WAAW,GACf,KAAK7E,aAAL,IAAsB,KAAKf,cAAL,CAAoB6F,SAApB,KAAkC,KAAK3F,oBAD/D;;IAGA,IAAI,CAAC0F,WAAL,EAAkB;MAChB;IACD;;IAED,IAAI;MAACxF;IAAD,IAAY,KAAKS,YAArB;;IAEA,IAAIT,OAAJ,EAAa;MACX,KAAKD,eAAL,GAAuB,KAAvB;IADF,OAEO;MACL,MAAM;QACJE,EADI;QAEJC,EAFI;QAGJC,OAHI;QAIJE,MAJI;QAKJD,OALI;QAMJE,QANI;QAOJC,UAPI;QAQJC;MARI,IASF,KAAKC,YATT;MAUAT,OAAO,GAAG,KAAKJ,cAAL,CAAoB8F,GAApB,CAAwB;QAChCzF,EADgC;QAEhCC,EAFgC;QAGhCC,OAHgC;QAIhCE,MAJgC;QAKhCD,OALgC;QAMhCE,QANgC;QAOhCC,UAPgC;QAQhCC;MARgC,CAAxB,CAAVR;;MAUA,IAAI,KAAKA,OAAL,IAAgB,KAAKD,eAAzB,EAA0C;QACxC,KAAKH,cAAL,CAAoB0C,OAApB,CAA4B,KAAKtC,OAAjC;MACD;;MACD,KAAKF,oBAAL,GAA4B,KAAKF,cAAL,CAAoB6F,SAAhD;MACA,KAAK1F,eAAL,GAAuB,IAAvB;IACD;;IAEDrB,MAAM,CAACsB,OAAO,YAAY9B,OAApB,EAA6B,uBAA7B,CAANQ;IAEA,KAAKiC,aAAL,GAAqB,KAArB;;IAEA,IAAIX,OAAO,KAAK,KAAKA,OAArB,EAA8B;MAC5B;IACD;;IAED,KAAKA,OAAL,GAAeA,OAAf;;IAEA,IAAI,KAAKU,WAAT,EAAsB;MAEpB,KAAKA,WAAL,CAAiByB,QAAjB,CAA0B;QAACnC,OAAO,EAAE,KAAKA,OAAf;QAAwBe,UAAU,EAAE,KAAKL,WAAL,CAAiBK;MAArD,CAA1B;IAFF,OAGO;MACL,KAAKL,WAAL,GAAmB,IAAIvC,WAAJ,CAAgB,KAAKmB,EAArB,EAAyB;QAACU,OAAO,EAAE,KAAKA;MAAf,CAAzB,CAAnB;IACD;;IAGD,KAAKmB,WAAL,CACEC,MAAM,CAACC,MAAPD,CACE,EADFA,EAEE,KAAKE,iBAAL,EAFFF,CADF;EAMD;;EAEDmB,sBAAsB,GAAG;IACvB,KAAK,MAAMc,IAAX,IAAmB,KAAK1B,eAAxB,EAAyC;MAEvC,MAAMgE,MAAM,GAAG,KAAKhE,eAAL,CAAqB0B,IAArB,EAA2B,CAA3B,KAAiC,KAAK1B,eAAL,CAAqB0B,IAArB,CAAhD;;MACA,IAAIsC,MAAM,YAAYrH,MAAtB,EAA8B;QAC5BqH,MAAM,CAACvD,MAAPuD;MACD;IACF;EACF;;EAIDC,kBAAkB,CAACC,cAAD,EAAiB;IACjC,IAAI,KAAKnG,QAAT,EAAmB;MACjBhB,MAAM,CAACmH,cAAD,EAAiB,uDAAjB,CAANnH;IAGD;EACF;;EAIDuG,mBAAmB,GAAuB;IAAA,IAAtBF,eAAsB,uEAAJ,EAAI;;IAExC,IAAIvG,aAAa,CAACuG,eAAD,CAAjB,EAAoC;MAClC,OAAO,IAAP;IACD;;IAED,MAAM;MAACzF;IAAD,IAAO,KAAKU,OAAlB;IACA,KAAK4D,iBAAL,GACE,KAAKA,iBAAL,IACA,IAAIvF,iBAAJ,CAAsBiB,EAAtB,EAA0B;MACxBU,OAAO,EAAE,KAAKA;IADU,CAA1B,CAFF;IAMA,KAAK4D,iBAAL,CAAuBkC,UAAvB,CAAkCf,eAAlC;IACA,OAAO,IAAP;EACD;;EAEDf,iBAAiB,CAAC+B,QAAD,EAAW;IAC1B,MAAMC,cAAc,GAAGD,QAAQ,GAAG,CAAXA,GAAe,CAAfA,GAAmB/G,gBAA1C;;IACA,IAAIiH,IAAI,CAACC,GAALD,KAAa,KAAKxG,WAAlBwG,GAAgCD,cAApC,EAAoD;MAClD,OAAOvE,SAAP;IACD;;IAED,KAAKhC,WAAL,GAAmBwG,IAAI,CAACC,GAALD,EAAnB;IAEA1H,GAAG,CAAC4H,KAAJ5H,CAAUQ,iBAAVR,EAA8B,qBAAoB,KAAKiB,EAAG,EAA1DjB,EAA6D;MAAC6H,SAAS,EAAE7H,GAAG,CAAC8H,KAAJ9H,IAAa;IAAzB,CAA7DA;IAEA,OAAOwH,QAAP;EACD;;EAEDnB,eAAe,CAACmB,QAAD,EAAWrF,WAAX,EAAwBM,QAAxB,EAAkC2C,WAAlC,EAA+C;IAE5D,IAAIoC,QAAQ,KAAKtE,SAAjB,EAA4B;MAC1B;IACD;;IAED,MAAM6E,cAAc,GAAG1H,2BAA2B,CAAC;MACjD8B,WADiD;MAEjD6F,MAAM,EAAG,GAAE,KAAK/G,EAAG,aAF8B;MAIjDuB,UAAU,EAAE,KAAKD;IAJgC,CAAD,CAAlD;IAOA,MAAM;MAAC0F,KAAK,EAAEC,YAAR;MAAsBC,WAAtB;MAAmCC;IAAnC,IAAkDhI,wBAAwB,CAAC;MAC/E4H,MAAM,EAAG,GAAE,KAAK/G,EAAG,WAD4D;MAE/EQ,OAAO,EAAE,KAAKA,OAFiE;MAG/EgB,QAAQ,EAAEI,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkB,KAAKpB,OAAL,CAAagB,QAA/BI,EAAyCJ,QAAzCI;IAHqE,CAAD,CAAhF;IAOA,MAAM;MAACoF,KAAK,EAAEI,YAAR;MAAsBC,KAAK,EAAEC;IAA7B,IAA6CnI,wBAAwB,CAAC;MAC1E4H,MAAM,EAAG,GAAE,KAAK/G,EAAG,WADuD;MAE1EQ,OAAO,EAAE,KAAKA,OAF4D;MAG1EgB,QAAQ,EAAEI,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkB,KAAKpB,OAAL,CAAagB,QAA/BI,EAAyCJ,QAAzCI,CAHgE;MAI1E2F,aAAa,EAAE;IAJ2D,CAAD,CAA3E;;IAOA,IAAID,YAAY,GAAG,CAAnB,EAAsB;MACpBvI,GAAG,CAACA,GAAJA,CAAQ,kBAARA,EAA4B6C,MAAM,CAAC4F,IAAP5F,CAAYwF,YAAZxF,CAA5B7C;IAED;;IACD,IAAIoI,WAAW,GAAG,CAAlB,EAAqB;MACnBpI,GAAG,CAACA,GAAJA,CAAQ,iBAARA,EAA2B6C,MAAM,CAAC4F,IAAP5F,CAAYsF,WAAZtF,CAA3B7C;IAED;;IAED,MAAM0I,WAAW,GAAGpI,oCAAoC,CAAC,KAAK6B,WAAL,CAAiBwG,aAAlB,CAAxD;IAEA3I,GAAG,CAACiI,KAAJjI,CAAUwH,QAAVxH,EAAoB+H,cAApB/H;IAEAA,GAAG,CAACiI,KAAJjI,CAAUwH,QAAVxH,EAAoBkI,YAApBlI;IAEAA,GAAG,CAACiI,KAAJjI,CAAUwH,QAAQ,GAAG,CAArBxH,EAAwB0I,WAAxB1I;;IAEA,IAAIoF,WAAJ,EAAiB;MACfA,WAAW,CAACpF,GAAZoF,CAAgB;QAACoC,QAAQ,EAAEhH,iBAAX;QAA8BoI,OAAO,EAAG,eAAcxD,WAAW,CAACnE,EAAG;MAArE,CAAhBmE;IACD;;IAEDpF,GAAG,CAAC6I,QAAJ7I,CAAaQ,iBAAbR,EAAiC,qBAAoB,KAAKiB,EAAG,EAA7DjB;EACD;;AA9hBwB","names":["isWebGL","ProgramManager","Program","VertexArray","clear","TransformFeedback","Buffer","log","isObjectEmpty","uid","assert","getDebugTableForUniforms","getDebugTableForVertexArray","getDebugTableForProgramConfiguration","getBuffersFromGeometry","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","constructor","gl","props","id","lastLogTime","animated","initialize","programManager","getDefaultProgramManager","_programManagerState","_managedProgram","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","programProps","vertexArray","_programDirty","userData","needsRedraw","_attributes","attributes","uniforms","pickable","_checkProgram","setUniforms","Object","assign","getModuleUniforms","moduleSettings","drawMode","undefined","vertexCount","geometryBuffers","isInstanced","instanced","instanceCount","_setModelProps","geometry","Number","isFinite","setProps","delete","key","release","_deleteGeometryBuffers","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","setAttributes","normalizedAttributes","name","attribute","getValue","opts","updateModuleSettings","draw","framebuffer","transformFeedback","parameters","logPriority","priority","_logDrawCallStart","drawParams","getDrawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","warn","onBeforeRender","onAfterRender","didDraw","offset","_logDrawCallEnd","transform","discard","feedbackBuffers","unbindModels","_setFeedbackBuffers","forEach","model","unbindBuffers","bindBuffers","render","_feedbackBuffers","needsUpdate","stateHash","get","buffer","_setAnimationProps","animationProps","setBuffers","logLevel","logDrawTimeout","Date","now","group","collapsed","level","attributeTable","header","table","uniformTable","unusedTable","unusedCount","missingTable","count","missingCount","undefinedOnly","keys","configTable","configuration","message","groupEnd"],"sources":["../../../src/lib/model.js"],"sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}