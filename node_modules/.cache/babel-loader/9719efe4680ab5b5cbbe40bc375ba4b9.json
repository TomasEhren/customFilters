{"ast":null,"code":"import AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\nlet requestId = 0;\nlet inputBatches;\nlet options;\nexport function createWorker(process, processInBatches) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context = {\n    process: processOnMainThread\n  };\n\n  WorkerBody.onmessage = async (type, payload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {\n            result\n          });\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n\n          inputBatches = new AsyncQueue();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {\n              result: batch\n            });\n          }\n\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {\n        error: message\n      });\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    const payload = {\n      id,\n      input: arrayBuffer,\n      options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}","map":{"version":3,"mappings":"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","names":["AsyncQueue","WorkerBody","requestId","inputBatches","options","createWorker","process","processInBatches","self","context","processOnMainThread","onmessage","type","payload","Error","result","input","postMessage","resultIterator","batch","push","close","error","message","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"sources":["../../../../src/lib/worker-api/create-worker.ts"],"sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches: AsyncQueue<any>;\nlet options: {[key: string]: any};\n\nexport type ProcessOnMainThread = (\n  data: any,\n  options?: {[key: string]: any},\n  context?: WorkerContext\n) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue<any>();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer: ArrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type: string, payload: WorkerMessagePayload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}