{"ast":null,"code":"import { isSVG, getBlob } from './svg-utils';\nimport parseToImage from './parse-to-image';\nconst EMPTY_OBJECT = {};\nlet imagebitmapOptionsSupported = true;\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  if (isSVG(url)) {\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\nasync function safeCreateImageBitmap(blob) {\n  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error);\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"mappings":"AACA,SAAQA,KAAR,EAAeC,OAAf,QAA6B,aAA7B;AACA,OAAOC,YAAP,MAAyB,kBAAzB;AAEA,MAAMC,YAAY,GAAG,EAArB;AAEA,IAAIC,2BAA2B,GAAG,IAAlC;AASA,eAAe,eAAeC,kBAAf,CACbC,WADa,EAEbC,OAFa,EAGbC,GAHa,EAIS;EACtB,IAAIC,IAAJ;;EAGA,IAAIT,KAAK,CAACQ,GAAD,CAAT,EAAgB;IAEd,MAAME,KAAK,GAAG,MAAMR,YAAY,CAACI,WAAD,EAAcC,OAAd,EAAuBC,GAAvB,CAAhC;IACAC,IAAI,GAAGC,KAAPD;EAHF,OAIO;IAELA,IAAI,GAAGR,OAAO,CAACK,WAAD,EAAcE,GAAd,CAAdC;EACD;;EAED,MAAME,kBAAkB,GAAGJ,OAAO,IAAIA,OAAO,CAACK,WAA9C;EAEA,OAAO,MAAMC,qBAAqB,CAACJ,IAAD,EAAOE,kBAAP,CAAlC;AACD;;AAQD,eAAeE,qBAAf,CACEJ,IADF,EAGwB;EAAA,IADtBE,kBACsB,uEAD0B,IAC1B;;EACtB,IAAIG,aAAa,CAACH,kBAAD,CAAbG,IAAqC,CAACV,2BAA1C,EAAuE;IACrEO,kBAAkB,GAAG,IAArBA;EACD;;EAED,IAAIA,kBAAJ,EAAwB;IACtB,IAAI;MAEF,OAAO,MAAMI,iBAAiB,CAACN,IAAD,EAAOE,kBAAP,CAA9B;IAFF,EAGE,OAAOK,KAAP,EAAc;MACdC,OAAO,CAACC,IAARD,CAAaD,KAAbC;MACAb,2BAA2B,GAAG,KAA9BA;IACD;EACF;;EAED,OAAO,MAAMW,iBAAiB,CAACN,IAAD,CAA9B;AACD;;AAED,SAASK,aAAT,CAAuBK,MAAvB,EAA+B;EAE7B,KAAK,MAAMC,GAAX,IAAkBD,MAAM,IAAIhB,YAA5B,EAA0C;IACxC,OAAO,KAAP;EACD;;EACD,OAAO,IAAP;AACD","names":["isSVG","getBlob","parseToImage","EMPTY_OBJECT","imagebitmapOptionsSupported","parseToImageBitmap","arrayBuffer","options","url","blob","image","imagebitmapOptions","imagebitmap","safeCreateImageBitmap","isEmptyObject","createImageBitmap","error","console","warn","object","key"],"sources":["../../../../src/lib/parsers/parse-to-image-bitmap.ts"],"sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<ImageBitmap> {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(\n  blob: Blob,\n  imagebitmapOptions: ImageBitmapOptions | null = null\n): Promise<ImageBitmap> {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  // @ts-ignore\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}