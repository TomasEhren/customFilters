{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Framebuffer, Texture2D, isWebGL2, readPixelsToArray, cssToDeviceRatio, cssToDevicePixels } from '@luma.gl/core';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport { getClosestObject, getUniqueObjects } from './picking/query-object';\nimport { processPickInfo, getLayerPickingInfo, getEmptyPickingInfo } from './picking/pick-info';\n\nvar DeckPicker = /*#__PURE__*/function () {\n  function DeckPicker(gl) {\n    _classCallCheck(this, DeckPicker);\n\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  _createClass(DeckPicker, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('layerFilter' in props) {\n        this.layerFilter = props.layerFilter;\n      }\n\n      if ('_pickable' in props) {\n        this._pickable = props._pickable;\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.pickingFBO) {\n        this.pickingFBO.delete();\n      }\n\n      if (this.depthFBO) {\n        this.depthFBO.color.delete();\n        this.depthFBO.delete();\n      }\n    }\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(opts) {\n      return this._pickClosestObject(opts);\n    }\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(opts) {\n      return this._pickVisibleObjects(opts);\n    }\n  }, {\n    key: \"getLastPickedObject\",\n    value: function getLastPickedObject(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          layers = _ref.layers,\n          viewports = _ref.viewports;\n      var lastPickedInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.lastPickedInfo.info;\n      var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n      var lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n      var layer = lastPickedLayerId ? layers.find(function (l) {\n        return l.id === lastPickedLayerId;\n      }) : null;\n      var viewport = lastPickedViewportId && viewports.find(function (v) {\n        return v.id === lastPickedViewportId;\n      }) || viewports[0];\n      var coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n      var info = {\n        x: x,\n        y: y,\n        viewport: viewport,\n        coordinate: coordinate,\n        layer: layer\n      };\n      return _objectSpread(_objectSpread({}, lastPickedInfo), info);\n    }\n  }, {\n    key: \"_resizeBuffer\",\n    value: function _resizeBuffer() {\n      var gl = this.gl;\n\n      if (!this.pickingFBO) {\n        this.pickingFBO = new Framebuffer(gl);\n\n        if (Framebuffer.isSupported(gl, {\n          colorBufferFloat: true\n        })) {\n          this.depthFBO = new Framebuffer(gl);\n          this.depthFBO.attach(_defineProperty({}, 36064, new Texture2D(gl, {\n            format: isWebGL2(gl) ? 34836 : 6408,\n            type: 5126\n          })));\n        }\n      }\n\n      this.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n\n      if (this.depthFBO) {\n        this.depthFBO.resize({\n          width: gl.canvas.width,\n          height: gl.canvas.height\n        });\n      }\n\n      return this.pickingFBO;\n    }\n  }, {\n    key: \"_getPickable\",\n    value: function _getPickable(layers) {\n      if (this._pickable === false) {\n        return null;\n      }\n\n      var pickableLayers = layers.filter(function (layer) {\n        return layer.isPickable() && !layer.isComposite;\n      });\n      return pickableLayers.length ? pickableLayers : null;\n    }\n  }, {\n    key: \"_pickClosestObject\",\n    value: function _pickClosestObject(_ref2) {\n      var layers = _ref2.layers,\n          views = _ref2.views,\n          viewports = _ref2.viewports,\n          x = _ref2.x,\n          y = _ref2.y,\n          _ref2$radius = _ref2.radius,\n          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,\n          _ref2$depth = _ref2.depth,\n          depth = _ref2$depth === void 0 ? 1 : _ref2$depth,\n          _ref2$mode = _ref2.mode,\n          mode = _ref2$mode === void 0 ? 'query' : _ref2$mode,\n          unproject3D = _ref2.unproject3D,\n          onViewportActive = _ref2.onViewportActive,\n          effects = _ref2.effects;\n      layers = this._getPickable(layers);\n\n      if (!layers) {\n        return {\n          result: [],\n          emptyInfo: getEmptyPickingInfo({\n            viewports: viewports,\n            x: x,\n            y: y\n          })\n        };\n      }\n\n      this._resizeBuffer();\n\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n      var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];\n      var deviceRadius = Math.round(radius * pixelRatio);\n      var _this$pickingFBO = this.pickingFBO,\n          width = _this$pickingFBO.width,\n          height = _this$pickingFBO.height;\n\n      var deviceRect = this._getPickingRect({\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius: deviceRadius,\n        deviceWidth: width,\n        deviceHeight: height\n      });\n\n      var infos;\n      var result = [];\n      var affectedLayers = new Set();\n\n      for (var i = 0; i < depth; i++) {\n        var pickedResult = deviceRect && this._drawAndSample({\n          layers: layers,\n          views: views,\n          viewports: viewports,\n          onViewportActive: onViewportActive,\n          deviceRect: deviceRect,\n          effects: effects,\n          pass: \"picking:\".concat(mode),\n          redrawReason: mode\n        });\n\n        var pickInfo = getClosestObject(_objectSpread(_objectSpread({}, pickedResult), {}, {\n          deviceX: devicePixel[0],\n          deviceY: devicePixel[1],\n          deviceRadius: deviceRadius,\n          deviceRect: deviceRect\n        }));\n        var z = void 0;\n\n        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n          var pickedResultPass2 = this._drawAndSample({\n            layers: [pickInfo.pickedLayer],\n            views: views,\n            viewports: viewports,\n            onViewportActive: onViewportActive,\n            deviceRect: {\n              x: pickInfo.pickedX,\n              y: pickInfo.pickedY,\n              width: 1,\n              height: 1\n            },\n            effects: effects,\n            pass: \"picking:\".concat(mode),\n            redrawReason: 'pick-z',\n            pickZ: true\n          });\n\n          z = pickedResultPass2.pickedColors[0];\n        }\n\n        if (pickInfo.pickedLayer && i + 1 < depth) {\n          affectedLayers.add(pickInfo.pickedLayer);\n          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n        }\n\n        infos = processPickInfo({\n          pickInfo: pickInfo,\n          lastPickedInfo: this.lastPickedInfo,\n          mode: mode,\n          layers: layers,\n          viewports: viewports,\n          x: x,\n          y: y,\n          z: z,\n          pixelRatio: pixelRatio\n        });\n\n        var _iterator = _createForOfIteratorHelper(infos.values()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var info = _step.value;\n\n            if (info.layer) {\n              result.push(info);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!pickInfo.pickedColor) {\n          break;\n        }\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(affectedLayers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          layer.restorePickingColors();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        result: result,\n        emptyInfo: infos && infos.get(null)\n      };\n    }\n  }, {\n    key: \"_pickVisibleObjects\",\n    value: function _pickVisibleObjects(_ref3) {\n      var layers = _ref3.layers,\n          views = _ref3.views,\n          viewports = _ref3.viewports,\n          x = _ref3.x,\n          y = _ref3.y,\n          _ref3$width = _ref3.width,\n          width = _ref3$width === void 0 ? 1 : _ref3$width,\n          _ref3$height = _ref3.height,\n          height = _ref3$height === void 0 ? 1 : _ref3$height,\n          _ref3$mode = _ref3.mode,\n          mode = _ref3$mode === void 0 ? 'query' : _ref3$mode,\n          _ref3$maxObjects = _ref3.maxObjects,\n          maxObjects = _ref3$maxObjects === void 0 ? null : _ref3$maxObjects,\n          onViewportActive = _ref3.onViewportActive,\n          effects = _ref3.effects;\n      layers = this._getPickable(layers);\n\n      if (!layers) {\n        return [];\n      }\n\n      this._resizeBuffer();\n\n      var pixelRatio = cssToDeviceRatio(this.gl);\n      var leftTop = cssToDevicePixels(this.gl, [x, y], true);\n      var deviceLeft = leftTop.x;\n      var deviceTop = leftTop.y + leftTop.height;\n      var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n      var deviceRight = rightBottom.x + rightBottom.width;\n      var deviceBottom = rightBottom.y;\n      var deviceRect = {\n        x: deviceLeft,\n        y: deviceBottom,\n        width: deviceRight - deviceLeft,\n        height: deviceTop - deviceBottom\n      };\n\n      var pickedResult = this._drawAndSample({\n        layers: layers,\n        views: views,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        deviceRect: deviceRect,\n        effects: effects,\n        pass: \"picking:\".concat(mode),\n        redrawReason: mode\n      });\n\n      var pickInfos = getUniqueObjects(pickedResult);\n      var uniqueInfos = new Map();\n      var isMaxObjects = Number.isFinite(maxObjects);\n\n      for (var i = 0; i < pickInfos.length; i++) {\n        if (isMaxObjects && uniqueInfos.size >= maxObjects) {\n          break;\n        }\n\n        var pickInfo = pickInfos[i];\n        var info = {\n          color: pickInfo.pickedColor,\n          layer: null,\n          index: pickInfo.pickedObjectIndex,\n          picked: true,\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          pixelRatio: pixelRatio\n        };\n        info = getLayerPickingInfo({\n          layer: pickInfo.pickedLayer,\n          info: info,\n          mode: mode\n        });\n\n        if (!uniqueInfos.has(info.object)) {\n          uniqueInfos.set(info.object, info);\n        }\n      }\n\n      return Array.from(uniqueInfos.values());\n    }\n  }, {\n    key: \"_drawAndSample\",\n    value: function _drawAndSample(_ref4) {\n      var layers = _ref4.layers,\n          views = _ref4.views,\n          viewports = _ref4.viewports,\n          onViewportActive = _ref4.onViewportActive,\n          deviceRect = _ref4.deviceRect,\n          effects = _ref4.effects,\n          pass = _ref4.pass,\n          redrawReason = _ref4.redrawReason,\n          pickZ = _ref4.pickZ;\n      var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n      var _this$pickLayersPass$ = this.pickLayersPass.render({\n        layers: layers,\n        layerFilter: this.layerFilter,\n        views: views,\n        viewports: viewports,\n        onViewportActive: onViewportActive,\n        pickingFBO: pickingFBO,\n        deviceRect: deviceRect,\n        effects: effects,\n        pass: pass,\n        redrawReason: redrawReason,\n        pickZ: pickZ\n      }),\n          decodePickingColor = _this$pickLayersPass$.decodePickingColor;\n\n      var x = deviceRect.x,\n          y = deviceRect.y,\n          width = deviceRect.width,\n          height = deviceRect.height;\n      var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n      readPixelsToArray(pickingFBO, {\n        sourceX: x,\n        sourceY: y,\n        sourceWidth: width,\n        sourceHeight: height,\n        target: pickedColors\n      });\n      return {\n        pickedColors: pickedColors,\n        decodePickingColor: decodePickingColor\n      };\n    }\n  }, {\n    key: \"_getPickingRect\",\n    value: function _getPickingRect(_ref5) {\n      var deviceX = _ref5.deviceX,\n          deviceY = _ref5.deviceY,\n          deviceRadius = _ref5.deviceRadius,\n          deviceWidth = _ref5.deviceWidth,\n          deviceHeight = _ref5.deviceHeight;\n      var x = Math.max(0, deviceX - deviceRadius);\n      var y = Math.max(0, deviceY - deviceRadius);\n      var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n      var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n      if (width <= 0 || height <= 0) {\n        return null;\n      }\n\n      return {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n    }\n  }]);\n\n  return DeckPicker;\n}();\n\nexport { DeckPicker as default };","map":{"version":3,"mappings":"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","names":["Framebuffer","Texture2D","isWebGL2","readPixelsToArray","cssToDeviceRatio","cssToDevicePixels","PickLayersPass","getClosestObject","getUniqueObjects","processPickInfo","getLayerPickingInfo","getEmptyPickingInfo","DeckPicker","constructor","gl","pickingFBO","pickLayersPass","layerFilter","lastPickedInfo","index","layerId","info","setProps","props","_pickable","finalize","delete","depthFBO","color","pickObject","opts","_pickClosestObject","pickObjects","_pickVisibleObjects","getLastPickedObject","x","y","layers","viewports","lastPickedLayerId","layer","id","lastPickedViewportId","viewport","find","l","v","coordinate","unproject","_resizeBuffer","isSupported","colorBufferFloat","attach","format","type","resize","width","canvas","height","_getPickable","pickableLayers","filter","isPickable","isComposite","length","views","radius","depth","mode","unproject3D","onViewportActive","effects","result","emptyInfo","pixelRatio","devicePixelRange","devicePixel","Math","floor","deviceRadius","round","deviceRect","_getPickingRect","deviceX","deviceY","deviceWidth","deviceHeight","infos","affectedLayers","Set","i","pickedResult","_drawAndSample","pass","redrawReason","pickInfo","z","pickedLayer","pickedResultPass2","pickedX","pickedY","pickZ","pickedColors","add","disablePickingIndex","pickedObjectIndex","values","push","pickedColor","restorePickingColors","get","maxObjects","leftTop","deviceLeft","deviceTop","rightBottom","deviceRight","deviceBottom","pickInfos","uniqueInfos","Map","isMaxObjects","Number","isFinite","size","picked","has","object","set","Array","from","render","decodePickingColor","Float32Array","Uint8Array","sourceX","sourceY","sourceWidth","sourceHeight","target","max","min"],"sources":["../../../src/lib/deck-picker.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {\n  Framebuffer,\n  Texture2D,\n  isWebGL2,\n  readPixelsToArray,\n  cssToDeviceRatio,\n  cssToDevicePixels\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport PickLayersPass from '../passes/pick-layers-pass';\nimport {getClosestObject, getUniqueObjects} from './picking/query-object';\nimport {processPickInfo, getLayerPickingInfo, getEmptyPickingInfo} from './picking/pick-info';\n\nexport default class DeckPicker {\n  constructor(gl) {\n    this.gl = gl;\n    this.pickingFBO = null;\n    this.pickLayersPass = new PickLayersPass(gl);\n    this.layerFilter = null;\n    this.lastPickedInfo = {\n      // For callback tracking and auto highlight\n      index: -1,\n      layerId: null,\n      info: null\n    };\n  }\n\n  setProps(props) {\n    if ('layerFilter' in props) {\n      this.layerFilter = props.layerFilter;\n    }\n\n    if ('_pickable' in props) {\n      this._pickable = props._pickable;\n    }\n  }\n\n  finalize() {\n    if (this.pickingFBO) {\n      this.pickingFBO.delete();\n    }\n    if (this.depthFBO) {\n      this.depthFBO.color.delete();\n      this.depthFBO.delete();\n    }\n  }\n\n  // Pick the closest info at given coordinate\n  pickObject(opts) {\n    return this._pickClosestObject(opts);\n  }\n\n  // Get all unique infos within a bounding box\n  pickObjects(opts) {\n    return this._pickVisibleObjects(opts);\n  }\n\n  // Returns a new picking info object by assuming the last picked object is still picked\n  getLastPickedObject({x, y, layers, viewports}, lastPickedInfo = this.lastPickedInfo.info) {\n    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;\n    const lastPickedViewportId =\n      lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;\n    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;\n    const viewport =\n      (lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId)) || viewports[0];\n    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);\n\n    const info = {\n      x,\n      y,\n      viewport,\n      coordinate,\n      layer\n    };\n\n    return {...lastPickedInfo, ...info};\n  }\n\n  // Private\n  _resizeBuffer() {\n    const {gl} = this;\n\n    // Create a frame buffer if not already available\n    if (!this.pickingFBO) {\n      this.pickingFBO = new Framebuffer(gl);\n      if (Framebuffer.isSupported(gl, {colorBufferFloat: true})) {\n        this.depthFBO = new Framebuffer(gl);\n        this.depthFBO.attach({\n          [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n            format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n            type: GL.FLOAT\n          })\n        });\n      }\n    }\n    // Resize it to current canvas size (this is a noop if size hasn't changed)\n    this.pickingFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    if (this.depthFBO) {\n      this.depthFBO.resize({width: gl.canvas.width, height: gl.canvas.height});\n    }\n    return this.pickingFBO;\n  }\n\n  // picking can only handle up to 255 layers. Drop non-pickable/invisible layers from the list.\n  _getPickable(layers) {\n    if (this._pickable === false) {\n      return null;\n    }\n    const pickableLayers = layers.filter(layer => layer.isPickable() && !layer.isComposite);\n    return pickableLayers.length ? pickableLayers : null;\n  }\n\n  // Pick the closest object at the given (x,y) coordinate\n  // eslint-disable-next-line max-statements,complexity\n  _pickClosestObject({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    radius = 0,\n    depth = 1,\n    mode = 'query',\n    unproject3D,\n    onViewportActive,\n    effects\n  }) {\n    layers = this._getPickable(layers);\n\n    if (!layers) {\n      return {\n        result: [],\n        emptyInfo: getEmptyPickingInfo({viewports, x, y})\n      };\n    }\n\n    this._resizeBuffer();\n\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // Top-left coordinates [x, y] to bottom-left coordinates [deviceX, deviceY]\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);\n    const devicePixel = [\n      devicePixelRange.x + Math.floor(devicePixelRange.width / 2),\n      devicePixelRange.y + Math.floor(devicePixelRange.height / 2)\n    ];\n\n    const deviceRadius = Math.round(radius * pixelRatio);\n    const {width, height} = this.pickingFBO;\n    const deviceRect = this._getPickingRect({\n      deviceX: devicePixel[0],\n      deviceY: devicePixel[1],\n      deviceRadius,\n      deviceWidth: width,\n      deviceHeight: height\n    });\n\n    let infos;\n    const result = [];\n    const affectedLayers = new Set();\n\n    for (let i = 0; i < depth; i++) {\n      const pickedResult =\n        deviceRect &&\n        this._drawAndSample({\n          layers,\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect,\n          effects,\n          pass: `picking:${mode}`,\n          redrawReason: mode\n        });\n\n      const pickInfo = getClosestObject({\n        ...pickedResult,\n        deviceX: devicePixel[0],\n        deviceY: devicePixel[1],\n        deviceRadius,\n        deviceRect\n      });\n\n      let z;\n      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {\n        const pickedResultPass2 = this._drawAndSample({\n          layers: [pickInfo.pickedLayer],\n          views,\n          viewports,\n          onViewportActive,\n          deviceRect: {x: pickInfo.pickedX, y: pickInfo.pickedY, width: 1, height: 1},\n          effects,\n          pass: `picking:${mode}`,\n          redrawReason: 'pick-z',\n          pickZ: true\n        });\n        // picked value is in common space (pixels) from the camera target (viewport.position)\n        // convert it to meters from the ground\n        z = pickedResultPass2.pickedColors[0];\n      }\n\n      // Only exclude if we need to run picking again.\n      // We need to run picking again if an object is detected AND\n      // we have not exhausted the requested depth.\n      if (pickInfo.pickedLayer && i + 1 < depth) {\n        affectedLayers.add(pickInfo.pickedLayer);\n        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);\n      }\n\n      // This logic needs to run even if no object is picked.\n      infos = processPickInfo({\n        pickInfo,\n        lastPickedInfo: this.lastPickedInfo,\n        mode,\n        layers,\n        viewports,\n        x,\n        y,\n        z,\n        pixelRatio\n      });\n\n      for (const info of infos.values()) {\n        if (info.layer) {\n          result.push(info);\n        }\n      }\n\n      // If no object is picked stop.\n      if (!pickInfo.pickedColor) {\n        break;\n      }\n    }\n\n    // reset only affected buffers\n    for (const layer of affectedLayers) {\n      layer.restorePickingColors();\n    }\n\n    return {result, emptyInfo: infos && infos.get(null)};\n  }\n\n  // Pick all objects within the given bounding box\n  _pickVisibleObjects({\n    layers,\n    views,\n    viewports,\n    x,\n    y,\n    width = 1,\n    height = 1,\n    mode = 'query',\n    maxObjects = null,\n    onViewportActive,\n    effects\n  }) {\n    layers = this._getPickable(layers);\n\n    if (!layers) {\n      return [];\n    }\n\n    this._resizeBuffer();\n    // Convert from canvas top-left to WebGL bottom-left coordinates\n    // And compensate for pixelRatio\n    const pixelRatio = cssToDeviceRatio(this.gl);\n    const leftTop = cssToDevicePixels(this.gl, [x, y], true);\n\n    // take left and top (y inverted in device pixels) from start location\n    const deviceLeft = leftTop.x;\n    const deviceTop = leftTop.y + leftTop.height;\n\n    // take right and bottom (y inverted in device pixels) from end location\n    const rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);\n    const deviceRight = rightBottom.x + rightBottom.width;\n    const deviceBottom = rightBottom.y;\n\n    const deviceRect = {\n      x: deviceLeft,\n      y: deviceBottom,\n      // deviceTop and deviceRight represent the first pixel outside the desired rect\n      width: deviceRight - deviceLeft,\n      height: deviceTop - deviceBottom\n    };\n\n    const pickedResult = this._drawAndSample({\n      layers,\n      views,\n      viewports,\n      onViewportActive,\n      deviceRect,\n      effects,\n      pass: `picking:${mode}`,\n      redrawReason: mode\n    });\n\n    const pickInfos = getUniqueObjects(pickedResult);\n\n    // Only return unique infos, identified by info.object\n    const uniqueInfos = new Map();\n\n    const isMaxObjects = Number.isFinite(maxObjects);\n\n    for (let i = 0; i < pickInfos.length; i++) {\n      if (isMaxObjects && uniqueInfos.size >= maxObjects) {\n        break;\n      }\n      const pickInfo = pickInfos[i];\n      let info = {\n        color: pickInfo.pickedColor,\n        layer: null,\n        index: pickInfo.pickedObjectIndex,\n        picked: true,\n        x,\n        y,\n        width,\n        height,\n        pixelRatio\n      };\n\n      info = getLayerPickingInfo({layer: pickInfo.pickedLayer, info, mode});\n      if (!uniqueInfos.has(info.object)) {\n        uniqueInfos.set(info.object, info);\n      }\n    }\n\n    return Array.from(uniqueInfos.values());\n  }\n\n  // returns pickedColor or null if no pickable layers found.\n  _drawAndSample({\n    layers,\n    views,\n    viewports,\n    onViewportActive,\n    deviceRect,\n    effects,\n    pass,\n    redrawReason,\n    pickZ\n  }) {\n    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;\n\n    const {decodePickingColor} = this.pickLayersPass.render({\n      layers,\n      layerFilter: this.layerFilter,\n      views,\n      viewports,\n      onViewportActive,\n      pickingFBO,\n      deviceRect,\n      effects,\n      pass,\n      redrawReason,\n      pickZ\n    });\n\n    // Read from an already rendered picking buffer\n    // Returns an Uint8ClampedArray of picked pixels\n    const {x, y, width, height} = deviceRect;\n    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);\n    readPixelsToArray(pickingFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: width,\n      sourceHeight: height,\n      target: pickedColors\n    });\n\n    return {pickedColors, decodePickingColor};\n  }\n\n  // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n  // Returns null if pixel is outside of device\n  _getPickingRect({deviceX, deviceY, deviceRadius, deviceWidth, deviceHeight}) {\n    // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n    const x = Math.max(0, deviceX - deviceRadius);\n    const y = Math.max(0, deviceY - deviceRadius);\n    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;\n    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;\n\n    // x, y out of bounds.\n    if (width <= 0 || height <= 0) {\n      return null;\n    }\n\n    return {x, y, width, height};\n  }\n}\n"]},"metadata":{},"sourceType":"module"}