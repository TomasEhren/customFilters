{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { concatenateTypedArrays } from '@loaders.gl/loader-utils';\nexport function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {\n  var outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);\n  var newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  var newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n  var newTriangles = new triangles.constructor(outsideEdges.length * 6);\n\n  for (var i = 0; i < outsideEdges.length; i++) {\n    var edge = outsideEdges[i];\n    updateAttributesForNewEdge({\n      edge: edge,\n      edgeIndex: i,\n      attributes: attributes,\n      skirtHeight: skirtHeight,\n      newPosition: newPosition,\n      newTexcoord0: newTexcoord0,\n      newTriangles: newTriangles\n    });\n  }\n\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  var resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);\n  return {\n    attributes: attributes,\n    triangles: resultTriangles\n  };\n}\n\nfunction getOutsideEdgesFromTriangles(triangles) {\n  var edges = [];\n\n  for (var i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n\n  edges.sort(function (a, b) {\n    return Math.min.apply(Math, _toConsumableArray(a)) - Math.min.apply(Math, _toConsumableArray(b)) || Math.max.apply(Math, _toConsumableArray(a)) - Math.max.apply(Math, _toConsumableArray(b));\n  });\n  var outsideEdges = [];\n  var index = 0;\n\n  while (index < edges.length) {\n    var _edges, _edges2;\n\n    if (edges[index][0] === ((_edges = edges[index + 1]) === null || _edges === void 0 ? void 0 : _edges[1]) && edges[index][1] === ((_edges2 = edges[index + 1]) === null || _edges2 === void 0 ? void 0 : _edges2[0])) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index]);\n      index++;\n    }\n  }\n\n  return outsideEdges;\n}\n\nfunction getOutsideEdgesFromIndices(indices, position) {\n  indices.westIndices.sort(function (a, b) {\n    return position[3 * a + 1] - position[3 * b + 1];\n  });\n  indices.eastIndices.sort(function (a, b) {\n    return position[3 * b + 1] - position[3 * a + 1];\n  });\n  indices.southIndices.sort(function (a, b) {\n    return position[3 * b] - position[3 * a];\n  });\n  indices.northIndices.sort(function (a, b) {\n    return position[3 * a] - position[3 * b];\n  });\n  var edges = [];\n\n  for (var index in indices) {\n    var indexGroup = indices[index];\n\n    for (var i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n\n  return edges;\n}\n\nfunction updateAttributesForNewEdge(_ref) {\n  var edge = _ref.edge,\n      edgeIndex = _ref.edgeIndex,\n      attributes = _ref.attributes,\n      skirtHeight = _ref.skirtHeight,\n      newPosition = _ref.newPosition,\n      newTexcoord0 = _ref.newTexcoord0,\n      newTriangles = _ref.newTriangles;\n  var positionsLength = attributes.POSITION.value.length;\n  var vertex1Offset = edgeIndex * 2;\n  var vertex2Offset = edgeIndex * 2 + 1;\n  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;\n  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);\n  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);\n  var triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = edge[1];\n  newTriangles[triangle1Offset + 2] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = positionsLength / 3 + vertex1Offset;\n  newTriangles[triangle1Offset + 5] = edge[0];\n}","map":{"version":3,"mappings":"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","names":["concatenateTypedArrays","addSkirt","attributes","triangles","skirtHeight","outsideIndices","outsideEdges","getOutsideEdgesFromIndices","POSITION","value","getOutsideEdgesFromTriangles","newPosition","constructor","length","newTexcoord0","TEXCOORD_0","newTriangles","i","edge","updateAttributesForNewEdge","edgeIndex","resultTriangles","Array","concat","edges","push","sort","a","b","Math","min","max","index","_edges","_edges2","indices","position","westIndices","eastIndices","southIndices","northIndices","indexGroup","positionsLength","vertex1Offset","vertex2Offset","set","subarray","triangle1Offset"],"sources":["../../../../src/lib/helpers/skirt.ts"],"sourcesContent":["import {concatenateTypedArrays} from '@loaders.gl/loader-utils';\n\nexport type EdgeIndices = {\n  westIndices: number[];\n  northIndices: number[];\n  eastIndices: number[];\n  southIndices: number[];\n};\n\n/**\n * Add skirt to existing mesh\n * @param {object} attributes - POSITION and TEXCOOD_0 attributes data\n * @param {any} triangles - indices array of the mesh geometry\n * @param skirtHeight - height of the skirt geometry\n * @param outsideIndices - edge indices from quantized mesh data\n * @returns - geometry data with added skirt\n */\nexport function addSkirt(attributes, triangles, skirtHeight: number, outsideIndices?: EdgeIndices) {\n  const outsideEdges = outsideIndices\n    ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value)\n    : getOutsideEdgesFromTriangles(triangles);\n\n  // 2 new vertices for each outside edge\n  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);\n  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);\n\n  // 2 new triangles for each outside edge\n  const newTriangles = new triangles.constructor(outsideEdges.length * 6);\n\n  for (let i = 0; i < outsideEdges.length; i++) {\n    const edge = outsideEdges[i];\n\n    updateAttributesForNewEdge({\n      edge,\n      edgeIndex: i,\n      attributes,\n      skirtHeight,\n      newPosition,\n      newTexcoord0,\n      newTriangles\n    });\n  }\n\n  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);\n  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);\n  const resultTriangles =\n    triangles instanceof Array\n      ? triangles.concat(newTriangles)\n      : concatenateTypedArrays(triangles, newTriangles);\n\n  return {\n    attributes,\n    triangles: resultTriangles\n  };\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {any} triangles - indices array of the mesh geometry\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromTriangles(triangles) {\n  const edges: number[][] = [];\n  for (let i = 0; i < triangles.length; i += 3) {\n    edges.push([triangles[i], triangles[i + 1]]);\n    edges.push([triangles[i + 1], triangles[i + 2]]);\n    edges.push([triangles[i + 2], triangles[i]]);\n  }\n\n  edges.sort((a, b) => Math.min(...a) - Math.min(...b) || Math.max(...a) - Math.max(...b));\n\n  const outsideEdges: number[][] = [];\n  let index = 0;\n  while (index < edges.length) {\n    if (edges[index][0] === edges[index + 1]?.[1] && edges[index][1] === edges[index + 1]?.[0]) {\n      index += 2;\n    } else {\n      outsideEdges.push(edges[index]);\n      index++;\n    }\n  }\n  return outsideEdges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} indices - edge indices from quantized mesh data\n * @param {TypedArray} position - position attribute geometry data\n * @returns {number[][]} - outside edges data\n */\nfunction getOutsideEdgesFromIndices(indices: EdgeIndices, position) {\n  // Sort skirt indices to create adjacent triangles\n  indices.westIndices.sort((a, b) => position[3 * a + 1] - position[3 * b + 1]);\n  // Reverse (b - a) to match triangle winding\n  indices.eastIndices.sort((a, b) => position[3 * b + 1] - position[3 * a + 1]);\n  indices.southIndices.sort((a, b) => position[3 * b] - position[3 * a]);\n  // Reverse (b - a) to match triangle winding\n  indices.northIndices.sort((a, b) => position[3 * a] - position[3 * b]);\n\n  const edges: number[][] = [];\n  for (const index in indices) {\n    const indexGroup = indices[index];\n    for (let i = 0; i < indexGroup.length - 1; i++) {\n      edges.push([indexGroup[i], indexGroup[i + 1]]);\n    }\n  }\n  return edges;\n}\n\n/**\n * Get geometry edges that located on a border of the mesh\n * @param {object} args\n * @param {number[]} args.edge - edge indices in geometry\n * @param {number} args.edgeIndex - edge index in outsideEdges array\n * @param {object} args.attributes - POSITION and TEXCOORD_0 attributes\n * @param {number} args.skirtHeight - height of the skirt geometry\n * @param {TypedArray} args.newPosition - POSITION array for skirt data\n * @param {TypedArray} args.newTexcoord0 - TEXCOORD_0 array for skirt data\n * @param {TypedArray | Array} args.newTriangles - trinagle indices array for skirt data\n * @returns {void}\n */\nfunction updateAttributesForNewEdge({\n  edge,\n  edgeIndex,\n  attributes,\n  skirtHeight,\n  newPosition,\n  newTexcoord0,\n  newTriangles\n}) {\n  const positionsLength = attributes.POSITION.value.length;\n  const vertex1Offset = edgeIndex * 2;\n  const vertex2Offset = edgeIndex * 2 + 1;\n\n  // Define POSITION for new 1st vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3),\n    vertex1Offset * 3\n  );\n  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Define POSITION for new 2nd vertex\n  newPosition.set(\n    attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3),\n    vertex2Offset * 3\n  );\n  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight; // put down elevation on the skirt height\n\n  // Use same TEXCOORDS for skirt vertices\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2),\n    vertex1Offset * 2\n  );\n  newTexcoord0.set(\n    attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2),\n    vertex2Offset * 2\n  );\n\n  // Define new triangles\n  const triangle1Offset = edgeIndex * 2 * 3;\n  newTriangles[triangle1Offset] = edge[0];\n  newTriangles[triangle1Offset + 1] = edge[1];\n  newTriangles[triangle1Offset + 2] = positionsLength / 3 + vertex2Offset;\n\n  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;\n  newTriangles[triangle1Offset + 4] = positionsLength / 3 + vertex1Offset;\n  newTriangles[triangle1Offset + 5] = edge[0];\n}\n"]},"metadata":{},"sourceType":"module"}