{"ast":null,"code":"import { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nconst REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\nexport default class GPUGridAggregator {\n  static getAggregationData(_ref) {\n    let {\n      aggregationData,\n      maxData,\n      minData,\n      maxMinData,\n      pixelIndex\n    } = _ref;\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n\n    return results;\n  }\n\n  static getCellData(_ref2) {\n    let {\n      countsData,\n      size = 1\n    } = _ref2;\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n\n    for (let i = 0; i < numCells; i++) {\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n\n    return {\n      cellCounts,\n      cellWeights\n    };\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  delete() {\n    const {\n      gridAggregationModel,\n      allAggregationModel,\n      meanTransform\n    } = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n    gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n    allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n    meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n    deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n  }\n\n  run() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      results: {}\n    });\n\n    const aggregationParams = this._normalizeAggregationParams(opts);\n\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n\n    return this._runAggregation(aggregationParams);\n  }\n\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n\n    if (!results[weightId].aggregationData) {\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n\n    data.aggregationData = results[weightId].aggregationData;\n\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n\n    return data;\n  }\n\n  updateShaders() {\n    let shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.setState({\n      shaderOptions,\n      modelDirty: true\n    });\n  }\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = { ...DEFAULT_RUN_PARAMS,\n      ...opts\n    };\n    const {\n      weights\n    } = aggregationParams;\n\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n\n    return aggregationParams;\n  }\n\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {\n        needMin,\n        needMax,\n        combineMaxMin\n      } = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer,\n        sourceType: 5126\n      });\n\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer,\n          sourceType: 5126\n        });\n        results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer,\n            sourceType: 5126\n          });\n          results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n        }\n\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer,\n            sourceType: 5126\n          });\n          results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n        }\n      }\n    }\n\n    this._trackGPUResultBuffers(results, weights);\n\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers\n    } = this.state;\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [1, 1]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax\n      } = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: { ...parameters,\n            blendEquation: MAX_MIN_BLEND_EQUATION\n          },\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {\n            clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n          },\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MIN_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {\n              clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n            },\n            combineMaxMin\n          });\n        }\n\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: { ...parameters,\n              blendEquation: MAX_BLEND_EQUATION\n            },\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, 0]\n            },\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  _renderToMaxMinTexture(opts) {\n    const {\n      id,\n      parameters,\n      gridSize,\n      minOrMaxFb,\n      combineMaxMin,\n      clearParams = {}\n    } = opts;\n    const {\n      framebuffers\n    } = this.state;\n    const {\n      gl,\n      allAggregationModel\n    } = this;\n    withParameters(gl, { ...clearParams,\n      framebuffer: minOrMaxFb,\n      viewport: [0, 0, gridSize[0], gridSize[1]]\n    }, () => {\n      gl.clear(16384);\n      allAggregationModel.draw({\n        parameters,\n        uniforms: {\n          uSampler: framebuffers[id].texture,\n          gridSize,\n          combineMaxMin\n        }\n      });\n    });\n  }\n\n  _renderToWeightsTexture(opts) {\n    const {\n      id,\n      parameters,\n      moduleSettings,\n      uniforms,\n      gridSize,\n      weights\n    } = opts;\n    const {\n      framebuffers,\n      equations,\n      weightAttributes\n    } = this.state;\n    const {\n      gl,\n      gridAggregationModel\n    } = this;\n    const {\n      operation\n    } = weights[id];\n    const clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n    withParameters(gl, {\n      framebuffer: framebuffers[id],\n      viewport: [0, 0, gridSize[0], gridSize[1]],\n      clearColor\n    }, () => {\n      gl.clear(16384);\n      const attributes = {\n        weights: weightAttributes[id]\n      };\n      gridAggregationModel.draw({\n        parameters: { ...parameters,\n          blendEquation: equations[id]\n        },\n        moduleSettings,\n        uniforms,\n        attributes\n      });\n    });\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {\n        meanTextures,\n        textures\n      } = this.state;\n      const transformOptions = {\n        _sourceTextures: {\n          aggregationValues: meanTextures[id]\n        },\n        _targetTexture: textures[id],\n        elementCount: textures[id].width * textures[id].height\n      };\n\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n      framebuffers[id].attach({\n        [36064]: textures[id]\n      });\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n\n    this._setupFramebuffers(opts);\n\n    this._renderAggregateData(opts);\n\n    const results = this._getAggregateData(opts);\n\n    this.setState({\n      results\n    });\n    return results;\n  }\n\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {\n      weights\n    } = opts;\n    const {\n      numCol,\n      numRow\n    } = opts;\n    const framebufferSize = {\n      width: numCol,\n      height: numRow\n    };\n\n    for (const id in weights) {\n      const {\n        needMin,\n        needMax,\n        combineMaxMin,\n        operation\n      } = weights[id];\n      textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n        id: \"\".concat(id, \"-texture\"),\n        width: numCol,\n        height: numRow\n      });\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-mean-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n\n      if (framebuffers[id]) {\n        framebuffers[id].attach({\n          [36064]: texture\n        });\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: \"\".concat(id, \"-fb\"),\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n              id: \"\".concat(id, \"-maxMinFb\"),\n              texture\n            });\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-minFb\"),\n                texture\n              });\n            }\n          }\n\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxFb\"),\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n\n  _getMinMaxTexture(name) {\n    const {\n      resources\n    } = this.state;\n\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {\n        id: \"resourceName\"\n      });\n    }\n\n    return resources[name];\n  }\n\n  _setupModels() {\n    let {\n      numCol = 0,\n      numRow = 0\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _this$gridAggregation;\n\n    const {\n      gl\n    } = this;\n    const {\n      shaderOptions\n    } = this.state;\n    (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  _setupWeightAttributes(opts) {\n    const {\n      weightAttributes\n    } = this.state;\n    const {\n      weights\n    } = opts;\n\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  _trackGPUResultBuffers(results, weights) {\n    const {\n      resources\n    } = this.state;\n\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            const name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n\n            if (resources[name]) {\n              resources[name].delete();\n            }\n\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n\n  _updateModels(opts) {\n    const {\n      vertexCount,\n      attributes,\n      numCol,\n      numRow\n    } = opts;\n    const {\n      modelDirty\n    } = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n\n      this.setState({\n        modelDirty: false\n      });\n    }\n\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n\n}\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n\n  for (const id in weights) {\n    result[id] = { ...DEFAULT_WEIGHT_PARAMS,\n      ...weights[id]\n    };\n  }\n\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}","map":{"version":3,"mappings":"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","names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","getAggregationData","aggregationData","pixelIndex","index","results","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","getCellData","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","isSupported","gl","constructor","opts","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","_hasGPUSupport","_setupModels","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","getData","weightId","data","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","viewport","clear","draw","uSampler","texture","operation","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","SUM","_getMinMaxTexture","name","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","vertexCount","setVertexCount","setAttributes","setInstanceCount","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n"]},"metadata":{},"sourceType":"module"}