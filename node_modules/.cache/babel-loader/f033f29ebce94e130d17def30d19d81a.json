{"ast":null,"code":"import Protobuf from 'pbf';\nimport { log } from '@deck.gl/core';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport { MVTLayer, _getURLFromTemplate } from '@deck.gl/geo-layers';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { geojsonToBinary } from '@loaders.gl/gis';\nimport { Tile } from './schema/carto-tile';\nimport { TILE_FORMATS } from '../api/maps-api-common';\n\nfunction parseJSON(arrayBuffer) {\n  return JSON.parse(new TextDecoder().decode(arrayBuffer));\n}\n\nfunction parsePbf(buffer) {\n  const pbf = new Protobuf(buffer);\n  const tile = Tile.read(pbf);\n  return tile;\n}\n\nfunction unpackProperties(properties) {\n  if (!properties || !properties.length) {\n    return [];\n  }\n\n  return properties.map(item => {\n    const currentRecord = {};\n    item.data.forEach(_ref => {\n      let {\n        key,\n        value\n      } = _ref;\n      currentRecord[key] = value;\n    });\n    return currentRecord;\n  });\n}\n\nfunction parseCartoTile(arrayBuffer, options) {\n  if (!arrayBuffer) return null;\n  const formatTiles = options && options.cartoTile && options.cartoTile.formatTiles;\n  if (formatTiles === TILE_FORMATS.GEOJSON) return geojsonToBinary(parseJSON(arrayBuffer).features);\n  const tile = parsePbf(arrayBuffer);\n  const {\n    points,\n    lines,\n    polygons\n  } = tile;\n  const data = {\n    points: { ...points,\n      properties: unpackProperties(points.properties)\n    },\n    lines: { ...lines,\n      properties: unpackProperties(lines.properties)\n    },\n    polygons: { ...polygons,\n      properties: unpackProperties(polygons.properties)\n    }\n  };\n  return data;\n}\n\nconst defaultTileFormat = TILE_FORMATS.BINARY;\nconst CartoTileLoader = {\n  name: 'CARTO Tile',\n  id: 'cartoTile',\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/x-protobuf'],\n  category: 'geometry',\n  worker: false,\n  parse: async (arrayBuffer, options) => parseCartoTile(arrayBuffer, options),\n  parseSync: parseCartoTile,\n  options: {\n    cartoTile: {\n      formatTiles: defaultTileFormat\n    }\n  }\n};\nconst defaultProps = { ...MVTLayer.defaultProps,\n  formatTiles: defaultTileFormat,\n  loaders: [CartoTileLoader]\n};\nexport default class CartoTileLayer extends MVTLayer {\n  getTileData(tile) {\n    const url = _getURLFromTemplate(this.state.data, tile);\n\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    let loadOptions = this.getLoadOptions();\n    const {\n      fetch,\n      formatTiles\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    loadOptions = { ...loadOptions,\n      mimeType: 'application/x-protobuf'\n    };\n\n    if (formatTiles) {\n      log.assert(Object.values(TILE_FORMATS).includes(formatTiles), \"Invalid value for formatTiles: \".concat(formatTiles, \". Use value from TILE_FORMATS\"));\n      loadOptions.cartoTile = {\n        formatTiles\n      };\n    }\n\n    return fetch(url, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n\n  renderSubLayers(props) {\n    if (props.data === null) {\n      return null;\n    }\n\n    props.autoHighlight = false;\n    const {\n      bbox: {\n        west,\n        south,\n        east,\n        north\n      }\n    } = props.tile;\n    props.extensions = [new ClipExtension(), ...(props.extensions || [])];\n    props.clipBounds = [west, south, east, north];\n    const subLayer = new GeoJsonLayer({ ...props\n    });\n    return subLayer;\n  }\n\n}\nCartoTileLayer.layerName = 'CartoTileLayer';\nCartoTileLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Protobuf","log","ClipExtension","MVTLayer","_getURLFromTemplate","GeoJsonLayer","geojsonToBinary","Tile","TILE_FORMATS","parseJSON","arrayBuffer","JSON","parse","TextDecoder","decode","parsePbf","buffer","pbf","tile","read","unpackProperties","properties","length","map","item","currentRecord","data","forEach","key","value","parseCartoTile","options","formatTiles","cartoTile","GEOJSON","features","points","lines","polygons","defaultTileFormat","BINARY","CartoTileLoader","name","id","module","extensions","mimeTypes","category","worker","parseSync","defaultProps","loaders","CartoTileLayer","getTileData","url","state","Promise","reject","loadOptions","getLoadOptions","fetch","props","signal","mimeType","assert","Object","values","includes","propName","layer","renderSubLayers","autoHighlight","bbox","west","south","east","north","clipBounds","subLayer","layerName"],"sources":["../../../src/layers/carto-tile-layer.js"],"sourcesContent":["/* global TextDecoder */\nimport Protobuf from 'pbf';\nimport {log} from '@deck.gl/core';\nimport {ClipExtension} from '@deck.gl/extensions';\nimport {MVTLayer, _getURLFromTemplate} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {geojsonToBinary} from '@loaders.gl/gis';\nimport {Tile} from './schema/carto-tile';\nimport {TILE_FORMATS} from '../api/maps-api-common';\n\nfunction parseJSON(arrayBuffer) {\n  return JSON.parse(new TextDecoder().decode(arrayBuffer));\n}\n\nfunction parsePbf(buffer) {\n  const pbf = new Protobuf(buffer);\n  const tile = Tile.read(pbf);\n  return tile;\n}\n\nfunction unpackProperties(properties) {\n  if (!properties || !properties.length) {\n    return [];\n  }\n  return properties.map(item => {\n    const currentRecord = {};\n    item.data.forEach(({key, value}) => {\n      currentRecord[key] = value;\n    });\n    return currentRecord;\n  });\n}\n\nfunction parseCartoTile(arrayBuffer, options) {\n  if (!arrayBuffer) return null;\n  const formatTiles = options && options.cartoTile && options.cartoTile.formatTiles;\n  if (formatTiles === TILE_FORMATS.GEOJSON) return geojsonToBinary(parseJSON(arrayBuffer).features);\n\n  const tile = parsePbf(arrayBuffer);\n\n  const {points, lines, polygons} = tile;\n  const data = {\n    points: {...points, properties: unpackProperties(points.properties)},\n    lines: {...lines, properties: unpackProperties(lines.properties)},\n    polygons: {...polygons, properties: unpackProperties(polygons.properties)}\n  };\n\n  return data;\n}\n\nconst defaultTileFormat = TILE_FORMATS.BINARY;\n\nconst CartoTileLoader = {\n  name: 'CARTO Tile',\n  id: 'cartoTile',\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/x-protobuf'],\n  category: 'geometry',\n  worker: false,\n  parse: async (arrayBuffer, options) => parseCartoTile(arrayBuffer, options),\n  parseSync: parseCartoTile,\n  options: {\n    cartoTile: {\n      formatTiles: defaultTileFormat\n    }\n  }\n};\n\nconst defaultProps = {\n  ...MVTLayer.defaultProps,\n  formatTiles: defaultTileFormat,\n  loaders: [CartoTileLoader]\n};\n\nexport default class CartoTileLayer extends MVTLayer {\n  getTileData(tile) {\n    const url = _getURLFromTemplate(this.state.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    let loadOptions = this.getLoadOptions();\n    const {fetch, formatTiles} = this.props;\n    const {signal} = tile;\n\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf'\n    };\n\n    if (formatTiles) {\n      log.assert(\n        Object.values(TILE_FORMATS).includes(formatTiles),\n        `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n      );\n      loadOptions.cartoTile = {formatTiles};\n    }\n\n    return fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n  }\n\n  renderSubLayers(props) {\n    if (props.data === null) {\n      return null;\n    }\n\n    props.autoHighlight = false;\n\n    const {\n      bbox: {west, south, east, north}\n    } = props.tile;\n    props.extensions = [new ClipExtension(), ...(props.extensions || [])];\n    props.clipBounds = [west, south, east, north];\n\n    const subLayer = new GeoJsonLayer({\n      ...props\n    });\n    return subLayer;\n  }\n}\n\nCartoTileLayer.layerName = 'CartoTileLayer';\nCartoTileLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}