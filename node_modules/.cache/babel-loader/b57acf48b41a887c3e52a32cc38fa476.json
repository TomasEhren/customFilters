{"ast":null,"code":"import { GL_TYPE as GL } from '../constants';\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\nconst NAME_TO_GL_TYPE = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\nexport default class GLType {\n  static fromTypedArray(arrayOrType) {\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n\n  static fromName(name) {\n    const glType = NAME_TO_GL_TYPE[name];\n\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n\n    return glType;\n  }\n\n  static getArrayType(glType) {\n    switch (glType) {\n      case GL.UNSIGNED_SHORT_5_6_5:\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        return Uint16Array;\n\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n\n        return ArrayType;\n    }\n  }\n\n  static getByteSize(glType) {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n\n  static validate(glType) {\n    return Boolean(GLType.getArrayType(glType));\n  }\n\n  static createTypedArray(glType, buffer) {\n    let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let length = arguments.length > 3 ? arguments[3] : undefined;\n\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n\n}","map":{"version":3,"mappings":"AACA,SAAQA,OAAO,IAAIC,EAAnB,QAA4B,cAA5B;AAEA,MAAMC,qBAAqB,GAAG;EAC5B,CAACD,EAAE,CAACE,MAAJ,GAAaC,YADe;EAE5B,CAACH,EAAE,CAACI,KAAJ,GAAYC,YAFgB;EAG5B,CAACL,EAAE,CAACM,cAAJ,GAAqBC,WAHO;EAI5B,CAACP,EAAE,CAACQ,YAAJ,GAAmBC,WAJS;EAK5B,CAACT,EAAE,CAACU,aAAJ,GAAoBC,UALQ;EAM5B,CAACX,EAAE,CAACY,IAAJ,GAAWC,SANiB;EAO5B,CAACb,EAAE,CAACc,KAAJ,GAAYC,UAPgB;EAQ5B,CAACf,EAAE,CAACgB,GAAJ,GAAUC;AARkB,CAA9B;AAaA,MAAMC,eAA0B,GAAG;EACjChB,MAAM,EAAEF,EAAE,CAACE,MADsB;EAEjCE,KAAK,EAAEJ,EAAE,CAACI,KAFuB;EAGjCE,cAAc,EAAEN,EAAE,CAACM,cAHc;EAIjCE,YAAY,EAAER,EAAE,CAACQ,YAJgB;EAKjCE,aAAa,EAAEV,EAAE,CAACU,aALe;EAMjCE,IAAI,EAAEZ,EAAE,CAACY,IANwB;EAOjCE,KAAK,EAAEd,EAAE,CAACc,KAPuB;EAQjCE,GAAG,EAAEhB,EAAE,CAACgB;AARyB,CAAnC;AAUA,MAAMG,mBAAmB,GAAG,2BAA5B;AAGA,eAAe,MAAMC,MAAN,CAAa;EAQL,OAAdC,cAAc,CAACC,WAAD,EAA6C;IAEhEA,WAAW,GAAGC,WAAW,CAACC,MAAZD,CAAmBD,WAAnBC,IAAkCD,WAAW,CAACG,WAA9CF,GAA4DD,WAA1EA;;IACA,KAAK,MAAMI,MAAX,IAAqBzB,qBAArB,EAA4C;MAC1C,MAAM0B,SAAS,GAAG1B,qBAAqB,CAACyB,MAAD,CAAvC;;MACA,IAAIC,SAAS,KAAKL,WAAlB,EAA+B;QAC7B,OAAOI,MAAP;MACD;IACF;;IACD,MAAM,IAAIE,KAAJ,CAAUT,mBAAV,CAAN;EACD;;EAMc,OAARU,QAAQ,CAACC,IAAD,EAAuB;IACpC,MAAMJ,MAAM,GAAGR,eAAe,CAACY,IAAD,CAA9B;;IACA,IAAI,CAACJ,MAAL,EAAa;MACX,MAAM,IAAIE,KAAJ,CAAUT,mBAAV,CAAN;IACD;;IACD,OAAOO,MAAP;EACD;;EAGkB,OAAZK,YAAY,CAACL,MAAD,EAAiB;IAClC,QAAQA,MAAR;MAGE,KAAK1B,EAAE,CAACgC,oBAAR;MAEA,KAAKhC,EAAE,CAACiC,sBAAR;MAEA,KAAKjC,EAAE,CAACkC,sBAAR;QAEE,OAAO3B,WAAP;;MACF;QACE,MAAMoB,SAAS,GAAG1B,qBAAqB,CAACyB,MAAD,CAAvC;;QACA,IAAI,CAACC,SAAL,EAAgB;UACd,MAAM,IAAIC,KAAJ,CAAUT,mBAAV,CAAN;QACD;;QACD,OAAOQ,SAAP;IAfJ;EAiBD;;EAMiB,OAAXQ,WAAW,CAACT,MAAD,EAAyB;IACzC,MAAMC,SAAS,GAAGP,MAAM,CAACW,YAAPX,CAAoBM,MAApBN,CAAlB;IACA,OAAOO,SAAS,CAACS,iBAAjB;EACD;;EAMc,OAARC,QAAQ,CAACX,MAAD,EAA0B;IACvC,OAAOY,OAAO,CAAClB,MAAM,CAACW,YAAPX,CAAoBM,MAApBN,CAAD,CAAd;EACD;;EASsB,OAAhBmB,gBAAgB,CACrBb,MADqB,EAErBc,MAFqB,EAKT;IAAA,IAFZC,UAEY,uEAFS,CAET;IAAA,IADZC,MACY;;IACZ,IAAIA,MAAM,KAAKC,SAAf,EAA0B;MACxBD,MAAM,GAAG,CAACF,MAAM,CAACI,UAAPJ,GAAoBC,UAArB,IAAmCrB,MAAM,CAACe,WAAPf,CAAmBM,MAAnBN,CAA5CsB;IACD;;IACD,MAAMf,SAAS,GAAGP,MAAM,CAACW,YAAPX,CAAoBM,MAApBN,CAAlB;IACA,OAAO,IAAIO,SAAJ,CAAca,MAAd,EAAsBC,UAAtB,EAAkCC,MAAlC,CAAP;EACD;;AAxFyB","names":["GL_TYPE","GL","GL_TYPE_TO_ARRAY_TYPE","DOUBLE","Float64Array","FLOAT","Float32Array","UNSIGNED_SHORT","Uint16Array","UNSIGNED_INT","Uint32Array","UNSIGNED_BYTE","Uint8Array","BYTE","Int8Array","SHORT","Int16Array","INT","Int32Array","NAME_TO_GL_TYPE","ERR_TYPE_CONVERSION","GLType","fromTypedArray","arrayOrType","ArrayBuffer","isView","constructor","glType","ArrayType","Error","fromName","name","getArrayType","UNSIGNED_SHORT_5_6_5","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","getByteSize","BYTES_PER_ELEMENT","validate","Boolean","createTypedArray","buffer","byteOffset","length","undefined","byteLength"],"sources":["../../../../src/geometry/gl/gl-type.ts"],"sourcesContent":["import {TypedArray} from '../types';\nimport {GL_TYPE as GL} from '../constants';\n\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\ntype GlTypeMap = {\n  [index: string]: number;\n};\nconst NAME_TO_GL_TYPE: GlTypeMap = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport default class GLType {\n  // Signature: fromTypedArray(new Uint8Array())\n  // Signature: fromTypedArray(Uint8Array)\n  /**\n   * Returns the size, in bytes, of the corresponding datatype\n   * @param arrayOrType\n   * @returns glType a a string\n   */\n  static fromTypedArray(arrayOrType: TypedArray | Function): string {\n    // If typed array, look up constructor\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n  /**\n   * Extracts name for glType from array NAME_TO_GL_TYPE\n   * @param name\n   * @returns glType as a number\n   */\n  static fromName(name: string): number {\n    const glType = NAME_TO_GL_TYPE[name];\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n    return glType;\n  }\n  // Converts GL constant to corresponding typed array type\n  // eslint-disable-next-line complexity\n  static getArrayType(glType: number) {\n    switch (glType) {\n      /*eslint-disable*/\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_6_5:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        /* eslint-enable*/\n        return Uint16Array;\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n        return ArrayType;\n    }\n  }\n  /**\n   * Returns the size in bytes of one element of the provided WebGL type\n   * @param glType\n   * @returns size of glType\n   */\n  static getByteSize(glType: number): number {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n  /**\n   * Returns `true` if `glType` is a valid WebGL data type.\n   * @param glType\n   * @returns boolean\n   */\n  static validate(glType: number): boolean {\n    return Boolean(GLType.getArrayType(glType));\n  }\n  /**\n   * Creates a typed view of an array of bytes\n   * @param glType The type of typed array (ArrayBuffer view) to create\n   * @param buffer The buffer storage to use for the view.\n   * @param byteOffset The offset, in bytes, to the first element in the view\n   * @param length The number of elements in the view. Defaults to buffer length\n   * @returns A typed array view of the buffer\n   */\n  static createTypedArray(\n    glType: number,\n    buffer: TypedArray,\n    byteOffset: number = 0,\n    length?: number\n  ): TypedArray {\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}