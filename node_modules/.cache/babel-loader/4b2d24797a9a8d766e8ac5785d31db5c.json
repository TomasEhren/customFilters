{"ast":null,"code":"import _objectWithoutProperties from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"instancePickingColors\"];\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport { replaceInRange } from '../utils';\nimport { binaryToFeatureForAccesor } from './geojson-binary';\nimport { POINT_LAYER, LINE_LAYER, POLYGON_LAYER, getDefaultProps, forwardProps } from './sub-layer-map';\nimport { getGeojsonFeatures, separateGeojsonFeatures } from './geojson';\nimport { createLayerPropsFromFeatures, createLayerPropsFromBinary } from './geojson-layer-props';\nvar FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nvar defaultProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, getDefaultProps(POINT_LAYER.circle)), getDefaultProps(POINT_LAYER.icon)), getDefaultProps(POINT_LAYER.text)), getDefaultProps(LINE_LAYER)), getDefaultProps(POLYGON_LAYER)), {}, {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {\n    type: 'object',\n    value: null\n  },\n  iconMapping: {\n    type: 'object',\n    value: {}\n  },\n  getIcon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.icon;\n    }\n  },\n  getText: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.properties.text;\n    }\n  },\n  pointType: 'circle',\n  getRadius: {\n    deprecatedFor: 'getPointRadius'\n  }\n});\n\nvar GeoJsonLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(GeoJsonLayer, _CompositeLayer);\n\n  var _super = _createSuper(GeoJsonLayer);\n\n  function GeoJsonLayer() {\n    _classCallCheck(this, GeoJsonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GeoJsonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        layerProps: {},\n        features: {}\n      };\n\n      if (this.props.getLineDashArray) {\n        log.removed('getLineDashArray', 'PathStyleExtension')();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (!changeFlags.dataChanged) {\n        return;\n      }\n\n      var data = this.props.data;\n      var binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n      this.setState({\n        binary: binary\n      });\n\n      if (binary) {\n        this._updateStateBinary({\n          props: props,\n          changeFlags: changeFlags\n        });\n      } else {\n        this._updateStateJSON({\n          props: props,\n          changeFlags: changeFlags\n        });\n      }\n    }\n  }, {\n    key: \"_updateStateBinary\",\n    value: function _updateStateBinary(_ref2) {\n      var props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n      var layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n      this.setState({\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"_updateStateJSON\",\n    value: function _updateStateJSON(_ref3) {\n      var props = _ref3.props,\n          changeFlags = _ref3.changeFlags;\n      var features = getGeojsonFeatures(props.data);\n      var wrapFeature = this.getSubLayerRow.bind(this);\n      var newFeatures = {};\n      var featuresDiff = {};\n\n      if (Array.isArray(changeFlags.dataChanged)) {\n        var oldFeatures = this.state.features;\n\n        for (var key in oldFeatures) {\n          newFeatures[key] = oldFeatures[key].slice();\n          featuresDiff[key] = [];\n        }\n\n        var _iterator = _createForOfIteratorHelper(changeFlags.dataChanged),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n            var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n\n            for (var _key in oldFeatures) {\n              featuresDiff[_key].push(replaceInRange({\n                data: newFeatures[_key],\n                getIndex: function getIndex(f) {\n                  return f.__source.index;\n                },\n                dataRange: dataRange,\n                replace: partialFeatures[_key]\n              }));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        newFeatures = separateGeojsonFeatures(features, wrapFeature);\n      }\n\n      var layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n      this.setState({\n        features: newFeatures,\n        featuresDiff: featuresDiff,\n        layerProps: layerProps\n      });\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var _this = this;\n\n      var info = _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var index = info.index,\n          sourceLayer = info.sourceLayer;\n      info.featureType = FEATURE_TYPES.find(function (ft) {\n        return sourceLayer.id.startsWith(\"\".concat(_this.id, \"-\").concat(ft, \"-\"));\n      });\n\n      if (index >= 0 && sourceLayer.id.startsWith(\"\".concat(this.id, \"-points-text\")) && this.state.binary) {\n        info.index = this.props.data.points.globalFeatureIds.value[index];\n      }\n\n      return info;\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      var pointLayerIdPrefix = \"\".concat(this.id, \"-points-\");\n      var sourceIsPoints = info.featureType === 'points';\n\n      var _iterator2 = _createForOfIteratorHelper(this.getSubLayers()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n\n          if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n            layer.updateAutoHighlight(info);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_renderPolygonLayer\",\n    value: function _renderPolygonLayer() {\n      var _this$props = this.props,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe;\n      var layerProps = this.state.layerProps;\n      var id = 'polygons-fill';\n      var PolygonFillLayer = this.shouldRenderSubLayer(id, layerProps.polygons.data) && this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n      if (PolygonFillLayer) {\n        var forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n        var useLineColor = extruded && wireframe;\n\n        if (!useLineColor) {\n          delete forwardedProps.getLineColor;\n        }\n\n        forwardedProps.updateTriggers.lineColors = useLineColor;\n        return new PolygonFillLayer(forwardedProps, this.getSubLayerProps({\n          id: id,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygons);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_renderLineLayers\",\n    value: function _renderLineLayers() {\n      var _this$props2 = this.props,\n          extruded = _this$props2.extruded,\n          stroked = _this$props2.stroked;\n      var layerProps = this.state.layerProps;\n      var polygonStrokeLayerId = 'polygons-stroke';\n      var lineStringsLayerId = 'linestrings';\n      var PolygonStrokeLayer = !extruded && stroked && this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) && this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n      var LineStringsLayer = this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) && this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n      if (PolygonStrokeLayer || LineStringsLayer) {\n        var forwardedProps = forwardProps(this, LINE_LAYER.props);\n        return [PolygonStrokeLayer && new PolygonStrokeLayer(forwardedProps, this.getSubLayerProps({\n          id: polygonStrokeLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.polygonsOutline), LineStringsLayer && new LineStringsLayer(forwardedProps, this.getSubLayerProps({\n          id: lineStringsLayerId,\n          updateTriggers: forwardedProps.updateTriggers\n        }), layerProps.lines)];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_renderPointLayers\",\n    value: function _renderPointLayers() {\n      var pointType = this.props.pointType;\n      var _this$state = this.state,\n          layerProps = _this$state.layerProps,\n          binary = _this$state.binary;\n      var highlightedObjectIndex = this.props.highlightedObjectIndex;\n\n      if (!binary && Number.isFinite(highlightedObjectIndex)) {\n        highlightedObjectIndex = layerProps.points.data.findIndex(function (d) {\n          return d.__source.index === highlightedObjectIndex;\n        });\n      }\n\n      var types = new Set(pointType.split('+'));\n      var pointLayers = [];\n\n      var _iterator3 = _createForOfIteratorHelper(types),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var type = _step3.value;\n          var id = \"points-\".concat(type);\n          var PointLayerMapping = POINT_LAYER[type];\n          var PointsLayer = PointLayerMapping && this.shouldRenderSubLayer(id, layerProps.points.data) && this.getSubLayerClass(id, PointLayerMapping.type);\n\n          if (PointsLayer) {\n            var forwardedProps = forwardProps(this, PointLayerMapping.props);\n            var pointsLayerProps = layerProps.points;\n\n            if (type === 'text' && this.state.binary) {\n              var _pointsLayerProps$dat = pointsLayerProps.data.attributes,\n                  instancePickingColors = _pointsLayerProps$dat.instancePickingColors,\n                  rest = _objectWithoutProperties(_pointsLayerProps$dat, _excluded);\n\n              pointsLayerProps = _objectSpread(_objectSpread({}, pointsLayerProps), {}, {\n                data: _objectSpread(_objectSpread({}, pointsLayerProps.data), {}, {\n                  attributes: rest\n                })\n              });\n            }\n\n            pointLayers.push(new PointsLayer(forwardedProps, this.getSubLayerProps({\n              id: id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex: highlightedObjectIndex\n            }), pointsLayerProps));\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return pointLayers;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var extruded = this.props.extruded;\n\n      var polygonFillLayer = this._renderPolygonLayer();\n\n      var lineLayers = this._renderLineLayers();\n\n      var pointLayers = this._renderPointLayers();\n\n      return [!extruded && polygonFillLayer, lineLayers, pointLayers, extruded && polygonFillLayer];\n    }\n  }, {\n    key: \"getSubLayerAccessor\",\n    value: function getSubLayerAccessor(accessor) {\n      var binary = this.state.binary;\n\n      if (!binary || typeof accessor !== 'function') {\n        return _get(_getPrototypeOf(GeoJsonLayer.prototype), \"getSubLayerAccessor\", this).call(this, accessor);\n      }\n\n      return function (object, info) {\n        var data = info.data,\n            index = info.index;\n        var feature = binaryToFeatureForAccesor(data, index);\n        return accessor(feature, info);\n      };\n    }\n  }]);\n\n  return GeoJsonLayer;\n}(CompositeLayer);\n\nexport { GeoJsonLayer as default };\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["CompositeLayer","log","replaceInRange","binaryToFeatureForAccesor","POINT_LAYER","LINE_LAYER","POLYGON_LAYER","getDefaultProps","forwardProps","getGeojsonFeatures","separateGeojsonFeatures","createLayerPropsFromFeatures","createLayerPropsFromBinary","FEATURE_TYPES","defaultProps","circle","icon","text","stroked","filled","extruded","wireframe","iconAtlas","type","value","iconMapping","getIcon","f","properties","getText","pointType","getRadius","deprecatedFor","GeoJsonLayer","initializeState","state","layerProps","features","props","getLineDashArray","removed","updateState","changeFlags","dataChanged","data","binary","setState","_updateStateBinary","_updateStateJSON","encodePickingColor","wrapFeature","getSubLayerRow","bind","newFeatures","featuresDiff","Array","isArray","oldFeatures","key","slice","dataRange","partialFeatures","push","getIndex","__source","index","replace","getPickingInfo","params","info","sourceLayer","featureType","find","ft","id","startsWith","points","globalFeatureIds","_updateAutoHighlight","pointLayerIdPrefix","sourceIsPoints","getSubLayers","layer","updateAutoHighlight","_renderPolygonLayer","PolygonFillLayer","shouldRenderSubLayer","polygons","getSubLayerClass","forwardedProps","useLineColor","getLineColor","updateTriggers","lineColors","getSubLayerProps","_renderLineLayers","polygonStrokeLayerId","lineStringsLayerId","PolygonStrokeLayer","polygonsOutline","LineStringsLayer","lines","_renderPointLayers","highlightedObjectIndex","Number","isFinite","findIndex","d","types","Set","split","pointLayers","PointLayerMapping","PointsLayer","pointsLayerProps","attributes","instancePickingColors","rest","renderLayers","polygonFillLayer","lineLayers","getSubLayerAccessor","accessor","object","feature","layerName"],"sources":["../../../src/geojson-layer/geojson-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, log} from '@deck.gl/core';\nimport {replaceInRange} from '../utils';\nimport {binaryToFeatureForAccesor} from './geojson-binary';\nimport {\n  POINT_LAYER,\n  LINE_LAYER,\n  POLYGON_LAYER,\n  getDefaultProps,\n  forwardProps\n} from './sub-layer-map';\n\nimport {getGeojsonFeatures, separateGeojsonFeatures} from './geojson';\nimport {createLayerPropsFromFeatures, createLayerPropsFromBinary} from './geojson-layer-props';\n\nconst FEATURE_TYPES = ['points', 'linestrings', 'polygons'];\n\nconst defaultProps = {\n  ...getDefaultProps(POINT_LAYER.circle),\n  ...getDefaultProps(POINT_LAYER.icon),\n  ...getDefaultProps(POINT_LAYER.text),\n  ...getDefaultProps(LINE_LAYER),\n  ...getDefaultProps(POLYGON_LAYER),\n\n  // Overwrite sub layer defaults\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  iconAtlas: {type: 'object', value: null},\n  iconMapping: {type: 'object', value: {}},\n  getIcon: {type: 'accessor', value: f => f.properties.icon},\n  getText: {type: 'accessor', value: f => f.properties.text},\n\n  // Self props\n  pointType: 'circle',\n\n  // TODO: deprecated, remove in v9\n  getRadius: {deprecatedFor: 'getPointRadius'}\n};\n\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      layerProps: {},\n      features: {}\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({props, changeFlags}) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const {data} = this.props;\n    const binary = data && 'points' in data && 'polygons' in data && 'lines' in data;\n\n    this.setState({binary});\n\n    if (binary) {\n      this._updateStateBinary({props, changeFlags});\n    } else {\n      this._updateStateJSON({props, changeFlags});\n    }\n  }\n\n  _updateStateBinary({props, changeFlags}) {\n    const layerProps = createLayerPropsFromBinary(props.data, this.encodePickingColor);\n    this.setState({layerProps});\n  }\n\n  _updateStateJSON({props, changeFlags}) {\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n    let newFeatures = {};\n    const featuresDiff = {};\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n    } else {\n      newFeatures = separateGeojsonFeatures(features, wrapFeature);\n    }\n\n    const layerProps = createLayerPropsFromFeatures(newFeatures, featuresDiff);\n\n    this.setState({\n      features: newFeatures,\n      featuresDiff,\n      layerProps\n    });\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {index, sourceLayer} = info;\n    info.featureType = FEATURE_TYPES.find(ft => sourceLayer.id.startsWith(`${this.id}-${ft}-`));\n    if (index >= 0 && sourceLayer.id.startsWith(`${this.id}-points-text`) && this.state.binary) {\n      info.index = this.props.data.points.globalFeatureIds.value[index];\n    }\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    // All sub layers except the points layer use source feature index to encode the picking color\n    // The points layer uses indices from the points data array.\n    const pointLayerIdPrefix = `${this.id}-points-`;\n    const sourceIsPoints = info.featureType === 'points';\n    for (const layer of this.getSubLayers()) {\n      if (layer.id.startsWith(pointLayerIdPrefix) === sourceIsPoints) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  _renderPolygonLayer() {\n    const {extruded, wireframe} = this.props;\n    const {layerProps} = this.state;\n    const id = 'polygons-fill';\n\n    const PolygonFillLayer =\n      this.shouldRenderSubLayer(id, layerProps.polygons.data) &&\n      this.getSubLayerClass(id, POLYGON_LAYER.type);\n\n    if (PolygonFillLayer) {\n      const forwardedProps = forwardProps(this, POLYGON_LAYER.props);\n      // Avoid building the lineColors attribute if wireframe is off\n      const useLineColor = extruded && wireframe;\n      if (!useLineColor) {\n        delete forwardedProps.getLineColor;\n      }\n      // using a legacy API to invalid lineColor attributes\n      forwardedProps.updateTriggers.lineColors = useLineColor;\n\n      return new PolygonFillLayer(\n        forwardedProps,\n        this.getSubLayerProps({\n          id,\n          updateTriggers: forwardedProps.updateTriggers\n        }),\n        layerProps.polygons\n      );\n    }\n    return null;\n  }\n\n  _renderLineLayers() {\n    const {extruded, stroked} = this.props;\n    const {layerProps} = this.state;\n    const polygonStrokeLayerId = 'polygons-stroke';\n    const lineStringsLayerId = 'linestrings';\n\n    const PolygonStrokeLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer(polygonStrokeLayerId, layerProps.polygonsOutline.data) &&\n      this.getSubLayerClass(polygonStrokeLayerId, LINE_LAYER.type);\n    const LineStringsLayer =\n      this.shouldRenderSubLayer(lineStringsLayerId, layerProps.lines.data) &&\n      this.getSubLayerClass(lineStringsLayerId, LINE_LAYER.type);\n\n    if (PolygonStrokeLayer || LineStringsLayer) {\n      const forwardedProps = forwardProps(this, LINE_LAYER.props);\n\n      return [\n        PolygonStrokeLayer &&\n          new PolygonStrokeLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: polygonStrokeLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.polygonsOutline\n          ),\n\n        LineStringsLayer &&\n          new LineStringsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id: lineStringsLayerId,\n              updateTriggers: forwardedProps.updateTriggers\n            }),\n            layerProps.lines\n          )\n      ];\n    }\n    return null;\n  }\n\n  _renderPointLayers() {\n    const {pointType} = this.props;\n    const {layerProps, binary} = this.state;\n    let {highlightedObjectIndex} = this.props;\n\n    if (!binary && Number.isFinite(highlightedObjectIndex)) {\n      highlightedObjectIndex = layerProps.points.data.findIndex(\n        d => d.__source.index === highlightedObjectIndex\n      );\n    }\n\n    // Avoid duplicate sub layer ids\n    const types = new Set(pointType.split('+'));\n    const pointLayers = [];\n    for (const type of types) {\n      const id = `points-${type}`;\n      const PointLayerMapping = POINT_LAYER[type];\n      const PointsLayer =\n        PointLayerMapping &&\n        this.shouldRenderSubLayer(id, layerProps.points.data) &&\n        this.getSubLayerClass(id, PointLayerMapping.type);\n      if (PointsLayer) {\n        const forwardedProps = forwardProps(this, PointLayerMapping.props);\n        let pointsLayerProps = layerProps.points;\n\n        if (type === 'text' && this.state.binary) {\n          // Picking colors are per-point but for text per-character are required\n          // getPickingInfo() maps back to the correct index\n          // eslint-disable-next-line no-unused-vars\n          const {instancePickingColors, ...rest} = pointsLayerProps.data.attributes;\n          pointsLayerProps = {\n            ...pointsLayerProps,\n            data: {...pointsLayerProps.data, attributes: rest}\n          };\n        }\n\n        pointLayers.push(\n          new PointsLayer(\n            forwardedProps,\n            this.getSubLayerProps({\n              id,\n              updateTriggers: forwardedProps.updateTriggers,\n              highlightedObjectIndex\n            }),\n            pointsLayerProps\n          )\n        );\n      }\n    }\n    return pointLayers;\n  }\n\n  renderLayers() {\n    const {extruded} = this.props;\n\n    const polygonFillLayer = this._renderPolygonLayer();\n    const lineLayers = this._renderLineLayers();\n    const pointLayers = this._renderPointLayers();\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      lineLayers,\n      pointLayers,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n\n  getSubLayerAccessor(accessor) {\n    const {binary} = this.state;\n    if (!binary || typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    return (object, info) => {\n      const {data, index} = info;\n      const feature = binaryToFeatureForAccesor(data, index);\n      return accessor(feature, info);\n    };\n  }\n}\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}