{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport log from '../../utils/log';\nvar NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\nexport function getClosestObject(_ref) {\n  var pickedColors = _ref.pickedColors,\n      decodePickingColor = _ref.decodePickingColor,\n      deviceX = _ref.deviceX,\n      deviceY = _ref.deviceY,\n      deviceRadius = _ref.deviceRadius,\n      deviceRect = _ref.deviceRect;\n\n  if (pickedColors) {\n    var x = deviceRect.x,\n        y = deviceRect.y,\n        width = deviceRect.width,\n        height = deviceRect.height;\n    var minSquareDistanceToCenter = deviceRadius * deviceRadius;\n    var closestPixelIndex = -1;\n    var i = 0;\n\n    for (var row = 0; row < height; row++) {\n      var dy = row + y - deviceY;\n      var dy2 = dy * dy;\n\n      if (dy2 > minSquareDistanceToCenter) {\n        i += 4 * width;\n      } else {\n        for (var col = 0; col < width; col++) {\n          var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n          if (pickedLayerIndex >= 0) {\n            var dx = col + x - deviceX;\n            var d2 = dx * dx + dy2;\n\n            if (d2 <= minSquareDistanceToCenter) {\n              minSquareDistanceToCenter = d2;\n              closestPixelIndex = i;\n            }\n          }\n\n          i += 4;\n        }\n      }\n    }\n\n    if (closestPixelIndex >= 0) {\n      var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n      var pickedObject = decodePickingColor(pickedColor);\n\n      if (pickedObject) {\n        var _dy = Math.floor(closestPixelIndex / 4 / width);\n\n        var _dx = closestPixelIndex / 4 - _dy * width;\n\n        return _objectSpread(_objectSpread({}, pickedObject), {}, {\n          pickedColor: pickedColor,\n          pickedX: x + _dx,\n          pickedY: y + _dy\n        });\n      }\n\n      log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n    }\n  }\n\n  return NO_PICKED_OBJECT;\n}\nexport function getUniqueObjects(_ref2) {\n  var pickedColors = _ref2.pickedColors,\n      decodePickingColor = _ref2.decodePickingColor;\n  var uniqueColors = new Map();\n\n  if (pickedColors) {\n    for (var i = 0; i < pickedColors.length; i += 4) {\n      var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        var pickedColor = pickedColors.slice(i, i + 4);\n        var colorKey = pickedColor.join(',');\n\n        if (!uniqueColors.has(colorKey)) {\n          var pickedObject = decodePickingColor(pickedColor);\n\n          if (pickedObject) {\n            uniqueColors.set(colorKey, _objectSpread(_objectSpread({}, pickedObject), {}, {\n              pickedColor: pickedColor\n            }));\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}","map":{"version":3,"mappings":";AAoBA,OAAOA,GAAP,MAAgB,iBAAhB;AAEA,IAAMC,gBAAgB,GAAG;EACvBC,WAAW,EAAE,IADU;EAEvBC,WAAW,EAAE,IAFU;EAGvBC,iBAAiB,EAAE,CAAC;AAHG,CAAzB;AAWA,OAAO,SAASC,gBAAT,OAOJ;EAAA,IANDC,YAMC,QANDA,YAMC;EAAA,IALDC,kBAKC,QALDA,kBAKC;EAAA,IAJDC,OAIC,QAJDA,OAIC;EAAA,IAHDC,OAGC,QAHDA,OAGC;EAAA,IAFDC,YAEC,QAFDA,YAEC;EAAA,IADDC,UACC,QADDA,UACC;;EACD,IAAIL,YAAJ,EAAkB;IAGhB,IAAOM,CAAP,GAA8BD,UAA9B,CAAOC,CAAP;IAAA,IAAUC,CAAV,GAA8BF,UAA9B,CAAUE,CAAV;IAAA,IAAaC,KAAb,GAA8BH,UAA9B,CAAaG,KAAb;IAAA,IAAoBC,MAApB,GAA8BJ,UAA9B,CAAoBI,MAApB;IACA,IAAIC,yBAAyB,GAAGN,YAAY,GAAGA,YAA/C;IACA,IAAIO,iBAAiB,GAAG,CAAC,CAAzB;IACA,IAAIC,CAAC,GAAG,CAAR;;IAEA,KAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,MAAxB,EAAgCI,GAAG,EAAnC,EAAuC;MACrC,IAAMC,EAAE,GAAGD,GAAG,GAAGN,CAANM,GAAUV,OAArB;MACA,IAAMY,GAAG,GAAGD,EAAE,GAAGA,EAAjB;;MAEA,IAAIC,GAAG,GAAGL,yBAAV,EAAqC;QAEnCE,CAAC,IAAI,IAAIJ,KAATI;MAFF,OAGO;QACL,KAAK,IAAII,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGR,KAAxB,EAA+BQ,GAAG,EAAlC,EAAsC;UAEpC,IAAMC,gBAAgB,GAAGjB,YAAY,CAACY,CAAC,GAAG,CAAL,CAAZZ,GAAsB,CAA/C;;UAEA,IAAIiB,gBAAgB,IAAI,CAAxB,EAA2B;YACzB,IAAMC,EAAE,GAAGF,GAAG,GAAGV,CAANU,GAAUd,OAArB;YACA,IAAMiB,EAAE,GAAGD,EAAE,GAAGA,EAALA,GAAUH,GAArB;;YAEA,IAAII,EAAE,IAAIT,yBAAV,EAAqC;cACnCA,yBAAyB,GAAGS,EAA5BT;cACAC,iBAAiB,GAAGC,CAApBD;YACD;UACF;;UACDC,CAAC,IAAI,CAALA;QACD;MACF;IACF;;IAED,IAAID,iBAAiB,IAAI,CAAzB,EAA4B;MAE1B,IAAMf,WAAW,GAAGI,YAAY,CAACoB,KAAbpB,CAAmBW,iBAAnBX,EAAsCW,iBAAiB,GAAG,CAA1DX,CAApB;MACA,IAAMqB,YAAY,GAAGpB,kBAAkB,CAACL,WAAD,CAAvC;;MACA,IAAIyB,YAAJ,EAAkB;QAChB,IAAMP,GAAE,GAAGQ,IAAI,CAACC,KAALD,CAAWX,iBAAiB,GAAG,CAApBA,GAAwBH,KAAnCc,CAAX;;QACA,IAAMJ,GAAE,GAAGP,iBAAiB,GAAG,CAApBA,GAAwBG,GAAE,GAAGN,KAAxC;;QACA,uCACKa,YADL;UAEEzB,WAFK,EAELA,WAFF;UAGE4B,OAAO,EAAElB,CAAC,GAAGY,GAHf;UAIEO,OAAO,EAAElB,CAAC,GAAGO;QAJf;MAMD;;MACDpB,GAAG,CAACgC,KAAJhC,CAAU,uDAAVA;IACD;EACF;;EACD,OAAOC,gBAAP;AACD;AAMD,OAAO,SAASgC,gBAAT,QAA8D;EAAA,IAAnC3B,YAAmC,SAAnCA,YAAmC;EAAA,IAArBC,kBAAqB,SAArBA,kBAAqB;EACnE,IAAM2B,YAAY,GAAG,IAAIC,GAAJ,EAArB;;EAGA,IAAI7B,YAAJ,EAAkB;IAChB,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,YAAY,CAAC8B,MAAjC,EAAyClB,CAAC,IAAI,CAA9C,EAAiD;MAE/C,IAAMK,gBAAgB,GAAGjB,YAAY,CAACY,CAAC,GAAG,CAAL,CAAZZ,GAAsB,CAA/C;;MAEA,IAAIiB,gBAAgB,IAAI,CAAxB,EAA2B;QACzB,IAAMrB,WAAW,GAAGI,YAAY,CAACoB,KAAbpB,CAAmBY,CAAnBZ,EAAsBY,CAAC,GAAG,CAA1BZ,CAApB;QACA,IAAM+B,QAAQ,GAAGnC,WAAW,CAACoC,IAAZpC,CAAiB,GAAjBA,CAAjB;;QAEA,IAAI,CAACgC,YAAY,CAACK,GAAbL,CAAiBG,QAAjBH,CAAL,EAAiC;UAC/B,IAAMP,YAAY,GAAGpB,kBAAkB,CAACL,WAAD,CAAvC;;UAEA,IAAIyB,YAAJ,EAAkB;YAChBO,YAAY,CAACM,GAAbN,CAAiBG,QAAjBH,kCACKP,YADLO;cAEEhC;YAFFgC;UADF,OAKO;YACLlC,GAAG,CAACgC,KAAJhC,CAAU,uDAAVA;UACD;QACF;MACF;IACF;EACF;;EAED,OAAOyC,KAAK,CAACC,IAAND,CAAWP,YAAY,CAACS,MAAbT,EAAXO,CAAP;AACD","names":["log","NO_PICKED_OBJECT","pickedColor","pickedLayer","pickedObjectIndex","getClosestObject","pickedColors","decodePickingColor","deviceX","deviceY","deviceRadius","deviceRect","x","y","width","height","minSquareDistanceToCenter","closestPixelIndex","i","row","dy","dy2","col","pickedLayerIndex","dx","d2","slice","pickedObject","Math","floor","pickedX","pickedY","error","getUniqueObjects","uniqueColors","Map","length","colorKey","join","has","set","Array","from","values"],"sources":["../../../../src/lib/picking/query-object.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../../utils/log';\n\nconst NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n\n/* eslint-disable max-depth, max-statements */\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getClosestObject({\n  pickedColors,\n  decodePickingColor,\n  deviceX,\n  deviceY,\n  deviceRadius,\n  deviceRect\n}) {\n  if (pickedColors) {\n    // Traverse all pixels in picking results and find the one closest to the supplied\n    // [deviceX, deviceY]\n    const {x, y, width, height} = deviceRect;\n    let minSquareDistanceToCenter = deviceRadius * deviceRadius;\n    let closestPixelIndex = -1;\n    let i = 0;\n\n    for (let row = 0; row < height; row++) {\n      const dy = row + y - deviceY;\n      const dy2 = dy * dy;\n\n      if (dy2 > minSquareDistanceToCenter) {\n        // skip this row\n        i += 4 * width;\n      } else {\n        for (let col = 0; col < width; col++) {\n          // Decode picked layer from color\n          const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n          if (pickedLayerIndex >= 0) {\n            const dx = col + x - deviceX;\n            const d2 = dx * dx + dy2;\n\n            if (d2 <= minSquareDistanceToCenter) {\n              minSquareDistanceToCenter = d2;\n              closestPixelIndex = i;\n            }\n          }\n          i += 4;\n        }\n      }\n    }\n\n    if (closestPixelIndex >= 0) {\n      // Decode picked object index from color\n      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n      const pickedObject = decodePickingColor(pickedColor);\n      if (pickedObject) {\n        const dy = Math.floor(closestPixelIndex / 4 / width);\n        const dx = closestPixelIndex / 4 - dy * width;\n        return {\n          ...pickedObject,\n          pickedColor,\n          pickedX: x + dx,\n          pickedY: y + dy\n        };\n      }\n      log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n    }\n  }\n  return NO_PICKED_OBJECT;\n}\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\nexport function getUniqueObjects({pickedColors, decodePickingColor}) {\n  const uniqueColors = new Map();\n\n  // Traverse all pixels in picking results and get unique colors\n  if (pickedColors) {\n    for (let i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      const pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        const pickedColor = pickedColors.slice(i, i + 4);\n        const colorKey = pickedColor.join(',');\n        // eslint-disable-next-line\n        if (!uniqueColors.has(colorKey)) {\n          const pickedObject = decodePickingColor(pickedColor);\n          // eslint-disable-next-line\n          if (pickedObject) {\n            uniqueColors.set(colorKey, {\n              ...pickedObject,\n              pickedColor\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?')();\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n"]},"metadata":{},"sourceType":"module"}