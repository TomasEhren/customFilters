{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport assert from './assert';\nimport { log2, clamp } from './math-utils';\nimport { MAX_LATITUDE, lngLatToWorld, worldToLngLat } from './web-mercator-utils';\nexport default function fitBounds(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      bounds = _ref.bounds,\n      _ref$minExtent = _ref.minExtent,\n      minExtent = _ref$minExtent === void 0 ? 0 : _ref$minExtent,\n      _ref$maxZoom = _ref.maxZoom,\n      maxZoom = _ref$maxZoom === void 0 ? 24 : _ref$maxZoom,\n      _ref$padding = _ref.padding,\n      padding = _ref$padding === void 0 ? 0 : _ref$padding,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;\n\n  var _bounds = _slicedToArray(bounds, 2),\n      _bounds$ = _slicedToArray(_bounds[0], 2),\n      west = _bounds$[0],\n      south = _bounds$[1],\n      _bounds$2 = _slicedToArray(_bounds[1], 2),\n      east = _bounds$2[0],\n      north = _bounds$2[1];\n\n  if (Number.isFinite(padding)) {\n    var p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    assert(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));\n  }\n\n  var nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  var se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n  var size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];\n  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n  var scaleX = targetSize[0] / size[0];\n  var scaleY = targetSize[1] / size[1];\n  var offsetX = (padding.right - padding.left) / 2 / scaleX;\n  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n  var centerLngLat = worldToLngLat(center);\n  var zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n  assert(Number.isFinite(zoom));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}","map":{"version":3,"mappings":"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","names":["assert","log2","clamp","MAX_LATITUDE","lngLatToWorld","worldToLngLat","fitBounds","width","height","bounds","minExtent","maxZoom","padding","offset","west","south","east","north","Number","isFinite","p","top","bottom","left","right","nw","se","size","Math","max","abs","targetSize","scaleX","scaleY","offsetX","offsetY","center","centerLngLat","zoom","min","longitude","latitude"],"sources":["../../src/fit-bounds.js"],"sourcesContent":["// @ts-nocheck TODO padding\nimport assert from './assert';\nimport {log2, clamp} from './math-utils';\nimport {MAX_LATITUDE, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\n\n// Returns map settings {latitude, longitude, zoom}\n// that will contain the provided corners within the provided width.\n// Only supports non-perspective mode.\n\nexport default function fitBounds({\n  width,\n  height,\n  bounds,\n  minExtent = 0, // 0.01 would be about 1000 meters (degree is ~110KM)\n  maxZoom = 24, // ~x4,000,000 => About 10 meter extents\n  // options\n  padding = 0,\n  offset = [0, 0]\n}) {\n  const [[west, south], [east, north]] = bounds;\n\n  if (Number.isFinite(padding)) {\n    const p = padding;\n    padding = {\n      top: p,\n      bottom: p,\n      left: p,\n      right: p\n    };\n  } else {\n    // Make sure all the required properties are set\n    assert(\n      Number.isFinite(padding.top) &&\n        Number.isFinite(padding.bottom) &&\n        Number.isFinite(padding.left) &&\n        Number.isFinite(padding.right)\n    );\n  }\n\n  const nw = lngLatToWorld([west, clamp(north, -MAX_LATITUDE, MAX_LATITUDE)]);\n  const se = lngLatToWorld([east, clamp(south, -MAX_LATITUDE, MAX_LATITUDE)]);\n\n  // width/height on the Web Mercator plane\n  const size = [\n    Math.max(Math.abs(se[0] - nw[0]), minExtent),\n    Math.max(Math.abs(se[1] - nw[1]), minExtent)\n  ];\n\n  const targetSize = [\n    width - padding.left - padding.right - Math.abs(offset[0]) * 2,\n    height - padding.top - padding.bottom - Math.abs(offset[1]) * 2\n  ];\n\n  assert(targetSize[0] > 0 && targetSize[1] > 0);\n\n  // scale = screen pixels per unit on the Web Mercator plane\n  const scaleX = targetSize[0] / size[0];\n  const scaleY = targetSize[1] / size[1];\n\n  // Find how much we need to shift the center\n  const offsetX = (padding.right - padding.left) / 2 / scaleX;\n  const offsetY = (padding.bottom - padding.top) / 2 / scaleY;\n\n  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];\n\n  const centerLngLat = worldToLngLat(center);\n  const zoom = Math.min(maxZoom, log2(Math.abs(Math.min(scaleX, scaleY))));\n\n  assert(Number.isFinite(zoom));\n\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom\n  };\n}\n"]},"metadata":{},"sourceType":"module"}