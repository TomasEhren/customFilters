{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../../utils/assert';\nexport default class Schema {\n  constructor(fields, metadata) {\n    _defineProperty(this, \"fields\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  compareTo(other) {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  select() {\n    const nameMap = Object.create(null);\n\n    for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n      columnNames[_key] = arguments[_key];\n    }\n\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n\n    const selectedFields = this.fields.filter(field => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt() {\n    for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      columnIndices[_key2] = arguments[_key2];\n    }\n\n    const selectedFields = columnIndices.map(index => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields) {\n    let fields;\n    let metadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    const fieldMap = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n    return new Schema(mergedFields, metadata);\n  }\n\n}\n\nfunction checkNames(fields) {\n  const usedNames = {};\n\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}","map":{"version":3,"mappings":"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","names":["assert","Schema","constructor","fields","metadata","_defineProperty","Array","isArray","checkNames","Map","compareTo","other","length","i","select","nameMap","Object","create","columnNames","name","selectedFields","filter","field","selectAt","columnIndices","map","index","Boolean","assign","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","usedNames","console","warn","m1","m2"],"sources":["../../../../../src/lib/schema/impl/schema.ts"],"sourcesContent":["import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"]},"metadata":{},"sourceType":"module"}