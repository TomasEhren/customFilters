{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { GLTFMaterialParser } from '@luma.gl/experimental';\nimport { Model, pbr } from '@luma.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  var hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n\n  if (!hasColorAttribute) {\n    attributes.colors = {\n      constant: true,\n      value: new Float32Array([1, 1, 1])\n    };\n  }\n}\n\nvar defaultProps = {\n  pbrMaterial: {\n    type: 'object',\n    value: null\n  },\n  featureIds: {\n    type: 'array',\n    value: null,\n    optional: true\n  }\n};\n\nvar _MeshLayer = /*#__PURE__*/function (_SimpleMeshLayer) {\n  _inherits(_MeshLayer, _SimpleMeshLayer);\n\n  var _super = _createSuper(_MeshLayer);\n\n  function _MeshLayer() {\n    _classCallCheck(this, _MeshLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(_MeshLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      var shaders = _get(_getPrototypeOf(_MeshLayer.prototype), \"getShaders\", this).call(this);\n\n      var modules = shaders.modules;\n      modules.push(pbr);\n      return _objectSpread(_objectSpread({}, shaders), {}, {\n        vs: vs,\n        fs: fs\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var featureIds = this.props.featureIds;\n\n      _get(_getPrototypeOf(_MeshLayer.prototype), \"initializeState\", this).call(this);\n\n      if (featureIds) {\n        this.state.attributeManager.add({\n          featureIdsPickingColors: {\n            type: 5121,\n            size: 3,\n            noAlloc: true,\n            update: this.calculateFeatureIdsPickingColors\n          }\n        });\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(_MeshLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      if (props.pbrMaterial !== oldProps.pbrMaterial) {\n        this.updatePbrMaterialUniforms(props.pbrMaterial);\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var featureIds = this.props.featureIds;\n\n      if (!this.state.model) {\n        return;\n      }\n\n      this.state.model.setUniforms({\n        u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n        u_pickFeatureIds: Boolean(featureIds)\n      });\n\n      _get(_getPrototypeOf(_MeshLayer.prototype), \"draw\", this).call(this, opts);\n    }\n  }, {\n    key: \"getModel\",\n    value: function getModel(mesh) {\n      var _this$props = this.props,\n          id = _this$props.id,\n          pbrMaterial = _this$props.pbrMaterial;\n      var materialParser = this.parseMaterial(pbrMaterial, mesh);\n      var shaders = this.getShaders();\n      validateGeometryAttributes(mesh.attributes);\n      var model = new Model(this.context.gl, _objectSpread(_objectSpread({}, this.getShaders()), {}, {\n        id: id,\n        geometry: mesh,\n        defines: _objectSpread(_objectSpread(_objectSpread({}, shaders.defines), materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines), {}, {\n          HAS_UV_REGIONS: mesh.attributes.uvRegions\n        }),\n        parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,\n        isInstanced: true\n      }));\n      return model;\n    }\n  }, {\n    key: \"updatePbrMaterialUniforms\",\n    value: function updatePbrMaterialUniforms(pbrMaterial) {\n      var model = this.state.model;\n\n      if (model) {\n        var mesh = this.props.mesh;\n        var materialParser = this.parseMaterial(pbrMaterial, mesh);\n        model.setUniforms(materialParser.uniforms);\n      }\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(pbrMaterial, mesh) {\n      var unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);\n      var materialParser = new GLTFMaterialParser(this.context.gl, {\n        attributes: {\n          NORMAL: mesh.attributes.normals,\n          TEXCOORD_0: mesh.attributes.texCoords\n        },\n        material: _objectSpread({\n          unlit: unlit\n        }, pbrMaterial),\n        pbrDebug: false,\n        imageBasedLightingEnvironment: null,\n        lights: true,\n        useTangents: false\n      });\n      return materialParser;\n    }\n  }, {\n    key: \"calculateFeatureIdsPickingColors\",\n    value: function calculateFeatureIdsPickingColors(attribute) {\n      var featureIds = this.props.featureIds;\n      var value = new Uint8ClampedArray(featureIds.length * attribute.size);\n      var pickingColor = [];\n\n      for (var index = 0; index < featureIds.length; index++) {\n        this.encodePickingColor(featureIds[index], pickingColor);\n        value[index * 3] = pickingColor[0];\n        value[index * 3 + 1] = pickingColor[1];\n        value[index * 3 + 2] = pickingColor[2];\n      }\n\n      attribute.value = value;\n    }\n  }]);\n\n  return _MeshLayer;\n}(SimpleMeshLayer);\n\nexport { _MeshLayer as default };\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["GLTFMaterialParser","Model","pbr","SimpleMeshLayer","vs","fs","validateGeometryAttributes","attributes","hasColorAttribute","COLOR_0","colors","constant","value","Float32Array","defaultProps","pbrMaterial","type","featureIds","optional","_MeshLayer","getShaders","shaders","modules","push","initializeState","props","state","attributeManager","add","featureIdsPickingColors","size","noAlloc","update","calculateFeatureIdsPickingColors","updateState","oldProps","changeFlags","updatePbrMaterialUniforms","draw","opts","model","setUniforms","u_Camera","getUniforms","project_uCameraPosition","u_pickFeatureIds","Boolean","getModel","mesh","id","materialParser","parseMaterial","context","gl","geometry","defines","HAS_UV_REGIONS","uvRegions","parameters","isInstanced","uniforms","unlit","pbrMetallicRoughness","baseColorTexture","NORMAL","normals","TEXCOORD_0","texCoords","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","attribute","Uint8ClampedArray","length","pickingColor","index","encodePickingColor","layerName"],"sources":["../../../src/mesh-layer/mesh-layer.js"],"sourcesContent":["import {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {Model, pbr} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n}\n\nconst defaultProps = {\n  // PBR material object. _lighting must be pbr for this to work\n  pbrMaterial: {type: 'object', value: null},\n  featureIds: {type: 'array', value: null, optional: true}\n};\n\nexport default class _MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return {...shaders, vs, fs};\n  }\n\n  initializeState() {\n    const {featureIds} = this.props;\n    super.initializeState();\n\n    if (featureIds) {\n      this.state.attributeManager.add({\n        featureIdsPickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {featureIds} = this.props;\n    if (!this.state.model) {\n      return;\n    }\n    this.state.model.setUniforms({\n      // Needed for PBR (TODO: find better way to get it)\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      u_pickFeatureIds: Boolean(featureIds)\n    });\n\n    super.draw(opts);\n  }\n\n  getModel(mesh) {\n    const {id, pbrMaterial} = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: {\n        ...shaders.defines,\n        ...materialParser?.defines,\n        HAS_UV_REGIONS: mesh.attributes.uvRegions\n      },\n      parameters: materialParser?.parameters,\n      isInstanced: true\n    });\n\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {model} = this.state;\n    if (model) {\n      const {mesh} = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(\n      pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture\n    );\n    const materialParser = new GLTFMaterialParser(this.context.gl, {\n      attributes: {NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords},\n      material: {unlit, ...pbrMaterial},\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n    return materialParser;\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    const {featureIds} = this.props;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n}\n\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}