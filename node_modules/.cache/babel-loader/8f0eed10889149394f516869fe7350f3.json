{"ast":null,"code":"import { assert } from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  const [qualifier, type, definition] = words;\n\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n\n  const name = definition.split(';')[0];\n  return {\n    qualifier,\n    type,\n    name\n  };\n}\nexport function getPassthroughFS() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    version = 100,\n    input,\n    inputType,\n    output\n  } = options;\n\n  if (!input) {\n    if (version === 300) {\n      return FS300;\n    } else if (version > 300) {\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n\n    return FS100;\n  }\n\n  const outputValue = convertToVec4(input, inputType);\n\n  if (version >= 300) {\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n\n    case 'vec2':\n      return 'xy';\n\n    case 'vec3':\n      return 'xyz';\n\n    case 'vec4':\n      return 'xyzw';\n\n    default:\n      assert(false);\n      return null;\n  }\n}\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n\n    case 'vec2':\n      return 2;\n\n    case 'vec3':\n      return 3;\n\n    case 'vec4':\n      return 4;\n\n    default:\n      assert(false);\n      return null;\n  }\n}\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n\n    case 'vec4':\n      return variable;\n\n    default:\n      assert(false);\n      return null;\n  }\n}","map":{"version":3,"mappings":"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","names":["assert","FS100","FS_GLES","FS300","getQualifierDetails","line","qualifiers","Array","isArray","words","replace","split","qualifier","type","definition","includes","name","getPassthroughFS","options","version","input","inputType","output","outputValue","convertToVec4","typeToChannelSuffix","typeToChannelCount","variable"],"sources":["../../../src/utils/shader-utils.js"],"sourcesContent":["import {assert} from '../utils';\nconst FS100 = `void main() {gl_FragColor = vec4(0);}`;\nconst FS_GLES = `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n  const words = line.replace(/^\\s+/, '').split(/\\s+/);\n  // TODO add support for precession qualifiers (highp, mediump and lowp)\n  const [qualifier, type, definition] = words;\n  if (!qualifiers.includes(qualifier) || !type || !definition) {\n    return null;\n  }\n  const name = definition.split(';')[0];\n  return {qualifier, type, name};\n}\n\n// Given the shader version, input and output variable names,\n// builds and return a pass through fragment shader.\nexport function getPassthroughFS(options = {}) {\n  const {version = 100, input, inputType, output} = options;\n  if (!input) {\n    if (version === 300) {\n      // Fast-path for WebGL 2.0\n      return FS300;\n    } else if (version > 300) {\n      // Use the supplied version for OpenGL/ES 3.2+\n      return `#version ${version}\\n${FS_GLES}`;\n    }\n    // Fast-path for WebGL 1.0\n    return FS100;\n  }\n  const outputValue = convertToVec4(input, inputType);\n  if (version >= 300) {\n    // If version is 300, assume WebGL 2.0\n    return `\\\n#version ${version} ${version === 300 ? 'es' : ''}\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n  }\n  // WebGL 1.0\n  return `\\\nvarying ${inputType} ${input};\nvoid main() {\n  gl_FragColor = ${outputValue};\n}`;\n}\n\n// convert glsl type to suffix\nexport function typeToChannelSuffix(type) {\n  switch (type) {\n    case 'float':\n      return 'x';\n    case 'vec2':\n      return 'xy';\n    case 'vec3':\n      return 'xyz';\n    case 'vec4':\n      return 'xyzw';\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// convert glsl type to channel count\nexport function typeToChannelCount(type) {\n  switch (type) {\n    case 'float':\n      return 1;\n    case 'vec2':\n      return 2;\n    case 'vec3':\n      return 3;\n    case 'vec4':\n      return 4;\n    default:\n      assert(false);\n      return null;\n  }\n}\n\n// Returns glsl instruction for converting to vec4\nexport function convertToVec4(variable, type) {\n  switch (type) {\n    case 'float':\n      return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n    case 'vec2':\n      return `vec4(${variable}, 0.0, 1.0)`;\n    case 'vec3':\n      return `vec4(${variable}, 1.0)`;\n    case 'vec4':\n      return variable;\n    default:\n      assert(false);\n      return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}