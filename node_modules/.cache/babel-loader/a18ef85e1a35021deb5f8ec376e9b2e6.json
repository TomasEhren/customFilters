{"ast":null,"code":"export function replaceInRange(_ref) {\n  let {\n    data,\n    getIndex,\n    dataRange,\n    replace\n  } = _ref;\n  const {\n    startRow = 0,\n    endRow = Infinity\n  } = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  const endChunk = dataLengthChanged && data.slice(replaceEnd);\n\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n\n  if (dataLengthChanged) {\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}","map":{"version":3,"mappings":"AAIA,OAAO,SAASA,cAAT,OAA8D;EAAA,IAAtC;IAACC,IAAD;IAAOC,QAAP;IAAiBC,SAAjB;IAA4BC;EAA5B,CAAsC;EACnE,MAAM;IAACC,QAAQ,GAAG,CAAZ;IAAeC,MAAM,GAAGC;EAAxB,IAAoCJ,SAA1C;EACA,MAAMK,KAAK,GAAGP,IAAI,CAACQ,MAAnB;EACA,IAAIC,YAAY,GAAGF,KAAnB;EACA,IAAIG,UAAU,GAAGH,KAAjB;;EACA,KAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,KAApB,EAA2BI,CAAC,EAA5B,EAAgC;IAC9B,MAAMC,GAAG,GAAGX,QAAQ,CAACD,IAAI,CAACW,CAAD,CAAL,CAApB;;IACA,IAAIF,YAAY,GAAGE,CAAfF,IAAoBG,GAAG,IAAIR,QAA/B,EAAyC;MACvCK,YAAY,GAAGE,CAAfF;IACD;;IACD,IAAIG,GAAG,IAAIP,MAAX,EAAmB;MACjBK,UAAU,GAAGC,CAAbD;MACA;IACD;EACF;;EACD,IAAIG,KAAK,GAAGJ,YAAZ;EACA,MAAMK,iBAAiB,GAAGJ,UAAU,GAAGD,YAAbC,KAA8BP,OAAO,CAACK,MAAhE;EAEA,MAAMO,QAAQ,GAAGD,iBAAiB,IAAId,IAAI,CAACgB,KAALhB,CAAWU,UAAXV,CAAtC;;EAEA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,OAAO,CAACK,MAA5B,EAAoCG,CAAC,EAArC,EAAyC;IACvCX,IAAI,CAACa,KAAK,EAAN,CAAJb,GAAgBG,OAAO,CAACQ,CAAD,CAAvBX;EACD;;EACD,IAAIc,iBAAJ,EAAuB;IAErB,KAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,QAAQ,CAACP,MAA7B,EAAqCG,CAAC,EAAtC,EAA0C;MACxCX,IAAI,CAACa,KAAK,EAAN,CAAJb,GAAgBe,QAAQ,CAACJ,CAAD,CAAxBX;IACD;;IAEDA,IAAI,CAACQ,MAALR,GAAca,KAAdb;EACD;;EAED,OAAO;IACLI,QAAQ,EAAEK,YADL;IAELJ,MAAM,EAAEI,YAAY,GAAGN,OAAO,CAACK;EAF1B,CAAP;AAID","names":["replaceInRange","data","getIndex","dataRange","replace","startRow","endRow","Infinity","count","length","replaceStart","replaceEnd","i","row","index","dataLengthChanged","endChunk","slice"],"sources":["../../src/utils.js"],"sourcesContent":["// Assume data array is sorted by <accessor>\n// Replaces the specified range with a new subarray\n// Mutates the data array\n// Returns {startRow, endRow} of the inserted items\nexport function replaceInRange({data, getIndex, dataRange, replace}) {\n  const {startRow = 0, endRow = Infinity} = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  // Save the items after replaceEnd before we overwrite data\n  const endChunk = dataLengthChanged && data.slice(replaceEnd);\n  // Insert new items\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n  if (dataLengthChanged) {\n    // Append items after replaceEnd\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n    // Trim additional items\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n"]},"metadata":{},"sourceType":"module"}