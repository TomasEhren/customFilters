{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Tile3DSubtreeLoader } from '../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nimport { LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE } from '@loaders.gl/tiles';\nimport { parseImplicitTiles, replaceContentUrlTemplate } from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  var contentUrl = tile.contentUrl;\n  var fileExtension = contentUrl.split('.').pop();\n\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n\n    default:\n      return refine;\n  }\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n\n  if (tile.content) {\n    var contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = \"\".concat(options.basePath, \"/\").concat(contentUri);\n  }\n\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n  return tile;\n}\nexport function normalizeTileHeaders(tileset) {\n  var basePath = tileset.basePath;\n  var root = normalizeTileData(tileset.root, tileset);\n  var stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    var tile = stack.pop() || {};\n    var children = tile.children || [];\n\n    var _iterator = _createForOfIteratorHelper(children),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var childHeader = _step.value;\n        normalizeTileData(childHeader, {\n          basePath: basePath\n        });\n        stack.push(childHeader);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return root;\n}\nexport function normalizeImplicitTileHeaders(_x) {\n  return _normalizeImplicitTileHeaders.apply(this, arguments);\n}\n\nfunction _normalizeImplicitTileHeaders() {\n  _normalizeImplicitTileHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tileset) {\n    var basePath, implicitTilingExtension, subdivisionScheme, maximumLevel, subtreeLevels, subtreesUriTemplate, subtreeUrl, rootSubtreeUrl, rootSubtree, contentUrlTemplate, refine, rootLodMetricValue, rootBoundingVolume, options;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (tileset.root) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 2:\n            basePath = tileset.basePath;\n            implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n            subdivisionScheme = implicitTilingExtension.subdivisionScheme, maximumLevel = implicitTilingExtension.maximumLevel, subtreeLevels = implicitTilingExtension.subtreeLevels, subtreesUriTemplate = implicitTilingExtension.subtrees.uri;\n            subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n            rootSubtreeUrl = \"\".concat(basePath, \"/\").concat(subtreeUrl);\n            _context.next = 9;\n            return load(rootSubtreeUrl, Tile3DSubtreeLoader);\n\n          case 9:\n            rootSubtree = _context.sent;\n            contentUrlTemplate = \"\".concat(basePath, \"/\").concat(tileset.root.content.uri);\n            refine = tileset.root.refine;\n            rootLodMetricValue = tileset.root.geometricError;\n            rootBoundingVolume = tileset.root.boundingVolume;\n            options = {\n              contentUrlTemplate: contentUrlTemplate,\n              subtreesUriTemplate: subtreesUriTemplate,\n              subdivisionScheme: subdivisionScheme,\n              subtreeLevels: subtreeLevels,\n              maximumLevel: maximumLevel,\n              refine: refine,\n              basePath: basePath,\n              lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n              rootLodMetricValue: rootLodMetricValue,\n              rootBoundingVolume: rootBoundingVolume,\n              getTileType: getTileType,\n              getRefine: getRefine\n            };\n            _context.next = 17;\n            return normalizeImplicitTileData(tileset.root, rootSubtree, options);\n\n          case 17:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _normalizeImplicitTileHeaders.apply(this, arguments);\n}\n\nexport function normalizeImplicitTileData(_x2, _x3, _x4) {\n  return _normalizeImplicitTileData.apply(this, arguments);\n}\n\nfunction _normalizeImplicitTileData() {\n  _normalizeImplicitTileData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tile, rootSubtree, options) {\n    var _yield$parseImplicitT, children, contentUrl;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (tile) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 2:\n            tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n            tile.lodMetricValue = tile.geometricError;\n            tile.transformMatrix = tile.transform;\n            _context2.next = 7;\n            return parseImplicitTiles(rootSubtree, options);\n\n          case 7:\n            _yield$parseImplicitT = _context2.sent;\n            children = _yield$parseImplicitT.children;\n            contentUrl = _yield$parseImplicitT.contentUrl;\n\n            if (contentUrl) {\n              tile.contentUrl = contentUrl;\n              tile.content = {\n                uri: contentUrl.replace(\"\".concat(options.basePath, \"/\"), '')\n              };\n            }\n\n            tile.refine = getRefine(tile.refine);\n            tile.type = getTileType(tile);\n            tile.children = children;\n            tile.id = tile.contentUrl;\n            return _context2.abrupt(\"return\", tile);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _normalizeImplicitTileData.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["Tile3DSubtreeLoader","load","LOD_METRIC_TYPE","TILE_REFINEMENT","TILE_TYPE","parseImplicitTiles","replaceContentUrlTemplate","getTileType","tile","contentUrl","EMPTY","fileExtension","split","pop","POINTCLOUD","SCENEGRAPH","getRefine","refine","REPLACE","ADD","normalizeTileData","options","content","contentUri","uri","url","basePath","id","lodMetricType","GEOMETRIC_ERROR","lodMetricValue","geometricError","transformMatrix","transform","type","normalizeTileHeaders","tileset","root","stack","push","length","children","childHeader","normalizeImplicitTileHeaders","implicitTilingExtension","extensions","subdivisionScheme","maximumLevel","subtreeLevels","subtreesUriTemplate","subtrees","subtreeUrl","rootSubtreeUrl","rootSubtree","contentUrlTemplate","rootLodMetricValue","rootBoundingVolume","boundingVolume","normalizeImplicitTileData","replace"],"sources":["../../../../src/lib/parsers/parse-3d-tile-header.ts"],"sourcesContent":["import {Tile3DSubtreeLoader} from '../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Subtree} from '../../types';\nimport {parseImplicitTiles, replaceContentUrlTemplate} from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = `${options.basePath}/${contentUri}`;\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n\n  return tile;\n}\n\n// normalize tile headers\nexport function normalizeTileHeaders(tileset) {\n  const basePath = tileset.basePath;\n  const root = normalizeTileData(tileset.root, tileset);\n\n  const stack: any[] = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    for (const childHeader of children) {\n      normalizeTileData(childHeader, {basePath});\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\n\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(tileset: Tileset3D) {\n  if (!tileset.root) {\n    return null;\n  }\n\n  const basePath = tileset.basePath;\n  const implicitTilingExtension = tileset.root.extensions['3DTILES_implicit_tiling'];\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {uri: subtreesUriTemplate}\n  } = implicitTilingExtension;\n  const subtreeUrl = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const rootSubtreeUrl = `${basePath}/${subtreeUrl}`;\n  const rootSubtree = await load(rootSubtreeUrl, Tile3DSubtreeLoader);\n  const contentUrlTemplate = `${basePath}/${tileset.root.content.uri}`;\n  const refine = tileset.root.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tileset.root.geometricError;\n  const rootBoundingVolume = tileset.root.boundingVolume;\n\n  const options = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n\n  return await normalizeImplicitTileData(tileset.root, rootSubtree, options);\n}\n\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, rootSubtree: Subtree, options: any) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n\n  const {children, contentUrl} = await parseImplicitTiles(rootSubtree, options);\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {uri: contentUrl.replace(`${options.basePath}/`, '')};\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n\n  return tile;\n}\n"]},"metadata":{},"sourceType":"module"}