{"ast":null,"code":"import Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport { normalizeShaderModule } from '@luma.gl/core';\nexport default class PostProcessEffect extends Effect {\n  constructor(module) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(props);\n    this.id = \"\".concat(module.name, \"-pass\");\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n\n  postRender(gl, params) {\n    if (!this.passes) {\n      this.passes = createPasses(gl, this.module, this.id, this.props);\n    }\n\n    const {\n      target\n    } = params;\n    let inputBuffer = params.inputBuffer;\n    let outputBuffer = params.swapBuffer;\n\n    for (let index = 0; index < this.passes.length; index++) {\n      if (target && index === this.passes.length - 1) {\n        outputBuffer = target;\n      }\n\n      this.passes[index].render({\n        inputBuffer,\n        outputBuffer\n      });\n      const switchBuffer = outputBuffer;\n      outputBuffer = inputBuffer;\n      inputBuffer = switchBuffer;\n    }\n\n    return inputBuffer;\n  }\n\n  cleanup() {\n    if (this.passes) {\n      for (const pass of this.passes) {\n        pass.delete();\n      }\n\n      this.passes = null;\n    }\n  }\n\n}\n\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    const fs = getFragmentShaderForRenderPass(module);\n    const pass = new ScreenPass(gl, {\n      id,\n      module,\n      fs,\n      moduleSettings\n    });\n    return [pass];\n  }\n\n  const passes = module.passes || [];\n  return passes.map((pass, index) => {\n    const fs = getFragmentShaderForRenderPass(module, pass);\n    const idn = \"\".concat(id, \"-\").concat(index);\n    return new ScreenPass(gl, {\n      id: idn,\n      module,\n      fs,\n      moduleSettings\n    });\n  });\n}\n\nconst FILTER_FS_TEMPLATE = func => \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = texture2D(texture, texCoord);\\n  gl_FragColor = \".concat(func, \"(gl_FragColor, texSize, texCoord);\\n}\\n\");\n\nconst SAMPLER_FS_TEMPLATE = func => \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = \".concat(func, \"(texture, texSize, texCoord);\\n}\\n\");\n\nfunction getFragmentShaderForRenderPass(module) {\n  let pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;\n\n  if (pass.filter) {\n    const func = typeof pass.filter === 'string' ? pass.filter : \"\".concat(module.name, \"_filterColor\");\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    const func = typeof pass.sampler === 'string' ? pass.sampler : \"\".concat(module.name, \"_sampleColor\");\n    return SAMPLER_FS_TEMPLATE(func);\n  }\n\n  return null;\n}","map":{"version":3,"mappings":"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","names":["Effect","ScreenPass","normalizeShaderModule","PostProcessEffect","constructor","module","props","id","name","postRender","gl","params","passes","createPasses","target","inputBuffer","outputBuffer","swapBuffer","index","length","render","switchBuffer","cleanup","pass","delete","moduleSettings","filter","sampler","fs","getFragmentShaderForRenderPass","map","idn","FILTER_FS_TEMPLATE","func","SAMPLER_FS_TEMPLATE"],"sources":["../../../src/effects/post-process-effect.js"],"sourcesContent":["import Effect from '../lib/effect';\nimport ScreenPass from '../passes/screen-pass';\nimport {normalizeShaderModule} from '@luma.gl/core';\n\nexport default class PostProcessEffect extends Effect {\n  constructor(module, props = {}) {\n    super(props);\n    this.id = `${module.name}-pass`;\n    normalizeShaderModule(module);\n    this.module = module;\n  }\n\n  postRender(gl, params) {\n    if (!this.passes) {\n      this.passes = createPasses(gl, this.module, this.id, this.props);\n    }\n\n    const {target} = params;\n    let inputBuffer = params.inputBuffer;\n    let outputBuffer = params.swapBuffer;\n\n    for (let index = 0; index < this.passes.length; index++) {\n      if (target && index === this.passes.length - 1) {\n        outputBuffer = target;\n      }\n      this.passes[index].render({inputBuffer, outputBuffer});\n      const switchBuffer = outputBuffer;\n      outputBuffer = inputBuffer;\n      inputBuffer = switchBuffer;\n    }\n    return inputBuffer;\n  }\n\n  cleanup() {\n    if (this.passes) {\n      for (const pass of this.passes) {\n        pass.delete();\n      }\n      this.passes = null;\n    }\n  }\n}\n\nfunction createPasses(gl, module, id, moduleSettings) {\n  if (module.filter || module.sampler) {\n    const fs = getFragmentShaderForRenderPass(module);\n    const pass = new ScreenPass(gl, {\n      id,\n      module,\n      fs,\n      moduleSettings\n    });\n    return [pass];\n  }\n\n  const passes = module.passes || [];\n  return passes.map((pass, index) => {\n    const fs = getFragmentShaderForRenderPass(module, pass);\n    const idn = `${id}-${index}`;\n\n    return new ScreenPass(gl, {\n      id: idn,\n      module,\n      fs,\n      moduleSettings\n    });\n  });\n}\n\nconst FILTER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);\n}\n`;\n\nconst SAMPLER_FS_TEMPLATE = func => `\\\nuniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ${func}(texture, texSize, texCoord);\n}\n`;\n\nfunction getFragmentShaderForRenderPass(module, pass = module) {\n  if (pass.filter) {\n    const func = typeof pass.filter === 'string' ? pass.filter : `${module.name}_filterColor`;\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    const func = typeof pass.sampler === 'string' ? pass.sampler : `${module.name}_sampleColor`;\n    return SAMPLER_FS_TEMPLATE(func);\n  }\n\n  // console.error(`${module.name} no fragment shader generated`);\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}