{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Timeline } from '@luma.gl/core';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport { flatten } from '../utils/flatten';\nimport { Stats } from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\nimport Viewport from '../viewports/viewport';\nimport { createProgramManager } from '../shaderlib';\nvar TRACE_SET_LAYERS = 'layerManager.setLayers';\nvar TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\nvar INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  resourceManager: null,\n  deck: null,\n  gl: null,\n  stats: null,\n  shaderCache: null,\n  pickingFBO: null,\n  mousePosition: null,\n  userData: {}\n});\n\nvar LayerManager = /*#__PURE__*/function () {\n  function LayerManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        deck = _ref.deck,\n        stats = _ref.stats,\n        viewport = _ref.viewport,\n        timeline = _ref.timeline;\n\n    _classCallCheck(this, LayerManager);\n\n    this.lastRenderedLayers = [];\n    this.layers = [];\n    this.resourceManager = new ResourceManager({\n      gl: gl,\n      protocol: 'deck://'\n    });\n    this.context = _objectSpread(_objectSpread({}, INITIAL_CONTEXT), {}, {\n      layerManager: this,\n      gl: gl,\n      deck: deck,\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      viewport: viewport || new Viewport({\n        id: 'DEFAULT-INITIAL-VIEWPORT'\n      }),\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager\n    });\n    this._nextLayers = null;\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n    this.activateViewport = this.activateViewport.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(LayerManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      this.resourceManager.finalize();\n\n      var _iterator = _createForOfIteratorHelper(this.layers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layer = _step.value;\n\n          this._finalizeLayer(layer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        clearRedrawFlags: false\n      };\n      var redraw = this._needsRedraw;\n\n      if (opts.clearRedrawFlags) {\n        this._needsRedraw = false;\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.layers),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var layer = _step2.value;\n          var layerNeedsRedraw = layer.getNeedsRedraw(opts);\n          redraw = redraw || layerNeedsRedraw;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return redraw;\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      if (this._nextLayers && this._nextLayers !== this.lastRenderedLayers) {\n        return 'layers changed';\n      }\n\n      return this._needsUpdate;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate(reason) {\n      this._needsUpdate = this._needsUpdate || reason;\n    }\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$layerIds = _ref2.layerIds,\n          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;\n\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('debug' in props) {\n        this._debug = props.debug;\n      }\n\n      if ('userData' in props) {\n        this.context.userData = props.userData;\n      }\n\n      if ('layers' in props) {\n        this._nextLayers = props.layers;\n      }\n\n      if ('onError' in props) {\n        this.context.onError = props.onError;\n      }\n    }\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(newLayers, reason) {\n      debug(TRACE_SET_LAYERS, this, reason, newLayers);\n      this.lastRenderedLayers = newLayers;\n      newLayers = flatten(newLayers, Boolean);\n\n      var _iterator3 = _createForOfIteratorHelper(newLayers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var layer = _step3.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      this._updateLayers(this.layers, newLayers);\n\n      return this;\n    }\n  }, {\n    key: \"updateLayers\",\n    value: function updateLayers() {\n      var reason = this.needsUpdate();\n\n      if (reason) {\n        this.setNeedsRedraw(\"updating layers: \".concat(reason));\n        this.setLayers(this._nextLayers || this.lastRenderedLayers, reason);\n      }\n\n      this._nextLayers = null;\n    }\n  }, {\n    key: \"activateViewport\",\n    value: function activateViewport(viewport) {\n      debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n\n      if (viewport) {\n        this.context.viewport = viewport;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(stage, error, layer) {\n      layer.raiseError(error, \"\".concat(stage, \" of \").concat(layer));\n    }\n  }, {\n    key: \"_updateLayers\",\n    value: function _updateLayers(oldLayers, newLayers) {\n      var oldLayerMap = {};\n\n      var _iterator4 = _createForOfIteratorHelper(oldLayers),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var oldLayer = _step4.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            log.warn(\"Multiple old layers with same id \".concat(oldLayer.id))();\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var generatedLayers = [];\n\n      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n      this._finalizeOldLayers(oldLayerMap);\n\n      var needsUpdate = false;\n\n      for (var _i = 0, _generatedLayers = generatedLayers; _i < _generatedLayers.length; _i++) {\n        var layer = _generatedLayers[_i];\n\n        if (layer.hasUniformTransition()) {\n          needsUpdate = true;\n          break;\n        }\n      }\n\n      this._needsUpdate = needsUpdate;\n      this.layers = generatedLayers;\n    }\n  }, {\n    key: \"_updateSublayersRecursively\",\n    value: function _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n      var _iterator5 = _createForOfIteratorHelper(newLayers),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var newLayer = _step5.value;\n          newLayer.context = this.context;\n          var oldLayer = oldLayerMap[newLayer.id];\n\n          if (oldLayer === null) {\n            log.warn(\"Multiple new layers with same id \".concat(newLayer.id))();\n          }\n\n          oldLayerMap[newLayer.id] = null;\n          var sublayers = null;\n\n          try {\n            if (this._debug && oldLayer !== newLayer) {\n              newLayer.validateProps();\n            }\n\n            if (!oldLayer) {\n              this._initializeLayer(newLayer);\n            } else {\n              this._transferLayerState(oldLayer, newLayer);\n\n              this._updateLayer(newLayer);\n            }\n\n            generatedLayers.push(newLayer);\n            sublayers = newLayer.isComposite && newLayer.getSubLayers();\n          } catch (err) {\n            this._handleError('matching', err, newLayer);\n          }\n\n          if (sublayers) {\n            this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"_finalizeOldLayers\",\n    value: function _finalizeOldLayers(oldLayerMap) {\n      for (var layerId in oldLayerMap) {\n        var layer = oldLayerMap[layerId];\n\n        if (layer) {\n          this._finalizeLayer(layer);\n        }\n      }\n    }\n  }, {\n    key: \"_initializeLayer\",\n    value: function _initializeLayer(layer) {\n      try {\n        layer._initialize();\n\n        layer.lifecycle = LIFECYCLE.INITIALIZED;\n      } catch (err) {\n        this._handleError('initialization', err, layer);\n      }\n    }\n  }, {\n    key: \"_transferLayerState\",\n    value: function _transferLayerState(oldLayer, newLayer) {\n      newLayer._transferState(oldLayer);\n\n      newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n      if (newLayer !== oldLayer) {\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n      }\n    }\n  }, {\n    key: \"_updateLayer\",\n    value: function _updateLayer(layer) {\n      try {\n        layer._update();\n      } catch (err) {\n        this._handleError('update', err, layer);\n      }\n    }\n  }, {\n    key: \"_finalizeLayer\",\n    value: function _finalizeLayer(layer) {\n      this._needsRedraw = this._needsRedraw || \"finalized \".concat(layer);\n      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n      try {\n        layer._finalize();\n\n        layer.lifecycle = LIFECYCLE.FINALIZED;\n      } catch (err) {\n        this._handleError('finalization', err, layer);\n      }\n    }\n  }]);\n\n  return LayerManager;\n}();\n\nexport { LayerManager as default };","map":{"version":3,"mappings":"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","names":["Timeline","LIFECYCLE","log","debug","flatten","Stats","ResourceManager","Viewport","createProgramManager","TRACE_SET_LAYERS","TRACE_ACTIVATE_VIEWPORT","INITIAL_CONTEXT","Object","seal","layerManager","resourceManager","deck","gl","stats","shaderCache","pickingFBO","mousePosition","userData","LayerManager","constructor","viewport","timeline","lastRenderedLayers","layers","protocol","context","programManager","id","_nextLayers","_needsRedraw","_needsUpdate","_debug","activateViewport","bind","finalize","layer","_finalizeLayer","needsRedraw","opts","clearRedrawFlags","redraw","layerNeedsRedraw","getNeedsRedraw","needsUpdate","setNeedsRedraw","reason","setNeedsUpdate","getLayers","layerIds","filter","find","layerId","indexOf","setProps","props","onError","setLayers","newLayers","Boolean","_updateLayers","updateLayers","_handleError","stage","error","raiseError","oldLayers","oldLayerMap","oldLayer","warn","generatedLayers","_updateSublayersRecursively","_finalizeOldLayers","hasUniformTransition","newLayer","sublayers","validateProps","_initializeLayer","_transferLayerState","_updateLayer","push","isComposite","getSubLayers","err","_initialize","lifecycle","INITIALIZED","_transferState","MATCHED","AWAITING_GC","_update","AWAITING_FINALIZATION","_finalize","FINALIZED"],"sources":["../../../src/lib/layer-manager.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Timeline} from '@luma.gl/core';\nimport {LIFECYCLE} from '../lifecycle/constants';\nimport log from '../utils/log';\nimport debug from '../debug';\nimport {flatten} from '../utils/flatten';\nimport {Stats} from '@probe.gl/stats';\nimport ResourceManager from './resource/resource-manager';\n\nimport Viewport from '../viewports/viewport';\nimport {createProgramManager} from '../shaderlib';\n\nconst TRACE_SET_LAYERS = 'layerManager.setLayers';\nconst TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';\n\n// CONTEXT IS EXPOSED TO LAYERS\nconst INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  resourceManager: null,\n  deck: null,\n  gl: null,\n\n  // General resources\n  stats: null, // for tracking lifecycle performance\n\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null, // Screen-size framebuffer that layers can reuse\n\n  mousePosition: null,\n\n  userData: {} // Place for any custom app `context`\n});\n\nexport default class LayerManager {\n  // eslint-disable-next-line\n  constructor(gl, {deck, stats, viewport, timeline} = {}) {\n    // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n    this.lastRenderedLayers = [];\n    this.layers = [];\n    this.resourceManager = new ResourceManager({gl, protocol: 'deck://'});\n\n    this.context = {\n      ...INITIAL_CONTEXT,\n      layerManager: this,\n      gl,\n      deck,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      programManager: gl && createProgramManager(gl),\n      stats: stats || new Stats({id: 'deck.gl'}),\n      // Make sure context.viewport is not empty on the first layer initialization\n      viewport: viewport || new Viewport({id: 'DEFAULT-INITIAL-VIEWPORT'}), // Current viewport, exposed to layers for project* function\n      timeline: timeline || new Timeline(),\n      resourceManager: this.resourceManager\n    };\n\n    this._nextLayers = null;\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._debug = false;\n\n    this.activateViewport = this.activateViewport.bind(this);\n\n    Object.seal(this);\n  }\n\n  // Method to call when the layer manager is not needed anymore.\n  finalize() {\n    this.resourceManager.finalize();\n    // Finalize all layers\n    for (const layer of this.layers) {\n      this._finalizeLayer(layer);\n    }\n  }\n\n  // Check if a redraw is needed\n  needsRedraw(opts = {clearRedrawFlags: false}) {\n    let redraw = this._needsRedraw;\n    if (opts.clearRedrawFlags) {\n      this._needsRedraw = false;\n    }\n\n    // This layers list doesn't include sublayers, relying on composite layers\n    for (const layer of this.layers) {\n      // Call every layer to clear their flags\n      const layerNeedsRedraw = layer.getNeedsRedraw(opts);\n      redraw = redraw || layerNeedsRedraw;\n    }\n\n    return redraw;\n  }\n\n  // Check if a deep update of all layers is needed\n  needsUpdate() {\n    if (this._nextLayers && this._nextLayers !== this.lastRenderedLayers) {\n      // New layers array may be the same as the old one if `setProps` is called by React\n      return 'layers changed';\n    }\n    return this._needsUpdate;\n  }\n\n  // Layers will be redrawn (in next animation frame)\n  setNeedsRedraw(reason) {\n    this._needsRedraw = this._needsRedraw || reason;\n  }\n\n  // Layers will be updated deeply (in next animation frame)\n  // Potentially regenerating attributes and sub layers\n  setNeedsUpdate(reason) {\n    this._needsUpdate = this._needsUpdate || reason;\n  }\n\n  // Gets an (optionally) filtered list of layers\n  getLayers({layerIds = null} = {}) {\n    // Filtering by layerId compares beginning of strings, so that sublayers will be included\n    // Dependes on the convention of adding suffixes to the parent's layer name\n    return layerIds\n      ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0))\n      : this.layers;\n  }\n\n  // Set props needed for layer rendering and picking.\n  setProps(props) {\n    if ('debug' in props) {\n      this._debug = props.debug;\n    }\n\n    // A way for apps to add data to context that can be accessed in layers\n    if ('userData' in props) {\n      this.context.userData = props.userData;\n    }\n\n    // New layers will be processed in `updateLayers` in the next update cycle\n    if ('layers' in props) {\n      this._nextLayers = props.layers;\n    }\n\n    if ('onError' in props) {\n      this.context.onError = props.onError;\n    }\n  }\n\n  // Supply a new layer list, initiating sublayer generation and layer matching\n  setLayers(newLayers, reason) {\n    debug(TRACE_SET_LAYERS, this, reason, newLayers);\n\n    this.lastRenderedLayers = newLayers;\n\n    newLayers = flatten(newLayers, Boolean);\n\n    for (const layer of newLayers) {\n      layer.context = this.context;\n    }\n\n    this._updateLayers(this.layers, newLayers);\n\n    return this;\n  }\n\n  // Update layers from last cycle if `setNeedsUpdate()` has been called\n  updateLayers() {\n    // NOTE: For now, even if only some layer has changed, we update all layers\n    // to ensure that layer id maps etc remain consistent even if different\n    // sublayers are rendered\n    const reason = this.needsUpdate();\n    if (reason) {\n      this.setNeedsRedraw(`updating layers: ${reason}`);\n      // Force a full update\n      this.setLayers(this._nextLayers || this.lastRenderedLayers, reason);\n    }\n    // Updated, clear the backlog\n    this._nextLayers = null;\n  }\n\n  //\n  // PRIVATE METHODS\n  //\n\n  // Make a viewport \"current\" in layer context, updating viewportChanged flags\n  activateViewport(viewport) {\n    debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);\n    if (viewport) {\n      this.context.viewport = viewport;\n    }\n    return this;\n  }\n\n  _handleError(stage, error, layer) {\n    layer.raiseError(error, `${stage} of ${layer}`);\n  }\n\n  // Match all layers, checking for caught errors\n  // To avoid having an exception in one layer disrupt other layers\n  // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n  _updateLayers(oldLayers, newLayers) {\n    // Create old layer map\n    const oldLayerMap = {};\n    for (const oldLayer of oldLayers) {\n      if (oldLayerMap[oldLayer.id]) {\n        log.warn(`Multiple old layers with same id ${oldLayer.id}`)();\n      } else {\n        oldLayerMap[oldLayer.id] = oldLayer;\n      }\n    }\n\n    // Allocate array for generated layers\n    const generatedLayers = [];\n\n    // Match sublayers\n    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);\n\n    // Finalize unmatched layers\n    this._finalizeOldLayers(oldLayerMap);\n\n    let needsUpdate = false;\n    for (const layer of generatedLayers) {\n      if (layer.hasUniformTransition()) {\n        needsUpdate = true;\n        break;\n      }\n    }\n\n    this._needsUpdate = needsUpdate;\n    this.layers = generatedLayers;\n  }\n\n  /* eslint-disable complexity,max-statements */\n  // Note: adds generated layers to `generatedLayers` array parameter\n  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {\n    for (const newLayer of newLayers) {\n      newLayer.context = this.context;\n\n      // Given a new coming layer, find its matching old layer (if any)\n      const oldLayer = oldLayerMap[newLayer.id];\n      if (oldLayer === null) {\n        // null, rather than undefined, means this id was originally there\n        log.warn(`Multiple new layers with same id ${newLayer.id}`)();\n      }\n      // Remove the old layer from candidates, as it has been matched with this layer\n      oldLayerMap[newLayer.id] = null;\n\n      let sublayers = null;\n\n      // We must not generate exceptions until after layer matching is complete\n      try {\n        if (this._debug && oldLayer !== newLayer) {\n          newLayer.validateProps();\n        }\n\n        if (!oldLayer) {\n          this._initializeLayer(newLayer);\n        } else {\n          this._transferLayerState(oldLayer, newLayer);\n          this._updateLayer(newLayer);\n        }\n        generatedLayers.push(newLayer);\n\n        // Call layer lifecycle method: render sublayers\n        sublayers = newLayer.isComposite && newLayer.getSubLayers();\n        // End layer lifecycle method: render sublayers\n      } catch (err) {\n        this._handleError('matching', err, newLayer); // Record first exception\n      }\n\n      if (sublayers) {\n        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);\n      }\n    }\n  }\n  /* eslint-enable complexity,max-statements */\n\n  // Finalize any old layers that were not matched\n  _finalizeOldLayers(oldLayerMap) {\n    for (const layerId in oldLayerMap) {\n      const layer = oldLayerMap[layerId];\n      if (layer) {\n        this._finalizeLayer(layer);\n      }\n    }\n  }\n\n  // EXCEPTION SAFE LAYER ACCESS\n\n  // Initializes a single layer, calling layer methods\n  _initializeLayer(layer) {\n    try {\n      layer._initialize();\n      layer.lifecycle = LIFECYCLE.INITIALIZED;\n    } catch (err) {\n      this._handleError('initialization', err, layer);\n      // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n    }\n  }\n\n  _transferLayerState(oldLayer, newLayer) {\n    newLayer._transferState(oldLayer);\n    newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n    if (newLayer !== oldLayer) {\n      oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n    }\n  }\n\n  // Updates a single layer, cleaning all flags\n  _updateLayer(layer) {\n    try {\n      layer._update();\n    } catch (err) {\n      this._handleError('update', err, layer);\n    }\n  }\n\n  // Finalizes a single layer\n  _finalizeLayer(layer) {\n    this._needsRedraw = this._needsRedraw || `finalized ${layer}`;\n\n    layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n\n    try {\n      layer._finalize();\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n    } catch (err) {\n      this._handleError('finalization', err, layer);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}