{"ast":null,"code":"import { getBlobOrSVGDataUrl } from './svg-utils';\nexport default async function parseToImage(arrayBuffer, options, url) {\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n\n      image.onerror = err => reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"mappings":"AACA,SAAQA,mBAAR,QAAkC,aAAlC;AAGA,eAAe,eAAeC,YAAf,CACbC,WADa,EAEbC,OAFa,EAGbC,GAHa,EAIc;EAK3B,MAAMC,aAAa,GAAGL,mBAAmB,CAACE,WAAD,EAAcE,GAAd,CAAzC;EACA,MAAME,GAAG,GAAGC,IAAI,CAACD,GAALC,IAAYA,IAAI,CAACC,SAA7B;EACA,MAAMC,SAAS,GAAG,OAAOJ,aAAP,KAAyB,QAAzB,IAAqCC,GAAG,CAACI,eAAJJ,CAAoBD,aAApBC,CAAvD;;EACA,IAAI;IACF,OAAO,MAAMK,WAAW,CAACF,SAAS,IAAIJ,aAAd,EAA6BF,OAA7B,CAAxB;EADF,UAEU;IACR,IAAIM,SAAJ,EAAe;MACbH,GAAG,CAACM,eAAJN,CAAoBG,SAApBH;IACD;EACF;AACF;AAED,OAAO,eAAeK,WAAf,CAA2BP,GAA3B,EAAgCD,OAAhC,EAAoE;EACzE,MAAMU,KAAK,GAAG,IAAIC,KAAJ,EAAd;EACAD,KAAK,CAACE,GAANF,GAAYT,GAAZS;;EASA,IAAIV,OAAO,CAACU,KAARV,IAAiBA,OAAO,CAACU,KAARV,CAAca,MAA/Bb,IAAyCU,KAAK,CAACG,MAAnD,EAA2D;IACzD,MAAMH,KAAK,CAACG,MAANH,EAAN;IACA,OAAOA,KAAP;EACD;;EAGD,OAAO,MAAM,IAAII,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IAC5C,IAAI;MACFN,KAAK,CAACO,MAANP,GAAe,MAAMK,OAAO,CAACL,KAAD,CAA5BA;;MACAA,KAAK,CAACQ,OAANR,GAAiBS,GAAD,IAASH,MAAM,CAAC,IAAII,KAAJ,gCAAkCnB,GAAlC,eAA0CkB,GAA1C,EAAD,CAA/BT;IAFF,EAGE,OAAOW,KAAP,EAAc;MACdL,MAAM,CAACK,KAAD,CAANL;IACD;EANU,EAAb;AAQD","names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}