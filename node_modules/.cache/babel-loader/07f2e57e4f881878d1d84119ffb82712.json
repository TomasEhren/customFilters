{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../../utils/assert';\n\nvar Schema = /*#__PURE__*/function () {\n  function Schema(fields, metadata) {\n    _classCallCheck(this, Schema);\n\n    _defineProperty(this, \"fields\", void 0);\n\n    _defineProperty(this, \"metadata\", void 0);\n\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  _createClass(Schema, [{\n    key: \"compareTo\",\n    value: function compareTo(other) {\n      if (this.metadata !== other.metadata) {\n        return false;\n      }\n\n      if (this.fields.length !== other.fields.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.fields.length; ++i) {\n        if (!this.fields[i].compareTo(other.fields[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"select\",\n    value: function select() {\n      var nameMap = Object.create(null);\n\n      for (var _len = arguments.length, columnNames = new Array(_len), _key = 0; _key < _len; _key++) {\n        columnNames[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _columnNames = columnNames; _i < _columnNames.length; _i++) {\n        var name = _columnNames[_i];\n        nameMap[name] = true;\n      }\n\n      var selectedFields = this.fields.filter(function (field) {\n        return nameMap[field.name];\n      });\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"selectAt\",\n    value: function selectAt() {\n      var _this = this;\n\n      for (var _len2 = arguments.length, columnIndices = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        columnIndices[_key2] = arguments[_key2];\n      }\n\n      var selectedFields = columnIndices.map(function (index) {\n        return _this.fields[index];\n      }).filter(Boolean);\n      return new Schema(selectedFields, this.metadata);\n    }\n  }, {\n    key: \"assign\",\n    value: function assign(schemaOrFields) {\n      var fields;\n      var metadata = this.metadata;\n\n      if (schemaOrFields instanceof Schema) {\n        var otherSchema = schemaOrFields;\n        fields = otherSchema.fields;\n        metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n      } else {\n        fields = schemaOrFields;\n      }\n\n      var fieldMap = Object.create(null);\n\n      var _iterator = _createForOfIteratorHelper(this.fields),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          fieldMap[field.name] = field;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(fields),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          fieldMap[_field.name] = _field;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var mergedFields = Object.values(fieldMap);\n      return new Schema(mergedFields, metadata);\n    }\n  }]);\n\n  return Schema;\n}();\n\nexport { Schema as default };\n\nfunction checkNames(fields) {\n  var usedNames = {};\n\n  var _iterator3 = _createForOfIteratorHelper(fields),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var field = _step3.value;\n\n      if (usedNames[field.name]) {\n        console.warn('Schema: duplicated field name', field.name, field);\n      }\n\n      usedNames[field.name] = true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nfunction mergeMaps(m1, m2) {\n  return new Map([].concat(_toConsumableArray(m1 || new Map()), _toConsumableArray(m2 || new Map())));\n}","map":{"version":3,"mappings":"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","names":["assert","Schema","constructor","fields","metadata","_defineProperty","Array","isArray","checkNames","Map","compareTo","other","length","i","select","nameMap","Object","create","columnNames","name","selectedFields","filter","field","selectAt","columnIndices","map","index","Boolean","assign","schemaOrFields","otherSchema","mergeMaps","fieldMap","mergedFields","values","usedNames","console","warn","m1","m2"],"sources":["../../../../../src/lib/schema/impl/schema.ts"],"sourcesContent":["import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n"]},"metadata":{},"sourceType":"module"}