{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from '../../lib/constants';\nimport project from '../project/project';\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport memoize from '../../utils/memoize';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nvar vs = \"\\nconst int max_lights = 2;\\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\\nuniform vec4 shadow_uProjectCenters[max_lights];\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform int shadow_uLightId;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\\n  if (shadow_uDrawShadowMap) {\\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\\n  }\\n  if (shadow_uUseShadowMap) {\\n    for (int i = 0; i < max_lights; i++) {\\n      if(i < int(shadow_uLightCount)) {\\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\\n      }\\n    }\\n  }\\n  return gl_Position;\\n}\\n\";\nvar fs = \"\\nconst int max_lights = 2;\\nuniform bool shadow_uDrawShadowMap;\\nuniform bool shadow_uUseShadowMap;\\nuniform sampler2D shadow_uShadowMap0;\\nuniform sampler2D shadow_uShadowMap1;\\nuniform vec4 shadow_uColor;\\nuniform float shadow_uLightCount;\\n\\nvarying vec3 shadow_vPosition[max_lights];\\n\\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\\n\\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\\n\\n  float z = dot(rgbaDepth, bitUnpackShift);\\n  return smoothstep(0.001, 0.01, position.z - z);\\n}\\n\\nvec4 shadow_filterShadowColor(vec4 color) {\\n  if (shadow_uDrawShadowMap) {\\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\\n    return rgbaDepth;\\n  }\\n  if (shadow_uUseShadowMap) {\\n    float shadowAlpha = 0.0;\\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\\n    if(shadow_uLightCount > 1.0) {\\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\\n    }\\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\\n\\n    return vec4(\\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\\n      blendedAlpha\\n    );\\n  }\\n  return color;\\n}\\n\";\nvar getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nvar getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nvar DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  var _xyz = _slicedToArray(xyz, 3),\n      x = _xyz[0],\n      y = _xyz[1],\n      z = _xyz[2];\n\n  var coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition(_ref) {\n  var viewport = _ref.viewport,\n      center = _ref.center;\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices(_ref2) {\n  var viewport = _ref2.viewport,\n      shadowMatrices = _ref2.shadowMatrices;\n  var projectionMatrices = [];\n  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  var farZ = viewport.isGeospatial ? undefined : 1;\n  var corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(function (pixel) {\n    return screenToCommonSpace(pixel, pixelUnprojectionMatrix);\n  });\n\n  var _iterator = _createForOfIteratorHelper(shadowMatrices),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var shadowMatrix = _step.value;\n      var viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n      var positions = corners.map(function (corner) {\n        return viewMatrix.transform(corner);\n      });\n      var projectionMatrix = new Matrix4().ortho({\n        left: Math.min.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return position[0];\n        }))),\n        right: Math.max.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return position[0];\n        }))),\n        bottom: Math.min.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return position[1];\n        }))),\n        top: Math.max.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return position[1];\n        }))),\n        near: Math.min.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return -position[2];\n        }))),\n        far: Math.max.apply(Math, _toConsumableArray(positions.map(function (position) {\n          return -position[2];\n        })))\n      });\n      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return projectionMatrices;\n}\n\nfunction createShadowUniforms() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var uniforms = {\n    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),\n    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    shadow_uLightId: opts.shadowLightId || 0,\n    shadow_uLightCount: opts.shadowMatrices.length\n  };\n  var center = getMemoizedViewportCenterPosition({\n    viewport: opts.viewport,\n    center: context.project_uCenter\n  });\n  var projectCenters = [];\n  var viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: opts.viewport\n  }).slice();\n\n  for (var i = 0; i < opts.shadowMatrices.length; i++) {\n    var viewProjectionMatrix = viewProjectionMatrices[i];\n    var viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());\n\n    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  for (var _i = 0; _i < viewProjectionMatrices.length; _i++) {\n    uniforms[\"shadow_uViewProjectionMatrices[\".concat(_i, \"]\")] = viewProjectionMatrices[_i];\n    uniforms[\"shadow_uProjectCenters[\".concat(_i, \"]\")] = projectCenters[_i];\n\n    if (opts.shadowMaps && opts.shadowMaps.length > 0) {\n      uniforms[\"shadow_uShadowMap\".concat(_i)] = opts.shadowMaps[_i];\n    } else {\n      uniforms[\"shadow_uShadowMap\".concat(_i)] = opts.dummyShadowMap;\n    }\n  }\n\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs: vs,\n  fs: fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': \"\\n    position = shadow_setVertexPosition(geometry.position);\\n    \",\n    'fs:DECKGL_FILTER_COLOR': \"\\n    color = shadow_filterShadowColor(color);\\n    \"\n  },\n  getUniforms: function getUniforms() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {\n      var _opts$shadowEnabled = opts.shadowEnabled,\n          shadowEnabled = _opts$shadowEnabled === void 0 ? true : _opts$shadowEnabled;\n      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0 ? createShadowUniforms(opts, context) : {\n        shadow_uDrawShadowMap: false,\n        shadow_uUseShadowMap: false\n      };\n    }\n\n    return {};\n  }\n};","map":{"version":3,"mappings":"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","names":["COORDINATE_SYSTEM","PROJECTION_MODE","project","Vector3","Matrix4","memoize","pixelsToWorld","vs","fs","getMemoizedViewportCenterPosition","getViewportCenterPosition","getMemoizedViewProjectionMatrices","getViewProjectionMatrices","DEFAULT_SHADOW_COLOR","VECTOR_TO_POINT_MATRIX","screenToCommonSpace","xyz","pixelUnprojectionMatrix","x","y","z","coord","Number","isFinite","viewport","center","viewProjectionMatrix","invert","transform","shadowMatrices","projectionMatrices","farZ","isGeospatial","undefined","corners","width","height","map","pixel","shadowMatrix","viewMatrix","clone","translate","negate","positions","corner","projectionMatrix","ortho","left","Math","min","position","right","max","bottom","top","near","far","push","multiplyRight","createShadowUniforms","opts","context","uniforms","shadow_uDrawShadowMap","Boolean","drawToShadowMap","shadow_uUseShadowMap","shadowMaps","length","shadow_uColor","shadowColor","shadow_uLightId","shadowLightId","shadow_uLightCount","project_uCenter","projectCenters","viewProjectionMatrices","slice","i","viewProjectionMatrixCentered","project_uCoordinateSystem","LNGLAT","project_uProjectionMode","WEB_MERCATOR","dummyShadowMap","name","dependencies","inject","getUniforms","shadowEnabled"],"sources":["../../../../src/shaderlib/shadow/shadow.js"],"sourcesContent":["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {COORDINATE_SYSTEM, PROJECTION_MODE} from '../../lib/constants';\nimport project from '../project/project';\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport memoize from '../../utils/memoize';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\n\nconst vs = `\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\n\nconst fs = `\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\n\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\n\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n  const [x, y, z] = xyz;\n  const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n\n  if (Number.isFinite(z)) {\n    return coord;\n  }\n  return [coord[0], coord[1], 0];\n}\n\nfunction getViewportCenterPosition({viewport, center}) {\n  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\n\nfunction getViewProjectionMatrices({viewport, shadowMatrices}) {\n  const projectionMatrices = [];\n  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n  const farZ = viewport.isGeospatial ? undefined : 1;\n  const corners = [\n    [0, 0, farZ], // top left ground\n    [viewport.width, 0, farZ], // top right ground\n    [0, viewport.height, farZ], // bottom left ground\n    [viewport.width, viewport.height, farZ], // bottom right ground\n    [0, 0, -1], // top left near\n    [viewport.width, 0, -1], // top right near\n    [0, viewport.height, -1], // bottom left near\n    [viewport.width, viewport.height, -1] // bottom right near\n  ].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n\n  for (const shadowMatrix of shadowMatrices) {\n    const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n    const positions = corners.map(corner => viewMatrix.transform(corner));\n    const projectionMatrix = new Matrix4().ortho({\n      left: Math.min(...positions.map(position => position[0])),\n      right: Math.max(...positions.map(position => position[0])),\n      bottom: Math.min(...positions.map(position => position[1])),\n      top: Math.max(...positions.map(position => position[1])),\n      near: Math.min(...positions.map(position => -position[2])),\n      far: Math.max(...positions.map(position => -position[2]))\n    });\n    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n  }\n  return projectionMatrices;\n}\n\nfunction createShadowUniforms(opts = {}, context = {}) {\n  const uniforms = {\n    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),\n    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n    shadow_uLightId: opts.shadowLightId || 0,\n    shadow_uLightCount: opts.shadowMatrices.length\n  };\n\n  const center = getMemoizedViewportCenterPosition({\n    viewport: opts.viewport,\n    center: context.project_uCenter\n  });\n\n  const projectCenters = [];\n  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n    shadowMatrices: opts.shadowMatrices,\n    viewport: opts.viewport\n  }).slice();\n\n  for (let i = 0; i < opts.shadowMatrices.length; i++) {\n    const viewProjectionMatrix = viewProjectionMatrices[i];\n    const viewProjectionMatrixCentered = viewProjectionMatrix\n      .clone()\n      .translate(new Vector3(opts.viewport.center).negate());\n\n    if (\n      context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT &&\n      context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR\n    ) {\n      viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n      projectCenters[i] = center;\n    } else {\n      viewProjectionMatrices[i] = viewProjectionMatrix\n        .clone()\n        .multiplyRight(VECTOR_TO_POINT_MATRIX);\n      projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n    }\n  }\n\n  for (let i = 0; i < viewProjectionMatrices.length; i++) {\n    uniforms[`shadow_uViewProjectionMatrices[${i}]`] = viewProjectionMatrices[i];\n    uniforms[`shadow_uProjectCenters[${i}]`] = projectCenters[i];\n\n    if (opts.shadowMaps && opts.shadowMaps.length > 0) {\n      uniforms[`shadow_uShadowMap${i}`] = opts.shadowMaps[i];\n    } else {\n      uniforms[`shadow_uShadowMap${i}`] = opts.dummyShadowMap;\n    }\n  }\n  return uniforms;\n}\n\nexport default {\n  name: 'shadow',\n  dependencies: [project],\n  vs,\n  fs,\n  inject: {\n    'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n    'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n  },\n  getUniforms: (opts = {}, context = {}) => {\n    if (opts.drawToShadowMap || (opts.shadowMaps && opts.shadowMaps.length > 0)) {\n      const {shadowEnabled = true} = opts;\n      return shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0\n        ? createShadowUniforms(opts, context)\n        : {\n            shadow_uDrawShadowMap: false,\n            shadow_uUseShadowMap: false\n          };\n    }\n    return {};\n  }\n};\n"]},"metadata":{},"sourceType":"module"}