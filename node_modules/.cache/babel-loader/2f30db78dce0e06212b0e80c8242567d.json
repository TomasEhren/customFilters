{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { load } from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\nimport { getLodStatus } from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nvar I3STilesetTraverser = /*#__PURE__*/function (_TilesetTraverser) {\n  _inherits(I3STilesetTraverser, _TilesetTraverser);\n\n  var _super = _createSuper(I3STilesetTraverser);\n\n  function I3STilesetTraverser(options) {\n    var _this;\n\n    _classCallCheck(this, I3STilesetTraverser);\n\n    _this = _super.call(this, options);\n\n    _defineProperty(_assertThisInitialized(_this), \"_tileManager\", void 0);\n\n    _this._tileManager = new I3STileManager();\n    return _this;\n  }\n\n  _createClass(I3STilesetTraverser, [{\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState) {\n      tile._lodJudge = getLodStatus(tile, frameState);\n      return tile._lodJudge === 'DIG';\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var _this2 = this;\n\n      var children = tile.header.children || [];\n      var childTiles = tile.children;\n      var tileset = tile.tileset;\n\n      var _iterator = _createForOfIteratorHelper(children),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var child = _step.value;\n          var extendedId = \"\".concat(child.id, \"-\").concat(frameState.viewport.id);\n          var childTile = childTiles && childTiles.find(function (t) {\n            return t.id === extendedId;\n          });\n\n          if (!childTile) {\n            var request = function request() {\n              return _this2._loadTile(child.id, tileset);\n            };\n\n            var cachedRequest = _this2._tileManager.find(extendedId);\n\n            if (!cachedRequest) {\n              if (tileset.tileset.nodePages) {\n                request = function request() {\n                  return tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n                };\n              }\n\n              _this2._tileManager.add(request, extendedId, function (header) {\n                return _this2._onTileLoad(header, tile, extendedId);\n              }, frameState);\n            } else {\n              _this2._tileManager.update(extendedId, frameState);\n            }\n          } else if (childTile) {\n            _this2.updateTile(childTile, frameState);\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_loadTile\",\n    value: function () {\n      var _loadTile2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(nodeId, tileset) {\n        var loader, nodeUrl, options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                loader = tileset.loader;\n                nodeUrl = tileset.getTileUrl(\"\".concat(tileset.url, \"/nodes/\").concat(nodeId));\n                options = _objectSpread(_objectSpread({}, tileset.loadOptions), {}, {\n                  i3s: _objectSpread(_objectSpread({}, tileset.loadOptions.i3s), {}, {\n                    isTileHeader: true,\n                    loadContent: false\n                  })\n                });\n                _context.next = 5;\n                return load(nodeUrl, loader, options);\n\n              case 5:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _loadTile(_x, _x2) {\n        return _loadTile2.apply(this, arguments);\n      }\n\n      return _loadTile;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(header, tile, extendedId) {\n      var childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n      tile.children.push(childTile);\n\n      var frameState = this._tileManager.find(childTile.id).frameState;\n\n      this.updateTile(childTile, frameState);\n\n      if (this._frameNumber === frameState.frameNumber) {\n        this.executeTraversal(childTile, frameState);\n      }\n    }\n  }]);\n\n  return I3STilesetTraverser;\n}(TilesetTraverser);\n\nexport { I3STilesetTraverser as default };","map":{"version":3,"mappings":"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","names":["load","TilesetTraverser","getLodStatus","TileHeader","I3STileManager","I3STilesetTraverser","constructor","options","_defineProperty","_tileManager","shouldRefine","tile","frameState","_lodJudge","updateChildTiles","children","header","childTiles","tileset","child","extendedId","id","viewport","childTile","find","t","request","_loadTile","cachedRequest","nodePages","nodePagesTile","formTileFromNodePages","add","_onTileLoad","update","updateTile","nodeId","loader","nodeUrl","getTileUrl","url","loadOptions","i3s","isTileHeader","loadContent","push","_frameNumber","frameNumber","executeTraversal"],"sources":["../../../../src/tileset/traversers/i3s-tileset-traverser.ts"],"sourcesContent":["import {load} from '@loaders.gl/core';\nimport TilesetTraverser from './tileset-traverser';\n\nimport {getLodStatus} from '../helpers/i3s-lod';\nimport TileHeader from '../tile-3d';\nimport I3STileManager from './i3s-tile-manager';\n\nexport default class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  shouldRefine(tile, frameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true,\n        loadContent: false\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init TileHeader instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {TileHeader} tile - the parent TileHeader instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new TileHeader(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (this._frameNumber === frameState.frameNumber) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}