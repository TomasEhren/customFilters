{"ast":null,"code":"import { deduceMeshField } from '@loaders.gl/schema';\nimport { Schema } from '@loaders.gl/schema';\nexport function getDracoSchema(attributes, loaderData, indices) {\n  var metadataMap = makeMetadata(loaderData.metadata);\n  var fields = [];\n  var namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    var field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);\n    fields.push(field);\n  }\n\n  if (indices) {\n    var indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData) {\n  var result = {};\n\n  for (var key in loaderData) {\n    var dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(attributeName, attribute, loaderData) {\n  var metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  var field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata) {\n  var metadataMap = new Map();\n\n  for (var key in metadata) {\n    metadataMap.set(\"\".concat(key, \".string\"), JSON.stringify(metadata[key]));\n  }\n\n  return metadataMap;\n}","map":{"version":3,"mappings":"AAAA,SAAQA,eAAR,QAA6C,oBAA7C;AACA,SAAQC,MAAR,QAA4B,oBAA5B;AAIA,OAAO,SAASC,cAAT,CACLC,UADK,EAELC,UAFK,EAGLC,OAHK,EAIG;EACR,IAAMC,WAAW,GAAGC,YAAY,CAACH,UAAU,CAACI,QAAZ,CAAhC;EACA,IAAMC,MAAe,GAAG,EAAxB;EACA,IAAMC,yBAAyB,GAAGC,6BAA6B,CAACP,UAAU,CAACD,UAAZ,CAA/D;;EACA,KAAK,IAAMS,aAAX,IAA4BT,UAA5B,EAAwC;IACtC,IAAMU,SAAS,GAAGV,UAAU,CAACS,aAAD,CAA5B;IACA,IAAME,KAAK,GAAGC,0BAA0B,CACtCH,aADsC,EAEtCC,SAFsC,EAGtCH,yBAAyB,CAACE,aAAD,CAHa,CAAxC;IAKAH,MAAM,CAACO,IAAPP,CAAYK,KAAZL;EACD;;EACD,IAAIJ,OAAJ,EAAa;IACX,IAAMY,YAAY,GAAGF,0BAA0B,CAAC,SAAD,EAAYV,OAAZ,CAA/C;IACAI,MAAM,CAACO,IAAPP,CAAYQ,YAAZR;EACD;;EACD,OAAO,IAAIR,MAAJ,CAAWQ,MAAX,EAAmBH,WAAnB,CAAP;AACD;;AAED,SAASK,6BAAT,CAAuCP,UAAvC,EAEE;EACA,IAAMc,MAAiD,GAAG,EAA1D;;EACA,KAAK,IAAMC,GAAX,IAAkBf,UAAlB,EAA8B;IAC5B,IAAMgB,cAAc,GAAGhB,UAAU,CAACe,GAAD,CAAjC;IACAD,MAAM,CAACE,cAAc,CAACC,IAAfD,IAAuB,WAAxB,CAANF,GAA6CE,cAA7CF;EACD;;EACD,OAAOA,MAAP;AACD;;AAED,SAASH,0BAAT,CACEH,aADF,EAEEC,SAFF,EAGET,UAHF,EAIS;EACP,IAAME,WAAW,GAAGF,UAAU,GAAGG,YAAY,CAACH,UAAU,CAACI,QAAZ,CAAf,GAAuCc,SAArE;EACA,IAAMR,KAAK,GAAGd,eAAe,CAACY,aAAD,EAAgBC,SAAhB,EAA2BP,WAA3B,CAA7B;EACA,OAAOQ,KAAP;AACD;;AAED,SAASP,YAAT,CAAsBC,QAAtB,EAA0F;EACxF,IAAMF,WAAW,GAAG,IAAIiB,GAAJ,EAApB;;EACA,KAAK,IAAMJ,GAAX,IAAkBX,QAAlB,EAA4B;IAC1BF,WAAW,CAACkB,GAAZlB,WAAmBa,GAAnB,cAAiCM,IAAI,CAACC,SAALD,CAAejB,QAAQ,CAACW,GAAD,CAAvBM,CAAjCnB;EACD;;EACD,OAAOA,WAAP;AACD","names":["deduceMeshField","Schema","getDracoSchema","attributes","loaderData","indices","metadataMap","makeMetadata","metadata","fields","namedLoaderDataAttributes","transformAttributesLoaderData","attributeName","attribute","field","getArrowFieldFromAttribute","push","indicesField","result","key","dracoAttribute","name","undefined","Map","set","JSON","stringify"],"sources":["../../../../src/lib/utils/get-draco-schema.ts"],"sourcesContent":["import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n"]},"metadata":{},"sourceType":"module"}