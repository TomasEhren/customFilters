{"ast":null,"code":"const isObject = value => value && typeof value === 'object';\n\nexport async function asyncDeepMap(tree, func) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return await mapSubtree(tree, func, options);\n}\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  const url = object;\n  return await func(url, options);\n}\n\nasync function mapObject(object, func, options) {\n  const promises = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then(value => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n  return values;\n}\n\nasync function mapArray(urlArray, func) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const promises = urlArray.map(url => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}","map":{"version":3,"mappings":"AAgBA,MAAMA,QAAQ,GAAIC,KAAD,IAAWA,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAAtD;;AAKA,OAAO,eAAeC,YAAf,CAA4BC,IAA5B,EAAkCC,IAAlC,EAAsD;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EAC3D,OAAO,MAAMC,UAAU,CAACH,IAAD,EAAOC,IAAP,EAAaC,OAAb,CAAvB;AACD;AAED,OAAO,eAAeC,UAAf,CAA0BC,MAA1B,EAAkCH,IAAlC,EAAwCC,OAAxC,EAAiD;EACtD,IAAIG,KAAK,CAACC,OAAND,CAAcD,MAAdC,CAAJ,EAA2B;IACzB,OAAO,MAAME,QAAQ,CAACH,MAAD,EAASH,IAAT,EAAeC,OAAf,CAArB;EACD;;EAED,IAAIL,QAAQ,CAACO,MAAD,CAAZ,EAAsB;IACpB,OAAO,MAAMI,SAAS,CAACJ,MAAD,EAASH,IAAT,EAAeC,OAAf,CAAtB;EACD;;EAGD,MAAMO,GAAG,GAAGL,MAAZ;EACA,OAAO,MAAMH,IAAI,CAACQ,GAAD,EAAMP,OAAN,CAAjB;AACD;;AAID,eAAeM,SAAf,CAAyBJ,MAAzB,EAAiCH,IAAjC,EAAuCC,OAAvC,EAAgD;EAC9C,MAAMQ,QAAwB,GAAG,EAAjC;EACA,MAAMC,MAAM,GAAG,EAAf;;EAEA,KAAK,MAAMC,GAAX,IAAkBR,MAAlB,EAA0B;IACxB,MAAMK,GAAG,GAAGL,MAAM,CAACQ,GAAD,CAAlB;IACA,MAAMC,OAAO,GAAGV,UAAU,CAACM,GAAD,EAAMR,IAAN,EAAYC,OAAZ,CAAVC,CAA+BW,IAA/BX,CAAqCL,KAAD,IAAW;MAC7Da,MAAM,CAACC,GAAD,CAAND,GAAcb,KAAda;IADc,EAAhB;IAGAD,QAAQ,CAACK,IAATL,CAAcG,OAAdH;EACD;;EAED,MAAMM,OAAO,CAACC,GAARD,CAAYN,QAAZM,CAAN;EAEA,OAAOL,MAAP;AACD;;AAED,eAAeJ,QAAf,CAAwBW,QAAxB,EAAkCjB,IAAlC,EAAsD;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EACpD,MAAMQ,QAAQ,GAAGQ,QAAQ,CAACC,GAATD,CAAcT,GAAD,IAASN,UAAU,CAACM,GAAD,EAAMR,IAAN,EAAYC,OAAZ,CAAhCgB,CAAjB;EACA,OAAO,MAAMF,OAAO,CAACC,GAARD,CAAYN,QAAZM,CAAb;AACD","names":["isObject","value","asyncDeepMap","tree","func","options","mapSubtree","object","Array","isArray","mapArray","mapObject","url","promises","values","key","promise","then","push","Promise","all","urlArray","map"],"sources":["../../../../src/lib/texture-api/async-deep-map.ts"],"sourcesContent":["/*\nAsynchronously maps a deep structure of values (e.g. objects and arrays of urls).\n\nE.g. a mipmapped cubemap\n{\n  [CUBE_FACE_FRONT]: [\n    \"image-front-0.jpg\",\n    \"image-front-1.jpg\",\n    \"image-front-2.jpg\",\n  ],\n  [CUBE_MAP_BACK]: [\n    ...\n  ]\n}\n*/\n\nconst isObject = (value) => value && typeof value === 'object';\n\n// Loads a deep structure of urls (objects and arrays of urls)\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function asyncDeepMap(tree, func, options = {}) {\n  return await mapSubtree(tree, func, options);\n}\n\nexport async function mapSubtree(object, func, options) {\n  if (Array.isArray(object)) {\n    return await mapArray(object, func, options);\n  }\n\n  if (isObject(object)) {\n    return await mapObject(object, func, options);\n  }\n\n  // TODO - ignore non-urls, non-arraybuffers?\n  const url = object;\n  return await func(url, options);\n}\n\n// HELPERS\n\nasync function mapObject(object, func, options) {\n  const promises: Promise<any>[] = [];\n  const values = {};\n\n  for (const key in object) {\n    const url = object[key];\n    const promise = mapSubtree(url, func, options).then((value) => {\n      values[key] = value;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return values;\n}\n\nasync function mapArray(urlArray, func, options = {}) {\n  const promises = urlArray.map((url) => mapSubtree(url, func, options));\n  return await Promise.all(promises);\n}\n"]},"metadata":{},"sourceType":"module"}