{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { getOSMTileIndices } from './tile-2d-traversal';\nvar TILE_SIZE = 512;\nvar DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\nexport var urlType = {\n  type: 'url',\n  value: null,\n  validate: function validate(value, propType) {\n    return propType.optional && value === null || typeof value === 'string' || Array.isArray(value) && value.every(function (url) {\n      return typeof url === 'string';\n    });\n  },\n  equals: function equals(value1, value2) {\n    if (value1 === value2) {\n      return true;\n    }\n\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n\n    var len = value1.length;\n\n    if (len !== value2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  var transformedCoords = [modelMatrix.transformAsPoint([bbox[0], bbox[1]]), modelMatrix.transformAsPoint([bbox[2], bbox[1]]), modelMatrix.transformAsPoint([bbox[0], bbox[3]]), modelMatrix.transformAsPoint([bbox[2], bbox[3]])];\n  var transformedBox = [Math.min.apply(Math, _toConsumableArray(transformedCoords.map(function (i) {\n    return i[0];\n  }))), Math.min.apply(Math, _toConsumableArray(transformedCoords.map(function (i) {\n    return i[1];\n  }))), Math.max.apply(Math, _toConsumableArray(transformedCoords.map(function (i) {\n    return i[0];\n  }))), Math.max.apply(Math, _toConsumableArray(transformedCoords.map(function (i) {\n    return i[1];\n  })))];\n  return transformedBox;\n}\n\nexport function getURLFromTemplate(template, properties) {\n  if (!template || !template.length) {\n    return null;\n  }\n\n  if (Array.isArray(template)) {\n    var index = Math.abs(properties.x + properties.y) % template.length;\n    template = template[index];\n  }\n\n  var x = properties.x,\n      y = properties.y,\n      z = properties.z;\n  return template.replace(/\\{x\\}/g, x).replace(/\\{y\\}/g, y).replace(/\\{z\\}/g, z).replace(/\\{-y\\}/g, Math.pow(2, z) - y - 1);\n}\n\nfunction getBoundingBox(viewport, zRange, extent) {\n  var bounds;\n\n  if (zRange && zRange.length === 2) {\n    var _zRange = _slicedToArray(zRange, 2),\n        minZ = _zRange[0],\n        maxZ = _zRange[1];\n\n    var bounds0 = viewport.getBounds({\n      z: minZ\n    });\n    var bounds1 = viewport.getBounds({\n      z: maxZ\n    });\n    bounds = [Math.min(bounds0[0], bounds1[0]), Math.min(bounds0[1], bounds1[1]), Math.max(bounds0[2], bounds1[2]), Math.max(bounds0[3], bounds1[3])];\n  } else {\n    bounds = viewport.getBounds();\n  }\n\n  if (!viewport.isGeospatial) {\n    return [Math.max(Math.min(bounds[0], extent[2]), extent[0]), Math.max(Math.min(bounds[1], extent[3]), extent[1]), Math.min(Math.max(bounds[2], extent[0]), extent[2]), Math.min(Math.max(bounds[3], extent[1]), extent[3])];\n  }\n\n  return [Math.max(bounds[0], extent[0]), Math.max(bounds[1], extent[1]), Math.min(bounds[2], extent[2]), Math.min(bounds[3], extent[3])];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    var transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(function (i) {\n      return i * scale / TILE_SIZE;\n    });\n    return transformedTileIndex;\n  }\n\n  return bbox.map(function (i) {\n    return i * scale / TILE_SIZE;\n  });\n}\n\nfunction getScale(z, tileSize) {\n  return Math.pow(2, z) * TILE_SIZE / tileSize;\n}\n\nexport function osmTile2lngLat(x, y, z) {\n  var scale = getScale(z, TILE_SIZE);\n  var lng = x / scale * 360 - 180;\n  var n = Math.PI - 2 * Math.PI * y / scale;\n  var lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  var scale = getScale(z, tileSize);\n  return [x / scale * TILE_SIZE, y / scale * TILE_SIZE];\n}\n\nexport function tileToBoundingBox(viewport, x, y, z) {\n  var tileSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : TILE_SIZE;\n\n  if (viewport.isGeospatial) {\n    var _osmTile2lngLat = osmTile2lngLat(x, y, z),\n        _osmTile2lngLat2 = _slicedToArray(_osmTile2lngLat, 2),\n        west = _osmTile2lngLat2[0],\n        north = _osmTile2lngLat2[1];\n\n    var _osmTile2lngLat3 = osmTile2lngLat(x + 1, y + 1, z),\n        _osmTile2lngLat4 = _slicedToArray(_osmTile2lngLat3, 2),\n        east = _osmTile2lngLat4[0],\n        south = _osmTile2lngLat4[1];\n\n    return {\n      west: west,\n      north: north,\n      east: east,\n      south: south\n    };\n  }\n\n  var _tile2XY = tile2XY(x, y, z, tileSize),\n      _tile2XY2 = _slicedToArray(_tile2XY, 2),\n      left = _tile2XY2[0],\n      top = _tile2XY2[1];\n\n  var _tile2XY3 = tile2XY(x + 1, y + 1, z, tileSize),\n      _tile2XY4 = _slicedToArray(_tile2XY3, 2),\n      right = _tile2XY4[0],\n      bottom = _tile2XY4[1];\n\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom\n  };\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  var bbox = getBoundingBox(viewport, null, extent);\n  var scale = getScale(z, tileSize);\n\n  var _getIndexingCoords = getIndexingCoords(bbox, scale, modelMatrixInverse),\n      _getIndexingCoords2 = _slicedToArray(_getIndexingCoords, 4),\n      minX = _getIndexingCoords2[0],\n      minY = _getIndexingCoords2[1],\n      maxX = _getIndexingCoords2[2],\n      maxY = _getIndexingCoords2[3];\n\n  var indices = [];\n\n  for (var x = Math.floor(minX); x < maxX; x++) {\n    for (var y = Math.floor(minY); y < maxY; y++) {\n      indices.push({\n        x: x,\n        y: y,\n        z: z\n      });\n    }\n  }\n\n  return indices;\n}\n\nexport function getTileIndices(_ref) {\n  var viewport = _ref.viewport,\n      maxZoom = _ref.maxZoom,\n      minZoom = _ref.minZoom,\n      zRange = _ref.zRange,\n      extent = _ref.extent,\n      _ref$tileSize = _ref.tileSize,\n      tileSize = _ref$tileSize === void 0 ? TILE_SIZE : _ref$tileSize,\n      modelMatrix = _ref.modelMatrix,\n      modelMatrixInverse = _ref.modelMatrixInverse,\n      _ref$zoomOffset = _ref.zoomOffset,\n      zoomOffset = _ref$zoomOffset === void 0 ? 0 : _ref$zoomOffset;\n  var z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;\n\n  if (Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n\n    z = minZoom;\n  }\n\n  if (Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n\n  var transformedExtent = extent;\n\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n\n  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);\n}\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}","map":{"version":3,"mappings":";;AAAA,SAAQA,iBAAR,QAAgC,qBAAhC;AAEA,IAAMC,SAAS,GAAG,GAAlB;AACA,IAAMC,cAAc,GAAG,CAAC,CAACC,QAAF,EAAY,CAACA,QAAb,EAAuBA,QAAvB,EAAiCA,QAAjC,CAAvB;AAEA,OAAO,IAAMC,OAAO,GAAG;EACrBC,IAAI,EAAE,KADe;EAErBC,KAAK,EAAE,IAFc;EAGrBC,QAAQ,EAAE,kBAACD,KAAD,EAAQE,QAAR;IAAA,OACPA,QAAQ,CAACC,QAATD,IAAqBF,KAAK,KAAK,IAA/BE,IACD,OAAOF,KAAP,KAAiB,QADhBE,IAEAE,KAAK,CAACC,OAAND,CAAcJ,KAAdI,KAAwBJ,KAAK,CAACM,KAANN,CAAYO,aAAG;MAAA,OAAI,OAAOA,GAAP,KAAe,QAAnB;IAAA,CAAfP,CAHjB;EAAA,CAHW;EAOrBQ,MAAM,EAAE,gBAACC,MAAD,EAASC,MAAT,EAAoB;IAC1B,IAAID,MAAM,KAAKC,MAAf,EAAuB;MACrB,OAAO,IAAP;IACD;;IACD,IAAI,CAACN,KAAK,CAACC,OAAND,CAAcK,MAAdL,CAAD,IAA0B,CAACA,KAAK,CAACC,OAAND,CAAcM,MAAdN,CAA/B,EAAsD;MACpD,OAAO,KAAP;IACD;;IACD,IAAMO,GAAG,GAAGF,MAAM,CAACG,MAAnB;;IACA,IAAID,GAAG,KAAKD,MAAM,CAACE,MAAnB,EAA2B;MACzB,OAAO,KAAP;IACD;;IACD,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;MAC5B,IAAIJ,MAAM,CAACI,CAAD,CAANJ,KAAcC,MAAM,CAACG,CAAD,CAAxB,EAA6B;QAC3B,OAAO,KAAP;MACD;IACF;;IACD,OAAO,IAAP;EACD;AAxBoB,CAAhB;;AA2BP,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,WAA5B,EAAyC;EACvC,IAAMC,iBAAiB,GAAG,CAExBD,WAAW,CAACE,gBAAZF,CAA6B,CAACD,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAA7BC,CAFwB,EAIxBA,WAAW,CAACE,gBAAZF,CAA6B,CAACD,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAA7BC,CAJwB,EAMxBA,WAAW,CAACE,gBAAZF,CAA6B,CAACD,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAA7BC,CANwB,EAQxBA,WAAW,CAACE,gBAAZF,CAA6B,CAACD,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAA7BC,CARwB,CAA1B;EAUA,IAAMG,cAAc,GAAG,CAErBC,IAAI,CAACC,GAALD,WAAI,qBAAQH,iBAAiB,CAACK,GAAlBL,CAAsBJ,WAAC;IAAA,OAAIA,CAAC,CAAC,CAAD,CAAL;EAAA,CAAvBI,CAAR,EAFiB,EAIrBG,IAAI,CAACC,GAALD,WAAI,qBAAQH,iBAAiB,CAACK,GAAlBL,CAAsBJ,WAAC;IAAA,OAAIA,CAAC,CAAC,CAAD,CAAL;EAAA,CAAvBI,CAAR,EAJiB,EAMrBG,IAAI,CAACG,GAALH,WAAI,qBAAQH,iBAAiB,CAACK,GAAlBL,CAAsBJ,WAAC;IAAA,OAAIA,CAAC,CAAC,CAAD,CAAL;EAAA,CAAvBI,CAAR,EANiB,EAQrBG,IAAI,CAACG,GAALH,WAAI,qBAAQH,iBAAiB,CAACK,GAAlBL,CAAsBJ,WAAC;IAAA,OAAIA,CAAC,CAAC,CAAD,CAAL;EAAA,CAAvBI,CAAR,EARiB,CAAvB;EAUA,OAAOE,cAAP;AACD;;AAED,OAAO,SAASK,kBAAT,CAA4BC,QAA5B,EAAsCC,UAAtC,EAAkD;EACvD,IAAI,CAACD,QAAD,IAAa,CAACA,QAAQ,CAACb,MAA3B,EAAmC;IACjC,OAAO,IAAP;EACD;;EACD,IAAIR,KAAK,CAACC,OAAND,CAAcqB,QAAdrB,CAAJ,EAA6B;IAC3B,IAAMuB,KAAK,GAAGP,IAAI,CAACQ,GAALR,CAASM,UAAU,CAACG,CAAXH,GAAeA,UAAU,CAACI,CAAnCV,IAAwCK,QAAQ,CAACb,MAA/D;IACAa,QAAQ,GAAGA,QAAQ,CAACE,KAAD,CAAnBF;EACD;;EAED,IAAOI,CAAP,GAAkBH,UAAlB,CAAOG,CAAP;EAAA,IAAUC,CAAV,GAAkBJ,UAAlB,CAAUI,CAAV;EAAA,IAAaC,CAAb,GAAkBL,UAAlB,CAAaK,CAAb;EACA,OAAON,QAAQ,CACZO,OADIP,CACI,QADJA,EACcI,CADdJ,EAEJO,OAFIP,CAEI,QAFJA,EAEcK,CAFdL,EAGJO,OAHIP,CAGI,QAHJA,EAGcM,CAHdN,EAIJO,OAJIP,CAII,SAJJA,EAIeL,IAAI,CAACa,GAALb,CAAS,CAATA,EAAYW,CAAZX,IAAiBU,CAAjBV,GAAqB,CAJpCK,CAAP;AAKD;;AAKD,SAASS,cAAT,CAAwBC,QAAxB,EAAkCC,MAAlC,EAA0CC,MAA1C,EAAkD;EAChD,IAAIC,MAAJ;;EACA,IAAIF,MAAM,IAAIA,MAAM,CAACxB,MAAPwB,KAAkB,CAAhC,EAAmC;IACjC,6BAAqBA,MAArB;IAAA,IAAOG,IAAP;IAAA,IAAaC,IAAb;;IACA,IAAMC,OAAO,GAAGN,QAAQ,CAACO,SAATP,CAAmB;MAACJ,CAAC,EAAEQ;IAAJ,CAAnBJ,CAAhB;IACA,IAAMQ,OAAO,GAAGR,QAAQ,CAACO,SAATP,CAAmB;MAACJ,CAAC,EAAES;IAAJ,CAAnBL,CAAhB;IACAG,MAAM,GAAG,CACPlB,IAAI,CAACC,GAALD,CAASqB,OAAO,CAAC,CAAD,CAAhBrB,EAAqBuB,OAAO,CAAC,CAAD,CAA5BvB,CADO,EAEPA,IAAI,CAACC,GAALD,CAASqB,OAAO,CAAC,CAAD,CAAhBrB,EAAqBuB,OAAO,CAAC,CAAD,CAA5BvB,CAFO,EAGPA,IAAI,CAACG,GAALH,CAASqB,OAAO,CAAC,CAAD,CAAhBrB,EAAqBuB,OAAO,CAAC,CAAD,CAA5BvB,CAHO,EAIPA,IAAI,CAACG,GAALH,CAASqB,OAAO,CAAC,CAAD,CAAhBrB,EAAqBuB,OAAO,CAAC,CAAD,CAA5BvB,CAJO,CAATkB;EAJF,OAUO;IACLA,MAAM,GAAGH,QAAQ,CAACO,SAATP,EAATG;EACD;;EACD,IAAI,CAACH,QAAQ,CAACS,YAAd,EAA4B;IAC1B,OAAO,CAELxB,IAAI,CAACG,GAALH,CAASA,IAAI,CAACC,GAALD,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAATA,EAAyCiB,MAAM,CAAC,CAAD,CAA/CjB,CAFK,EAGLA,IAAI,CAACG,GAALH,CAASA,IAAI,CAACC,GAALD,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAATA,EAAyCiB,MAAM,CAAC,CAAD,CAA/CjB,CAHK,EAKLA,IAAI,CAACC,GAALD,CAASA,IAAI,CAACG,GAALH,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAATA,EAAyCiB,MAAM,CAAC,CAAD,CAA/CjB,CALK,EAMLA,IAAI,CAACC,GAALD,CAASA,IAAI,CAACG,GAALH,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAATA,EAAyCiB,MAAM,CAAC,CAAD,CAA/CjB,CANK,CAAP;EAQD;;EACD,OAAO,CACLA,IAAI,CAACG,GAALH,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CADK,EAELA,IAAI,CAACG,GAALH,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAFK,EAGLA,IAAI,CAACC,GAALD,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAHK,EAILA,IAAI,CAACC,GAALD,CAASkB,MAAM,CAAC,CAAD,CAAflB,EAAoBiB,MAAM,CAAC,CAAD,CAA1BjB,CAJK,CAAP;AAMD;;AAED,SAASyB,iBAAT,CAA2B9B,IAA3B,EAAiC+B,KAAjC,EAAwCC,kBAAxC,EAA4D;EAC1D,IAAIA,kBAAJ,EAAwB;IACtB,IAAMC,oBAAoB,GAAGlC,YAAY,CAACC,IAAD,EAAOgC,kBAAP,CAAZjC,CAAuCQ,GAAvCR,CAC3BD,WAAC;MAAA,OAAKA,CAAC,GAAGiC,KAAJjC,GAAalB,SAAlB;IAAA,CAD0BmB,CAA7B;IAGA,OAAOkC,oBAAP;EACD;;EACD,OAAOjC,IAAI,CAACO,GAALP,CAASF,WAAC;IAAA,OAAKA,CAAC,GAAGiC,KAAJjC,GAAalB,SAAlB;EAAA,CAAVoB,CAAP;AACD;;AAED,SAASkC,QAAT,CAAkBlB,CAAlB,EAAqBmB,QAArB,EAA+B;EAC7B,OAAQ9B,IAAI,CAACa,GAALb,CAAS,CAATA,EAAYW,CAAZX,IAAiBzB,SAAjByB,GAA8B8B,QAAtC;AACD;;AAGD,OAAO,SAASC,cAAT,CAAwBtB,CAAxB,EAA2BC,CAA3B,EAA8BC,CAA9B,EAAiC;EACtC,IAAMe,KAAK,GAAGG,QAAQ,CAAClB,CAAD,EAAIpC,SAAJ,CAAtB;EACA,IAAMyD,GAAG,GAAIvB,CAAC,GAAGiB,KAAJjB,GAAa,GAAbA,GAAmB,GAAhC;EACA,IAAMwB,CAAC,GAAGjC,IAAI,CAACkC,EAALlC,GAAW,IAAIA,IAAI,CAACkC,EAAT,GAAcxB,CAAd,GAAmBgB,KAAxC;EACA,IAAMS,GAAG,GAAI,MAAMnC,IAAI,CAACkC,EAAX,GAAiBlC,IAAI,CAACoC,IAALpC,CAAU,OAAOA,IAAI,CAACqC,GAALrC,CAASiC,CAATjC,IAAcA,IAAI,CAACqC,GAALrC,CAAS,CAACiC,CAAVjC,CAArB,CAAVA,CAA9B;EACA,OAAO,CAACgC,GAAD,EAAMG,GAAN,CAAP;AACD;;AAED,SAASG,OAAT,CAAiB7B,CAAjB,EAAoBC,CAApB,EAAuBC,CAAvB,EAA0BmB,QAA1B,EAAoC;EAClC,IAAMJ,KAAK,GAAGG,QAAQ,CAAClB,CAAD,EAAImB,QAAJ,CAAtB;EACA,OAAO,CAAErB,CAAC,GAAGiB,KAAJjB,GAAalC,SAAf,EAA2BmC,CAAC,GAAGgB,KAAJhB,GAAanC,SAAxC,CAAP;AACD;;AACD,OAAO,SAASgE,iBAAT,CAA2BxB,QAA3B,EAAqCN,CAArC,EAAwCC,CAAxC,EAA2CC,CAA3C,EAAoE;EAAA,IAAtBmB,QAAsB,uEAAXvD,SAAW;;EACzE,IAAIwC,QAAQ,CAACS,YAAb,EAA2B;IACzB,sBAAsBO,cAAc,CAACtB,CAAD,EAAIC,CAAJ,EAAOC,CAAP,CAApC;IAAA;IAAA,IAAO6B,IAAP;IAAA,IAAaC,KAAb;;IACA,uBAAsBV,cAAc,CAACtB,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAG,CAAZ,EAAeC,CAAf,CAApC;IAAA;IAAA,IAAO+B,IAAP;IAAA,IAAaC,KAAb;;IACA,OAAO;MAACH,IAAD,EAACA,IAAD;MAAOC,KAAP,EAAOA,KAAP;MAAcC,IAAd,EAAcA,IAAd;MAAoBC;IAApB,CAAP;EACD;;EACD,eAAoBL,OAAO,CAAC7B,CAAD,EAAIC,CAAJ,EAAOC,CAAP,EAAUmB,QAAV,CAA3B;EAAA;EAAA,IAAOc,IAAP;EAAA,IAAaC,GAAb;;EACA,gBAAwBP,OAAO,CAAC7B,CAAC,GAAG,CAAL,EAAQC,CAAC,GAAG,CAAZ,EAAeC,CAAf,EAAkBmB,QAAlB,CAA/B;EAAA;EAAA,IAAOgB,KAAP;EAAA,IAAcC,MAAd;;EACA,OAAO;IAACH,IAAD,EAACA,IAAD;IAAOC,GAAP,EAAOA,GAAP;IAAYC,KAAZ,EAAYA,KAAZ;IAAmBC;EAAnB,CAAP;AACD;;AAED,SAASC,sBAAT,CAAgCjC,QAAhC,EAA0CJ,CAA1C,EAA6CmB,QAA7C,EAAuDb,MAAvD,EAA+DU,kBAA/D,EAAmF;EACjF,IAAMhC,IAAI,GAAGmB,cAAc,CAACC,QAAD,EAAW,IAAX,EAAiBE,MAAjB,CAA3B;EACA,IAAMS,KAAK,GAAGG,QAAQ,CAAClB,CAAD,EAAImB,QAAJ,CAAtB;;EACA,yBAAiCL,iBAAiB,CAAC9B,IAAD,EAAO+B,KAAP,EAAcC,kBAAd,CAAlD;EAAA;EAAA,IAAOsB,IAAP;EAAA,IAAaC,IAAb;EAAA,IAAmBC,IAAnB;EAAA,IAAyBC,IAAzB;;EACA,IAAMC,OAAO,GAAG,EAAhB;;EAMA,KAAK,IAAI5C,CAAC,GAAGT,IAAI,CAACsD,KAALtD,CAAWiD,IAAXjD,CAAb,EAA+BS,CAAC,GAAG0C,IAAnC,EAAyC1C,CAAC,EAA1C,EAA8C;IAC5C,KAAK,IAAIC,CAAC,GAAGV,IAAI,CAACsD,KAALtD,CAAWkD,IAAXlD,CAAb,EAA+BU,CAAC,GAAG0C,IAAnC,EAAyC1C,CAAC,EAA1C,EAA8C;MAC5C2C,OAAO,CAACE,IAARF,CAAa;QAAC5C,CAAD,EAACA,CAAD;QAAIC,CAAJ,EAAIA,CAAJ;QAAOC;MAAP,CAAb0C;IACD;EACF;;EACD,OAAOA,OAAP;AACD;;AAQD,OAAO,SAASG,cAAT,OAUJ;EAAA,IATDzC,QASC,QATDA,QASC;EAAA,IARD0C,OAQC,QARDA,OAQC;EAAA,IAPDC,OAOC,QAPDA,OAOC;EAAA,IAND1C,MAMC,QANDA,MAMC;EAAA,IALDC,MAKC,QALDA,MAKC;EAAA,yBAJDa,QAIC;EAAA,IAJDA,QAIC,8BAJUvD,SAIV;EAAA,IAHDqB,WAGC,QAHDA,WAGC;EAAA,IAFD+B,kBAEC,QAFDA,kBAEC;EAAA,2BADDgC,UACC;EAAA,IADDA,UACC,gCADY,CACZ;EACD,IAAIhD,CAAC,GAAGI,QAAQ,CAACS,YAATT,GACJf,IAAI,CAAC4D,KAAL5D,CAAWe,QAAQ,CAAC8C,IAAT9C,GAAgBf,IAAI,CAAC8D,IAAL9D,CAAUzB,SAAS,GAAGuD,QAAtB9B,CAA3BA,IAA8D2D,UAD1D5C,GAEJf,IAAI,CAAC+D,IAAL/D,CAAUe,QAAQ,CAAC8C,IAAnB7D,IAA2B2D,UAF/B;;EAGA,IAAIK,MAAM,CAACC,QAAPD,CAAgBN,OAAhBM,KAA4BrD,CAAC,GAAG+C,OAApC,EAA6C;IAC3C,IAAI,CAACzC,MAAL,EAAa;MACX,OAAO,EAAP;IACD;;IACDN,CAAC,GAAG+C,OAAJ/C;EACD;;EACD,IAAIqD,MAAM,CAACC,QAAPD,CAAgBP,OAAhBO,KAA4BrD,CAAC,GAAG8C,OAApC,EAA6C;IAC3C9C,CAAC,GAAG8C,OAAJ9C;EACD;;EACD,IAAIuD,iBAAiB,GAAGjD,MAAxB;;EACA,IAAIrB,WAAW,IAAI+B,kBAAf/B,IAAqCqB,MAArCrB,IAA+C,CAACmB,QAAQ,CAACS,YAA7D,EAA2E;IACzE0C,iBAAiB,GAAGxE,YAAY,CAACuB,MAAD,EAASrB,WAAT,CAAhCsE;EACD;;EACD,OAAOnD,QAAQ,CAACS,YAATT,GACHzC,iBAAiB,CAACyC,QAAD,EAAWJ,CAAX,EAAcK,MAAd,EAAsBC,MAAtB,CADdF,GAEHiC,sBAAsB,CACpBjC,QADoB,EAEpBJ,CAFoB,EAGpBmB,QAHoB,EAIpBoC,iBAAiB,IAAI1F,cAJD,EAKpBmD,kBALoB,CAF1B;AASD;AAKD,OAAO,SAASwC,aAAT,CAAuBC,CAAvB,EAA0B;EAC/B,OAAO,qCAAqCC,IAArC,CAA0CD,CAA1C,CAAP;AACD","names":["getOSMTileIndices","TILE_SIZE","DEFAULT_EXTENT","Infinity","urlType","type","value","validate","propType","optional","Array","isArray","every","url","equals","value1","value2","len","length","i","transformBox","bbox","modelMatrix","transformedCoords","transformAsPoint","transformedBox","Math","min","map","max","getURLFromTemplate","template","properties","index","abs","x","y","z","replace","pow","getBoundingBox","viewport","zRange","extent","bounds","minZ","maxZ","bounds0","getBounds","bounds1","isGeospatial","getIndexingCoords","scale","modelMatrixInverse","transformedTileIndex","getScale","tileSize","osmTile2lngLat","lng","n","PI","lat","atan","exp","tile2XY","tileToBoundingBox","west","north","east","south","left","top","right","bottom","getIdentityTileIndices","minX","minY","maxX","maxY","indices","floor","push","getTileIndices","maxZoom","minZoom","zoomOffset","round","zoom","log2","ceil","Number","isFinite","transformedExtent","isURLTemplate","s","test"],"sources":["../../../src/tile-layer/utils.js"],"sourcesContent":["import {getOSMTileIndices} from './tile-2d-traversal';\n\nconst TILE_SIZE = 512;\nconst DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];\n\nexport const urlType = {\n  type: 'url',\n  value: null,\n  validate: (value, propType) =>\n    (propType.optional && value === null) ||\n    typeof value === 'string' ||\n    (Array.isArray(value) && value.every(url => typeof url === 'string')),\n  equals: (value1, value2) => {\n    if (value1 === value2) {\n      return true;\n    }\n    if (!Array.isArray(value1) || !Array.isArray(value2)) {\n      return false;\n    }\n    const len = value1.length;\n    if (len !== value2.length) {\n      return false;\n    }\n    for (let i = 0; i < len; i++) {\n      if (value1[i] !== value2[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n\nfunction transformBox(bbox, modelMatrix) {\n  const transformedCoords = [\n    // top-left\n    modelMatrix.transformAsPoint([bbox[0], bbox[1]]),\n    // top-right\n    modelMatrix.transformAsPoint([bbox[2], bbox[1]]),\n    // bottom-left\n    modelMatrix.transformAsPoint([bbox[0], bbox[3]]),\n    // bottom-right\n    modelMatrix.transformAsPoint([bbox[2], bbox[3]])\n  ];\n  const transformedBox = [\n    // Minimum x coord\n    Math.min(...transformedCoords.map(i => i[0])),\n    // Minimum y coord\n    Math.min(...transformedCoords.map(i => i[1])),\n    // Max x coord\n    Math.max(...transformedCoords.map(i => i[0])),\n    // Max y coord\n    Math.max(...transformedCoords.map(i => i[1]))\n  ];\n  return transformedBox;\n}\n\nexport function getURLFromTemplate(template, properties) {\n  if (!template || !template.length) {\n    return null;\n  }\n  if (Array.isArray(template)) {\n    const index = Math.abs(properties.x + properties.y) % template.length;\n    template = template[index];\n  }\n\n  const {x, y, z} = properties;\n  return template\n    .replace(/\\{x\\}/g, x)\n    .replace(/\\{y\\}/g, y)\n    .replace(/\\{z\\}/g, z)\n    .replace(/\\{-y\\}/g, Math.pow(2, z) - y - 1);\n}\n\n/**\n * gets the bounding box of a viewport\n */\nfunction getBoundingBox(viewport, zRange, extent) {\n  let bounds;\n  if (zRange && zRange.length === 2) {\n    const [minZ, maxZ] = zRange;\n    const bounds0 = viewport.getBounds({z: minZ});\n    const bounds1 = viewport.getBounds({z: maxZ});\n    bounds = [\n      Math.min(bounds0[0], bounds1[0]),\n      Math.min(bounds0[1], bounds1[1]),\n      Math.max(bounds0[2], bounds1[2]),\n      Math.max(bounds0[3], bounds1[3])\n    ];\n  } else {\n    bounds = viewport.getBounds();\n  }\n  if (!viewport.isGeospatial) {\n    return [\n      // Top corner should not be more then bottom corner in either direction\n      Math.max(Math.min(bounds[0], extent[2]), extent[0]),\n      Math.max(Math.min(bounds[1], extent[3]), extent[1]),\n      // Bottom corner should not be less then top corner in either direction\n      Math.min(Math.max(bounds[2], extent[0]), extent[2]),\n      Math.min(Math.max(bounds[3], extent[1]), extent[3])\n    ];\n  }\n  return [\n    Math.max(bounds[0], extent[0]),\n    Math.max(bounds[1], extent[1]),\n    Math.min(bounds[2], extent[2]),\n    Math.min(bounds[3], extent[3])\n  ];\n}\n\nfunction getIndexingCoords(bbox, scale, modelMatrixInverse) {\n  if (modelMatrixInverse) {\n    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map(\n      i => (i * scale) / TILE_SIZE\n    );\n    return transformedTileIndex;\n  }\n  return bbox.map(i => (i * scale) / TILE_SIZE);\n}\n\nfunction getScale(z, tileSize) {\n  return (Math.pow(2, z) * TILE_SIZE) / tileSize;\n}\n\n// https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Lon..2Flat._to_tile_numbers_2\nexport function osmTile2lngLat(x, y, z) {\n  const scale = getScale(z, TILE_SIZE);\n  const lng = (x / scale) * 360 - 180;\n  const n = Math.PI - (2 * Math.PI * y) / scale;\n  const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n  return [lng, lat];\n}\n\nfunction tile2XY(x, y, z, tileSize) {\n  const scale = getScale(z, tileSize);\n  return [(x / scale) * TILE_SIZE, (y / scale) * TILE_SIZE];\n}\nexport function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE) {\n  if (viewport.isGeospatial) {\n    const [west, north] = osmTile2lngLat(x, y, z);\n    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);\n    return {west, north, east, south};\n  }\n  const [left, top] = tile2XY(x, y, z, tileSize);\n  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);\n  return {left, top, right, bottom};\n}\n\nfunction getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {\n  const bbox = getBoundingBox(viewport, null, extent);\n  const scale = getScale(z, tileSize);\n  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale, modelMatrixInverse);\n  const indices = [];\n\n  /*\n      |  TILE  |  TILE  |  TILE  |\n        |(minX)            |(maxX)\n   */\n  for (let x = Math.floor(minX); x < maxX; x++) {\n    for (let y = Math.floor(minY); y < maxY; y++) {\n      indices.push({x, y, z});\n    }\n  }\n  return indices;\n}\n\n/**\n * Returns all tile indices in the current viewport. If the current zoom level is smaller\n * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n * return tiles that are on maxZoom.\n */\n// eslint-disable-next-line complexity\nexport function getTileIndices({\n  viewport,\n  maxZoom,\n  minZoom,\n  zRange,\n  extent,\n  tileSize = TILE_SIZE,\n  modelMatrix,\n  modelMatrixInverse,\n  zoomOffset = 0\n}) {\n  let z = viewport.isGeospatial\n    ? Math.round(viewport.zoom + Math.log2(TILE_SIZE / tileSize)) + zoomOffset\n    : Math.ceil(viewport.zoom) + zoomOffset;\n  if (Number.isFinite(minZoom) && z < minZoom) {\n    if (!extent) {\n      return [];\n    }\n    z = minZoom;\n  }\n  if (Number.isFinite(maxZoom) && z > maxZoom) {\n    z = maxZoom;\n  }\n  let transformedExtent = extent;\n  if (modelMatrix && modelMatrixInverse && extent && !viewport.isGeospatial) {\n    transformedExtent = transformBox(extent, modelMatrix);\n  }\n  return viewport.isGeospatial\n    ? getOSMTileIndices(viewport, z, zRange, extent)\n    : getIdentityTileIndices(\n        viewport,\n        z,\n        tileSize,\n        transformedExtent || DEFAULT_EXTENT,\n        modelMatrixInverse\n      );\n}\n\n/**\n * Returns true if s is a valid URL template\n */\nexport function isURLTemplate(s) {\n  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);\n}\n"]},"metadata":{},"sourceType":"module"}