{"ast":null,"code":"import { Ellipsoid } from '@math.gl/geospatial';\nimport { Matrix4, Vector3 } from '@math.gl/core';\nimport { assert } from '@loaders.gl/loader-utils';\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n  var rtcCenter = tile.rtcCenter,\n      gltfUpAxis = tile.gltfUpAxis;\n  var computedTransform = tileHeader.computedTransform,\n      center = tileHeader.boundingVolume.center;\n  var modelMatrix = new Matrix4(computedTransform);\n\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n\n    case 'Y':\n      var rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n\n    case 'X':\n      var rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n\n    default:\n      break;\n  }\n\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  var cartesianOrigin = new Vector3(center);\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n  var cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());\n  var fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  var toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n\n  if (!tile.coordinateSystem) {\n    tile.modelMatrix = tile.cartographicModelMatrix;\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAQA,SAAR,QAAwB,qBAAxB;AACA,SAAQC,OAAR,EAAiBC,OAAjB,QAA+B,eAA/B;AACA,SAAQC,MAAR,QAAqB,0BAArB;AAEA,OAAO,SAASC,uBAAT,CAAiCC,UAAjC,EAA6CC,IAA7C,EAAmD;EACxDH,MAAM,CAACE,UAAD,CAANF;EACAA,MAAM,CAACG,IAAD,CAANH;EAEA,IAAOI,SAAP,GAAgCD,IAAhC,CAAOC,SAAP;EAAA,IAAkBC,UAAlB,GAAgCF,IAAhC,CAAkBE,UAAlB;EACA,IACEC,iBADF,GAGIJ,UAHJ,CACEI,iBADF;EAAA,IAEmBC,MAFnB,GAGIL,UAHJ,CAEEM,cAFF,CAEmBD,MAFnB;EAKA,IAAIE,WAAW,GAAG,IAAIX,OAAJ,CAAYQ,iBAAZ,CAAlB;;EAGA,IAAIF,SAAJ,EAAe;IACbK,WAAW,CAACC,SAAZD,CAAsBL,SAAtBK;EACD;;EAID,QAAQJ,UAAR;IACE,KAAK,GAAL;MACE;;IACF,KAAK,GAAL;MACE,IAAMM,SAAS,GAAG,IAAIb,OAAJ,GAAcc,OAAd,CAAsBC,IAAI,CAACC,EAALD,GAAU,CAAhC,CAAlB;MACAJ,WAAW,GAAGA,WAAW,CAACM,aAAZN,CAA0BE,SAA1BF,CAAdA;MACA;;IACF,KAAK,GAAL;MACE,IAAMO,SAAS,GAAG,IAAIlB,OAAJ,GAAcmB,OAAd,CAAsB,CAACJ,IAAI,CAACC,EAAN,GAAW,CAAjC,CAAlB;MACAL,WAAW,GAAGA,WAAW,CAACM,aAAZN,CAA0BO,SAA1BP,CAAdA;MACA;;IACF;MACE;EAZJ;;EAgBA,IAAIN,IAAI,CAACe,WAAT,EAAsB;IACpBT,WAAW,CAACC,SAAZD,CAAsBN,IAAI,CAACgB,qBAA3BV,EAAkDW,KAAlDX,CAAwDN,IAAI,CAACkB,oBAA7DZ;EACD;;EAGD,IAAMa,eAAe,GAAG,IAAIvB,OAAJ,CAAYQ,MAAZ,CAAxB;EAEAJ,IAAI,CAACoB,oBAALpB,GAA4BM,WAA5BN;EACAA,IAAI,CAACmB,eAALnB,GAAuBmB,eAAvBnB;EAGA,IAAMqB,kBAAkB,GAAG3B,SAAS,CAAC4B,KAAV5B,CAAgB6B,uBAAhB7B,CACzByB,eADyBzB,EAEzB,IAAIE,OAAJ,EAFyBF,CAA3B;EAIA,IAAM8B,oBAAoB,GAAG9B,SAAS,CAAC4B,KAAV5B,CAAgB+B,uBAAhB/B,CAAwCyB,eAAxCzB,CAA7B;EACA,IAAMgC,kBAAkB,GAAGF,oBAAoB,CAACG,MAArBH,EAA3B;EAEAxB,IAAI,CAAC4B,uBAAL5B,GAA+B0B,kBAAkB,CAACd,aAAnBc,CAAiCpB,WAAjCoB,CAA/B1B;EACAA,IAAI,CAACqB,kBAALrB,GAA0BqB,kBAA1BrB;;EAGA,IAAI,CAACA,IAAI,CAAC6B,gBAAV,EAA4B;IAC1B7B,IAAI,CAACM,WAALN,GAAmBA,IAAI,CAAC4B,uBAAxB5B;EACD;AACF","names":["Ellipsoid","Matrix4","Vector3","assert","calculateTransformProps","tileHeader","tile","rtcCenter","gltfUpAxis","computedTransform","center","boundingVolume","modelMatrix","translate","rotationY","rotateX","Math","PI","multiplyRight","rotationX","rotateY","isQuantized","quantizedVolumeOffset","scale","quantizedVolumeScale","cartesianOrigin","cartesianModelMatrix","cartographicOrigin","WGS84","cartesianToCartographic","fromFixedFrameMatrix","eastNorthUpToFixedFrame","toFixedFrameMatrix","invert","cartographicModelMatrix","coordinateSystem"],"sources":["../../../../src/tileset/helpers/transform-utils.ts"],"sourcesContent":["import {Ellipsoid} from '@math.gl/geospatial';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n\n  const {rtcCenter, gltfUpAxis} = tile;\n  const {\n    computedTransform,\n    boundingVolume: {center}\n  } = tileHeader;\n\n  let modelMatrix = new Matrix4(computedTransform);\n\n  // Translate if appropriate\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n    default:\n      break;\n  }\n\n  // Scale/offset positions if normalized integers\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  // Option 1: Cartesian matrix and origin\n  const cartesianOrigin = new Vector3(center);\n\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n\n  // Option 2: Cartographic matrix and origin\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(\n    cartesianOrigin,\n    new Vector3()\n  );\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n\n  // Deprecated, drop\n  if (!tile.coordinateSystem) {\n    tile.modelMatrix = tile.cartographicModelMatrix;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}