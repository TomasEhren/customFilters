{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  constructor(draco) {\n    _defineProperty(this, \"draco\", void 0);\n\n    _defineProperty(this, \"dracoEncoder\", void 0);\n\n    _defineProperty(this, \"dracoMeshBuilder\", void 0);\n\n    _defineProperty(this, \"dracoMetadataBuilder\", void 0);\n\n    _defineProperty(this, \"log\", void 0);\n\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy() {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    this.dracoMeshBuilder = null;\n    this.dracoEncoder = null;\n    this.draco = null;\n  }\n\n  destroyEncodedObject(object) {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  encodeSync(mesh) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.log = noop;\n\n    this._setOptions(options);\n\n    return options.pointcloud ? this._encodePointCloud(mesh, options) : this._encodeMesh(mesh, options);\n  }\n\n  _getAttributesFromMesh(mesh) {\n    const attributes = { ...mesh,\n      ...mesh.attributes\n    };\n\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud, options) {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(dracoPointCloud, false, dracoData);\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(\"DRACO encoded \".concat(dracoPointCloud.num_points(), \" points\\n        with \").concat(dracoPointCloud.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh, options) {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(\"DRACO encoded \".concat(dracoMesh.num_points(), \" points\\n        with \").concat(dracoMesh.num_attributes(), \" attributes into \").concat(encodedLen, \" bytes\"));\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  _setOptions(options) {\n    if ('speed' in options) {\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  _createDracoMesh(dracoMesh, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n\n      if (!positions) {\n        throw new Error('positions');\n      }\n\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  _createDracoPointCloud(dracoPointCloud, attributes, options) {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n\n      if (!positions) {\n        throw new Error('positions');\n      }\n\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n\n        const uniqueId = this._addAttributeToMesh(dracoPointCloud, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      const numFaces = attribute.length / 3;\n      this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(numFaces));\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(\"Adding attribute \".concat(attributeName, \", size \").concat(size));\n    const builder = this.dracoMeshBuilder;\n    const {\n      buffer\n    } = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  _getDracoAttributeType(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n\n      const dracoType = this._getDracoAttributeType(attributeName);\n\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n\n    return null;\n  }\n\n  _addGeometryMetadata(dracoGeometry, metadata) {\n    const dracoMetadata = new this.draco.Metadata();\n\n    this._populateDracoMetadata(dracoMetadata, metadata);\n\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {\n    const dracoAttributeMetadata = new this.draco.Metadata();\n\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n\n    this.dracoMeshBuilder.SetMetadataForAttribute(dracoGeometry, uniqueAttributeId, dracoAttributeMetadata);\n  }\n\n  _populateDracoMetadata(dracoMetadata, metadata) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n\n          break;\n\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n\n          break;\n\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n\n}\n\nfunction dracoInt8ArrayToArrayBuffer(dracoData) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n\n  return outputBuffer;\n}\n\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}","map":{"version":3,"mappings":"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","names":["GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","noop","DracoBuilder","constructor","draco","_defineProperty","dracoEncoder","Encoder","dracoMeshBuilder","MeshBuilder","dracoMetadataBuilder","MetadataBuilder","destroy","destroyEncodedObject","object","encodeSync","mesh","options","log","_setOptions","pointcloud","_encodePointCloud","_encodeMesh","_getAttributesFromMesh","attributes","indices","dracoPointCloud","PointCloud","metadata","_addGeometryMetadata","_createDracoPointCloud","dracoData","DracoInt8Array","encodedLen","EncodePointCloudToDracoBuffer","Error","num_points","num_attributes","dracoInt8ArrayToArrayBuffer","dracoMesh","Mesh","_createDracoMesh","EncodeMeshToDracoBuffer","SetSpeedOptions","speed","dracoMethod","method","SetEncodingMethod","attribute","quantization","bits","dracoPosition","SetAttributeQuantization","optionalMetadata","attributesMetadata","positions","_getPositionAttribute","vertexCount","length","attributeName","uniqueId","_addAttributeToMesh","_addAttributeMetadata","name","error","ArrayBuffer","isView","type","_getDracoAttributeType","size","numFaces","AddFacesToMesh","builder","buffer","Int8Array","AddInt8Attribute","Int16Array","AddInt16Attribute","Int32Array","AddInt32Attribute","Uint8Array","Uint8ClampedArray","AddUInt8Attribute","Uint16Array","AddUInt16Attribute","Uint32Array","AddUInt32Attribute","Float32Array","AddFloatAttribute","toLowerCase","COLOR","TEX_COORD","GENERIC","dracoType","dracoGeometry","dracoMetadata","Metadata","_populateDracoMetadata","AddMetadata","uniqueAttributeId","dracoAttributeMetadata","SetMetadataForAttribute","key","value","getEntries","Math","trunc","AddIntEntry","AddDoubleEntry","AddIntEntryArray","AddStringEntry","byteLength","outputBuffer","outputData","i","GetValue","container","hasEntriesFunc","entries","hasOwnProperty","Object"],"sources":["../../../src/lib/draco-builder.ts"],"sourcesContent":["/* eslint-disable camelcase */\n// This code is inspired by example code in the DRACO repository\nimport type {\n  Draco3D,\n  DracoInt8Array,\n  Encoder,\n  Mesh,\n  MeshBuilder,\n  PointCloud,\n  Metadata,\n  MetadataBuilder,\n  draco_GeometryAttribute_Type\n} from '../draco3d/draco3d-types';\n\nimport type {TypedArray} from '@loaders.gl/schema';\nimport type {DracoMesh} from './draco-types';\n\nexport type DracoBuildOptions = {\n  pointcloud?: boolean;\n  metadata?: {[key: string]: string};\n  attributesMetadata?: {};\n  log?: any;\n\n  // draco encoding options\n  speed?: [number, number];\n  method?: string;\n  quantization?: {[attributeName: string]: number};\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR_0: 'COLOR',\n  TEXCOORD_0: 'TEX_COORD'\n};\n\nconst noop = () => {};\n\nexport default class DracoBuilder {\n  draco: Draco3D;\n  dracoEncoder: Encoder;\n  dracoMeshBuilder: MeshBuilder;\n  dracoMetadataBuilder: MetadataBuilder;\n  log: any;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.dracoEncoder = new this.draco.Encoder();\n    this.dracoMeshBuilder = new this.draco.MeshBuilder();\n    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();\n  }\n\n  destroy(): void {\n    this.destroyEncodedObject(this.dracoMeshBuilder);\n    this.destroyEncodedObject(this.dracoEncoder);\n    this.destroyEncodedObject(this.dracoMetadataBuilder);\n    // @ts-ignore\n    this.dracoMeshBuilder = null;\n    // @ts-ignore\n    this.dracoEncoder = null;\n    // @ts-ignore\n    this.draco = null;\n  }\n\n  // TBD - when does this need to be called?\n  destroyEncodedObject(object): void {\n    if (object) {\n      this.draco.destroy(object);\n    }\n  }\n\n  /**\n   * Encode mesh or point cloud\n   * @param mesh =({})\n   * @param options\n   */\n  encodeSync(mesh: DracoMesh, options: DracoBuildOptions = {}): ArrayBuffer {\n    this.log = noop; // TODO\n    this._setOptions(options);\n\n    return options.pointcloud\n      ? this._encodePointCloud(mesh, options)\n      : this._encodeMesh(mesh, options);\n  }\n\n  // PRIVATE\n\n  _getAttributesFromMesh(mesh: DracoMesh) {\n    // TODO - Change the encodePointCloud interface instead?\n    const attributes = {...mesh, ...mesh.attributes};\n    // Fold indices into the attributes\n    if (mesh.indices) {\n      attributes.indices = mesh.indices;\n    }\n    return attributes;\n  }\n\n  _encodePointCloud(pointcloud: DracoMesh, options: DracoBuildOptions): ArrayBuffer {\n    const dracoPointCloud = new this.draco.PointCloud();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoPointCloud, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(pointcloud);\n\n    // Build a `DracoPointCloud` from the input data\n    this._createDracoPointCloud(dracoPointCloud, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(\n        dracoPointCloud,\n        false,\n        dracoData\n      );\n\n      if (!(encodedLen > 0)) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points\n        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoPointCloud);\n    }\n  }\n\n  _encodeMesh(mesh: DracoMesh, options: DracoBuildOptions): ArrayBuffer {\n    const dracoMesh = new this.draco.Mesh();\n\n    if (options.metadata) {\n      this._addGeometryMetadata(dracoMesh, options.metadata);\n    }\n\n    const attributes = this._getAttributesFromMesh(mesh);\n\n    // Build a `DracoMesh` from the input data\n    this._createDracoMesh(dracoMesh, attributes, options);\n\n    const dracoData = new this.draco.DracoInt8Array();\n\n    try {\n      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);\n      if (encodedLen <= 0) {\n        throw new Error('Draco encoding failed.');\n      }\n\n      this.log(`DRACO encoded ${dracoMesh.num_points()} points\n        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);\n\n      return dracoInt8ArrayToArrayBuffer(dracoData);\n    } finally {\n      this.destroyEncodedObject(dracoData);\n      this.destroyEncodedObject(dracoMesh);\n    }\n  }\n\n  /**\n   * Set encoding options.\n   * @param {{speed?: any; method?: any; quantization?: any;}} options\n   */\n  _setOptions(options: DracoBuildOptions): void {\n    if ('speed' in options) {\n      // @ts-ignore\n      this.dracoEncoder.SetSpeedOptions(...options.speed);\n    }\n    if ('method' in options) {\n      const dracoMethod = this.draco[options.method || 'MESH_SEQUENTIAL_ENCODING'];\n      // assert(dracoMethod)\n      this.dracoEncoder.SetEncodingMethod(dracoMethod);\n    }\n    if ('quantization' in options) {\n      for (const attribute in options.quantization) {\n        const bits = options.quantization[attribute];\n        const dracoPosition = this.draco[attribute];\n        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);\n      }\n    }\n  }\n\n  /**\n   * @param {Mesh} dracoMesh\n   * @param {object} attributes\n   * @returns {Mesh}\n   */\n  _createDracoMesh(dracoMesh: Mesh, attributes, options: DracoBuildOptions): Mesh {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);\n\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoMesh, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoMesh);\n      throw error;\n    }\n\n    return dracoMesh;\n  }\n\n  /**\n   * @param {} dracoPointCloud\n   * @param {object} attributes\n   */\n  _createDracoPointCloud(\n    dracoPointCloud: PointCloud,\n    attributes: object,\n    options: DracoBuildOptions\n  ): PointCloud {\n    const optionalMetadata = options.attributesMetadata || {};\n\n    try {\n      const positions = this._getPositionAttribute(attributes);\n      if (!positions) {\n        throw new Error('positions');\n      }\n      const vertexCount = positions.length / 3;\n\n      for (let attributeName in attributes) {\n        const attribute = attributes[attributeName];\n        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;\n        const uniqueId = this._addAttributeToMesh(\n          dracoPointCloud,\n          attributeName,\n          attribute,\n          vertexCount\n        );\n        if (uniqueId !== -1) {\n          this._addAttributeMetadata(dracoPointCloud, uniqueId, {\n            name: attributeName,\n            ...(optionalMetadata[attributeName] || {})\n          });\n        }\n      }\n    } catch (error) {\n      this.destroyEncodedObject(dracoPointCloud);\n      throw error;\n    }\n\n    return dracoPointCloud;\n  }\n\n  /**\n   * @param mesh\n   * @param attributeName\n   * @param attribute\n   * @param vertexCount\n   */\n  _addAttributeToMesh(\n    mesh: PointCloud,\n    attributeName: string,\n    attribute: TypedArray,\n    vertexCount: number\n  ) {\n    if (!ArrayBuffer.isView(attribute)) {\n      return -1;\n    }\n\n    const type = this._getDracoAttributeType(attributeName);\n    // @ts-ignore TODO/fix types\n    const size = attribute.length / vertexCount;\n\n    if (type === 'indices') {\n      // @ts-ignore TODO/fix types\n      const numFaces = attribute.length / 3;\n      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);\n\n      // @ts-ignore assumes mesh is a Mesh, not a point cloud\n      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);\n      return -1;\n    }\n\n    this.log(`Adding attribute ${attributeName}, size ${size}`);\n\n    const builder = this.dracoMeshBuilder;\n    const {buffer} = attribute;\n\n    switch (attribute.constructor) {\n      case Int8Array:\n        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));\n\n      case Int16Array:\n        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));\n\n      case Int32Array:\n        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));\n      case Uint8Array:\n      case Uint8ClampedArray:\n        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));\n\n      case Uint16Array:\n        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));\n\n      case Uint32Array:\n        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));\n\n      case Float32Array:\n      default:\n        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));\n    }\n  }\n\n  /**\n   * DRACO can compress attributes of know type better\n   * TODO - expose an attribute type map?\n   * @param attributeName\n   */\n  _getDracoAttributeType(attributeName: string): draco_GeometryAttribute_Type | 'indices' {\n    switch (attributeName.toLowerCase()) {\n      case 'indices':\n        return 'indices';\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return this.draco.POSITION;\n      case 'normal':\n      case 'normals':\n        return this.draco.NORMAL;\n      case 'color':\n      case 'colors':\n        return this.draco.COLOR;\n      case 'texcoord':\n      case 'texcoords':\n        return this.draco.TEX_COORD;\n      default:\n        return this.draco.GENERIC;\n    }\n  }\n\n  _getPositionAttribute(attributes) {\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const dracoType = this._getDracoAttributeType(attributeName);\n      if (dracoType === this.draco.POSITION) {\n        return attribute;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add metadata for the geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param metadata\n   */\n  _addGeometryMetadata(dracoGeometry: PointCloud, metadata: {[key: string]: string}) {\n    const dracoMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoMetadata, metadata);\n    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);\n  }\n\n  /**\n   * Add metadata for an attribute to geometry.\n   * @param dracoGeometry - WASM Draco Object\n   * @param uniqueAttributeId\n   * @param metadata\n   */\n  _addAttributeMetadata(\n    dracoGeometry: PointCloud,\n    uniqueAttributeId: number,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to\n    // create such objects automatically from draco.Metadata object.\n    const dracoAttributeMetadata = new this.draco.Metadata();\n    this._populateDracoMetadata(dracoAttributeMetadata, metadata);\n    // Draco3d doc note: Directly add attribute metadata to geometry.\n    // You can do this without explicitly adding |GeometryMetadata| to mesh.\n    this.dracoMeshBuilder.SetMetadataForAttribute(\n      dracoGeometry,\n      uniqueAttributeId,\n      dracoAttributeMetadata\n    );\n  }\n\n  /**\n   * Add contents of object or map to a WASM Draco Metadata Object\n   * @param dracoMetadata - WASM Draco Object\n   * @param metadata\n   */\n  _populateDracoMetadata(\n    dracoMetadata: Metadata,\n    metadata: Map<string, string> | {[key: string]: string}\n  ) {\n    for (const [key, value] of getEntries(metadata)) {\n      switch (typeof value) {\n        case 'number':\n          if (Math.trunc(value) === value) {\n            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);\n          } else {\n            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);\n          }\n          break;\n        case 'object':\n          if (value instanceof Int32Array) {\n            this.dracoMetadataBuilder.AddIntEntryArray(dracoMetadata, key, value, value.length);\n          }\n          break;\n        case 'string':\n        default:\n          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);\n      }\n    }\n  }\n}\n\n// HELPER FUNCTIONS\n\n/**\n * Copy encoded data to buffer\n * @param dracoData\n */\nfunction dracoInt8ArrayToArrayBuffer(dracoData: DracoInt8Array) {\n  const byteLength = dracoData.size();\n  const outputBuffer = new ArrayBuffer(byteLength);\n  const outputData = new Int8Array(outputBuffer);\n  for (let i = 0; i < byteLength; ++i) {\n    outputData[i] = dracoData.GetValue(i);\n  }\n  return outputBuffer;\n}\n\n/** Enable iteration over either an object or a map */\nfunction getEntries(container) {\n  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');\n  return hasEntriesFunc ? container.entries() : Object.entries(container);\n}\n"]},"metadata":{},"sourceType":"module"}