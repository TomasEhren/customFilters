{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { BasisLoader, selectSupportedBasisFormat } from '@loaders.gl/textures';\nimport { ImageLoader } from '@loaders.gl/images';\nimport { parseJSON, sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { assert } from '../utils/assert';\nimport { resolveUrl } from '../gltf-utils/resolve-url';\nimport { getTypedArrayForBufferView } from '../gltf-utils/get-typed-array';\nimport { preprocessExtensions, decodeExtensions } from '../api/gltf-extensions';\nimport { normalizeGLTFV1 } from '../api/normalize-gltf-v1';\nimport { postProcessGLTF } from '../api/post-process-gltf';\nimport parseGLBSync, { isGLB } from './parse-glb';\nexport function isGLTF(arrayBuffer, options) {\n  var byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\nexport function parseGLTF(_x, _x2) {\n  return _parseGLTF.apply(this, arguments);\n}\n\nfunction _parseGLTF() {\n  _parseGLTF = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltf, arrayBufferOrString) {\n    var byteOffset,\n        options,\n        context,\n        _options$gltf,\n        _options$gltf2,\n        _options$gltf3,\n        _options$gltf4,\n        promises,\n        _promise,\n        promise,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            byteOffset = _args.length > 2 && _args[2] !== undefined ? _args[2] : 0;\n            options = _args.length > 3 ? _args[3] : undefined;\n            context = _args.length > 4 ? _args[4] : undefined;\n            parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n            normalizeGLTFV1(gltf, {\n              normalize: options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.normalize\n            });\n            preprocessExtensions(gltf, options, context);\n            promises = [];\n\n            if (!(options !== null && options !== void 0 && (_options$gltf2 = options.gltf) !== null && _options$gltf2 !== void 0 && _options$gltf2.loadBuffers && gltf.json.buffers)) {\n              _context.next = 10;\n              break;\n            }\n\n            _context.next = 10;\n            return loadBuffers(gltf, options, context);\n\n          case 10:\n            if (options !== null && options !== void 0 && (_options$gltf3 = options.gltf) !== null && _options$gltf3 !== void 0 && _options$gltf3.loadImages) {\n              _promise = loadImages(gltf, options, context);\n              promises.push(_promise);\n            }\n\n            promise = decodeExtensions(gltf, options, context);\n            promises.push(promise);\n            _context.next = 15;\n            return Promise.all(promises);\n\n          case 15:\n            return _context.abrupt(\"return\", options !== null && options !== void 0 && (_options$gltf4 = options.gltf) !== null && _options$gltf4 !== void 0 && _options$gltf4.postProcess ? postProcessGLTF(gltf, options) : gltf);\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _parseGLTF.apply(this, arguments);\n}\n\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    var textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    var glb = {};\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n    assert(glb.type === 'glTF', \"Invalid GLB magic string \".concat(glb.type));\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  var buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    var binChunks = gltf._glb.binChunks;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n  }\n\n  var images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\nfunction loadBuffers(_x3, _x4, _x5) {\n  return _loadBuffers.apply(this, arguments);\n}\n\nfunction _loadBuffers() {\n  _loadBuffers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(gltf, options, context) {\n    var buffers, i, buffer, _context$fetch, _response$arrayBuffer, fetch, uri, response, arrayBuffer;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            buffers = gltf.json.buffers || [];\n            i = 0;\n\n          case 2:\n            if (!(i < buffers.length)) {\n              _context2.next = 19;\n              break;\n            }\n\n            buffer = buffers[i];\n\n            if (!buffer.uri) {\n              _context2.next = 16;\n              break;\n            }\n\n            fetch = context.fetch;\n            assert(fetch);\n            uri = resolveUrl(buffer.uri, options);\n            _context2.next = 10;\n            return context === null || context === void 0 ? void 0 : (_context$fetch = context.fetch) === null || _context$fetch === void 0 ? void 0 : _context$fetch.call(context, uri);\n\n          case 10:\n            response = _context2.sent;\n            _context2.next = 13;\n            return response === null || response === void 0 ? void 0 : (_response$arrayBuffer = response.arrayBuffer) === null || _response$arrayBuffer === void 0 ? void 0 : _response$arrayBuffer.call(response);\n\n          case 13:\n            arrayBuffer = _context2.sent;\n            gltf.buffers[i] = {\n              arrayBuffer: arrayBuffer,\n              byteOffset: 0,\n              byteLength: arrayBuffer.byteLength\n            };\n            delete buffer.uri;\n\n          case 16:\n            ++i;\n            _context2.next = 2;\n            break;\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadBuffers.apply(this, arguments);\n}\n\nfunction loadImages(_x6, _x7, _x8) {\n  return _loadImages.apply(this, arguments);\n}\n\nfunction _loadImages() {\n  _loadImages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(gltf, options, context) {\n    var imageIndices, images, promises, _iterator2, _step2, imageIndex;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            imageIndices = getReferencesImageIndices(gltf);\n            images = gltf.json.images || [];\n            promises = [];\n            _iterator2 = _createForOfIteratorHelper(imageIndices);\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                imageIndex = _step2.value;\n                promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            _context3.next = 7;\n            return Promise.all(promises);\n\n          case 7:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _loadImages.apply(this, arguments);\n}\n\nfunction getReferencesImageIndices(gltf) {\n  var imageIndices = new Set();\n  var textures = gltf.json.textures || [];\n\n  var _iterator = _createForOfIteratorHelper(textures),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var texture = _step.value;\n\n      if (texture.source !== undefined) {\n        imageIndices.add(texture.source);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\nfunction loadImage(_x9, _x10, _x11, _x12, _x13) {\n  return _loadImage.apply(this, arguments);\n}\n\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(gltf, image, index, options, context) {\n    var fetch, parse, arrayBuffer, uri, response, array, parsedImage;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            fetch = context.fetch, parse = context.parse;\n\n            if (!image.uri) {\n              _context4.next = 9;\n              break;\n            }\n\n            uri = resolveUrl(image.uri, options);\n            _context4.next = 5;\n            return fetch(uri);\n\n          case 5:\n            response = _context4.sent;\n            _context4.next = 8;\n            return response.arrayBuffer();\n\n          case 8:\n            arrayBuffer = _context4.sent;\n\n          case 9:\n            if (Number.isFinite(image.bufferView)) {\n              array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n              arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n            }\n\n            assert(arrayBuffer, 'glTF image has no data');\n            _context4.next = 13;\n            return parse(arrayBuffer, [ImageLoader, BasisLoader], {\n              mimeType: image.mimeType,\n              basis: options.basis || {\n                format: selectSupportedBasisFormat()\n              }\n            }, context);\n\n          case 13:\n            parsedImage = _context4.sent;\n\n            if (parsedImage && parsedImage[0]) {\n              parsedImage = {\n                compressed: true,\n                mipmaps: false,\n                width: parsedImage[0].width,\n                height: parsedImage[0].height,\n                data: parsedImage\n              };\n            }\n\n            gltf.images = gltf.images || [];\n            gltf.images[index] = parsedImage;\n\n          case 17:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _loadImage.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["BasisLoader","selectSupportedBasisFormat","ImageLoader","parseJSON","sliceArrayBuffer","assert","resolveUrl","getTypedArrayForBufferView","preprocessExtensions","decodeExtensions","normalizeGLTFV1","postProcessGLTF","parseGLBSync","isGLB","isGLTF","arrayBuffer","options","byteOffset","parseGLTF","gltf","arrayBufferOrString","context","parseGLTFContainerSync","normalize","_options$gltf","promises","loadBuffers","json","buffers","_options$gltf3","loadImages","promise","push","Promise","all","postProcess","data","uri","baseUri","ArrayBuffer","textDecoder","TextDecoder","decode","glb","type","_glb","Array","length","fill","header","hasBinChunk","binChunks","byteLength","images","i","buffer","fetch","_context$fetch","response","_response$arrayBuffer","imageIndices","getReferencesImageIndices","imageIndex","loadImage","Set","textures","texture","source","undefined","add","from","sort","image","index","parse","Number","isFinite","bufferView","array","mimeType","basis","format","parsedImage","compressed","mipmaps","width","height"],"sources":["../../../../src/lib/parsers/parse-gltf.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n"]},"metadata":{},"sourceType":"module"}