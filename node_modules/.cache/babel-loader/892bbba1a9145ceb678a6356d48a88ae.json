{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport TinySDF from '@mapbox/tiny-sdf';\nimport { log } from '@deck.gl/core';\nimport { buildMapping } from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  var charSet = [];\n\n  for (var i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nexport var DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport var DEFAULT_FONT_FAMILY = 'Monaco, monospace';\nexport var DEFAULT_FONT_WEIGHT = 'normal';\nexport var DEFAULT_FONT_SIZE = 64;\nexport var DEFAULT_BUFFER = 4;\nexport var DEFAULT_CUTOFF = 0.25;\nexport var DEFAULT_RADIUS = 12;\nvar MAX_CANVAS_WIDTH = 1024;\nvar BASELINE_SCALE = 0.9;\nvar HEIGHT_SCALE = 1.2;\nvar CACHE_LIMIT = 3;\nvar cache = new LRUCache(CACHE_LIMIT);\nvar VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];\n\nfunction getNewChars(key, characterSet) {\n  var cachedFontAtlas = cache.get(key);\n\n  if (!cachedFontAtlas) {\n    return characterSet;\n  }\n\n  var newChars = [];\n  var cachedMapping = cachedFontAtlas.mapping;\n  var cachedCharSet = Object.keys(cachedMapping);\n  cachedCharSet = new Set(cachedCharSet);\n  var charSet = characterSet;\n\n  if (charSet instanceof Array) {\n    charSet = new Set(charSet);\n  }\n\n  charSet.forEach(function (char) {\n    if (!cachedCharSet.has(char)) {\n      newChars.push(char);\n    }\n  });\n  return newChars;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (var i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'baseline';\n  ctx.textAlign = 'left';\n}\n\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n  cache = new LRUCache(limit);\n}\n\nvar FontAtlasManager = /*#__PURE__*/function () {\n  function FontAtlasManager() {\n    _classCallCheck(this, FontAtlasManager);\n\n    this.props = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      sdf: false,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS\n    };\n    this._key = null;\n    this._atlas = null;\n  }\n\n  _createClass(FontAtlasManager, [{\n    key: \"texture\",\n    get: function get() {\n      return this._atlas;\n    }\n  }, {\n    key: \"mapping\",\n    get: function get() {\n      return this._atlas && this._atlas.mapping;\n    }\n  }, {\n    key: \"scale\",\n    get: function get() {\n      return HEIGHT_SCALE;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps() {\n      var _this = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      VALID_PROPS.forEach(function (prop) {\n        if (prop in props) {\n          _this.props[prop] = props[prop];\n        }\n      });\n      var oldKey = this._key;\n      this._key = this._getKey();\n      var charSet = getNewChars(this._key, this.props.characterSet);\n      var cachedFontAtlas = cache.get(this._key);\n\n      if (cachedFontAtlas && charSet.length === 0) {\n        if (this._key !== oldKey) {\n          this._atlas = cachedFontAtlas;\n        }\n\n        return;\n      }\n\n      var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n\n      this._atlas = fontAtlas;\n      cache.set(this._key, fontAtlas);\n    }\n  }, {\n    key: \"_generateFontAtlas\",\n    value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n      var _this$props = this.props,\n          fontFamily = _this$props.fontFamily,\n          fontWeight = _this$props.fontWeight,\n          fontSize = _this$props.fontSize,\n          buffer = _this$props.buffer,\n          sdf = _this$props.sdf,\n          radius = _this$props.radius,\n          cutoff = _this$props.cutoff;\n      var canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n      if (!canvas) {\n        canvas = document.createElement('canvas');\n        canvas.width = MAX_CANVAS_WIDTH;\n      }\n\n      var ctx = canvas.getContext('2d');\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      var _buildMapping = buildMapping(_objectSpread({\n        getFontWidth: function getFontWidth(char) {\n          return ctx.measureText(char).width;\n        },\n        fontHeight: fontSize * HEIGHT_SCALE,\n        buffer: buffer,\n        characterSet: characterSet,\n        maxCanvasWidth: MAX_CANVAS_WIDTH\n      }, cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })),\n          mapping = _buildMapping.mapping,\n          canvasHeight = _buildMapping.canvasHeight,\n          xOffset = _buildMapping.xOffset,\n          yOffset = _buildMapping.yOffset;\n\n      if (canvas.height !== canvasHeight) {\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        canvas.height = canvasHeight;\n        ctx.putImageData(imageData, 0, 0);\n      }\n\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      if (sdf) {\n        var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n\n        var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n        var _iterator = _createForOfIteratorHelper(characterSet),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var char = _step.value;\n            populateAlphaChannel(tinySDF.draw(char), _imageData);\n            ctx.putImageData(_imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(characterSet),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _char = _step2.value;\n            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return {\n        xOffset: xOffset,\n        yOffset: yOffset,\n        mapping: mapping,\n        data: canvas,\n        width: canvas.width,\n        height: canvas.height\n      };\n    }\n  }, {\n    key: \"_getKey\",\n    value: function _getKey() {\n      var _this$props2 = this.props,\n          fontFamily = _this$props2.fontFamily,\n          fontWeight = _this$props2.fontWeight,\n          fontSize = _this$props2.fontSize,\n          buffer = _this$props2.buffer,\n          sdf = _this$props2.sdf,\n          radius = _this$props2.radius,\n          cutoff = _this$props2.cutoff;\n\n      if (sdf) {\n        return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff);\n      }\n\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n    }\n  }]);\n\n  return FontAtlasManager;\n}();\n\nexport { FontAtlasManager as default };","map":{"version":3,"mappings":"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","names":["TinySDF","log","buildMapping","LRUCache","getDefaultCharacterSet","charSet","i","push","String","fromCharCode","DEFAULT_CHAR_SET","DEFAULT_FONT_FAMILY","DEFAULT_FONT_WEIGHT","DEFAULT_FONT_SIZE","DEFAULT_BUFFER","DEFAULT_CUTOFF","DEFAULT_RADIUS","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","cache","VALID_PROPS","getNewChars","key","characterSet","cachedFontAtlas","get","newChars","cachedMapping","mapping","cachedCharSet","Object","keys","Set","Array","forEach","char","has","populateAlphaChannel","alphaChannel","imageData","length","data","setTextStyle","ctx","fontFamily","fontSize","fontWeight","font","fillStyle","textBaseline","textAlign","setFontAtlasCacheLimit","limit","assert","Number","isFinite","FontAtlasManager","constructor","props","buffer","sdf","cutoff","radius","_key","_atlas","setProps","prop","oldKey","_getKey","fontAtlas","_generateFontAtlas","set","canvas","document","createElement","width","getContext","getFontWidth","measureText","fontHeight","maxCanvasWidth","xOffset","yOffset","canvasHeight","height","getImageData","putImageData","tinySDF","size","draw","x","y","fillText"],"sources":["../../../src/text-layer/font-atlas-manager.js"],"sourcesContent":["/* global document */\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {log} from '@deck.gl/core';\n\nimport {buildMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport const DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport const DEFAULT_FONT_FAMILY = 'Monaco, monospace';\nexport const DEFAULT_FONT_WEIGHT = 'normal';\nexport const DEFAULT_FONT_SIZE = 64;\nexport const DEFAULT_BUFFER = 4;\nexport const DEFAULT_CUTOFF = 0.25;\nexport const DEFAULT_RADIUS = 12;\n\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\n/**\n * [key]: {\n *   xOffset, // x position of last character in mapping\n *   yOffset, // y position of last character in mapping\n *   mapping, // x, y coordinate of each character in shared `fontAtlas`\n *   data, // canvas\n *   width. // canvas.width,\n *   height, // canvas.height\n * }\n *\n */\nlet cache = new LRUCache(CACHE_LIMIT);\n\nconst VALID_PROPS = [\n  'fontFamily',\n  'fontWeight',\n  'characterSet',\n  'fontSize',\n  'sdf',\n  'buffer',\n  'cutoff',\n  'radius'\n];\n\n/**\n * get all the chars not in cache\n * @param key cache key\n * @param characterSet (Array|Set)\n * @returns {Array} chars not in cache\n */\nfunction getNewChars(key, characterSet) {\n  const cachedFontAtlas = cache.get(key);\n  if (!cachedFontAtlas) {\n    return characterSet;\n  }\n\n  const newChars = [];\n  const cachedMapping = cachedFontAtlas.mapping;\n  let cachedCharSet = Object.keys(cachedMapping);\n  cachedCharSet = new Set(cachedCharSet);\n\n  let charSet = characterSet;\n  if (charSet instanceof Array) {\n    charSet = new Set(charSet);\n  }\n\n  charSet.forEach(char => {\n    if (!cachedCharSet.has(char)) {\n      newChars.push(char);\n    }\n  });\n\n  return newChars;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'baseline';\n  ctx.textAlign = 'left';\n}\n\n/**\n * Sets the Font Atlas LRU Cache Limit\n * @param {number} limit LRU Cache limit\n */\nexport function setFontAtlasCacheLimit(limit) {\n  log.assert(Number.isFinite(limit) && limit >= CACHE_LIMIT, 'Invalid cache limit');\n\n  cache = new LRUCache(limit);\n}\n\nexport default class FontAtlasManager {\n  constructor() {\n    // font settings\n    this.props = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      // sdf only props\n      // https://github.com/mapbox/tiny-sdf\n      sdf: false,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS\n    };\n\n    // key is used for caching generated fontAtlas\n    this._key = null;\n    this._atlas = null;\n  }\n\n  get texture() {\n    return this._atlas;\n  }\n\n  get mapping() {\n    return this._atlas && this._atlas.mapping;\n  }\n\n  get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props = {}) {\n    VALID_PROPS.forEach(prop => {\n      if (prop in props) {\n        this.props[prop] = props[prop];\n      }\n    });\n\n    // update cache key\n    const oldKey = this._key;\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.length === 0) {\n      // update texture with cached fontAtlas\n      if (this._key !== oldKey) {\n        this._atlas = cachedFontAtlas;\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n    this._atlas = fontAtlas;\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d');\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping({\n      getFontWidth: char => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y + buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}