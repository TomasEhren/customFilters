{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResizeCircleMode = void 0;\n\nvar _nearestPointOnLine = _interopRequireDefault(require(\"@turf/nearest-point-on-line\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _circle = _interopRequireDefault(require(\"@turf/circle\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _center = _interopRequireDefault(require(\"@turf/center\"));\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ResizeCircleMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ResizeCircleMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ResizeCircleMode);\n\n  function ResizeCircleMode() {\n    var _this;\n\n    _classCallCheck(this, ResizeCircleMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isResizing\", false);\n\n    return _this;\n  }\n\n  _createClass(ResizeCircleMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var _this2 = this;\n\n      var handles = [];\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var lastPointerMoveEvent = props.lastPointerMoveEvent;\n      var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n      var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords; // intermediate edit handle\n\n      if (picks && picks.length && mapCoords && selectedFeatureIndexes.length === 1 && !this._isResizing) {\n        var featureAsPick = picks.find(function (pick) {\n          return !pick.isGuide;\n        }); // is the feature in the pick selected\n\n        if (featureAsPick && featureAsPick.object.properties.shape && featureAsPick.object.properties.shape.includes('Circle') && props.selectedIndexes.includes(featureAsPick.index)) {\n          var intermediatePoint = null;\n          var positionIndexPrefix = [];\n          var referencePoint = (0, _helpers.point)(mapCoords); // process all lines of the (single) feature\n\n          (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function (lineString, prefix) {\n            var lineStringFeature = (0, _helpers.lineString)(lineString);\n\n            var candidateIntermediatePoint = _this2.getNearestPoint( // @ts-ignore\n            lineStringFeature, referencePoint, props.modeConfig && props.modeConfig.viewport);\n\n            if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }); // tack on the lone intermediate point to the set of handles\n\n          if (intermediatePoint) {\n            var _intermediatePoint = intermediatePoint,\n                position = _intermediatePoint.geometry.coordinates,\n                index = _intermediatePoint.properties.index;\n            handles.push({\n              type: 'Feature',\n              properties: {\n                guideType: 'editHandle',\n                editHandleType: 'intermediate',\n                featureIndex: featureAsPick.index,\n                positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])\n              },\n              geometry: {\n                type: 'Point',\n                coordinates: position\n              }\n            });\n          }\n        }\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: handles\n      };\n    } // turf.js does not support elevation for nearestPointOnLine\n\n  }, {\n    key: \"getNearestPoint\",\n    value: function getNearestPoint(line, inPoint, viewport) {\n      var coordinates = line.geometry.coordinates;\n\n      if (coordinates.some(function (coord) {\n        return coord.length > 2;\n      })) {\n        if (viewport) {\n          // This line has elevation, we need to use alternative algorithm\n          return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);\n        } // eslint-disable-next-line no-console,no-undef\n\n\n        console.log('Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.');\n      }\n\n      return (0, _nearestPointOnLine[\"default\"])(line, inPoint);\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        // Cancel map panning if pointer went down on an edit handle\n        event.cancelPan();\n        var editHandleProperties = editHandle.properties;\n        var feature = this.getSelectedFeature(props);\n        var center = (0, _center[\"default\"])(feature).geometry.coordinates;\n        var numberOfSteps = Object.entries(feature.geometry.coordinates[0]).length - 1;\n        var radius = Math.max((0, _distance[\"default\"])(center, event.mapCoords), 0.001);\n        var _ref = {},\n            _ref$steps = _ref.steps,\n            steps = _ref$steps === void 0 ? numberOfSteps : _ref$steps;\n        var options = {\n          steps: steps\n        };\n        var updatedFeature = (0, _circle[\"default\"])(center, radius, options);\n        var geometry = updatedFeature.geometry;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(editHandleProperties.featureIndex, geometry).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'unionGeometry',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex]\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isResizing) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'intermediate' ? selectedEditHandle : null;\n      }\n\n      var cursor = this.getCursor(event);\n      props.onUpdateCursor(cursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isResizing = true;\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isResizing) {\n        this._selectedEditHandle = null;\n        this._isResizing = false;\n      }\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(event) {\n      var picks = event && event.picks || [];\n      var handlesPicked = (0, _utils.getPickedEditHandles)(picks);\n\n      if (handlesPicked.length) {\n        return 'cell';\n      }\n\n      return null;\n    }\n  }]);\n\n  return ResizeCircleMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ResizeCircleMode = ResizeCircleMode;","map":{"version":3,"mappings":"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","names":["ResizeCircleMode","props","handles","selectedFeatureIndexes","selectedIndexes","lastPointerMoveEvent","picks","mapCoords","length","_isResizing","featureAsPick","find","pick","isGuide","object","properties","shape","includes","index","intermediatePoint","positionIndexPrefix","referencePoint","geometry","coordinates","lineString","prefix","lineStringFeature","candidateIntermediatePoint","_this2","getNearestPoint","modeConfig","viewport","dist","position","push","type","guideType","editHandleType","featureIndex","positionIndexes","features","line","inPoint","some","coord","console","log","event","editHandle","pointerDownPicks","cancelPan","editHandleProperties","feature","getSelectedFeature","center","numberOfSteps","Object","entries","radius","Math","max","steps","options","updatedFeature","updatedData","ImmutableFeatureCollection","data","replaceGeometry","getObject","onEdit","editType","editContext","featureIndexes","selectedEditHandle","_selectedEditHandle","cursor","getCursor","onUpdateCursor","handlesPicked","GeoJsonEditMode"],"sources":["../../src/lib/resize-circle-mode.ts"],"sourcesContent":["import nearestPointOnLine from '@turf/nearest-point-on-line';\nimport { point, lineString as toLineString } from '@turf/helpers';\nimport circle from '@turf/circle';\nimport distance from '@turf/distance';\nimport turfCenter from '@turf/center';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  getPickedEditHandles,\n  getPickedEditHandle,\n  NearestPointType,\n} from '../utils';\nimport { LineString, Point, FeatureCollection, FeatureOf } from '../geojson-types';\nimport {\n  ModeProps,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Viewport,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ResizeCircleMode extends GeoJsonEditMode {\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _isResizing = false;\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const handles = [];\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const { lastPointerMoveEvent } = props;\n    const picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n    const mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n    // intermediate edit handle\n    if (\n      picks &&\n      picks.length &&\n      mapCoords &&\n      selectedFeatureIndexes.length === 1 &&\n      !this._isResizing\n    ) {\n      const featureAsPick = picks.find((pick) => !pick.isGuide);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        featureAsPick.object.properties.shape &&\n        featureAsPick.object.properties.shape.includes('Circle') &&\n        props.selectedIndexes.includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: NearestPointType | null | undefined = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(mapCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.getNearestPoint(\n              // @ts-ignore\n              lineStringFeature,\n              referencePoint,\n              props.modeConfig && props.modeConfig.viewport\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index },\n          } = intermediatePoint;\n          handles.push({\n            type: 'Feature',\n            properties: {\n              guideType: 'editHandle',\n              editHandleType: 'intermediate',\n              featureIndex: featureAsPick.index,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n            },\n            geometry: {\n              type: 'Point',\n              coordinates: position,\n            },\n          });\n        }\n      }\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features: handles,\n    };\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  getNearestPoint(\n    line: FeatureOf<LineString>,\n    inPoint: FeatureOf<Point>,\n    viewport: Viewport | null | undefined\n  ): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some((coord) => coord.length > 2)) {\n      if (viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n\n    return nearestPointOnLine(line, inPoint);\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      // Cancel map panning if pointer went down on an edit handle\n      event.cancelPan();\n\n      const editHandleProperties = editHandle.properties;\n\n      const feature = this.getSelectedFeature(props);\n      const center = turfCenter(feature).geometry.coordinates;\n      const numberOfSteps = Object.entries(feature.geometry.coordinates[0]).length - 1;\n      const radius = Math.max(distance(center, event.mapCoords), 0.001);\n\n      const { steps = numberOfSteps } = {};\n      const options = { steps };\n      const updatedFeature = circle(center, radius, options);\n      const geometry = updatedFeature.geometry;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(editHandleProperties.featureIndex, geometry)\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n        },\n      });\n    }\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    if (!this._isResizing) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'intermediate'\n          ? selectedEditHandle\n          : null;\n    }\n\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isResizing = true;\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isResizing) {\n      this._selectedEditHandle = null;\n      this._isResizing = false;\n    }\n  }\n\n  getCursor(event: PointerMoveEvent): string | null | undefined {\n    const picks = (event && event.picks) || [];\n\n    const handlesPicked = getPickedEditHandles(picks);\n    if (handlesPicked.length) {\n      return 'cell';\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}