{"ast":null,"code":"import DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\nexport default class Attribute extends DataColumn {\n  constructor(gl) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(gl, opts);\n    const {\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || accessor && this._autoUpdater,\n      accessor,\n      transform\n    });\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw() {\n    let {\n      clearChangedFlags = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {\n      accessor\n    } = this.settings;\n    return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n\n    const {\n      accessor\n    } = this.settings;\n    const layerSettings = this.settings.transition;\n    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    let dataRange = arguments.length > 1 ? arguments[1] : undefined;\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n\n    if (dataRange) {\n      const {\n        startRow = 0,\n        endRow = Infinity\n      } = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {\n      state,\n      settings\n    } = this;\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer(_ref) {\n    let {\n      numInstances,\n      data,\n      props,\n      context\n    } = _ref;\n\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {\n        updateRanges\n      },\n      settings: {\n        update,\n        noAlloc\n      }\n    } = this;\n    let updated = true;\n\n    if (update) {\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {\n          data,\n          startRow,\n          endRow,\n          props,\n          numInstances\n        });\n      }\n\n      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n          super.updateSubBuffer({\n            startOffset,\n            endOffset\n          });\n        }\n      }\n\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n    return updated;\n  }\n\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({\n      constant: true,\n      value\n    });\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  setExternalBuffer(buffer) {\n    const {\n      state\n    } = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  setBinaryValue(buffer) {\n    let startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      state,\n      settings\n    } = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {\n        value: buffer\n      };\n    }\n\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), \"invalid \".concat(settings.accessor));\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {\n      startIndices\n    } = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {\n      [this.id]: null\n    };\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n    }\n\n    return shaderAttributes;\n  }\n\n  _autoUpdater(attribute, _ref2) {\n    let {\n      data,\n      startRow,\n      endRow,\n      props,\n      numInstances\n    } = _ref2;\n\n    if (attribute.constant) {\n      return;\n    }\n\n    const {\n      settings,\n      state,\n      value,\n      size,\n      startIndices\n    } = attribute;\n    const {\n      accessor,\n      transform\n    } = settings;\n    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n    assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n    let i = attribute.getVertexOffset(startRow);\n    const {\n      iterable,\n      objectInfo\n    } = createIterable(data, startRow, endRow);\n\n    for (const object of iterable) {\n      objectInfo.index++;\n      let objectValue = accessorFunc(object, objectInfo);\n\n      if (transform) {\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n\n        i += size;\n      }\n    }\n  }\n\n  _validateAttributeUpdaters() {\n    const {\n      settings\n    } = this;\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n\n    if (!hasUpdater) {\n      throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n    }\n  }\n\n  _checkAttributeArray() {\n    const {\n      value\n    } = this;\n    const limit = Math.min(4, this.size);\n\n    if (value && value.length >= limit) {\n      let valid = true;\n\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(\"Illegal attribute generated for \".concat(this.id));\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","constructor","gl","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","assign","settings","_autoUpdater","state","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","seal","_validateAttributeUpdaters","layout","clearChangedFlags","getUpdateTriggers","id","concat","supportsTransition","Boolean","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","setData","allocate","numInstances","copy","updateBuffer","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","startOffset","Number","isFinite","getVertexOffset","endOffset","length","size","updateSubBuffer","_checkAttributeArray","setConstantValue","undefined","hasChanged","setExternalBuffer","setBinaryValue","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","shaderAttributeName","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"sources":["../../../../src/lib/attribute/attribute.js"],"sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"]},"metadata":{},"sourceType":"module"}