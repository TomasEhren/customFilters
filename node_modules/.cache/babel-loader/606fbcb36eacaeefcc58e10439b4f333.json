{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { assembleShaders } from '@luma.gl/shadertools';\nimport { Program } from '@luma.gl/webgl';\n\nvar ProgramManager = /*#__PURE__*/function () {\n  function ProgramManager(gl) {\n    _classCallCheck(this, ProgramManager);\n\n    this.gl = gl;\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {};\n    this._hookFunctions = [];\n    this._defaultModules = [];\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0;\n    this._useCounts = {};\n  }\n\n  _createClass(ProgramManager, [{\n    key: \"addDefaultModule\",\n    value: function addDefaultModule(module) {\n      if (!this._defaultModules.find(function (m) {\n        return m.name === module.name;\n      })) {\n        this._defaultModules.push(module);\n      }\n\n      this.stateHash++;\n    }\n  }, {\n    key: \"removeDefaultModule\",\n    value: function removeDefaultModule(module) {\n      var moduleName = typeof module === 'string' ? module : module.name;\n      this._defaultModules = this._defaultModules.filter(function (m) {\n        return m.name !== moduleName;\n      });\n      this.stateHash++;\n    }\n  }, {\n    key: \"addShaderHook\",\n    value: function addShaderHook(hook, opts) {\n      if (opts) {\n        hook = Object.assign(opts, {\n          hook: hook\n        });\n      }\n\n      this._hookFunctions.push(hook);\n\n      this.stateHash++;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      var _this = this;\n\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _props$vs = props.vs,\n          vs = _props$vs === void 0 ? '' : _props$vs,\n          _props$fs = props.fs,\n          fs = _props$fs === void 0 ? '' : _props$fs,\n          _props$defines = props.defines,\n          defines = _props$defines === void 0 ? {} : _props$defines,\n          _props$inject = props.inject,\n          inject = _props$inject === void 0 ? {} : _props$inject,\n          _props$varyings = props.varyings,\n          varyings = _props$varyings === void 0 ? [] : _props$varyings,\n          _props$bufferMode = props.bufferMode,\n          bufferMode = _props$bufferMode === void 0 ? 0x8c8d : _props$bufferMode,\n          _props$transpileToGLS = props.transpileToGLSL100,\n          transpileToGLSL100 = _props$transpileToGLS === void 0 ? false : _props$transpileToGLS;\n\n      var modules = this._getModuleList(props.modules);\n\n      var vsHash = this._getHash(vs);\n\n      var fsHash = this._getHash(fs);\n\n      var moduleHashes = modules.map(function (m) {\n        return _this._getHash(m.name);\n      }).sort();\n      var varyingHashes = varyings.map(function (v) {\n        return _this._getHash(v);\n      });\n      var defineKeys = Object.keys(defines).sort();\n      var injectKeys = Object.keys(inject).sort();\n      var defineHashes = [];\n      var injectHashes = [];\n\n      var _iterator = _createForOfIteratorHelper(defineKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          defineHashes.push(this._getHash(key));\n          defineHashes.push(this._getHash(defines[key]));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(injectKeys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _key = _step2.value;\n          injectHashes.push(this._getHash(_key));\n          injectHashes.push(this._getHash(inject[_key]));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var hash = \"\".concat(vsHash, \"/\").concat(fsHash, \"D\").concat(defineHashes.join('/'), \"M\").concat(moduleHashes.join('/'), \"I\").concat(injectHashes.join('/'), \"V\").concat(varyingHashes.join('/'), \"H\").concat(this.stateHash, \"B\").concat(bufferMode).concat(transpileToGLSL100 ? 'T' : '');\n\n      if (!this._programCache[hash]) {\n        var assembled = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          hookFunctions: this._hookFunctions,\n          transpileToGLSL100: transpileToGLSL100\n        });\n        this._programCache[hash] = new Program(this.gl, {\n          hash: hash,\n          vs: assembled.vs,\n          fs: assembled.fs,\n          varyings: varyings,\n          bufferMode: bufferMode\n        });\n\n        this._getUniforms[hash] = assembled.getUniforms || function (x) {};\n\n        this._useCounts[hash] = 0;\n      }\n\n      this._useCounts[hash]++;\n      return this._programCache[hash];\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms(program) {\n      return this._getUniforms[program.hash] || null;\n    }\n  }, {\n    key: \"release\",\n    value: function release(program) {\n      var hash = program.hash;\n      this._useCounts[hash]--;\n\n      if (this._useCounts[hash] === 0) {\n        this._programCache[hash].delete();\n\n        delete this._programCache[hash];\n        delete this._getUniforms[hash];\n        delete this._useCounts[hash];\n      }\n    }\n  }, {\n    key: \"_getHash\",\n    value: function _getHash(key) {\n      if (this._hashes[key] === undefined) {\n        this._hashes[key] = this._hashCounter++;\n      }\n\n      return this._hashes[key];\n    }\n  }, {\n    key: \"_getModuleList\",\n    value: function _getModuleList() {\n      var appModules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var modules = new Array(this._defaultModules.length + appModules.length);\n      var seen = {};\n      var count = 0;\n\n      for (var i = 0, len = this._defaultModules.length; i < len; ++i) {\n        var module = this._defaultModules[i];\n        var name = module.name;\n        modules[count++] = module;\n        seen[name] = true;\n      }\n\n      for (var _i = 0, _len = appModules.length; _i < _len; ++_i) {\n        var _module = appModules[_i];\n        var _name = _module.name;\n\n        if (!seen[_name]) {\n          modules[count++] = _module;\n          seen[_name] = true;\n        }\n      }\n\n      modules.length = count;\n      return modules;\n    }\n  }], [{\n    key: \"getDefaultProgramManager\",\n    value: function getDefaultProgramManager(gl) {\n      gl.luma = gl.luma || {};\n      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n      return gl.luma.defaultProgramManager;\n    }\n  }]);\n\n  return ProgramManager;\n}();\n\nexport { ProgramManager as default };","map":{"version":3,"mappings":"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","names":["assembleShaders","Program","ProgramManager","constructor","gl","_programCache","_getUniforms","_registeredModules","_hookFunctions","_defaultModules","_hashes","_hashCounter","stateHash","_useCounts","addDefaultModule","module","find","m","name","push","removeDefaultModule","moduleName","filter","addShaderHook","hook","opts","Object","assign","get","props","vs","fs","defines","inject","varyings","bufferMode","transpileToGLSL100","modules","_getModuleList","vsHash","_getHash","fsHash","moduleHashes","map","sort","varyingHashes","v","defineKeys","keys","injectKeys","defineHashes","injectHashes","key","hash","join","assembled","hookFunctions","getUniforms","x","program","release","delete","undefined","appModules","Array","length","seen","count","i","len","luma","defaultProgramManager"],"sources":["../../../src/lib/program-manager.js"],"sourcesContent":["import {assembleShaders} from '@luma.gl/shadertools';\nimport {Program} from '@luma.gl/webgl';\n\nexport default class ProgramManager {\n  static getDefaultProgramManager(gl) {\n    gl.luma = gl.luma || {};\n    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);\n\n    return gl.luma.defaultProgramManager;\n  }\n\n  constructor(gl) {\n    this.gl = gl;\n\n    this._programCache = {};\n    this._getUniforms = {};\n    this._registeredModules = {}; // TODO: Remove? This isn't used anywhere in luma.gl\n    this._hookFunctions = [];\n    this._defaultModules = [];\n\n    this._hashes = {};\n    this._hashCounter = 0;\n    this.stateHash = 0; // Used change hashing if hooks are modified\n    this._useCounts = {};\n  }\n\n  addDefaultModule(module) {\n    if (!this._defaultModules.find(m => m.name === module.name)) {\n      this._defaultModules.push(module);\n    }\n\n    this.stateHash++;\n  }\n\n  removeDefaultModule(module) {\n    const moduleName = typeof module === 'string' ? module : module.name;\n    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    this.stateHash++;\n  }\n\n  addShaderHook(hook, opts) {\n    if (opts) {\n      hook = Object.assign(opts, {hook});\n    }\n\n    this._hookFunctions.push(hook);\n\n    this.stateHash++;\n  }\n\n  get(props = {}) {\n    const {\n      vs = '',\n      fs = '',\n      defines = {},\n      inject = {},\n      varyings = [],\n      bufferMode = 0x8c8d,\n      transpileToGLSL100 = false\n    } = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS\n\n    const modules = this._getModuleList(props.modules); // Combine with default modules\n\n    const vsHash = this._getHash(vs);\n    const fsHash = this._getHash(fs);\n    const moduleHashes = modules.map(m => this._getHash(m.name)).sort();\n    const varyingHashes = varyings.map(v => this._getHash(v));\n\n    const defineKeys = Object.keys(defines).sort();\n    const injectKeys = Object.keys(inject).sort();\n    const defineHashes = [];\n    const injectHashes = [];\n\n    for (const key of defineKeys) {\n      defineHashes.push(this._getHash(key));\n      defineHashes.push(this._getHash(defines[key]));\n    }\n\n    for (const key of injectKeys) {\n      injectHashes.push(this._getHash(key));\n      injectHashes.push(this._getHash(inject[key]));\n    }\n\n    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(\n      '/'\n    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}${\n      transpileToGLSL100 ? 'T' : ''\n    }`;\n\n    if (!this._programCache[hash]) {\n      const assembled = assembleShaders(this.gl, {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        hookFunctions: this._hookFunctions,\n        transpileToGLSL100\n      });\n\n      this._programCache[hash] = new Program(this.gl, {\n        hash,\n        vs: assembled.vs,\n        fs: assembled.fs,\n        varyings,\n        bufferMode\n      });\n\n      this._getUniforms[hash] = assembled.getUniforms || (x => {});\n      this._useCounts[hash] = 0;\n    }\n\n    this._useCounts[hash]++;\n\n    return this._programCache[hash];\n  }\n\n  getUniforms(program) {\n    return this._getUniforms[program.hash] || null;\n  }\n\n  release(program) {\n    const hash = program.hash;\n    this._useCounts[hash]--;\n\n    if (this._useCounts[hash] === 0) {\n      this._programCache[hash].delete();\n      delete this._programCache[hash];\n      delete this._getUniforms[hash];\n      delete this._useCounts[hash];\n    }\n  }\n\n  _getHash(key) {\n    if (this._hashes[key] === undefined) {\n      this._hashes[key] = this._hashCounter++;\n    }\n\n    return this._hashes[key];\n  }\n\n  // Dedup and combine with default modules\n  _getModuleList(appModules = []) {\n    const modules = new Array(this._defaultModules.length + appModules.length);\n    const seen = {};\n    let count = 0;\n\n    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n      const module = this._defaultModules[i];\n      const name = module.name;\n      modules[count++] = module;\n      seen[name] = true;\n    }\n\n    for (let i = 0, len = appModules.length; i < len; ++i) {\n      const module = appModules[i];\n      const name = module.name;\n      if (!seen[name]) {\n        modules[count++] = module;\n        seen[name] = true;\n      }\n    }\n\n    modules.length = count;\n\n    return modules;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}