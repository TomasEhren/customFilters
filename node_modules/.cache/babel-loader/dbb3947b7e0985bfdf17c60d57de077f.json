{"ast":null,"code":"import _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport { createIterable, getAccessorFromBuffer } from '../../utils/iterable-utils';\nimport { fillArray } from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport { normalizeTransitionSettings } from './attribute-transition-utils';\n\nvar Attribute = /*#__PURE__*/function (_DataColumn) {\n  _inherits(Attribute, _DataColumn);\n\n  var _super = _createSuper(Attribute);\n\n  function Attribute(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Attribute);\n\n    _this = _super.call(this, gl, opts);\n    var _opts$transition = opts.transition,\n        transition = _opts$transition === void 0 ? false : _opts$transition,\n        _opts$noAlloc = opts.noAlloc,\n        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,\n        _opts$update = opts.update,\n        update = _opts$update === void 0 ? null : _opts$update,\n        _opts$accessor = opts.accessor,\n        accessor = _opts$accessor === void 0 ? null : _opts$accessor,\n        _opts$transform = opts.transform,\n        transform = _opts$transform === void 0 ? null : _opts$transform,\n        _opts$startIndices = opts.startIndices,\n        startIndices = _opts$startIndices === void 0 ? null : _opts$startIndices;\n    Object.assign(_this.settings, {\n      transition: transition,\n      noAlloc: noAlloc,\n      update: update || accessor && _this._autoUpdater,\n      accessor: accessor,\n      transform: transform\n    });\n    Object.assign(_this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices: startIndices\n    });\n    Object.seal(_this.settings);\n    Object.seal(_this.state);\n\n    _this._validateAttributeUpdaters();\n\n    return _this;\n  }\n\n  _createClass(Attribute, [{\n    key: \"startIndices\",\n    get: function get() {\n      return this.state.startIndices;\n    },\n    set: function set(layout) {\n      this.state.startIndices = layout;\n    }\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.state.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearChangedFlag = _ref.clearChangedFlags,\n          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;\n\n      var needsRedraw = this.state.needsRedraw;\n      this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.settings.accessor;\n      return [this.id].concat(typeof accessor !== 'function' && accessor || []);\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return Boolean(this.settings.transition);\n    }\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      if (!opts || !this.supportsTransition()) {\n        return null;\n      }\n\n      var accessor = this.settings.accessor;\n      var layerSettings = this.settings.transition;\n      var userSettings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor];\n      return normalizeTransitionSettings(userSettings, layerSettings);\n    }\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      var dataRange = arguments.length > 1 ? arguments[1] : undefined;\n      this.state.needsUpdate = this.state.needsUpdate || reason;\n      this.setNeedsRedraw(reason);\n\n      if (dataRange) {\n        var _dataRange$startRow = dataRange.startRow,\n            startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow,\n            _dataRange$endRow = dataRange.endRow,\n            endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;\n        this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n      } else {\n        this.state.updateRanges = range.FULL;\n      }\n    }\n  }, {\n    key: \"clearNeedsUpdate\",\n    value: function clearNeedsUpdate() {\n      this.state.needsUpdate = false;\n      this.state.updateRanges = range.EMPTY;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.state.needsRedraw = this.state.needsRedraw || reason;\n    }\n  }, {\n    key: \"update\",\n    value: function update(opts) {\n      this.setData(opts);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.state,\n          settings = this.settings;\n\n      if (settings.noAlloc) {\n        return false;\n      }\n\n      if (settings.update) {\n        _get(_getPrototypeOf(Attribute.prototype), \"allocate\", this).call(this, {\n          numInstances: numInstances,\n          copy: state.updateRanges !== range.FULL\n        });\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref2) {\n      var numInstances = _ref2.numInstances,\n          data = _ref2.data,\n          props = _ref2.props,\n          context = _ref2.context;\n\n      if (!this.needsUpdate()) {\n        return false;\n      }\n\n      var updateRanges = this.state.updateRanges,\n          _this$settings = this.settings,\n          update = _this$settings.update,\n          noAlloc = _this$settings.noAlloc;\n      var updated = true;\n\n      if (update) {\n        var _iterator = _createForOfIteratorHelper(updateRanges),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                _startRow = _step$value[0],\n                _endRow = _step$value[1];\n\n            update.call(context, this, {\n              data: data,\n              startRow: _startRow,\n              endRow: _endRow,\n              props: props,\n              numInstances: numInstances\n            });\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {\n          this.setData({\n            value: this.value,\n            constant: this.constant\n          });\n          this.constant = false;\n        } else {\n          var _iterator2 = _createForOfIteratorHelper(updateRanges),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                  startRow = _step2$value[0],\n                  endRow = _step2$value[1];\n\n              var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n              var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;\n\n              _get(_getPrototypeOf(Attribute.prototype), \"updateSubBuffer\", this).call(this, {\n                startOffset: startOffset,\n                endOffset: endOffset\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n\n      this.clearNeedsUpdate();\n      this.setNeedsRedraw();\n      return updated;\n    }\n  }, {\n    key: \"setConstantValue\",\n    value: function setConstantValue(value) {\n      if (value === undefined || typeof value === 'function') {\n        return false;\n      }\n\n      var hasChanged = this.setData({\n        constant: true,\n        value: value\n      });\n\n      if (hasChanged) {\n        this.setNeedsRedraw();\n      }\n\n      this.clearNeedsUpdate();\n      return true;\n    }\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer) {\n      var state = this.state;\n\n      if (!buffer) {\n        state.lastExternalBuffer = null;\n        return false;\n      }\n\n      this.clearNeedsUpdate();\n\n      if (state.lastExternalBuffer === buffer) {\n        return true;\n      }\n\n      state.lastExternalBuffer = buffer;\n      this.setNeedsRedraw();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"setBinaryValue\",\n    value: function setBinaryValue(buffer) {\n      var startIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var state = this.state,\n          settings = this.settings;\n\n      if (!buffer) {\n        state.binaryValue = null;\n        state.binaryAccessor = null;\n        return false;\n      }\n\n      if (settings.noAlloc) {\n        return false;\n      }\n\n      if (state.binaryValue === buffer) {\n        this.clearNeedsUpdate();\n        return true;\n      }\n\n      state.binaryValue = buffer;\n      this.setNeedsRedraw();\n\n      if (ArrayBuffer.isView(buffer)) {\n        buffer = {\n          value: buffer\n        };\n      }\n\n      var needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n      if (needsUpdate) {\n        assert(ArrayBuffer.isView(buffer.value), \"invalid \".concat(settings.accessor));\n        var needsNormalize = buffer.size && buffer.size !== this.size;\n        state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n          size: buffer.size || this.size,\n          stride: buffer.stride,\n          offset: buffer.offset,\n          startIndices: startIndices,\n          nested: needsNormalize\n        });\n        return false;\n      }\n\n      this.clearNeedsUpdate();\n      this.setData(buffer);\n      return true;\n    }\n  }, {\n    key: \"getVertexOffset\",\n    value: function getVertexOffset(row) {\n      var startIndices = this.startIndices;\n      var vertexIndex = startIndices ? startIndices[row] : row;\n      return vertexIndex * this.size;\n    }\n  }, {\n    key: \"getShaderAttributes\",\n    value: function getShaderAttributes() {\n      var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty({}, this.id, null);\n\n      var shaderAttributes = {};\n\n      for (var shaderAttributeName in shaderAttributeDefs) {\n        Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute.prototype), \"getShaderAttributes\", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));\n      }\n\n      return shaderAttributes;\n    }\n  }, {\n    key: \"_autoUpdater\",\n    value: function _autoUpdater(attribute, _ref4) {\n      var data = _ref4.data,\n          startRow = _ref4.startRow,\n          endRow = _ref4.endRow,\n          props = _ref4.props,\n          numInstances = _ref4.numInstances;\n\n      if (attribute.constant) {\n        return;\n      }\n\n      var settings = attribute.settings,\n          state = attribute.state,\n          value = attribute.value,\n          size = attribute.size,\n          startIndices = attribute.startIndices;\n      var accessor = settings.accessor,\n          transform = settings.transform;\n      var accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = attribute.getVertexOffset(startRow);\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator3 = _createForOfIteratorHelper(iterable),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var object = _step3.value;\n          objectInfo.index++;\n          var objectValue = accessorFunc(object, objectInfo);\n\n          if (transform) {\n            objectValue = transform.call(this, objectValue);\n          }\n\n          if (startIndices) {\n            var numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];\n\n            if (objectValue && Array.isArray(objectValue[0])) {\n              var startIndex = i;\n\n              var _iterator4 = _createForOfIteratorHelper(objectValue),\n                  _step4;\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var item = _step4.value;\n\n                  attribute._normalizeValue(item, value, startIndex);\n\n                  startIndex += size;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            } else if (objectValue && objectValue.length > size) {\n              value.set(objectValue, i);\n            } else {\n              attribute._normalizeValue(objectValue, objectInfo.target, 0);\n\n              fillArray({\n                target: value,\n                source: objectInfo.target,\n                start: i,\n                count: numVertices\n              });\n            }\n\n            i += numVertices * size;\n          } else {\n            attribute._normalizeValue(objectValue, value, i);\n\n            i += size;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var settings = this.settings;\n      var hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n      var limit = Math.min(4, this.size);\n\n      if (value && value.length >= limit) {\n        var valid = true;\n\n        switch (limit) {\n          case 4:\n            valid = valid && Number.isFinite(value[3]);\n\n          case 3:\n            valid = valid && Number.isFinite(value[2]);\n\n          case 2:\n            valid = valid && Number.isFinite(value[1]);\n\n          case 1:\n            valid = valid && Number.isFinite(value[0]);\n            break;\n\n          default:\n            valid = false;\n        }\n\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }]);\n\n  return Attribute;\n}(DataColumn);\n\nexport { Attribute as default };","map":{"version":3,"mappings":"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","names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","constructor","gl","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","assign","settings","_autoUpdater","state","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","seal","_validateAttributeUpdaters","layout","clearChangedFlags","getUpdateTriggers","id","concat","supportsTransition","Boolean","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","setData","allocate","numInstances","copy","updateBuffer","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","startOffset","Number","isFinite","getVertexOffset","endOffset","length","size","_checkAttributeArray","setConstantValue","undefined","hasChanged","setExternalBuffer","setBinaryValue","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","shaderAttributeName","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"sources":["../../../../src/lib/attribute/attribute.js"],"sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    if (!opts || !this.supportsTransition()) {\n      return null;\n    }\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n        // Setting attribute.constant in updater is a legacy approach that interferes with allocation in the next cycle\n        // Respect it here but reset after use\n        this.constant = false;\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n            ? this.value.length\n            : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"]},"metadata":{},"sourceType":"module"}