{"ast":null,"code":"import { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nconst defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {\n      vs,\n      fs,\n      modules: [picking]\n    };\n  }\n\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        update: this.calculateInstancePositions\n      },\n      instanceCounts: {\n        size: 4,\n        noAlloc: true\n      }\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(_ref2) {\n    let {\n      oldProps,\n      props,\n      changeFlags\n    } = _ref2;\n    super.updateState({\n      oldProps,\n      props,\n      changeFlags\n    });\n    const attributeManager = this.getAttributeManager();\n\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw(_ref3) {\n    let {\n      uniforms\n    } = _ref3;\n    const {\n      parameters,\n      maxTexture\n    } = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {\n      model\n    } = this.state;\n    model.setUniforms(uniforms).setUniforms({\n      minColor,\n      maxColor,\n      maxTexture,\n      colorDomain\n    }).draw({\n      parameters: {\n        depthTest: false,\n        depthMask: false,\n        ...parameters\n      }\n    });\n  }\n\n  calculateInstancePositions(attribute, _ref4) {\n    let {\n      numInstances\n    } = _ref4;\n    const {\n      width,\n      height\n    } = this.context.viewport;\n    const {\n      cellSizePixels\n    } = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n    const {\n      value,\n      size\n    } = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n      value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  _getModel(gl) {\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {\n      minColor,\n      maxColor,\n      colorDomain,\n      colorRange\n    } = this.props;\n\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n\n    if (colorDomain || colorRange) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {\n      model\n    } = this.state;\n\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({\n        shouldUseMinMax: this._shouldUseMinMax()\n      });\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({\n        colorRange: colorRangeToFlatArray(props.colorRange)\n      });\n    }\n\n    if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n      const {\n        width,\n        height\n      } = this.context.viewport;\n      const {\n        cellSizePixels,\n        cellMarginPixels\n      } = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n      const cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n      model.setUniforms({\n        cellScale\n      });\n    }\n  }\n\n}\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Model","Geometry","FEATURES","hasFeatures","Layer","log","picking","defaultColorRange","colorRangeToFlatArray","vs","fs","DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","ScreenGridCellLayer","isSupported","gl","TEXTURE_FLOAT","getShaders","modules","initializeState","context","attributeManager","getAttributeManager","addInstanced","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","setState","model","_getModel","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","props","numInstances","invalidateAll","invalidate","_updateUniforms","draw","uniforms","parameters","maxTexture","minColor","maxColor","state","setUniforms","depthTest","depthMask","attribute","width","height","viewport","numCol","Math","ceil","i","x","y","floor","id","geometry","drawMode","attributes","positions","Float32Array","isInstanced","_shouldUseMinMax","deprecated","some","key","shouldUseMinMax","viewportChanged","margin","cellScale","layerName"],"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}