{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Model, Geometry, FEATURES, hasFeatures } from '@luma.gl/core';\nimport { Layer, log, picking } from '@deck.gl/core';\nimport { defaultColorRange, colorRangeToFlatArray } from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nvar DEFAULT_MINCOLOR = [0, 0, 0, 0];\nvar DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nvar COLOR_PROPS = [\"minColor\", \"maxColor\", \"colorRange\", \"colorDomain\"];\nvar defaultProps = {\n  cellSizePixels: {\n    value: 100,\n    min: 1\n  },\n  cellMarginPixels: {\n    value: 2,\n    min: 0,\n    max: 5\n  },\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nvar ScreenGridCellLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(ScreenGridCellLayer, _Layer);\n\n  var _super = _createSuper(ScreenGridCellLayer);\n\n  function ScreenGridCellLayer() {\n    _classCallCheck(this, ScreenGridCellLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ScreenGridCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [picking]\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          update: this.calculateInstancePositions\n        },\n        instanceCounts: {\n          size: 4,\n          noAlloc: true\n        }\n      });\n      this.setState({\n        model: this._getModel(gl)\n      });\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(ScreenGridCellLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.numInstances !== oldProps.numInstances) {\n        attributeManager.invalidateAll();\n      } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n        attributeManager.invalidate('instancePositions');\n      }\n\n      this._updateUniforms(oldProps, props, changeFlags);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var _this$props = this.props,\n          parameters = _this$props.parameters,\n          maxTexture = _this$props.maxTexture;\n      var minColor = this.props.minColor || DEFAULT_MINCOLOR;\n      var maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n      var colorDomain = this.props.colorDomain || [1, 0];\n      var model = this.state.model;\n      model.setUniforms(uniforms).setUniforms({\n        minColor: minColor,\n        maxColor: maxColor,\n        maxTexture: maxTexture,\n        colorDomain: colorDomain\n      }).draw({\n        parameters: _objectSpread({\n          depthTest: false,\n          depthMask: false\n        }, parameters)\n      });\n    }\n  }, {\n    key: \"calculateInstancePositions\",\n    value: function calculateInstancePositions(attribute, _ref4) {\n      var numInstances = _ref4.numInstances;\n      var _this$context$viewpor = this.context.viewport,\n          width = _this$context$viewpor.width,\n          height = _this$context$viewpor.height;\n      var cellSizePixels = this.props.cellSizePixels;\n      var numCol = Math.ceil(width / cellSizePixels);\n      var value = attribute.value,\n          size = attribute.size;\n\n      for (var i = 0; i < numInstances; i++) {\n        var x = i % numCol;\n        var y = Math.floor(i / numCol);\n        value[i * size + 0] = x * cellSizePixels / width * 2 - 1;\n        value[i * size + 1] = 1 - y * cellSizePixels / height * 2;\n        value[i * size + 2] = 0;\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, _objectSpread(_objectSpread({}, this.getShaders()), {}, {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_shouldUseMinMax\",\n    value: function _shouldUseMinMax() {\n      var _this$props2 = this.props,\n          minColor = _this$props2.minColor,\n          maxColor = _this$props2.maxColor,\n          colorDomain = _this$props2.colorDomain,\n          colorRange = _this$props2.colorRange;\n\n      if (minColor || maxColor) {\n        log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n        return true;\n      }\n\n      if (colorDomain || colorRange) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_updateUniforms\",\n    value: function _updateUniforms(oldProps, props, changeFlags) {\n      var model = this.state.model;\n\n      if (COLOR_PROPS.some(function (key) {\n        return oldProps[key] !== props[key];\n      })) {\n        model.setUniforms({\n          shouldUseMinMax: this._shouldUseMinMax()\n        });\n      }\n\n      if (oldProps.colorRange !== props.colorRange) {\n        model.setUniforms({\n          colorRange: colorRangeToFlatArray(props.colorRange)\n        });\n      }\n\n      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {\n        var _this$context$viewpor2 = this.context.viewport,\n            width = _this$context$viewpor2.width,\n            height = _this$context$viewpor2.height;\n        var _this$props3 = this.props,\n            cellSizePixels = _this$props3.cellSizePixels,\n            cellMarginPixels = _this$props3.cellMarginPixels;\n        var margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n        var cellScale = new Float32Array([(cellSizePixels - margin) / width * 2, -(cellSizePixels - margin) / height * 2, 1]);\n        model.setUniforms({\n          cellScale: cellScale\n        });\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n    }\n  }]);\n\n  return ScreenGridCellLayer;\n}(Layer);\n\nexport { ScreenGridCellLayer as default };\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Model","Geometry","FEATURES","hasFeatures","Layer","log","picking","defaultColorRange","colorRangeToFlatArray","vs","fs","DEFAULT_MINCOLOR","DEFAULT_MAXCOLOR","COLOR_PROPS","defaultProps","cellSizePixels","value","min","cellMarginPixels","max","colorDomain","colorRange","ScreenGridCellLayer","getShaders","modules","initializeState","gl","context","attributeManager","getAttributeManager","addInstanced","instancePositions","size","update","calculateInstancePositions","instanceCounts","noAlloc","setState","model","_getModel","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","props","numInstances","invalidateAll","invalidate","_updateUniforms","draw","uniforms","parameters","maxTexture","minColor","maxColor","state","setUniforms","depthTest","depthMask","attribute","viewport","width","height","numCol","Math","ceil","i","x","y","floor","id","geometry","drawMode","attributes","positions","Float32Array","isInstanced","_shouldUseMinMax","deprecated","some","key","shouldUseMinMax","viewportChanged","margin","cellScale","TEXTURE_FLOAT","layerName"],"sources":["../../../src/screen-grid-layer/screen-grid-cell-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, FEATURES, hasFeatures} from '@luma.gl/core';\nimport {Layer, log, picking} from '@deck.gl/core';\nimport {defaultColorRange, colorRangeToFlatArray} from '../utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\n\nconst DEFAULT_MINCOLOR = [0, 0, 0, 0];\nconst DEFAULT_MAXCOLOR = [0, 255, 0, 255];\nconst COLOR_PROPS = [`minColor`, `maxColor`, `colorRange`, `colorDomain`];\n\nconst defaultProps = {\n  cellSizePixels: {value: 100, min: 1},\n  cellMarginPixels: {value: 2, min: 0, max: 5},\n\n  colorDomain: null,\n  colorRange: defaultColorRange\n};\n\nexport default class ScreenGridCellLayer extends Layer {\n  static isSupported(gl) {\n    return hasFeatures(gl, [FEATURES.TEXTURE_FLOAT]);\n  }\n\n  getShaders() {\n    return {vs, fs, modules: [picking]};\n  }\n\n  initializeState() {\n    const {gl} = this.context;\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {size: 3, update: this.calculateInstancePositions},\n      instanceCounts: {size: 4, noAlloc: true}\n    });\n    this.setState({\n      model: this._getModel(gl)\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    // 'instanceCounts' buffer contetns change on viewport change.\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({oldProps, props, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    if (props.numInstances !== oldProps.numInstances) {\n      attributeManager.invalidateAll();\n    } else if (oldProps.cellSizePixels !== props.cellSizePixels) {\n      attributeManager.invalidate('instancePositions');\n    }\n\n    this._updateUniforms(oldProps, props, changeFlags);\n  }\n\n  draw({uniforms}) {\n    const {parameters, maxTexture} = this.props;\n    const minColor = this.props.minColor || DEFAULT_MINCOLOR;\n    const maxColor = this.props.maxColor || DEFAULT_MAXCOLOR;\n\n    // If colorDomain not specified we use default domain [1, maxCount]\n    // maxCount value will be sampled form maxTexture in vertex shader.\n    const colorDomain = this.props.colorDomain || [1, 0];\n    const {model} = this.state;\n    model\n      .setUniforms(uniforms)\n      .setUniforms({\n        minColor,\n        maxColor,\n        maxTexture,\n        colorDomain\n      })\n      .draw({\n        parameters: {\n          depthTest: false,\n          depthMask: false,\n          ...parameters\n        }\n      });\n  }\n\n  calculateInstancePositions(attribute, {numInstances}) {\n    const {width, height} = this.context.viewport;\n    const {cellSizePixels} = this.props;\n    const numCol = Math.ceil(width / cellSizePixels);\n\n    const {value, size} = attribute;\n\n    for (let i = 0; i < numInstances; i++) {\n      const x = i % numCol;\n      const y = Math.floor(i / numCol);\n      value[i * size + 0] = ((x * cellSizePixels) / width) * 2 - 1;\n      value[i * size + 1] = 1 - ((y * cellSizePixels) / height) * 2;\n      value[i * size + 2] = 0;\n    }\n  }\n\n  // Private Methods\n\n  _getModel(gl) {\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          positions: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _shouldUseMinMax() {\n    const {minColor, maxColor, colorDomain, colorRange} = this.props;\n    if (minColor || maxColor) {\n      log.deprecated('ScreenGridLayer props: minColor and maxColor', 'colorRange, colorDomain')();\n      return true;\n    }\n    // minColor and maxColor not supplied, check if colorRange or colorDomain supplied.\n    // NOTE: colorDomain and colorRange are experimental features, use them only when supplied.\n    if (colorDomain || colorRange) {\n      return false;\n    }\n    // None specified, use default minColor and maxColor\n    return true;\n  }\n\n  _updateUniforms(oldProps, props, changeFlags) {\n    const {model} = this.state;\n    if (COLOR_PROPS.some(key => oldProps[key] !== props[key])) {\n      model.setUniforms({shouldUseMinMax: this._shouldUseMinMax()});\n    }\n\n    if (oldProps.colorRange !== props.colorRange) {\n      model.setUniforms({colorRange: colorRangeToFlatArray(props.colorRange)});\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels, cellMarginPixels} = this.props;\n      const margin = cellSizePixels > cellMarginPixels ? cellMarginPixels : 0;\n\n      const cellScale = new Float32Array([\n        ((cellSizePixels - margin) / width) * 2,\n        (-(cellSizePixels - margin) / height) * 2,\n        1\n      ]);\n      model.setUniforms({cellScale});\n    }\n  }\n}\n\nScreenGridCellLayer.layerName = 'ScreenGridCellLayer';\nScreenGridCellLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}