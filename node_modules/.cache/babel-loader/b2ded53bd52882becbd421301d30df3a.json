{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils } from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from '../constants';\nimport { fromCartographicToRadians, toCartographicFromRadians } from '../type-utils';\nimport _scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport _localFrameToFixedFrame from './helpers/ellipsoid-transform';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\nvar scratchK = new Vector3();\nvar scratchPosition = new Vector3();\nvar scratchHeight = new Vector3();\nvar scratchCartesian = new Vector3();\nvar wgs84;\n\nvar Ellipsoid = /*#__PURE__*/function () {\n  function Ellipsoid() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;\n\n    _classCallCheck(this, Ellipsoid);\n\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n    this.radii = new Vector3(x, y, z);\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);\n    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));\n    this.minimumRadius = Math.min(x, y, z);\n    this.maximumRadius = Math.max(x, y, z);\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  _createClass(Ellipsoid, [{\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right && this.radii.equals(right.radii));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.radii.toString();\n    }\n  }, {\n    key: \"cartographicToCartesian\",\n    value: function cartographicToCartesian(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var normal = scratchNormal;\n      var k = scratchK;\n\n      var _cartographic = _slicedToArray(cartographic, 3),\n          height = _cartographic[2];\n\n      this.geodeticSurfaceNormalCartographic(cartographic, normal);\n      k.copy(this.radiiSquared).scale(normal);\n      var gamma = Math.sqrt(normal.dot(k));\n      k.scale(1 / gamma);\n      normal.scale(height);\n      k.add(normal);\n      return k.to(result);\n    }\n  }, {\n    key: \"cartesianToCartographic\",\n    value: function cartesianToCartographic(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchCartesian.from(cartesian);\n      var point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n      if (!point) {\n        return undefined;\n      }\n\n      var normal = this.geodeticSurfaceNormal(point, scratchNormal);\n      var h = scratchHeight;\n      h.copy(scratchCartesian).subtract(point);\n      var longitude = Math.atan2(normal.y, normal.x);\n      var latitude = Math.asin(normal.z);\n      var height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n      return toCartographicFromRadians([longitude, latitude, height], result);\n    }\n  }, {\n    key: \"eastNorthUpToFixedFrame\",\n    value: function eastNorthUpToFixedFrame(origin) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n      return _localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n    }\n  }, {\n    key: \"localFrameToFixedFrame\",\n    value: function localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {\n      var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Matrix4();\n      return _localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n    }\n  }, {\n    key: \"geocentricSurfaceNormal\",\n    value: function geocentricSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).normalize().to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormalCartographic\",\n    value: function geodeticSurfaceNormalCartographic(cartographic) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      var cartographicVectorRadians = fromCartographicToRadians(cartographic);\n      var longitude = cartographicVectorRadians[0];\n      var latitude = cartographicVectorRadians[1];\n      var cosLatitude = Math.cos(latitude);\n      scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();\n      return scratchVector.to(result);\n    }\n  }, {\n    key: \"geodeticSurfaceNormal\",\n    value: function geodeticSurfaceNormal(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n    }\n  }, {\n    key: \"scaleToGeodeticSurface\",\n    value: function scaleToGeodeticSurface(cartesian, result) {\n      return _scaleToGeodeticSurface(cartesian, this, result);\n    }\n  }, {\n    key: \"scaleToGeocentricSurface\",\n    value: function scaleToGeocentricSurface(cartesian) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      scratchPosition.from(cartesian);\n      var positionX = scratchPosition.x;\n      var positionY = scratchPosition.y;\n      var positionZ = scratchPosition.z;\n      var oneOverRadiiSquared = this.oneOverRadiiSquared;\n      var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);\n      return scratchPosition.multiplyScalar(beta).to(result);\n    }\n  }, {\n    key: \"transformPositionToScaledSpace\",\n    value: function transformPositionToScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n    }\n  }, {\n    key: \"transformPositionFromScaledSpace\",\n    value: function transformPositionFromScaledSpace(position) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      return scratchPosition.from(position).scale(this.radii).to(result);\n    }\n  }, {\n    key: \"getSurfaceNormalIntersectionWithZAxis\",\n    value: function getSurfaceNormalIntersectionWithZAxis(position) {\n      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];\n      assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n      assert(this.radii.z > 0);\n      scratchPosition.from(position);\n      var z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n      if (Math.abs(z) >= this.radii.z - buffer) {\n        return undefined;\n      }\n\n      return scratchPosition.set(0.0, 0.0, z).to(result);\n    }\n  }], [{\n    key: \"WGS84\",\n    get: function get() {\n      wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n      return wgs84;\n    }\n  }]);\n\n  return Ellipsoid;\n}();\n\nexport { Ellipsoid as default };","map":{"version":3,"mappings":"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","names":["Vector3","Matrix4","toRadians","toDegrees","assert","equals","_MathUtils","vec3","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","fromCartographicToRadians","toCartographicFromRadians","scaleToGeodeticSurface","localFrameToFixedFrame","scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","wgs84","Ellipsoid","constructor","x","y","z","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","centerToleranceSquared","EPSILON1","squaredXOverSquaredZ","Object","freeze","right","Boolean","toString","cartographicToCartesian","cartographic","result","normal","k","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesianToCartographic","cartesian","from","point","undefined","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","length","eastNorthUpToFixedFrame","origin","firstAxis","secondAxis","thirdAxis","geocentricSurfaceNormal","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","scaleToGeocentricSurface","positionX","positionY","positionZ","beta","multiplyScalar","transformPositionToScaledSpace","position","transformPositionFromScaledSpace","getSurfaceNormalIntersectionWithZAxis","buffer","EPSILON15","abs"],"sources":["../../../src/ellipsoid/ellipsoid.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n// A quadratic surface defined in Cartesian coordinates by the equation\n// <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n// to represent the shape of planetary bodies.\nexport default class Ellipsoid {\n  // An Ellipsoid instance initialized to the WGS84 standard.\n  static get WGS84() {\n    wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n    return wgs84;\n  }\n\n  // Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  // Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  // Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n  toString() {\n    return this.radii.toString();\n  }\n\n  // Converts the provided cartographic to Cartesian representation.\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  // Converts the provided cartesian to cartographic (lng/lat/z) representation.\n  // The cartesian is undefined at the center of the ellipsoid.\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n  // centered at the provided origin to the provided ellipsoid's fixed reference frame.\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  // Computes the unit vector directed from the center of this ellipsoid toward\n  // the provided Cartesian position.\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at provided position.\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  // Scales the provided Cartesian position along the geodetic surface normal\n  // so that it is on the surface of this ellipsoid.  If the position is\n  // at the center of the ellipsoid, this function returns undefined.\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  // Scales the provided Cartesian position along the geocentric surface normal\n  // so that it is on the surface of this ellipsoid.\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#oneOverRadii`\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#radii`.\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  // Computes a point which is the intersection of the surface normal with the z-axis.\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0.0, result = [0, 0, 0]) {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}