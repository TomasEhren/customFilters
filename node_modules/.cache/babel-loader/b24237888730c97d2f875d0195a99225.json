{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  const {\n    magic,\n    version = 1,\n    byteLength = 12\n  } = tile;\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true);\n  dataView.setUint32(byteOffset + 8, byteLength, true);\n  byteOffset += HEADER_SIZE;\n  return byteOffset;\n}\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true);\n}","map":{"version":3,"mappings":"AACA,SAAQA,MAAR,QAAqB,0BAArB;AAEA,OAAO,SAASC,kBAAT,CAA4BC,IAA5B,EAAkCC,QAAlC,EAA4CC,UAA5C,EAAwD;EAC7D,MAAMC,WAAW,GAAG,EAApB;;EAEA,IAAI,CAACF,QAAL,EAAe;IACb,OAAOC,UAAU,GAAGC,WAApB;EACD;;EAED,MAAM;IAACC,KAAD;IAAQC,OAAO,GAAG,CAAlB;IAAqBC,UAAU,GAAG;EAAlC,IAAwCN,IAA9C;EAEAF,MAAM,CAACS,KAAK,CAACC,OAAND,CAAcH,KAAdG,KAAwBE,MAAM,CAACC,QAAPD,CAAgBJ,OAAhBI,CAAxBF,IAAoDE,MAAM,CAACC,QAAPD,CAAgBH,UAAhBG,CAArD,CAANX;EAEAG,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH;EACAA,QAAQ,CAACU,QAATV,CAAkBC,UAAU,GAAG,CAA/BD,EAAkCG,KAAK,CAAC,CAAD,CAAvCH;EACAA,QAAQ,CAACW,SAATX,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCI,OAAnCJ,EAA4C,IAA5CA;EACAA,QAAQ,CAACW,SAATX,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCK,UAAnCL,EAA+C,IAA/CA;EAEAC,UAAU,IAAIC,WAAdD;EAEA,OAAOA,UAAP;AACD;AAGD,OAAO,SAASW,sBAAT,CAAgCZ,QAAhC,EAA0Ca,mBAA1C,EAA+DR,UAA/D,EAA2E;EAChF,IAAI,CAACL,QAAL,EAAe;IACb;EACD;;EAEDA,QAAQ,CAACW,SAATX,CAAmBa,mBAAmB,GAAG,CAAzCb,EAA4CK,UAA5CL,EAAwD,IAAxDA;AACD","names":["assert","encode3DTileHeader","tile","dataView","byteOffset","HEADER_SIZE","magic","version","byteLength","Array","isArray","Number","isFinite","setUint8","setUint32","encode3DTileByteLength","byteOffsetTileStart"],"sources":["../../../../../src/lib/encoders/helpers/encode-3d-tile-header.ts"],"sourcesContent":["// HELPER ENCODERS\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  const {magic, version = 1, byteLength = 12} = tile;\n\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true); // version\n  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n\n  byteOffset += HEADER_SIZE;\n\n  return byteOffset;\n}\n\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n"]},"metadata":{},"sourceType":"module"}