{"ast":null,"code":"import { isWebGL2 } from '@luma.gl/core';\nexport function getBounds(points) {\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n  return [xMin, yMin, xMax, yMax];\n}\nexport function boundsContain(currentBounds, targetBounds) {\n  if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {\n    return true;\n  }\n\n  return false;\n}\nconst scratchArray = new Float32Array(12);\nexport function packVertices(points) {\n  let dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  let index = 0;\n\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n\n  return scratchArray;\n}\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n\n  if (currentWidth / currentHeight < width / height) {\n    newWidth = width / height * currentHeight;\n  } else {\n    newHeight = height / width * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n  return [xCenter - newWidth / 2, yCenter - newHeight / 2, xCenter + newWidth / 2, yCenter + newHeight / 2];\n}\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\nexport function getTextureParams(_ref) {\n  let {\n    gl,\n    floatTargetSupport\n  } = _ref;\n  return {\n    format: isWebGL2(gl) ? 34836 : 6408,\n    type: floatTargetSupport ? 5126 : 5121\n  };\n}","map":{"version":3,"mappings":"AACA,SAAQA,QAAR,QAAuB,eAAvB;AAEA,OAAO,SAASC,SAAT,CAAmBC,MAAnB,EAA2B;EAEhC,MAAMC,CAAC,GAAGD,MAAM,CAACE,GAAPF,CAAWG,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAjBH,CAAV;EACA,MAAMI,CAAC,GAAGJ,MAAM,CAACE,GAAPF,CAAWG,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAjBH,CAAV;EAEA,MAAMK,IAAI,GAAGC,IAAI,CAACC,GAALD,CAASE,KAATF,CAAe,IAAfA,EAAqBL,CAArBK,CAAb;EACA,MAAMG,IAAI,GAAGH,IAAI,CAACI,GAALJ,CAASE,KAATF,CAAe,IAAfA,EAAqBL,CAArBK,CAAb;EACA,MAAMK,IAAI,GAAGL,IAAI,CAACC,GAALD,CAASE,KAATF,CAAe,IAAfA,EAAqBF,CAArBE,CAAb;EACA,MAAMM,IAAI,GAAGN,IAAI,CAACI,GAALJ,CAASE,KAATF,CAAe,IAAfA,EAAqBF,CAArBE,CAAb;EAEA,OAAO,CAACD,IAAD,EAAOM,IAAP,EAAaF,IAAb,EAAmBG,IAAnB,CAAP;AACD;AAGD,OAAO,SAASC,aAAT,CAAuBC,aAAvB,EAAsCC,YAAtC,EAAoD;EACzD,IACEA,YAAY,CAAC,CAAD,CAAZA,IAAmBD,aAAa,CAAC,CAAD,CAAhCC,IACAA,YAAY,CAAC,CAAD,CAAZA,IAAmBD,aAAa,CAAC,CAAD,CADhCC,IAEAA,YAAY,CAAC,CAAD,CAAZA,IAAmBD,aAAa,CAAC,CAAD,CAFhCC,IAGAA,YAAY,CAAC,CAAD,CAAZA,IAAmBD,aAAa,CAAC,CAAD,CAJlC,EAKE;IACA,OAAO,IAAP;EACD;;EACD,OAAO,KAAP;AACD;AAED,MAAME,YAAY,GAAG,IAAIC,YAAJ,CAAiB,EAAjB,CAArB;AAGA,OAAO,SAASC,YAAT,CAAsBlB,MAAtB,EAA8C;EAAA,IAAhBmB,UAAgB,uEAAH,CAAG;EACnD,IAAIC,KAAK,GAAG,CAAZ;;EACA,KAAK,MAAMC,KAAX,IAAoBrB,MAApB,EAA4B;IAC1B,KAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAApB,EAAgCG,CAAC,EAAjC,EAAqC;MACnCN,YAAY,CAACI,KAAK,EAAN,CAAZJ,GAAwBK,KAAK,CAACC,CAAD,CAALD,IAAY,CAApCL;IACD;EACF;;EACD,OAAOA,YAAP;AACD;AAGD,OAAO,SAASO,kBAAT,CAA4BC,WAA5B,EAAyCC,KAAzC,EAAgDC,MAAhD,EAAwD;EAC7D,MAAM,CAACrB,IAAD,EAAOM,IAAP,EAAaF,IAAb,EAAmBG,IAAnB,IAA2BY,WAAjC;EAEA,MAAMG,YAAY,GAAGlB,IAAI,GAAGJ,IAA5B;EACA,MAAMuB,aAAa,GAAGhB,IAAI,GAAGD,IAA7B;EAEA,IAAIkB,QAAQ,GAAGF,YAAf;EACA,IAAIG,SAAS,GAAGF,aAAhB;;EACA,IAAID,YAAY,GAAGC,aAAfD,GAA+BF,KAAK,GAAGC,MAA3C,EAAmD;IAEjDG,QAAQ,GAAIJ,KAAK,GAAGC,MAARD,GAAkBG,aAA9BC;EAFF,OAGO;IACLC,SAAS,GAAIJ,MAAM,GAAGD,KAATC,GAAkBC,YAA/BG;EACD;;EAED,IAAID,QAAQ,GAAGJ,KAAf,EAAsB;IACpBI,QAAQ,GAAGJ,KAAXI;IACAC,SAAS,GAAGJ,MAAZI;EACD;;EAED,MAAMC,OAAO,GAAG,CAACtB,IAAI,GAAGJ,IAAR,IAAgB,CAAhC;EACA,MAAM2B,OAAO,GAAG,CAACpB,IAAI,GAAGD,IAAR,IAAgB,CAAhC;EAEA,OAAO,CACLoB,OAAO,GAAGF,QAAQ,GAAG,CADhB,EAELG,OAAO,GAAGF,SAAS,GAAG,CAFjB,EAGLC,OAAO,GAAGF,QAAQ,GAAG,CAHhB,EAILG,OAAO,GAAGF,SAAS,GAAG,CAJjB,CAAP;AAMD;AAGD,OAAO,SAASG,qBAAT,CAA+BZ,KAA/B,EAAsCa,MAAtC,EAA8C;EACnD,MAAM,CAAC7B,IAAD,EAAOM,IAAP,EAAaF,IAAb,EAAmBG,IAAnB,IAA2BsB,MAAjC;EACA,OAAO,CAAC,CAACb,KAAK,CAAC,CAAD,CAALA,GAAWhB,IAAZ,KAAqBI,IAAI,GAAGJ,IAA5B,CAAD,EAAoC,CAACgB,KAAK,CAAC,CAAD,CAALA,GAAWV,IAAZ,KAAqBC,IAAI,GAAGD,IAA5B,CAApC,CAAP;AACD;AAGD,OAAO,SAASwB,gBAAT,OAAoD;EAAA,IAA1B;IAACC,EAAD;IAAKC;EAAL,CAA0B;EACzD,OAAO;IAELC,MAAM,EAAExC,QAAQ,CAACsC,EAAD,CAARtC,eAFH;IAGLyC,IAAI,EAAEF,kBAAkB;EAHnB,CAAP;AAKD","names":["isWebGL2","getBounds","points","x","map","p","y","xMin","Math","min","apply","xMax","max","yMin","yMax","boundsContain","currentBounds","targetBounds","scratchArray","Float32Array","packVertices","dimensions","index","point","i","scaleToAspectRatio","boundingBox","width","height","currentWidth","currentHeight","newWidth","newHeight","xCenter","yCenter","getTextureCoordinates","bounds","getTextureParams","gl","floatTargetSupport","format","type"],"sources":["../../../src/heatmap-layer/heatmap-layer-utils.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2} from '@luma.gl/core';\n\nexport function getBounds(points) {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds, targetBounds) {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points, dimensions = 2) {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(boundingBox, width, height) {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point, bounds) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n\n// Returns format and type for creating texture objects\nexport function getTextureParams({gl, floatTargetSupport}) {\n  return {\n    // format:  should be RGBA32F on WebGL2 (float textures), RGBA in WebGL1 for float or non float textures\n    format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n    type: floatTargetSupport ? GL.FLOAT : GL.UNSIGNED_BYTE\n  };\n}\n"]},"metadata":{},"sourceType":"module"}