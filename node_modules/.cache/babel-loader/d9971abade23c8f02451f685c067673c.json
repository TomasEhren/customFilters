{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDeckColor = toDeckColor;\nexports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;\nexports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;\nexports.distance2d = distance2d;\nexports.mix = mix;\nexports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;\nexports.insertBefore = insertBefore;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _pointToLineDistance = _interopRequireDefault(require(\"@turf/point-to-line-distance\"));\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _viewportMercatorProject = _interopRequireDefault(require(\"viewport-mercator-project\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toDeckColor(color) {\n  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];\n\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n} //\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\n\n\nfunction recursivelyTraverseNestedArrays(array, prefix, fn) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n\n  return false;\n}\n\nfunction generatePointsParallelToLinePoints(p1, p2, groundCoords) {\n  var lineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  var pt = (0, _helpers.point)(groundCoords);\n  var ddistance = (0, _pointToLineDistance[\"default\"])(pt, lineString);\n  var lineBearing = (0, _bearing[\"default\"])(p1, p2); // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n\n  var isPointToLeftOfLine = (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string\n\n  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n\n  var p3 = (0, _destination[\"default\"])(p2, ddistance, orthogonalBearing);\n  var p4 = (0, _destination[\"default\"])(p1, ddistance, orthogonalBearing); //@ts-ignore\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nfunction distance2d(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction mix(a, b, ratio) {\n  return b * ratio + a * (1 - ratio);\n}\n\nfunction nearestPointOnProjectedLine(line, inPoint, viewport) {\n  var wmViewport = new _viewportMercatorProject[\"default\"](viewport); // Project the line to viewport, then find the nearest point\n\n  var coordinates = line.geometry.coordinates;\n  var projectedCoords = coordinates.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        x = _ref2[0],\n        y = _ref2[1],\n        _ref2$ = _ref2[2],\n        z = _ref2$ === void 0 ? 0 : _ref2$;\n\n    return wmViewport.project([x, y, z]);\n  }); //@ts-ignore\n\n  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),\n      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),\n      x = _wmViewport$project2[0],\n      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n\n  var minDistance = Infinity;\n  var minPointInfo = {};\n  projectedCoords.forEach(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x2 = _ref4[0],\n        y2 = _ref4[1];\n\n    if (index === 0) {\n      return;\n    }\n\n    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),\n        x1 = _projectedCoords[0],\n        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n\n\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n\n    var div = A * A + B * B;\n    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index: index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  }); //@ts-ignore\n\n  var _minPointInfo = minPointInfo,\n      index = _minPointInfo.index,\n      x0 = _minPointInfo.x0,\n      y0 = _minPointInfo.y0;\n\n  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),\n      x1 = _projectedCoords2[0],\n      y1 = _projectedCoords2[1],\n      _projectedCoords2$ = _projectedCoords2[2],\n      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;\n\n  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),\n      x2 = _projectedCoords$inde[0],\n      y2 = _projectedCoords$inde[1],\n      _projectedCoords$inde2 = _projectedCoords$inde[2],\n      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z\n\n\n  var lineLength = distance2d(x1, y1, x2, y2);\n  var startToPointLength = distance2d(x1, y1, x0, y0);\n  var ratio = startToPointLength / lineLength;\n  var z0 = mix(z1, z2, ratio);\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n/**\n * Inserts toInsert string into base string before insertBefore string.\n * @param base A string to insert into.\n * @param insertBefore A sub string in `base` string to insert before.\n * @param toInsert A string to insert.\n * @returns Combined string. `base` string if `insertBefore` string isn't found.\n */\n\n\nfunction insertBefore(base, insertBefore, toInsert) {\n  var at = base.indexOf(insertBefore);\n\n  if (at < 0) {\n    return base;\n  }\n\n  return base.slice(0, at) + toInsert + base.slice(at);\n}","map":{"version":3,"mappings":"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","names":["toDeckColor","color","defaultColor","Array","isArray","recursivelyTraverseNestedArrays","array","prefix","fn","i","length","generatePointsParallelToLinePoints","p1","p2","groundCoords","lineString","type","coordinates","pt","ddistance","lineBearing","isPointToLeftOfLine","orthogonalBearing","p3","p4","geometry","distance2d","x1","y1","x2","y2","dx","dy","Math","sqrt","mix","a","b","ratio","nearestPointOnProjectedLine","line","inPoint","viewport","wmViewport","WebMercatorViewport","projectedCoords","map","x","y","z","project","minDistance","Infinity","minPointInfo","forEach","index","A","B","C","div","distance","abs","x0","y0","z1","z2","lineLength","startToPointLength","z0","unproject","properties","dist","insertBefore","base","toInsert","at","indexOf","slice"],"sources":["../src/utils.ts"],"sourcesContent":["import destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { point } from '@turf/helpers';\nimport {\n  Position,\n  Point,\n  LineString,\n  FeatureOf,\n  FeatureWithProps,\n  Viewport,\n} from '@nebula.gl/edit-modes';\nimport WebMercatorViewport from 'viewport-mercator-project';\n\n// TODO edit-modes: delete and use edit-modes/utils instead\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number; index: number }>;\n\nexport function toDeckColor(\n  color?: [number, number, number, number] | number,\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  groundCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2],\n  };\n  const pt = point(groundCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (groundCoords[0] - p1[0]) * (p2[1] - p1[1]) - (groundCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n  //@ts-ignore\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: Viewport\n): NearestPointType {\n  const wmViewport = new WebMercatorViewport(viewport);\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = line.geometry.coordinates as any;\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => wmViewport.project([x, y, z]));\n  //@ts-ignore\n  const [x, y] = wmViewport.project(inPoint.geometry.coordinates);\n  // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div,\n      };\n    }\n  });\n  //@ts-ignore\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0]),\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1,\n    },\n  };\n}\n\n/**\n * Inserts toInsert string into base string before insertBefore string.\n * @param base A string to insert into.\n * @param insertBefore A sub string in `base` string to insert before.\n * @param toInsert A string to insert.\n * @returns Combined string. `base` string if `insertBefore` string isn't found.\n */\nexport function insertBefore(base: string, insertBefore: string, toInsert: string): string {\n  const at = base.indexOf(insertBefore);\n  if (at < 0) {\n    return base;\n  }\n  return base.slice(0, at) + toInsert + base.slice(at);\n}\n"]},"metadata":{},"sourceType":"script"}