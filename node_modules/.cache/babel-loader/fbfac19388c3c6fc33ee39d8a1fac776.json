{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, equals as _equals, assert } from '@math.gl/core';\nvar scratchPosition = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar Plane = /*#__PURE__*/function () {\n  function Plane() {\n    var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 1];\n    var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Plane);\n\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  _createClass(Plane, [{\n    key: \"fromNormalDistance\",\n    value: function fromNormalDistance(normal, distance) {\n      assert(Number.isFinite(distance));\n      this.normal.from(normal).normalize();\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromPointNormal\",\n    value: function fromPointNormal(point, normal) {\n      point = scratchPosition.from(point);\n      this.normal.from(normal).normalize();\n      var distance = -this.normal.dot(point);\n      this.distance = distance;\n      return this;\n    }\n  }, {\n    key: \"fromCoefficients\",\n    value: function fromCoefficients(a, b, c, d) {\n      this.normal.set(a, b, c);\n      assert(_equals(this.normal.len(), 1));\n      this.distance = d;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(plane) {\n      return new Plane(this.normal, this.distance);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return _equals(this.distance, right.distance) && _equals(this.normal, right.normal);\n    }\n  }, {\n    key: \"getPointDistance\",\n    value: function getPointDistance(point) {\n      return this.normal.dot(point) + this.distance;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(matrix4) {\n      var normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n      var point = this.normal.scale(-this.distance).transform(matrix4);\n      return this.fromPointNormal(point, normal);\n    }\n  }, {\n    key: \"projectPointOntoPlane\",\n    value: function projectPointOntoPlane(point) {\n      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n      point = scratchPosition.from(point);\n      var pointDistance = this.getPointDistance(point);\n      var scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n      return point.subtract(scaledNormal).to(result);\n    }\n  }]);\n\n  return Plane;\n}();\n\nexport { Plane as default };","map":{"version":3,"mappings":";;AAIA,SAAQA,OAAR,EAAiBC,MAAjB,IAAiBA,OAAjB,EAAyBC,MAAzB,QAAsC,eAAtC;AAEA,IAAMC,eAAe,GAAG,IAAIH,OAAJ,EAAxB;AACA,IAAMI,aAAa,GAAG,IAAIJ,OAAJ,EAAtB;;IAGqBK,K;EACnBC,iBAA8C;IAAA,IAAlCC,MAAkC,uEAAzB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAyB;IAAA,IAAdC,QAAc,uEAAH,CAAG;;IAAA;;IAC5C,KAAKD,MAAL,GAAc,IAAIP,OAAJ,EAAd;IACA,KAAKQ,QAAL,GAAgB,CAAC,CAAjB;IACA,KAAKC,kBAAL,CAAwBF,MAAxB,EAAgCC,QAAhC;EACD;;;;WAEDC,4BAAmBF,MAAnBE,EAA2BD,QAA3BC,EAAqC;MACnCP,MAAM,CAACQ,MAAM,CAACC,QAAPD,CAAgBF,QAAhBE,CAAD,CAANR;MACA,KAAKK,MAAL,CAAYK,IAAZ,CAAiBL,MAAjB,EAAyBM,SAAzB;MACA,KAAKL,QAAL,GAAgBA,QAAhB;MACA,OAAO,IAAP;IACD;;;WAGDM,yBAAgBC,KAAhBD,EAAuBP,MAAvBO,EAA+B;MAC7BC,KAAK,GAAGZ,eAAe,CAACS,IAAhBT,CAAqBY,KAArBZ,CAARY;MACA,KAAKR,MAAL,CAAYK,IAAZ,CAAiBL,MAAjB,EAAyBM,SAAzB;MACA,IAAML,QAAQ,GAAG,CAAC,KAAKD,MAAL,CAAYS,GAAZ,CAAgBD,KAAhB,CAAlB;MACA,KAAKP,QAAL,GAAgBA,QAAhB;MAEA,OAAO,IAAP;IACD;;;WAGDS,0BAAiBC,CAAjBD,EAAoBE,CAApBF,EAAuBG,CAAvBH,EAA0BI,CAA1BJ,EAA6B;MAC3B,KAAKV,MAAL,CAAYe,GAAZ,CAAgBJ,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB;MACAlB,MAAM,CAACD,OAAM,CAAC,KAAKM,MAAL,CAAYgB,GAAZ,EAAD,EAAoB,CAApB,CAAP,CAANrB;MACA,KAAKM,QAAL,GAAgBa,CAAhB;MACA,OAAO,IAAP;IACD;;;WAGDG,eAAMC,KAAND,EAAa;MACX,OAAO,IAAInB,KAAJ,CAAU,KAAKE,MAAf,EAAuB,KAAKC,QAA5B,CAAP;IACD;;;WAGDP,gBAAOyB,KAAPzB,EAAc;MACZ,OAAOA,OAAM,CAAC,KAAKO,QAAN,EAAgBkB,KAAK,CAAClB,QAAtB,CAANP,IAAyCA,OAAM,CAAC,KAAKM,MAAN,EAAcmB,KAAK,CAACnB,MAApB,CAAtD;IACD;;;WAIDoB,0BAAiBZ,KAAjBY,EAAwB;MACtB,OAAO,KAAKpB,MAAL,CAAYS,GAAZ,CAAgBD,KAAhB,IAAyB,KAAKP,QAArC;IACD;;;WAGDoB,mBAAUC,OAAVD,EAAmB;MACjB,IAAMrB,MAAM,GAAGH,aAAa,CAAC0B,IAAd1B,CAAmB,KAAKG,MAAxBH,EAAgC2B,iBAAhC3B,CAAkDyB,OAAlDzB,EAA2DS,SAA3DT,EAAf;MACA,IAAMW,KAAK,GAAG,KAAKR,MAAL,CAAYyB,KAAZ,CAAkB,CAAC,KAAKxB,QAAxB,EAAkCoB,SAAlC,CAA4CC,OAA5C,CAAd;MACA,OAAO,KAAKf,eAAL,CAAqBC,KAArB,EAA4BR,MAA5B,CAAP;IACD;;;WAGD0B,+BAAsBlB,KAAtBkB,EAAiD;MAAA,IAApBC,MAAoB,uEAAX,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAW;MAC/CnB,KAAK,GAAGZ,eAAe,CAACS,IAAhBT,CAAqBY,KAArBZ,CAARY;MAEA,IAAMoB,aAAa,GAAG,KAAKR,gBAAL,CAAsBZ,KAAtB,CAAtB;MACA,IAAMqB,YAAY,GAAGhC,aAAa,CAAC0B,IAAd1B,CAAmB,KAAKG,MAAxBH,EAAgC4B,KAAhC5B,CAAsC+B,aAAtC/B,CAArB;MAEA,OAAOW,KAAK,CAACsB,QAANtB,CAAeqB,YAAfrB,EAA6BuB,EAA7BvB,CAAgCmB,MAAhCnB,CAAP;IACD;;;;;;SA/DkBV,K","names":["Vector3","equals","assert","scratchPosition","scratchNormal","Plane","constructor","normal","distance","fromNormalDistance","Number","isFinite","from","normalize","fromPointNormal","point","dot","fromCoefficients","a","b","c","d","set","len","clone","plane","right","getPointDistance","transform","matrix4","copy","transformAsVector","scale","projectPointOntoPlane","result","pointDistance","scaledNormal","subtract","to"],"sources":["../../../src/lib/plane.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport default class Plane {\n  constructor(normal = [0, 0, 1], distance = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  fromNormalDistance(normal, distance) {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  // Creates a plane from a normal and a point on the plane.\n  fromPointNormal(point, normal) {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n\n    return this;\n  }\n\n  // Creates a plane from the general equation\n  fromCoefficients(a, b, c, d) {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  // Duplicates a Plane instance.\n  clone(plane) {\n    return new Plane(this.normal, this.distance);\n  }\n\n  // Compares the provided Planes by normal and distance\n  equals(right) {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  // Computes the signed shortest distance of a point to a plane.\n  // The sign of the distance determines which side of the plane the point is on.\n  getPointDistance(point) {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  // Transforms the plane by the given transformation matrix.\n  transform(matrix4) {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  // Projects a point onto the plane.\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return point.subtract(scaledNormal).to(result);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}