{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { Geometry } from '@luma.gl/core';\nimport { COORDINATE_SYSTEM, CompositeLayer } from '@deck.gl/core';\nimport { PointCloudLayer } from '@deck.gl/layers';\nimport { ScenegraphLayer } from '@deck.gl/mesh-layers';\nimport { default as _MeshLayer } from '../mesh-layer/mesh-layer';\nimport { log } from '@deck.gl/core';\nimport { load } from '@loaders.gl/core';\nimport { Tileset3D, TILE_TYPE } from '@loaders.gl/tiles';\nimport { Tiles3DLoader } from '@loaders.gl/3d-tiles';\nvar SINGLE_DATA = [0];\nvar defaultProps = {\n  getPointColor: {\n    type: 'accessor',\n    value: [0, 0, 0, 255]\n  },\n  pointSize: 1.0,\n  data: null,\n  loader: Tiles3DLoader,\n  onTilesetLoad: {\n    type: 'function',\n    value: function value(tileset3d) {},\n    compare: false\n  },\n  onTileLoad: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileUnload: {\n    type: 'function',\n    value: function value(tileHeader) {},\n    compare: false\n  },\n  onTileError: {\n    type: 'function',\n    value: function value(tile, message, url) {},\n    compare: false\n  },\n  _getMeshColor: {\n    type: 'function',\n    value: function value(tileHeader) {\n      return [255, 255, 255];\n    },\n    compare: false\n  }\n};\n\nvar Tile3DLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(Tile3DLayer, _CompositeLayer);\n\n  var _super = _createSuper(Tile3DLayer);\n\n  function Tile3DLayer() {\n    _classCallCheck(this, Tile3DLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Tile3DLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      if ('onTileLoadFail' in this.props) {\n        log.removed('onTileLoadFail', 'onTileError')();\n      }\n\n      this.state = {\n        layerMap: {},\n        tileset3d: null,\n        activeViewports: {},\n        lastUpdatedViewports: null\n      };\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      var tileset3d = this.state.tileset3d;\n      return tileset3d && tileset3d.isLoaded();\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      return changeFlags.somethingChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (props.data && props.data !== oldProps.data) {\n        this._loadTileset(props.data);\n      }\n\n      if (changeFlags.viewportChanged) {\n        var activeViewports = this.state.activeViewports;\n        var viewportsNumber = Object.keys(activeViewports).length;\n\n        if (viewportsNumber) {\n          this._updateTileset(activeViewports);\n\n          this.state.lastUpdatedViewports = activeViewports;\n          this.state.activeViewports = {};\n        }\n      }\n\n      if (changeFlags.propsChanged) {\n        var layerMap = this.state.layerMap;\n\n        for (var key in layerMap) {\n          layerMap[key].needsUpdate = true;\n        }\n      }\n    }\n  }, {\n    key: \"activateViewport\",\n    value: function activateViewport(viewport) {\n      var _this$state = this.state,\n          activeViewports = _this$state.activeViewports,\n          lastUpdatedViewports = _this$state.lastUpdatedViewports;\n      this.internalState.viewport = viewport;\n      activeViewports[viewport.id] = viewport;\n      var lastViewport = lastUpdatedViewports === null || lastUpdatedViewports === void 0 ? void 0 : lastUpdatedViewports[viewport.id];\n\n      if (!lastViewport || !viewport.equals(lastViewport)) {\n        this.setChangeFlags({\n          viewportChanged: true\n        });\n        this.setNeedsUpdate();\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info,\n          sourceLayer = _ref3.sourceLayer;\n      var layerMap = this.state.layerMap;\n      var layerId = sourceLayer && sourceLayer.id;\n\n      if (layerId) {\n        var substr = layerId.substring(this.id.length + 1);\n        var tileId = substr.substring(substr.indexOf('-') + 1);\n        info.object = layerMap[tileId] && layerMap[tileId].tile;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"filterSubLayer\",\n    value: function filterSubLayer(_ref4) {\n      var layer = _ref4.layer,\n          viewport = _ref4.viewport;\n      var tile = layer.props.tile;\n      var viewportId = viewport.id;\n      return tile.selected && tile.viewportIds.includes(viewportId);\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      if (info.sourceLayer) {\n        info.sourceLayer.updateAutoHighlight(info);\n      }\n    }\n  }, {\n    key: \"_loadTileset\",\n    value: function () {\n      var _loadTileset2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(tilesetUrl) {\n        var _this$props$loadOptio, loadOptions, loader, options, preloadOptions, tilesetJson, tileset3d;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props$loadOptio = this.props.loadOptions, loadOptions = _this$props$loadOptio === void 0 ? {} : _this$props$loadOptio;\n                loader = this.props.loader || this.props.loaders;\n\n                if (Array.isArray(loader)) {\n                  loader = loader[0];\n                }\n\n                options = {\n                  loadOptions: _objectSpread({}, loadOptions)\n                };\n\n                if (!loader.preload) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 7;\n                return loader.preload(tilesetUrl, loadOptions);\n\n              case 7:\n                preloadOptions = _context.sent;\n\n                if (preloadOptions.headers) {\n                  options.loadOptions.fetch = _objectSpread(_objectSpread({}, options.loadOptions.fetch), {}, {\n                    headers: preloadOptions.headers\n                  });\n                }\n\n                Object.assign(options, preloadOptions);\n\n              case 10:\n                _context.next = 12;\n                return load(tilesetUrl, loader, options.loadOptions);\n\n              case 12:\n                tilesetJson = _context.sent;\n                tileset3d = new Tileset3D(tilesetJson, _objectSpread({\n                  onTileLoad: this._onTileLoad.bind(this),\n                  onTileUnload: this._onTileUnload.bind(this),\n                  onTileLoadFail: this.props.onTileError\n                }, options));\n                this.setState({\n                  tileset3d: tileset3d,\n                  layerMap: {}\n                });\n\n                this._updateTileset(this.state.activeViewports);\n\n                this.props.onTilesetLoad(tileset3d);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _loadTileset(_x) {\n        return _loadTileset2.apply(this, arguments);\n      }\n\n      return _loadTileset;\n    }()\n  }, {\n    key: \"_onTileLoad\",\n    value: function _onTileLoad(tileHeader) {\n      var lastUpdatedViewports = this.state.lastUpdatedViewports;\n      this.props.onTileLoad(tileHeader);\n\n      this._updateTileset(lastUpdatedViewports);\n\n      this.setNeedsUpdate();\n    }\n  }, {\n    key: \"_onTileUnload\",\n    value: function _onTileUnload(tileHeader) {\n      delete this.state.layerMap[tileHeader.id];\n      this.props.onTileUnload(tileHeader);\n    }\n  }, {\n    key: \"_updateTileset\",\n    value: function _updateTileset(viewports) {\n      var tileset3d = this.state.tileset3d;\n      var timeline = this.context.timeline;\n      var viewportsNumber = Object.keys(viewports).length;\n\n      if (!timeline || !viewportsNumber || !tileset3d) {\n        return;\n      }\n\n      var frameNumber = tileset3d.update(Object.values(viewports));\n      var tilesetChanged = this.state.frameNumber !== frameNumber;\n\n      if (tilesetChanged) {\n        this.setState({\n          frameNumber: frameNumber\n        });\n      }\n    }\n  }, {\n    key: \"_getSubLayer\",\n    value: function _getSubLayer(tileHeader, oldLayer) {\n      if (!tileHeader.content) {\n        return null;\n      }\n\n      switch (tileHeader.type) {\n        case TILE_TYPE.POINTCLOUD:\n          return this._makePointCloudLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.SCENEGRAPH:\n          return this._make3DModelLayer(tileHeader, oldLayer);\n\n        case TILE_TYPE.MESH:\n          return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n\n        default:\n          throw new Error(\"Tile3DLayer: Failed to render layer of type \".concat(tileHeader.content.type));\n      }\n    }\n  }, {\n    key: \"_makePointCloudLayer\",\n    value: function _makePointCloudLayer(tileHeader, oldLayer) {\n      var _tileHeader$content = tileHeader.content,\n          attributes = _tileHeader$content.attributes,\n          pointCount = _tileHeader$content.pointCount,\n          constantRGBA = _tileHeader$content.constantRGBA,\n          cartographicOrigin = _tileHeader$content.cartographicOrigin,\n          modelMatrix = _tileHeader$content.modelMatrix;\n      var positions = attributes.positions,\n          normals = attributes.normals,\n          colors = attributes.colors;\n\n      if (!positions) {\n        return null;\n      }\n\n      var data = oldLayer && oldLayer.props.data || {\n        header: {\n          vertexCount: pointCount\n        },\n        attributes: {\n          POSITION: positions,\n          NORMAL: normals,\n          COLOR_0: colors\n        }\n      };\n      var _this$props = this.props,\n          pointSize = _this$props.pointSize,\n          getPointColor = _this$props.getPointColor;\n      var SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n      return new SubLayerClass({\n        pointSize: pointSize\n      }, this.getSubLayerProps({\n        id: 'pointcloud'\n      }), {\n        id: \"\".concat(this.id, \"-pointcloud-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_make3DModelLayer\",\n    value: function _make3DModelLayer(tileHeader) {\n      var _tileHeader$content2 = tileHeader.content,\n          gltf = _tileHeader$content2.gltf,\n          instances = _tileHeader$content2.instances,\n          cartographicOrigin = _tileHeader$content2.cartographicOrigin,\n          modelMatrix = _tileHeader$content2.modelMatrix;\n      var SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n      return new SubLayerClass({\n        _lighting: 'pbr'\n      }, this.getSubLayerProps({\n        id: 'scenegraph'\n      }), {\n        id: \"\".concat(this.id, \"-scenegraph-\").concat(tileHeader.id),\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix: modelMatrix,\n        getTransformMatrix: function getTransformMatrix(instance) {\n          return instance.modelMatrix;\n        },\n        getPosition: [0, 0, 0],\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"_makeSimpleMeshLayer\",\n    value: function _makeSimpleMeshLayer(tileHeader, oldLayer) {\n      var content = tileHeader.content;\n      var attributes = content.attributes,\n          indices = content.indices,\n          modelMatrix = content.modelMatrix,\n          cartographicOrigin = content.cartographicOrigin,\n          _content$coordinateSy = content.coordinateSystem,\n          coordinateSystem = _content$coordinateSy === void 0 ? COORDINATE_SYSTEM.METER_OFFSETS : _content$coordinateSy,\n          material = content.material,\n          featureIds = content.featureIds;\n      var _getMeshColor = this.props._getMeshColor;\n      var geometry = oldLayer && oldLayer.props.mesh || new Geometry({\n        drawMode: 4,\n        attributes: getMeshGeometry(attributes),\n        indices: indices\n      });\n      var SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n      return new SubLayerClass(this.getSubLayerProps({\n        id: 'mesh'\n      }), {\n        id: \"\".concat(this.id, \"-mesh-\").concat(tileHeader.id),\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix: modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem: coordinateSystem,\n        featureIds: featureIds,\n        _offset: 0\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var _this$state2 = this.state,\n          tileset3d = _this$state2.tileset3d,\n          layerMap = _this$state2.layerMap;\n\n      if (!tileset3d) {\n        return null;\n      }\n\n      return tileset3d.tiles.map(function (tile) {\n        var layerCache = layerMap[tile.id] = layerMap[tile.id] || {\n          tile: tile\n        };\n        var layer = layerCache.layer;\n\n        if (tile.selected) {\n          if (!layer) {\n            layer = _this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            layer = _this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n\n        layerCache.layer = layer;\n        return layer;\n      }).filter(Boolean);\n    }\n  }]);\n\n  return Tile3DLayer;\n}(CompositeLayer);\n\nexport { Tile3DLayer as default };\n\nfunction getMeshGeometry(contentAttributes) {\n  var attributes = {};\n  attributes.positions = _objectSpread(_objectSpread({}, contentAttributes.positions), {}, {\n    value: new Float32Array(contentAttributes.positions.value)\n  });\n\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Geometry","COORDINATE_SYSTEM","CompositeLayer","PointCloudLayer","ScenegraphLayer","default","_MeshLayer","log","load","Tileset3D","TILE_TYPE","Tiles3DLoader","SINGLE_DATA","defaultProps","getPointColor","type","value","pointSize","data","loader","onTilesetLoad","tileset3d","compare","onTileLoad","tileHeader","onTileUnload","onTileError","tile","message","url","_getMeshColor","Tile3DLayer","initializeState","props","removed","state","layerMap","activeViewports","lastUpdatedViewports","isLoaded","shouldUpdateState","changeFlags","somethingChanged","updateState","oldProps","_loadTileset","viewportChanged","viewportsNumber","Object","keys","length","_updateTileset","propsChanged","key","needsUpdate","activateViewport","viewport","internalState","id","lastViewport","equals","setChangeFlags","setNeedsUpdate","getPickingInfo","info","sourceLayer","layerId","substr","substring","tileId","indexOf","object","filterSubLayer","layer","viewportId","selected","viewportIds","includes","_updateAutoHighlight","updateAutoHighlight","tilesetUrl","loadOptions","loaders","Array","isArray","options","preload","preloadOptions","headers","fetch","assign","tilesetJson","_onTileLoad","bind","_onTileUnload","onTileLoadFail","setState","viewports","timeline","context","frameNumber","update","values","tilesetChanged","_getSubLayer","oldLayer","content","POINTCLOUD","_makePointCloudLayer","SCENEGRAPH","_make3DModelLayer","MESH","_makeSimpleMeshLayer","Error","attributes","pointCount","constantRGBA","cartographicOrigin","modelMatrix","positions","normals","colors","header","vertexCount","POSITION","NORMAL","COLOR_0","SubLayerClass","getSubLayerClass","getSubLayerProps","coordinateSystem","METER_OFFSETS","coordinateOrigin","getColor","_offset","gltf","instances","_lighting","scenegraph","getTransformMatrix","instance","getPosition","indices","material","featureIds","geometry","mesh","drawMode","getMeshGeometry","pbrMaterial","renderLayers","tiles","map","layerCache","filter","Boolean","contentAttributes","Float32Array","texCoords","uvRegions","layerName"],"sources":["../../../src/tile-3d-layer/tile-3d-layer.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Geometry} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, CompositeLayer} from '@deck.gl/core';\nimport {PointCloudLayer} from '@deck.gl/layers';\nimport {ScenegraphLayer} from '@deck.gl/mesh-layers';\nimport {default as _MeshLayer} from '../mesh-layer/mesh-layer';\nimport {log} from '@deck.gl/core';\n\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, TILE_TYPE} from '@loaders.gl/tiles';\nimport {Tiles3DLoader} from '@loaders.gl/3d-tiles';\n\nconst SINGLE_DATA = [0];\n\nconst defaultProps = {\n  getPointColor: {type: 'accessor', value: [0, 0, 0, 255]},\n  pointSize: 1.0,\n\n  data: null,\n  loader: Tiles3DLoader,\n\n  onTilesetLoad: {type: 'function', value: tileset3d => {}, compare: false},\n  onTileLoad: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileUnload: {type: 'function', value: tileHeader => {}, compare: false},\n  onTileError: {type: 'function', value: (tile, message, url) => {}, compare: false},\n  _getMeshColor: {type: 'function', value: tileHeader => [255, 255, 255], compare: false}\n};\n\nexport default class Tile3DLayer extends CompositeLayer {\n  initializeState() {\n    if ('onTileLoadFail' in this.props) {\n      log.removed('onTileLoadFail', 'onTileError')();\n    }\n    // prop verification\n    this.state = {\n      layerMap: {},\n      tileset3d: null,\n      activeViewports: {},\n      lastUpdatedViewports: null\n    };\n  }\n\n  get isLoaded() {\n    const {tileset3d} = this.state;\n    return tileset3d && tileset3d.isLoaded();\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    if (props.data && props.data !== oldProps.data) {\n      this._loadTileset(props.data);\n    }\n\n    if (changeFlags.viewportChanged) {\n      const {activeViewports} = this.state;\n      const viewportsNumber = Object.keys(activeViewports).length;\n      if (viewportsNumber) {\n        this._updateTileset(activeViewports);\n        this.state.lastUpdatedViewports = activeViewports;\n        this.state.activeViewports = {};\n      }\n    }\n    if (changeFlags.propsChanged) {\n      const {layerMap} = this.state;\n      for (const key in layerMap) {\n        layerMap[key].needsUpdate = true;\n      }\n    }\n  }\n\n  activateViewport(viewport) {\n    const {activeViewports, lastUpdatedViewports} = this.state;\n    this.internalState.viewport = viewport;\n\n    activeViewports[viewport.id] = viewport;\n    const lastViewport = lastUpdatedViewports?.[viewport.id];\n    if (!lastViewport || !viewport.equals(lastViewport)) {\n      this.setChangeFlags({viewportChanged: true});\n      this.setNeedsUpdate();\n    }\n  }\n\n  getPickingInfo({info, sourceLayer}) {\n    const {layerMap} = this.state;\n    const layerId = sourceLayer && sourceLayer.id;\n    if (layerId) {\n      // layerId: this.id-[scenegraph|pointcloud]-tileId\n      const substr = layerId.substring(this.id.length + 1);\n      const tileId = substr.substring(substr.indexOf('-') + 1);\n      info.object = layerMap[tileId] && layerMap[tileId].tile;\n    }\n\n    return info;\n  }\n\n  filterSubLayer({layer, viewport}) {\n    const {tile} = layer.props;\n    const {id: viewportId} = viewport;\n    return tile.selected && tile.viewportIds.includes(viewportId);\n  }\n\n  _updateAutoHighlight(info) {\n    if (info.sourceLayer) {\n      info.sourceLayer.updateAutoHighlight(info);\n    }\n  }\n\n  async _loadTileset(tilesetUrl) {\n    const {loadOptions = {}} = this.props;\n\n    // TODO: deprecate `loader` in v9.0\n    let loader = this.props.loader || this.props.loaders;\n    if (Array.isArray(loader)) {\n      loader = loader[0];\n    }\n\n    const options = {loadOptions: {...loadOptions}};\n    if (loader.preload) {\n      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);\n\n      if (preloadOptions.headers) {\n        options.loadOptions.fetch = {\n          ...options.loadOptions.fetch,\n          headers: preloadOptions.headers\n        };\n      }\n      Object.assign(options, preloadOptions);\n    }\n    const tilesetJson = await load(tilesetUrl, loader, options.loadOptions);\n\n    const tileset3d = new Tileset3D(tilesetJson, {\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileUnload: this._onTileUnload.bind(this),\n      onTileLoadFail: this.props.onTileError,\n      ...options\n    });\n\n    this.setState({\n      tileset3d,\n      layerMap: {}\n    });\n\n    this._updateTileset(this.state.activeViewports);\n    this.props.onTilesetLoad(tileset3d);\n  }\n\n  _onTileLoad(tileHeader) {\n    const {lastUpdatedViewports} = this.state;\n    this.props.onTileLoad(tileHeader);\n    this._updateTileset(lastUpdatedViewports);\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tileHeader) {\n    // Was cleaned up from tileset cache. We no longer need to track it.\n    delete this.state.layerMap[tileHeader.id];\n    this.props.onTileUnload(tileHeader);\n  }\n\n  _updateTileset(viewports) {\n    const {tileset3d} = this.state;\n    const {timeline} = this.context;\n    const viewportsNumber = Object.keys(viewports).length;\n    if (!timeline || !viewportsNumber || !tileset3d) {\n      return;\n    }\n    const frameNumber = tileset3d.update(Object.values(viewports));\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (tilesetChanged) {\n      this.setState({frameNumber});\n    }\n  }\n\n  _getSubLayer(tileHeader, oldLayer) {\n    if (!tileHeader.content) {\n      return null;\n    }\n\n    switch (tileHeader.type) {\n      case TILE_TYPE.POINTCLOUD:\n        return this._makePointCloudLayer(tileHeader, oldLayer);\n      case TILE_TYPE.SCENEGRAPH:\n        return this._make3DModelLayer(tileHeader, oldLayer);\n      case TILE_TYPE.MESH:\n        return this._makeSimpleMeshLayer(tileHeader, oldLayer);\n      default:\n        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);\n    }\n  }\n\n  _makePointCloudLayer(tileHeader, oldLayer) {\n    const {attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix} =\n      tileHeader.content;\n    const {positions, normals, colors} = attributes;\n\n    if (!positions) {\n      return null;\n    }\n    const data = (oldLayer && oldLayer.props.data) || {\n      header: {\n        vertexCount: pointCount\n      },\n      attributes: {\n        POSITION: positions,\n        NORMAL: normals,\n        COLOR_0: colors\n      }\n    };\n\n    const {pointSize, getPointColor} = this.props;\n    const SubLayerClass = this.getSubLayerClass('pointcloud', PointCloudLayer);\n    return new SubLayerClass(\n      {\n        pointSize\n      },\n      this.getSubLayerProps({\n        id: 'pointcloud'\n      }),\n      {\n        id: `${this.id}-pointcloud-${tileHeader.id}`,\n        tile: tileHeader,\n        data,\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getColor: constantRGBA || getPointColor,\n        _offset: 0\n      }\n    );\n  }\n\n  _make3DModelLayer(tileHeader) {\n    const {gltf, instances, cartographicOrigin, modelMatrix} = tileHeader.content;\n\n    const SubLayerClass = this.getSubLayerClass('scenegraph', ScenegraphLayer);\n\n    return new SubLayerClass(\n      {\n        _lighting: 'pbr'\n      },\n      this.getSubLayerProps({\n        id: 'scenegraph'\n      }),\n      {\n        id: `${this.id}-scenegraph-${tileHeader.id}`,\n        tile: tileHeader,\n        data: instances || SINGLE_DATA,\n        scenegraph: gltf,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: cartographicOrigin,\n        modelMatrix,\n        getTransformMatrix: instance => instance.modelMatrix,\n        getPosition: [0, 0, 0],\n        _offset: 0\n      }\n    );\n  }\n\n  _makeSimpleMeshLayer(tileHeader, oldLayer) {\n    const content = tileHeader.content;\n    const {\n      attributes,\n      indices,\n      modelMatrix,\n      cartographicOrigin,\n      coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS,\n      material,\n      featureIds\n    } = content;\n    const {_getMeshColor} = this.props;\n\n    const geometry =\n      (oldLayer && oldLayer.props.mesh) ||\n      new Geometry({\n        drawMode: GL.TRIANGLES,\n        attributes: getMeshGeometry(attributes),\n        indices\n      });\n\n    const SubLayerClass = this.getSubLayerClass('mesh', _MeshLayer);\n\n    return new SubLayerClass(\n      this.getSubLayerProps({\n        id: 'mesh'\n      }),\n      {\n        id: `${this.id}-mesh-${tileHeader.id}`,\n        tile: tileHeader,\n        mesh: geometry,\n        data: SINGLE_DATA,\n        getColor: _getMeshColor(tileHeader),\n        pbrMaterial: material,\n        modelMatrix,\n        coordinateOrigin: cartographicOrigin,\n        coordinateSystem,\n        featureIds,\n        _offset: 0\n      }\n    );\n  }\n\n  renderLayers() {\n    const {tileset3d, layerMap} = this.state;\n    if (!tileset3d) {\n      return null;\n    }\n\n    return tileset3d.tiles\n      .map(tile => {\n        const layerCache = (layerMap[tile.id] = layerMap[tile.id] || {tile});\n        let {layer} = layerCache;\n        if (tile.selected) {\n          // render selected tiles\n          if (!layer) {\n            // create layer\n            layer = this._getSubLayer(tile);\n          } else if (layerCache.needsUpdate) {\n            // props have changed, rerender layer\n            layer = this._getSubLayer(tile, layer);\n            layerCache.needsUpdate = false;\n          }\n        }\n        layerCache.layer = layer;\n        return layer;\n      })\n      .filter(Boolean);\n  }\n}\n\nfunction getMeshGeometry(contentAttributes) {\n  const attributes = {};\n  attributes.positions = {\n    ...contentAttributes.positions,\n    value: new Float32Array(contentAttributes.positions.value)\n  };\n  if (contentAttributes.normals) {\n    attributes.normals = contentAttributes.normals;\n  }\n  if (contentAttributes.texCoords) {\n    attributes.texCoords = contentAttributes.texCoords;\n  }\n  if (contentAttributes.colors) {\n    attributes.colors = contentAttributes.colors;\n  }\n  if (contentAttributes.uvRegions) {\n    attributes.uvRegions = contentAttributes.uvRegions;\n  }\n  return attributes;\n}\n\nTile3DLayer.layerName = 'Tile3DLayer';\nTile3DLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}