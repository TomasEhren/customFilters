{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nvar KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport var name = KHR_TECHNIQUES_WEBGL;\nexport function decode(_x) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData) {\n    var gltfScenegraph, json, extension, techniques, _iterator, _step, material, materialExtension;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            gltfScenegraph = new GLTFScenegraph(gltfData);\n            json = gltfScenegraph.json;\n            extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n\n            if (extension) {\n              techniques = resolveTechniques(extension, gltfScenegraph);\n              _iterator = _createForOfIteratorHelper(json.materials || []);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  material = _step.value;\n                  materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n\n                  if (materialExtension) {\n                    material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n                    material.technique.values = resolveValues(material.technique, gltfScenegraph);\n                  }\n\n                  gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n            }\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nexport function encode(_x2, _x3) {\n  return _encode.apply(this, arguments);\n}\n\nfunction _encode() {\n  _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(gltfData, options) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encode.apply(this, arguments);\n}\n\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  var _techniquesExtension$ = techniquesExtension.programs,\n      programs = _techniquesExtension$ === void 0 ? [] : _techniquesExtension$,\n      _techniquesExtension$2 = techniquesExtension.shaders,\n      shaders = _techniquesExtension$2 === void 0 ? [] : _techniquesExtension$2,\n      _techniquesExtension$3 = techniquesExtension.techniques,\n      techniques = _techniquesExtension$3 === void 0 ? [] : _techniquesExtension$3;\n  var textDecoder = new TextDecoder();\n  shaders.forEach(function (shader) {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(function (program) {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(function (technique) {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  var values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(function (uniform) {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(function (uniform) {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"mappings":"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","names":["GLTFScenegraph","KHR_TECHNIQUES_WEBGL","name","decode","gltfData","gltfScenegraph","json","extension","getExtension","techniques","resolveTechniques","materials","material","materialExtension","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","removeExtension","encode","options","techniquesExtension","programs","shaders","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","value","index","undefined","texture","getTexture"],"sources":["../../../../../src/lib/extensions/deprecated/KHR_techniques_webgl.ts"],"sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"]},"metadata":{},"sourceType":"module"}