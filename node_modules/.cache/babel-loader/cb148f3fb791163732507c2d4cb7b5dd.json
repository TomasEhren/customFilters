{"ast":null,"code":"import { DracoLoader } from '@loaders.gl/draco';\nimport { sliceArrayBuffer } from '@loaders.gl/loader-utils';\nimport { default as Scenegraph } from '../api/gltf-scenegraph';\nimport { getGLTFAccessors, getGLTFAccessor } from '../gltf-utils/gltf-attribute-utils';\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\nexport const name = KHR_DRACO_MESH_COMPRESSION;\nexport function preprocess(gltfData, options, context) {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {}\n  }\n}\nexport async function decode(gltfData, options, context) {\n  var _options$gltf;\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises = [];\n\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\nexport function encode(gltfData) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    compressMesh(mesh, options);\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\nasync function decompressPrimitive(scenegraph, primitive, options, context) {\n  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);\n  const {\n    parse\n  } = context;\n  const dracoOptions = { ...options\n  };\n  delete dracoOptions['3d-tiles'];\n  const decodedData = await parse(bufferCopy, DracoLoader, dracoOptions, context);\n  const decodedAttributes = getGLTFAccessors(decodedData.attributes);\n\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n\n      if (accessor !== null && accessor !== void 0 && accessor.min && accessor !== null && accessor !== void 0 && accessor.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  primitive.attributes = decodedAttributes;\n\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  checkPrimitive(primitive);\n}\n\nfunction compressMesh(attributes, indices) {\n  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;\n  let options = arguments.length > 3 ? arguments[3] : undefined;\n  let context = arguments.length > 4 ? arguments[4] : undefined;\n\n  var _context$parseSync;\n\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  const compressedData = options.DracoWriter.encodeSync({\n    attributes\n  });\n  const decodedData = context === null || context === void 0 ? void 0 : (_context$parseSync = context.parseSync) === null || _context$parseSync === void 0 ? void 0 : _context$parseSync.call(context, {\n    attributes\n  });\n\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n  const glTFMesh = {\n    primitives: [{\n      attributes: fauxAccessors,\n      mode,\n      extensions: {\n        [KHR_DRACO_MESH_COMPRESSION]: {\n          bufferView: bufferViewIndex,\n          attributes: fauxAccessors\n        }\n      }\n    }]\n  };\n  return glTFMesh;\n}\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["DracoLoader","sliceArrayBuffer","default","Scenegraph","getGLTFAccessors","getGLTFAccessor","KHR_DRACO_MESH_COMPRESSION","name","preprocess","gltfData","options","context","scenegraph","primitive","makeMeshPrimitiveIterator","getObjectExtension","decode","gltf","_options$gltf","decompressMeshes","promises","push","decompressPrimitive","Promise","all","removeExtension","encode","mesh","json","meshes","compressMesh","addRequiredExtension","dracoExtension","buffer","getTypedArrayForBufferView","bufferView","bufferCopy","byteOffset","parse","dracoOptions","decodedData","decodedAttributes","attributes","attributeName","decodedAttribute","Object","entries","accessorIndex","accessor","getAccessor","min","max","indices","checkPrimitive","mode","DracoWriter","Error","compressedData","encodeSync","parseSync","_context$parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","keys","length"],"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.ts"],"sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\n\n/* eslint-disable camelcase */\nimport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFMeshPrimitive,\n  GLTF_KHR_draco_mesh_compression\n} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMesh} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\n\nexport function preprocess(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): void {\n  const scenegraph = new Scenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\n\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension<GLTF_KHR_draco_mesh_compression>(\n    primitive,\n    KHR_DRACO_MESH_COMPRESSION\n  );\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(bufferCopy, DracoLoader, dracoOptions, context)) as DracoMesh;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}