{"ast":null,"code":"import { assert } from '../env-utils/assert';\nexport function padToNBytes(byteLength, padding) {\n  assert(byteLength >= 0);\n  assert(padding > 0);\n  return byteLength + (padding - 1) & ~(padding - 1);\n}\nexport function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {\n  let byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\nexport function copyToArray(source, target, targetOffset) {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  target.set(sourceArray, targetOffset);\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}","map":{"version":3,"mappings":"AAAA,SAAQA,MAAR,QAAqB,qBAArB;AASA,OAAO,SAASC,WAAT,CAAqBC,UAArB,EAAyCC,OAAzC,EAAkE;EACvEH,MAAM,CAACE,UAAU,IAAI,CAAf,CAANF;EACAA,MAAM,CAACG,OAAO,GAAG,CAAX,CAANH;EACA,OAAQE,UAAU,IAAIC,OAAO,GAAG,CAAd,CAAVD,GAA8B,EAAEC,OAAO,GAAG,CAAZ,CAAtC;AACD;AAQD,OAAO,SAASC,eAAT,CACLC,YADK,EAELC,YAFK,EAGLC,UAHK,EAKQ;EAAA,IADbL,UACa,uEADQI,YAAY,CAACJ,UACrB;EACb,MAAMM,WAAW,GAAG,IAAIC,UAAJ,CAAeJ,YAAf,EAA6BE,UAA7B,EAAyCL,UAAzC,CAApB;EACA,MAAMQ,WAAW,GAAG,IAAID,UAAJ,CAAeH,YAAf,CAApB;EACAE,WAAW,CAACG,GAAZH,CAAgBE,WAAhBF;EACA,OAAOH,YAAP;AACD;AAUD,OAAO,SAASO,WAAT,CAAqBC,MAArB,EAAgDC,MAAhD,EAA6DC,YAA7D,EAA2F;EAChG,IAAIL,WAAJ;;EAEA,IAAIG,MAAM,YAAYG,WAAtB,EAAmC;IACjCN,WAAW,GAAG,IAAID,UAAJ,CAAeI,MAAf,CAAdH;EADF,OAEO;IAOL,MAAMO,aAAa,GAAGJ,MAAM,CAACN,UAA7B;IACA,MAAMW,aAAa,GAAGL,MAAM,CAACX,UAA7B;IAGAQ,WAAW,GAAG,IAAID,UAAJ,CAAeI,MAAM,CAACM,MAAPN,IAAiBA,MAAM,CAACO,WAAvC,EAAoDH,aAApD,EAAmEC,aAAnE,CAAdR;EACD;;EAGDI,MAAM,CAACH,GAAPG,CAAWJ,WAAXI,EAAwBC,YAAxBD;EAEA,OAAOC,YAAY,GAAGd,WAAW,CAACS,WAAW,CAACR,UAAb,EAAyB,CAAzB,CAAjC;AACD","names":["assert","padToNBytes","byteLength","padding","copyArrayBuffer","targetBuffer","sourceBuffer","byteOffset","targetArray","Uint8Array","sourceArray","set","copyToArray","source","target","targetOffset","ArrayBuffer","srcByteOffset","srcByteLength","buffer","arrayBuffer"],"sources":["../../../../src/lib/binary-utils/memory-copy-utils.ts"],"sourcesContent":["import {assert} from '../env-utils/assert';\n\n/**\n * Calculate new size of an arrayBuffer to be aligned to an n-byte boundary\n * This function increases `byteLength` by the minimum delta,\n * allowing the total length to be divided by `padding`\n * @param byteLength\n * @param padding\n */\nexport function padToNBytes(byteLength: number, padding: number): number {\n  assert(byteLength >= 0); // `Incorrect 'byteLength' value: ${byteLength}`\n  assert(padding > 0); // `Incorrect 'padding' value: ${padding}`\n  return (byteLength + (padding - 1)) & ~(padding - 1);\n}\n\n/**\n * Creates a new Uint8Array based on two different ArrayBuffers\n * @param targetBuffer The first buffer.\n * @param sourceBuffer The second buffer.\n * @return The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer: ArrayBuffer,\n  sourceBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength: number = sourceBuffer.byteLength\n): ArrayBuffer {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param source - The data to copy\n * @param target - The destination to copy data into\n * @param targetOffset - The start offset into target to place the copied data\n * @returns the new offset taking into account proper padding\n */\nexport function copyToArray(source: ArrayBuffer | any, target: any, targetOffset: number): number {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    // In gltf parser it is set as \"arrayBuffer\" instead of \"buffer\"\n    // https://github.com/visgl/loaders.gl/blob/1e3a82a0a65d7b6a67b1e60633453e5edda2960a/modules/gltf/src/lib/parse-gltf.js#L85\n    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padToNBytes(sourceArray.byteLength, 4);\n}\n"]},"metadata":{},"sourceType":"module"}