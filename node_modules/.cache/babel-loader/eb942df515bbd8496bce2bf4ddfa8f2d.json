{"ast":null,"code":"export function binaryToGeojson(data, options) {\n  const globalFeatureId = options === null || options === void 0 ? void 0 : options.globalFeatureId;\n\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n\n  return parseFeatures(data, options === null || options === void 0 ? void 0 : options.type);\n}\nexport function binaryToGeoJson(data, type) {\n  let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'feature';\n\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data, type);\n\n    case 'geometry':\n      return binaryToGeometry(data);\n\n    default:\n      throw new Error(format);\n  }\n}\n\nfunction getSingleFeature(data, globalFeatureId) {\n  const dataArray = normalizeInput(data);\n\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n\n      if (currValue === lastValue) {\n        continue;\n      }\n\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(\"featureId:\".concat(globalFeatureId, \" not found\"));\n}\n\nfunction parseFeatures(data, type) {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\nexport function binaryToGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n\n    default:\n      const unexpectedInput = data;\n      throw new Error(\"Unsupported geometry type: \".concat(unexpectedInput === null || unexpectedInput === void 0 ? void 0 : unexpectedInput.type));\n  }\n}\n\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      continue;\n    }\n\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n\n      if (currValue === lastValue) {\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n\n  return features;\n}\n\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {\n    type: 'Feature',\n    geometry,\n    properties,\n    ...fields\n  };\n}\n\nfunction parseFields(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 ? arguments[2] : undefined;\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\nfunction parseProperties(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let endIndex = arguments.length > 2 ? arguments[2] : undefined;\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n\n  return properties;\n}\n\nfunction polygonToGeoJson(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  const {\n    positions\n  } = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = polygonIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = [];\n\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {\n      type: 'Polygon',\n      coordinates\n    };\n  }\n\n  const coordinates = [];\n\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {\n    type: 'MultiPolygon',\n    coordinates\n  };\n}\n\nfunction lineStringToGeoJson(data) {\n  let startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;\n  let endIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  const {\n    positions\n  } = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {\n      type: 'LineString',\n      coordinates\n    };\n  }\n\n  const coordinates = [];\n\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {\n    type: 'MultiLineString',\n    coordinates\n  };\n}\n\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {\n    positions\n  } = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {\n      type: 'MultiPoint',\n      coordinates\n    };\n  }\n\n  return {\n    type: 'Point',\n    coordinates: coordinates[0]\n  };\n}\n\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n  const ringCoordinates = [];\n\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array();\n\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n\n    ringCoordinates.push(coord);\n  }\n\n  return ringCoordinates;\n}\n\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}","map":{"version":3,"mappings":"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","names":["binaryToGeojson","data","options","globalFeatureId","undefined","getSingleFeature","parseFeatures","type","binaryToGeoJson","format","binaryToGeometry","Error","dataArray","normalizeInput","lastIndex","lastValue","featureIds","value","i","length","currValue","globalFeatureIds","parseFeature","parseFeatureCollection","startIndex","endIndex","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","unexpectedInput","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","geometry","properties","parseProperties","fields","parseFields","Object","assign","key","numericProps","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","coord","Array","k","Number"],"sources":["../../../src/lib/binary-to-geojson.ts"],"sourcesContent":["import type {\n  BinaryGeometry,\n  BinaryFeatures,\n  BinaryGeometryType,\n  BinaryPointFeatures,\n  BinaryLineFeatures,\n  BinaryPolygonFeatures,\n  BinaryAttribute\n} from '@loaders.gl/schema';\nimport type {Feature, Geometry, Position, GeoJsonProperties} from '@loaders.gl/schema';\nimport type {\n  Point,\n  MultiPoint,\n  LineString,\n  MultiLineString,\n  Polygon,\n  MultiPolygon\n} from '@loaders.gl/schema';\n\n// Note:L We do not handle GeometryCollection, define a limited Geometry type that always has coordinates.\n// type FeatureGeometry = Point | MultiPoint | LineString | MultiLineString | Polygon | MultiPolygon;\n\ntype BinaryToGeoJsonOptions = {\n  type?: BinaryGeometryType;\n  globalFeatureId?: number;\n};\n\n/**\n * Convert binary geometry representation to GeoJSON\n * @param data   geometry data in binary representation\n * @param options\n * @param options.type  Input data type: Point, LineString, or Polygon\n * @param options.featureId  Global feature id. If specified, only a single feature is extracted\n * @return GeoJSON objects\n */\nexport function binaryToGeojson(\n  data: BinaryFeatures,\n  options?: BinaryToGeoJsonOptions\n): Feature[] | Feature {\n  const globalFeatureId = options?.globalFeatureId;\n  if (globalFeatureId !== undefined) {\n    return getSingleFeature(data, globalFeatureId);\n  }\n  return parseFeatures(data, options?.type);\n}\n\n/** @deprecated use `binaryToGeojson` or `binaryToGeometry` instead */\nexport function binaryToGeoJson(\n  data: BinaryGeometry | BinaryFeatures,\n  type?: BinaryGeometryType,\n  format: 'feature' | 'geometry' = 'feature'\n): Geometry | Feature[] {\n  switch (format) {\n    case 'feature':\n      return parseFeatures(data as BinaryFeatures, type);\n    case 'geometry':\n      return binaryToGeometry(data as BinaryGeometry);\n    default:\n      throw new Error(format);\n  }\n}\n\n/**\n * Return a single feature from a binary geometry representation as GeoJSON\n * @param data   geometry data in binary representation\n * @return GeoJSON feature\n */\nfunction getSingleFeature(data: BinaryFeatures, globalFeatureId: number): Feature {\n  const dataArray = normalizeInput(data);\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Scan through data until we find matching feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n        return parseFeature(data, lastIndex, i);\n      }\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    if (globalFeatureId === data.globalFeatureIds.value[lastIndex]) {\n      return parseFeature(data, lastIndex, data.featureIds.value.length);\n    }\n  }\n\n  throw new Error(`featureId:${globalFeatureId} not found`);\n}\n\nfunction parseFeatures(data: BinaryFeatures, type?: BinaryGeometryType): Feature[] {\n  const dataArray = normalizeInput(data, type);\n  return parseFeatureCollection(dataArray);\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nexport function binaryToGeometry(\n  data: BinaryGeometry,\n  startIndex?: number,\n  endIndex?: number\n): Geometry {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      const unexpectedInput: never = data;\n      throw new Error(`Unsupported geometry type: ${(unexpectedInput as any)?.type}`);\n  }\n}\n\ntype BinaryFeature = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\ntype BinaryFeaturesArray = BinaryFeature[];\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data: BinaryFeatures, type?: BinaryGeometryType): BinaryFeaturesArray {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    // @ts-expect-error This is a legacy check which allowed `data` to be an instance of the values\n    // here. Aka the new data.points, data.lines, or data.polygons.\n    data.type = type || parseType(data);\n    return [data] as BinaryFeaturesArray;\n  }\n\n  const features: BinaryFeaturesArray = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n\n  return features;\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray): Feature[] {\n  const features: Feature[] = [];\n  for (const data of dataArray) {\n    if (data.featureIds.value.length === 0) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex?: number, endIndex?: number): Feature {\n  const geometry = binaryToGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  const fields = parseFields(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties, ...fields};\n}\n\n/** Parse input binary data and return an object of fields */\nfunction parseFields(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  return data.fields && data.fields[data.featureIds.value[startIndex]];\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex: number = 0, endIndex?: number): GeoJsonProperties {\n  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): Polygon | MultiPolygon {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    (x) => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  // Polygon\n  if (!multi) {\n    const coordinates: Position[][] = [];\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  const coordinates: Position[][][] = [];\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(\n      data,\n      startPolygonIndex,\n      endPolygonIndex\n    ).coordinates;\n    coordinates.push(polygonCoordinates as Position[][]);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(\n  data,\n  startIndex: number = -Infinity,\n  endIndex: number = Infinity\n): LineString | MultiLineString {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates: Position[][] = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex): Point | MultiPoint {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param startIndex Start index to include in ring\n * @param endIndex End index to include in ring\n * @returns GeoJSON ring\n */\nfunction ringToGeoJson(\n  positions: BinaryAttribute,\n  startIndex?: number,\n  endIndex?: number\n): Position[] {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates: Position[] = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    const coord = Array<number>();\n    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {\n      coord.push(Number(positions.value[k]));\n    }\n    ringCoordinates.push(coord);\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"]},"metadata":{},"sourceType":"module"}