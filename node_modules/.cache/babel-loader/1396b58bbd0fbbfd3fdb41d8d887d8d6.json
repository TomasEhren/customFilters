{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransformMode = void 0;\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _translateMode = require(\"./translate-mode\");\n\nvar _scaleMode = require(\"./scale-mode\");\n\nvar _rotateMode = require(\"./rotate-mode\");\n\nvar _compositeMode = require(\"./composite-mode\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar TransformMode = /*#__PURE__*/function (_CompositeMode) {\n  _inherits(TransformMode, _CompositeMode);\n\n  var _super = _createSuper(TransformMode);\n\n  function TransformMode() {\n    _classCallCheck(this, TransformMode);\n\n    return _super.call(this, [new _translateMode.TranslateMode(), new _scaleMode.ScaleMode(), new _rotateMode.RotateMode()]);\n  }\n\n  _createClass(TransformMode, [{\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var updatedCursor = null;\n\n      _get(_getPrototypeOf(TransformMode.prototype), \"handlePointerMove\", this).call(this, event, _objectSpread({}, props, {\n        onUpdateCursor: function onUpdateCursor(cursor) {\n          updatedCursor = cursor || updatedCursor;\n        }\n      }));\n\n      props.onUpdateCursor(updatedCursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var scaleMode = null;\n      var translateMode = null;\n      var filteredModes = []; // If the user selects a scaling edit handle that overlaps with part of the selected feature,\n      // it is possible for both scale and translate actions to be triggered. This logic prevents\n      // this simultaneous action trigger from happening by putting a higher priority on scaling\n      // since the user needs to be more precise to hover over a scaling edit handle.\n\n      this._modes.forEach(function (mode) {\n        if (mode instanceof _translateMode.TranslateMode) {\n          translateMode = mode;\n        } else {\n          if (mode instanceof _scaleMode.ScaleMode) {\n            scaleMode = mode;\n          }\n\n          filteredModes.push(mode);\n        }\n      });\n\n      if (scaleMode instanceof _scaleMode.ScaleMode && !scaleMode.isEditHandleSelected()) {\n        filteredModes.push(translateMode);\n      }\n\n      filteredModes.filter(Boolean).forEach(function (mode) {\n        return mode.handleStartDragging(event, props);\n      });\n    }\n  }, {\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var compositeGuides = _get(_getPrototypeOf(TransformMode.prototype), \"getGuides\", this).call(this, props);\n\n      var rotateMode = (this._modes || []).find(function (mode) {\n        return mode instanceof _rotateMode.RotateMode;\n      });\n\n      if (rotateMode instanceof _rotateMode.RotateMode) {\n        var nonEnvelopeGuides = compositeGuides.features.filter(function (guide) {\n          var _ref = guide.properties || {},\n              editHandleType = _ref.editHandleType,\n              mode = _ref.mode; // Both scale and rotate modes have the same enveloping box as a guide - only need one\n\n\n          var guidesToFilterOut = [mode]; // Do not render scaling edit handles if rotating\n\n          if (rotateMode.getIsRotating()) {\n            guidesToFilterOut.push(editHandleType);\n          }\n\n          return !guidesToFilterOut.includes('scale');\n        }); // @ts-ignore\n\n        compositeGuides = (0, _helpers.featureCollection)(nonEnvelopeGuides);\n      }\n\n      return compositeGuides;\n    }\n  }]);\n\n  return TransformMode;\n}(_compositeMode.CompositeMode);\n\nexports.TransformMode = TransformMode;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAGA;;AACA;;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAEaA,a;;;;;EACX,yBAAc;IAAAC;;IAAA,yBACN,CAAC,IAAIC,4BAAJ,EAAD,EAAsB,IAAIC,oBAAJ,EAAtB,EAAuC,IAAIC,sBAAJ,EAAvC,CADM;EAEb;;;;sCAEiBC,OAAyBC,OAAqC;MAC9E,IAAIC,aAAa,GAAG,IAApB;;MACAC,qFAAwBH,KAAxB,oBACKC,KADL;QAEEG,cAAc,EAAE,wBAACC,MAAD,EAAY;UAC1BH,aAAa,GAAGG,MAAM,IAAIH,aAA1BA;QACD;MAJH;;MAMAD,KAAK,CAACG,cAANH,CAAqBC,aAArBD;IACD;;;wCAEmBD,OAA2BC,OAAqC;MAClF,IAAIK,SAAS,GAAG,IAAhB;MACA,IAAIC,aAAa,GAAG,IAApB;MACA,IAAMC,aAAa,GAAG,EAAtB,CAHkF,CAKlF;MACA;MACA;MACA;;MACA,KAAKC,MAAL,CAAYC,OAAZ,CAAoB,UAACC,IAAD,EAAU;QAC5B,IAAIA,IAAI,YAAYd,4BAApB,EAAmC;UACjCU,aAAa,GAAGI,IAAhBJ;QADF,OAEO;UACL,IAAII,IAAI,YAAYb,oBAApB,EAA+B;YAC7BQ,SAAS,GAAGK,IAAZL;UACD;;UACDE,aAAa,CAACI,IAAdJ,CAAmBG,IAAnBH;QACD;MARH;;MAWA,IAAIF,SAAS,YAAYR,oBAArBQ,IAAkC,CAACA,SAAS,CAACO,oBAAVP,EAAvC,EAAyE;QACvEE,aAAa,CAACI,IAAdJ,CAAmBD,aAAnBC;MACD;;MAEDA,aAAa,CAACM,MAAdN,CAAqBO,OAArBP,EAA8BE,OAA9BF,CAAsC,UAACG,IAAD;QAAA,OAAUA,IAAI,CAACK,mBAALL,CAAyBX,KAAzBW,EAAgCV,KAAhCU,CAAV;MAAtC;IACD;;;8BAESV,OAAqC;MAC7C,IAAIgB,eAAe,gFAAmBhB,KAAnB,CAAnB;;MACA,IAAMiB,UAAU,GAAG,CAAC,KAAKT,MAAL,IAAe,EAAhB,EAAoBU,IAApB,CAAyB,UAACR,IAAD;QAAA,OAAUA,IAAI,YAAYZ,sBAA1B;MAAzB,EAAnB;;MAEA,IAAImB,UAAU,YAAYnB,sBAA1B,EAAsC;QACpC,IAAMqB,iBAAiB,GAAGH,eAAe,CAACI,QAAhBJ,CAAyBH,MAAzBG,CAAgC,UAACK,KAAD,EAAW;UAAA,WACjCA,KAAK,CAACC,UAAND,IAA4B,EADK;UAAA,IAC3DE,cAD2D,QAC3DA,cAD2D;UAAA,IAC3Cb,IAD2C,QAC3CA,IAD2C,EAEnE;;;UACA,IAAMc,iBAAiB,GAAG,CAACd,IAAD,CAA1B,CAHmE,CAInE;;UACA,IAAIO,UAAU,CAACQ,aAAXR,EAAJ,EAAgC;YAC9BO,iBAAiB,CAACb,IAAlBa,CAAuBD,cAAvBC;UACD;;UACD,OAAO,CAACA,iBAAiB,CAACE,QAAlBF,CAA2B,OAA3BA,CAAR;QARwB,EAA1B,CADoC,CAWpC;;QACAR,eAAe,GAAG,gCAAkBG,iBAAlB,CAAlBH;MACD;;MACD,OAAOA,eAAP;IACD;;;;EA9DgCW,4B","names":["TransformMode","_classCallCheck","TranslateMode","ScaleMode","RotateMode","event","props","updatedCursor","_get","onUpdateCursor","cursor","scaleMode","translateMode","filteredModes","_modes","forEach","mode","push","isEditHandleSelected","filter","Boolean","handleStartDragging","compositeGuides","rotateMode","find","nonEnvelopeGuides","features","guide","properties","editHandleType","guidesToFilterOut","getIsRotating","includes","CompositeMode"],"sources":["../../src/lib/transform-mode.ts"],"sourcesContent":["import { featureCollection } from '@turf/helpers';\nimport { PointerMoveEvent, ModeProps, StartDraggingEvent } from '../types';\nimport { FeatureCollection } from '../geojson-types';\nimport { TranslateMode } from './translate-mode';\nimport { ScaleMode } from './scale-mode';\nimport { RotateMode } from './rotate-mode';\n\nimport { CompositeMode } from './composite-mode';\n\nexport class TransformMode extends CompositeMode {\n  constructor() {\n    super([new TranslateMode(), new ScaleMode(), new RotateMode()]);\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    let updatedCursor = null;\n    super.handlePointerMove(event, {\n      ...props,\n      onUpdateCursor: (cursor) => {\n        updatedCursor = cursor || updatedCursor;\n      },\n    });\n    props.onUpdateCursor(updatedCursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    let scaleMode = null;\n    let translateMode = null;\n    const filteredModes = [];\n\n    // If the user selects a scaling edit handle that overlaps with part of the selected feature,\n    // it is possible for both scale and translate actions to be triggered. This logic prevents\n    // this simultaneous action trigger from happening by putting a higher priority on scaling\n    // since the user needs to be more precise to hover over a scaling edit handle.\n    this._modes.forEach((mode) => {\n      if (mode instanceof TranslateMode) {\n        translateMode = mode;\n      } else {\n        if (mode instanceof ScaleMode) {\n          scaleMode = mode;\n        }\n        filteredModes.push(mode);\n      }\n    });\n\n    if (scaleMode instanceof ScaleMode && !scaleMode.isEditHandleSelected()) {\n      filteredModes.push(translateMode);\n    }\n\n    filteredModes.filter(Boolean).forEach((mode) => mode.handleStartDragging(event, props));\n  }\n\n  getGuides(props: ModeProps<FeatureCollection>) {\n    let compositeGuides = super.getGuides(props);\n    const rotateMode = (this._modes || []).find((mode) => mode instanceof RotateMode);\n\n    if (rotateMode instanceof RotateMode) {\n      const nonEnvelopeGuides = compositeGuides.features.filter((guide) => {\n        const { editHandleType, mode } = (guide.properties as any) || {};\n        // Both scale and rotate modes have the same enveloping box as a guide - only need one\n        const guidesToFilterOut = [mode];\n        // Do not render scaling edit handles if rotating\n        if (rotateMode.getIsRotating()) {\n          guidesToFilterOut.push(editHandleType);\n        }\n        return !guidesToFilterOut.includes('scale');\n      });\n      // @ts-ignore\n      compositeGuides = featureCollection(nonEnvelopeGuides);\n    }\n    return compositeGuides;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}