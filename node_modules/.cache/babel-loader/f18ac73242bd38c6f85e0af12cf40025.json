{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RotateMode = void 0;\n\nvar _bbox = _interopRequireDefault(require(\"@turf/bbox\"));\n\nvar _centroid = _interopRequireDefault(require(\"@turf/centroid\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _bboxPolygon = _interopRequireDefault(require(\"@turf/bbox-polygon\"));\n\nvar _distance = _interopRequireDefault(require(\"@turf/distance\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _transformRotate = _interopRequireDefault(require(\"@turf/transform-rotate\"));\n\nvar _polygonToLine = _interopRequireDefault(require(\"@turf/polygon-to-line\"));\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar RotateMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(RotateMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(RotateMode);\n\n  function RotateMode() {\n    var _this;\n\n    _classCallCheck(this, RotateMode);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"_selectedEditHandle\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_geometryBeingRotated\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isRotating\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_isSinglePointGeometrySelected\", function (geometry) {\n      var _ref = geometry || {},\n          features = _ref.features;\n\n      if (Array.isArray(features) && features.length === 1) {\n        // @ts-ignore\n        var _getGeom = (0, _invariant.getGeom)(features[0]),\n            type = _getGeom.type;\n\n        return type === 'Point';\n      }\n\n      return false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getIsRotating\", function () {\n      return _this._isRotating;\n    });\n\n    return _this;\n  }\n\n  _createClass(RotateMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var selectedGeometry = this._geometryBeingRotated || this.getSelectedFeaturesAsFeatureCollection(props);\n\n      if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n        return {\n          type: 'FeatureCollection',\n          features: []\n        };\n      }\n\n      if (this._isRotating) {\n        // Display rotate pivot\n        return (0, _helpers.featureCollection)([(0, _centroid[\"default\"])(selectedGeometry)]);\n      }\n\n      var boundingBox = (0, _bboxPolygon[\"default\"])((0, _bbox[\"default\"])(selectedGeometry));\n      var previousCoord = null;\n      var topEdgeMidpointCoords = null;\n      var longestEdgeLength = 0;\n      (0, _meta.coordEach)(boundingBox, function (coord) {\n        if (previousCoord) {\n          // @ts-ignore\n          var edgeMidpoint = (0, _geojsonEditMode.getIntermediatePosition)(coord, previousCoord);\n\n          if (!topEdgeMidpointCoords || edgeMidpoint[1] > topEdgeMidpointCoords[1]) {\n            // Get the top edge midpoint of the enveloping box\n            topEdgeMidpointCoords = edgeMidpoint;\n          } // Get the length of the longest edge of the enveloping box\n\n\n          var edgeDistance = (0, _distance[\"default\"])(coord, previousCoord);\n          longestEdgeLength = Math.max(longestEdgeLength, edgeDistance);\n        }\n\n        previousCoord = coord;\n      }); // Scale the length of the line between the rotate handler and the enveloping box\n      // relative to the length of the longest edge of the enveloping box\n\n      var rotateHandleCoords = topEdgeMidpointCoords && [topEdgeMidpointCoords[0], topEdgeMidpointCoords[1] + longestEdgeLength / 1000];\n      var lineFromEnvelopeToRotateHandle = (0, _helpers.lineString)([topEdgeMidpointCoords, rotateHandleCoords]);\n      var rotateHandle = (0, _helpers.point)(rotateHandleCoords, {\n        guideType: 'editHandle',\n        editHandleType: 'rotate'\n      }); // @ts-ignore\n\n      return (0, _helpers.featureCollection)([// @ts-ignore\n      (0, _polygonToLine[\"default\"])(boundingBox), // @ts-ignore\n      rotateHandle, // @ts-ignore\n      lineFromEnvelopeToRotateHandle]);\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      if (!this._isRotating) {\n        return;\n      }\n\n      var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, 'rotating', props);\n\n      if (rotateAction) {\n        props.onEdit(rotateAction);\n      }\n\n      event.cancelPan();\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      if (!this._isRotating) {\n        var selectedEditHandle = (0, _utils.getPickedEditHandle)(event.picks);\n        this._selectedEditHandle = selectedEditHandle && selectedEditHandle.properties.editHandleType === 'rotate' ? selectedEditHandle : null;\n      }\n\n      this.updateCursor(props);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      if (this._selectedEditHandle) {\n        this._isRotating = true;\n        this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      if (this._isRotating) {\n        // Rotate the geometry\n        var rotateAction = this.getRotateAction(event.pointerDownMapCoords, event.mapCoords, 'rotated', props);\n\n        if (rotateAction) {\n          props.onEdit(rotateAction);\n        }\n\n        this._geometryBeingRotated = null;\n        this._selectedEditHandle = null;\n        this._isRotating = false;\n      }\n    }\n  }, {\n    key: \"updateCursor\",\n    value: function updateCursor(props) {\n      if (this._selectedEditHandle) {\n        // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n        props.onUpdateCursor('crosshair');\n      } else {\n        props.onUpdateCursor(null);\n      }\n    }\n  }, {\n    key: \"getRotateAction\",\n    value: function getRotateAction(startDragPoint, currentPoint, editType, props) {\n      if (!this._geometryBeingRotated) {\n        return null;\n      }\n\n      var centroid = (0, _centroid[\"default\"])(this._geometryBeingRotated);\n      var angle = getRotationAngle(centroid, startDragPoint, currentPoint); // @ts-ignore\n\n      var rotatedFeatures = (0, _transformRotate[\"default\"])( // @ts-ignore\n      this._geometryBeingRotated, angle, {\n        pivot: centroid\n      });\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data);\n      var selectedIndexes = props.selectedIndexes;\n\n      for (var i = 0; i < selectedIndexes.length; i++) {\n        var selectedIndex = selectedIndexes[i];\n        var movedFeature = rotatedFeatures.features[i];\n        updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: editType,\n        editContext: {\n          featureIndexes: selectedIndexes\n        }\n      };\n    }\n  }]);\n\n  return RotateMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.RotateMode = RotateMode;\n\nfunction getRotationAngle(centroid, startDragPoint, currentPoint) {\n  var bearing1 = (0, _bearing[\"default\"])(centroid, startDragPoint);\n  var bearing2 = (0, _bearing[\"default\"])(centroid, currentPoint);\n  return bearing2 - bearing1;\n}","map":{"version":3,"mappings":"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","names":["RotateMode","geometry","features","Array","isArray","length","type","_this","_isRotating","props","selectedGeometry","_geometryBeingRotated","getSelectedFeaturesAsFeatureCollection","_isSinglePointGeometrySelected","boundingBox","previousCoord","topEdgeMidpointCoords","longestEdgeLength","coord","edgeMidpoint","edgeDistance","Math","max","rotateHandleCoords","lineFromEnvelopeToRotateHandle","rotateHandle","guideType","editHandleType","event","rotateAction","getRotateAction","pointerDownMapCoords","mapCoords","onEdit","cancelPan","selectedEditHandle","picks","_selectedEditHandle","properties","updateCursor","onUpdateCursor","startDragPoint","currentPoint","editType","centroid","angle","getRotationAngle","rotatedFeatures","pivot","updatedData","ImmutableFeatureCollection","data","selectedIndexes","i","selectedIndex","movedFeature","replaceGeometry","getObject","editContext","featureIndexes","GeoJsonEditMode","bearing1","bearing2"],"sources":["../../src/lib/rotate-mode.ts"],"sourcesContent":["/* eslint-disable prettier/prettier */\nimport bbox from '@turf/bbox';\nimport turfCentroid from '@turf/centroid';\nimport turfBearing from '@turf/bearing';\nimport bboxPolygon from '@turf/bbox-polygon';\nimport turfDistance from '@turf/distance';\nimport { coordEach } from '@turf/meta';\nimport { getGeom } from '@turf/invariant';\nimport { point, featureCollection, lineString } from '@turf/helpers';\nimport turfTransformRotate from '@turf/transform-rotate';\nimport polygonToLine from '@turf/polygon-to-line';\nimport {\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  ModeProps,\n  EditHandleFeature,\n  GuideFeatureCollection,\n} from '../types';\nimport { getPickedEditHandle } from '../utils';\nimport { FeatureCollection, Position } from '../geojson-types';\nimport { GeoJsonEditMode, GeoJsonEditAction, getIntermediatePosition } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class RotateMode extends GeoJsonEditMode {\n  _selectedEditHandle: EditHandleFeature | null | undefined;\n  _geometryBeingRotated: FeatureCollection | null | undefined;\n  _isRotating = false;\n\n  _isSinglePointGeometrySelected = (geometry: FeatureCollection | null | undefined): boolean => {\n    const { features } = geometry || {};\n    if (Array.isArray(features) && features.length === 1) {\n      // @ts-ignore\n      const { type } = getGeom(features[0]);\n      return type === 'Point';\n    }\n    return false;\n  };\n\n  getIsRotating = () => this._isRotating;\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const selectedGeometry =\n      this._geometryBeingRotated || this.getSelectedFeaturesAsFeatureCollection(props);\n\n    if (this._isSinglePointGeometrySelected(selectedGeometry)) {\n      return { type: 'FeatureCollection', features: [] };\n    }\n\n    if (this._isRotating) {\n      // Display rotate pivot\n      return featureCollection([turfCentroid(selectedGeometry)]) as GuideFeatureCollection;\n    }\n\n    const boundingBox = bboxPolygon(bbox(selectedGeometry));\n\n    let previousCoord = null;\n    let topEdgeMidpointCoords = null;\n    let longestEdgeLength = 0;\n\n    coordEach(boundingBox, (coord) => {\n      if (previousCoord) {\n        // @ts-ignore\n        const edgeMidpoint = getIntermediatePosition(coord, previousCoord);\n        if (!topEdgeMidpointCoords || edgeMidpoint[1] > topEdgeMidpointCoords[1]) {\n          // Get the top edge midpoint of the enveloping box\n          topEdgeMidpointCoords = edgeMidpoint;\n        }\n        // Get the length of the longest edge of the enveloping box\n        const edgeDistance = turfDistance(coord, previousCoord);\n        longestEdgeLength = Math.max(longestEdgeLength, edgeDistance);\n      }\n      previousCoord = coord;\n    });\n\n    // Scale the length of the line between the rotate handler and the enveloping box\n    // relative to the length of the longest edge of the enveloping box\n    const rotateHandleCoords = topEdgeMidpointCoords && [\n      topEdgeMidpointCoords[0],\n      topEdgeMidpointCoords[1] + longestEdgeLength / 1000,\n    ];\n\n    const lineFromEnvelopeToRotateHandle = lineString([topEdgeMidpointCoords, rotateHandleCoords]);\n    const rotateHandle = point(rotateHandleCoords, {\n      guideType: 'editHandle',\n      editHandleType: 'rotate',\n    });\n    // @ts-ignore\n    return featureCollection([\n      // @ts-ignore\n      polygonToLine(boundingBox),\n      // @ts-ignore\n      rotateHandle,\n      // @ts-ignore\n      lineFromEnvelopeToRotateHandle,\n    ]);\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isRotating) {\n      return;\n    }\n\n    const rotateAction = this.getRotateAction(\n      event.pointerDownMapCoords,\n      event.mapCoords,\n      'rotating',\n      props\n    );\n    if (rotateAction) {\n      props.onEdit(rotateAction);\n    }\n\n    event.cancelPan();\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>) {\n    if (!this._isRotating) {\n      const selectedEditHandle = getPickedEditHandle(event.picks);\n      this._selectedEditHandle =\n        selectedEditHandle && selectedEditHandle.properties.editHandleType === 'rotate'\n          ? selectedEditHandle\n          : null;\n    }\n\n    this.updateCursor(props);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      this._isRotating = true;\n      this._geometryBeingRotated = this.getSelectedFeaturesAsFeatureCollection(props);\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    if (this._isRotating) {\n      // Rotate the geometry\n      const rotateAction = this.getRotateAction(\n        event.pointerDownMapCoords,\n        event.mapCoords,\n        'rotated',\n        props\n      );\n\n      if (rotateAction) {\n        props.onEdit(rotateAction);\n      }\n\n      this._geometryBeingRotated = null;\n      this._selectedEditHandle = null;\n      this._isRotating = false;\n    }\n  }\n\n  updateCursor(props: ModeProps<FeatureCollection>) {\n    if (this._selectedEditHandle) {\n      // TODO: look at doing SVG cursors to get a better \"rotate\" cursor\n      props.onUpdateCursor('crosshair');\n    } else {\n      props.onUpdateCursor(null);\n    }\n  }\n\n  getRotateAction(\n    startDragPoint: Position,\n    currentPoint: Position,\n    editType: string,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction | null | undefined {\n    if (!this._geometryBeingRotated) {\n      return null;\n    }\n\n    const centroid = turfCentroid(this._geometryBeingRotated);\n    const angle = getRotationAngle(centroid, startDragPoint, currentPoint);\n    // @ts-ignore\n    const rotatedFeatures: FeatureCollection = turfTransformRotate(\n      // @ts-ignore\n      this._geometryBeingRotated,\n      angle,\n      {\n        pivot: centroid,\n      }\n    );\n\n    let updatedData = new ImmutableFeatureCollection(props.data);\n\n    const selectedIndexes = props.selectedIndexes;\n    for (let i = 0; i < selectedIndexes.length; i++) {\n      const selectedIndex = selectedIndexes[i];\n      const movedFeature = rotatedFeatures.features[i];\n      updatedData = updatedData.replaceGeometry(selectedIndex, movedFeature.geometry);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType,\n      editContext: {\n        featureIndexes: selectedIndexes,\n      },\n    };\n  }\n}\n\nfunction getRotationAngle(centroid: Position, startDragPoint: Position, currentPoint: Position) {\n  const bearing1 = turfBearing(centroid, startDragPoint);\n  const bearing2 = turfBearing(centroid, currentPoint);\n  return bearing2 - bearing1;\n}\n"]},"metadata":{},"sourceType":"script"}