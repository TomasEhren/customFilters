{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Model, Transform, FEATURES, hasFeatures, isWebGL2, readPixelsToBuffer, withParameters } from '@luma.gl/core';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { log, project32, _mergeShaders as mergeShaders } from '@deck.gl/core';\nimport { DEFAULT_RUN_PARAMS, MAX_32_BIT_FLOAT, MIN_BLEND_EQUATION, MAX_BLEND_EQUATION, MAX_MIN_BLEND_EQUATION, EQUATION_MAP, DEFAULT_WEIGHT_PARAMS, PIXEL_SIZE } from './gpu-grid-aggregator-constants';\nimport { AGGREGATION_OPERATION } from '../aggregation-operation-utils';\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport { getFloatTexture, getFramebuffer } from './../resource-utils.js';\nvar BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nvar ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\nvar REQUIRED_FEATURES = [FEATURES.WEBGL2, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.FLOAT_BLEND, FEATURES.TEXTURE_FLOAT];\n\nvar GPUGridAggregator = /*#__PURE__*/function () {\n  function GPUGridAggregator(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GPUGridAggregator);\n\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n      resources: {},\n      results: {}\n    };\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  _createClass(GPUGridAggregator, [{\n    key: \"delete\",\n    value: function _delete() {\n      var gridAggregationModel = this.gridAggregationModel,\n          allAggregationModel = this.allAggregationModel,\n          meanTransform = this.meanTransform;\n      var _this$state = this.state,\n          textures = _this$state.textures,\n          framebuffers = _this$state.framebuffers,\n          maxMinFramebuffers = _this$state.maxMinFramebuffers,\n          minFramebuffers = _this$state.minFramebuffers,\n          maxFramebuffers = _this$state.maxFramebuffers,\n          meanTextures = _this$state.meanTextures,\n          resources = _this$state.resources;\n      gridAggregationModel === null || gridAggregationModel === void 0 ? void 0 : gridAggregationModel.delete();\n      allAggregationModel === null || allAggregationModel === void 0 ? void 0 : allAggregationModel.delete();\n      meanTransform === null || meanTransform === void 0 ? void 0 : meanTransform.delete();\n      deleteResources([framebuffers, textures, maxMinFramebuffers, minFramebuffers, maxFramebuffers, meanTextures, resources]);\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        results: {}\n      });\n\n      var aggregationParams = this._normalizeAggregationParams(opts);\n\n      if (!this._hasGPUSupport) {\n        log.log(1, 'GPUGridAggregator: not supported')();\n      }\n\n      return this._runAggregation(aggregationParams);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData(weightId) {\n      var data = {};\n      var results = this.state.results;\n\n      if (!results[weightId].aggregationData) {\n        results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n      }\n\n      data.aggregationData = results[weightId].aggregationData;\n\n      for (var arrayName in ARRAY_BUFFER_MAP) {\n        var bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n        if (results[weightId][arrayName] || results[weightId][bufferName]) {\n          results[weightId][arrayName] = results[weightId][arrayName] || results[weightId][bufferName].getData();\n          data[arrayName] = results[weightId][arrayName];\n        }\n      }\n\n      return data;\n    }\n  }, {\n    key: \"updateShaders\",\n    value: function updateShaders() {\n      var shaderOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.setState({\n        shaderOptions: shaderOptions,\n        modelDirty: true\n      });\n    }\n  }, {\n    key: \"_normalizeAggregationParams\",\n    value: function _normalizeAggregationParams(opts) {\n      var aggregationParams = _objectSpread(_objectSpread({}, DEFAULT_RUN_PARAMS), opts);\n\n      var weights = aggregationParams.weights;\n\n      if (weights) {\n        aggregationParams.weights = normalizeWeightParams(weights);\n      }\n\n      return aggregationParams;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n    }\n  }, {\n    key: \"_getAggregateData\",\n    value: function _getAggregateData(opts) {\n      var results = {};\n      var _this$state2 = this.state,\n          textures = _this$state2.textures,\n          framebuffers = _this$state2.framebuffers,\n          maxMinFramebuffers = _this$state2.maxMinFramebuffers,\n          minFramebuffers = _this$state2.minFramebuffers,\n          maxFramebuffers = _this$state2.maxFramebuffers,\n          resources = _this$state2.resources;\n      var weights = opts.weights;\n\n      for (var id in weights) {\n        results[id] = {};\n        var _weights$id = weights[id],\n            needMin = _weights$id.needMin,\n            needMax = _weights$id.needMax,\n            combineMaxMin = _weights$id.combineMaxMin;\n        results[id].aggregationTexture = textures[id];\n        results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n          target: weights[id].aggregationBuffer,\n          sourceType: 5126\n        });\n\n        if (needMin && needMax && combineMaxMin) {\n          results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n            target: weights[id].maxMinBuffer,\n            sourceType: 5126\n          });\n          results[id].maxMinTexture = resources[\"\".concat(id, \"-maxMinTexture\")];\n        } else {\n          if (needMin) {\n            results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n              target: weights[id].minBuffer,\n              sourceType: 5126\n            });\n            results[id].minTexture = resources[\"\".concat(id, \"-minTexture\")];\n          }\n\n          if (needMax) {\n            results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n              target: weights[id].maxBuffer,\n              sourceType: 5126\n            });\n            results[id].maxTexture = resources[\"\".concat(id, \"-maxTexture\")];\n          }\n        }\n      }\n\n      this._trackGPUResultBuffers(results, weights);\n\n      return results;\n    }\n  }, {\n    key: \"_renderAggregateData\",\n    value: function _renderAggregateData(opts) {\n      var cellSize = opts.cellSize,\n          projectPoints = opts.projectPoints,\n          attributes = opts.attributes,\n          moduleSettings = opts.moduleSettings,\n          numCol = opts.numCol,\n          numRow = opts.numRow,\n          weights = opts.weights,\n          translation = opts.translation,\n          scaling = opts.scaling;\n      var _this$state3 = this.state,\n          maxMinFramebuffers = _this$state3.maxMinFramebuffers,\n          minFramebuffers = _this$state3.minFramebuffers,\n          maxFramebuffers = _this$state3.maxFramebuffers;\n      var gridSize = [numCol, numRow];\n      var parameters = {\n        blend: true,\n        depthTest: false,\n        blendFunc: [1, 1]\n      };\n      var uniforms = {\n        cellSize: cellSize,\n        gridSize: gridSize,\n        projectPoints: projectPoints,\n        translation: translation,\n        scaling: scaling\n      };\n\n      for (var id in weights) {\n        var _weights$id2 = weights[id],\n            needMin = _weights$id2.needMin,\n            needMax = _weights$id2.needMax;\n        var combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n\n        this._renderToWeightsTexture({\n          id: id,\n          parameters: parameters,\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          gridSize: gridSize,\n          attributes: attributes,\n          weights: weights\n        });\n\n        if (combineMaxMin) {\n          this._renderToMaxMinTexture({\n            id: id,\n            parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n              blendEquation: MAX_MIN_BLEND_EQUATION\n            }),\n            gridSize: gridSize,\n            minOrMaxFb: maxMinFramebuffers[id],\n            clearParams: {\n              clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]\n            },\n            combineMaxMin: combineMaxMin\n          });\n        } else {\n          if (needMin) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n                blendEquation: MIN_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: minFramebuffers[id],\n              clearParams: {\n                clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n\n          if (needMax) {\n            this._renderToMaxMinTexture({\n              id: id,\n              parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n                blendEquation: MAX_BLEND_EQUATION\n              }),\n              gridSize: gridSize,\n              minOrMaxFb: maxFramebuffers[id],\n              clearParams: {\n                clearColor: [0, 0, 0, 0]\n              },\n              combineMaxMin: combineMaxMin\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_renderToMaxMinTexture\",\n    value: function _renderToMaxMinTexture(opts) {\n      var id = opts.id,\n          parameters = opts.parameters,\n          gridSize = opts.gridSize,\n          minOrMaxFb = opts.minOrMaxFb,\n          combineMaxMin = opts.combineMaxMin,\n          _opts$clearParams = opts.clearParams,\n          clearParams = _opts$clearParams === void 0 ? {} : _opts$clearParams;\n      var framebuffers = this.state.framebuffers;\n      var gl = this.gl,\n          allAggregationModel = this.allAggregationModel;\n      withParameters(gl, _objectSpread(_objectSpread({}, clearParams), {}, {\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      }), function () {\n        gl.clear(16384);\n        allAggregationModel.draw({\n          parameters: parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize: gridSize,\n            combineMaxMin: combineMaxMin\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_renderToWeightsTexture\",\n    value: function _renderToWeightsTexture(opts) {\n      var id = opts.id,\n          parameters = opts.parameters,\n          moduleSettings = opts.moduleSettings,\n          uniforms = opts.uniforms,\n          gridSize = opts.gridSize,\n          weights = opts.weights;\n      var _this$state4 = this.state,\n          framebuffers = _this$state4.framebuffers,\n          equations = _this$state4.equations,\n          weightAttributes = _this$state4.weightAttributes;\n      var gl = this.gl,\n          gridAggregationModel = this.gridAggregationModel;\n      var operation = weights[id].operation;\n      var clearColor = operation === AGGREGATION_OPERATION.MIN ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0] : [0, 0, 0, 0];\n      withParameters(gl, {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor: clearColor\n      }, function () {\n        gl.clear(16384);\n        var attributes = {\n          weights: weightAttributes[id]\n        };\n        gridAggregationModel.draw({\n          parameters: _objectSpread(_objectSpread({}, parameters), {}, {\n            blendEquation: equations[id]\n          }),\n          moduleSettings: moduleSettings,\n          uniforms: uniforms,\n          attributes: attributes\n        });\n      });\n\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        var _this$state5 = this.state,\n            meanTextures = _this$state5.meanTextures,\n            textures = _this$state5.textures;\n        var transformOptions = {\n          _sourceTextures: {\n            aggregationValues: meanTextures[id]\n          },\n          _targetTexture: textures[id],\n          elementCount: textures[id].width * textures[id].height\n        };\n\n        if (this.meanTransform) {\n          this.meanTransform.update(transformOptions);\n        } else {\n          this.meanTransform = getMeanTransform(gl, transformOptions);\n        }\n\n        this.meanTransform.run({\n          parameters: {\n            blend: false,\n            depthTest: false\n          }\n        });\n        framebuffers[id].attach(_defineProperty({}, 36064, textures[id]));\n      }\n    }\n  }, {\n    key: \"_runAggregation\",\n    value: function _runAggregation(opts) {\n      this._updateModels(opts);\n\n      this._setupFramebuffers(opts);\n\n      this._renderAggregateData(opts);\n\n      var results = this._getAggregateData(opts);\n\n      this.setState({\n        results: results\n      });\n      return results;\n    }\n  }, {\n    key: \"_setupFramebuffers\",\n    value: function _setupFramebuffers(opts) {\n      var _this$state6 = this.state,\n          textures = _this$state6.textures,\n          framebuffers = _this$state6.framebuffers,\n          maxMinFramebuffers = _this$state6.maxMinFramebuffers,\n          minFramebuffers = _this$state6.minFramebuffers,\n          maxFramebuffers = _this$state6.maxFramebuffers,\n          meanTextures = _this$state6.meanTextures,\n          equations = _this$state6.equations;\n      var weights = opts.weights;\n      var numCol = opts.numCol,\n          numRow = opts.numRow;\n      var framebufferSize = {\n        width: numCol,\n        height: numRow\n      };\n\n      for (var id in weights) {\n        var _weights$id3 = weights[id],\n            needMin = _weights$id3.needMin,\n            needMax = _weights$id3.needMax,\n            combineMaxMin = _weights$id3.combineMaxMin,\n            operation = _weights$id3.operation;\n        textures[id] = weights[id].aggregationTexture || textures[id] || getFloatTexture(this.gl, {\n          id: \"\".concat(id, \"-texture\"),\n          width: numCol,\n          height: numRow\n        });\n        textures[id].resize(framebufferSize);\n        var texture = textures[id];\n\n        if (operation === AGGREGATION_OPERATION.MEAN) {\n          meanTextures[id] = meanTextures[id] || getFloatTexture(this.gl, {\n            id: \"\".concat(id, \"-mean-texture\"),\n            width: numCol,\n            height: numRow\n          });\n          meanTextures[id].resize(framebufferSize);\n          texture = meanTextures[id];\n        }\n\n        if (framebuffers[id]) {\n          framebuffers[id].attach(_defineProperty({}, 36064, texture));\n        } else {\n          framebuffers[id] = getFramebuffer(this.gl, {\n            id: \"\".concat(id, \"-fb\"),\n            width: numCol,\n            height: numRow,\n            texture: texture\n          });\n        }\n\n        framebuffers[id].resize(framebufferSize);\n        equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n\n        if (needMin || needMax) {\n          if (needMin && needMax && combineMaxMin) {\n            if (!maxMinFramebuffers[id]) {\n              texture = weights[id].maxMinTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxMinTexture\"));\n              maxMinFramebuffers[id] = getFramebuffer(this.gl, {\n                id: \"\".concat(id, \"-maxMinFb\"),\n                texture: texture\n              });\n            }\n          } else {\n            if (needMin) {\n              if (!minFramebuffers[id]) {\n                texture = weights[id].minTexture || this._getMinMaxTexture(\"\".concat(id, \"-minTexture\"));\n                minFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-minFb\"),\n                  texture: texture\n                });\n              }\n            }\n\n            if (needMax) {\n              if (!maxFramebuffers[id]) {\n                texture = weights[id].maxTexture || this._getMinMaxTexture(\"\".concat(id, \"-maxTexture\"));\n                maxFramebuffers[id] = getFramebuffer(this.gl, {\n                  id: \"\".concat(id, \"-maxFb\"),\n                  texture: texture\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_getMinMaxTexture\",\n    value: function _getMinMaxTexture(name) {\n      var resources = this.state.resources;\n\n      if (!resources[name]) {\n        resources[name] = getFloatTexture(this.gl, {\n          id: \"resourceName\"\n        });\n      }\n\n      return resources[name];\n    }\n  }, {\n    key: \"_setupModels\",\n    value: function _setupModels() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$numCol = _ref.numCol,\n          numCol = _ref$numCol === void 0 ? 0 : _ref$numCol,\n          _ref$numRow = _ref.numRow,\n          numRow = _ref$numRow === void 0 ? 0 : _ref$numRow;\n\n      var _this$gridAggregation;\n\n      var gl = this.gl;\n      var shaderOptions = this.state.shaderOptions;\n      (_this$gridAggregation = this.gridAggregationModel) === null || _this$gridAggregation === void 0 ? void 0 : _this$gridAggregation.delete();\n      this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n\n      if (!this.allAggregationModel) {\n        var instanceCount = numCol * numRow;\n        this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n      }\n    }\n  }, {\n    key: \"_setupWeightAttributes\",\n    value: function _setupWeightAttributes(opts) {\n      var weightAttributes = this.state.weightAttributes;\n      var weights = opts.weights;\n\n      for (var id in weights) {\n        weightAttributes[id] = opts.attributes[id];\n      }\n    }\n  }, {\n    key: \"_trackGPUResultBuffers\",\n    value: function _trackGPUResultBuffers(results, weights) {\n      var resources = this.state.resources;\n\n      for (var id in results) {\n        if (results[id]) {\n          var _iterator = _createForOfIteratorHelper(BUFFER_NAMES),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var bufferName = _step.value;\n\n              if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n                var name = \"gpu-result-\".concat(id, \"-\").concat(bufferName);\n\n                if (resources[name]) {\n                  resources[name].delete();\n                }\n\n                resources[name] = results[id][bufferName];\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_updateModels\",\n    value: function _updateModels(opts) {\n      var vertexCount = opts.vertexCount,\n          attributes = opts.attributes,\n          numCol = opts.numCol,\n          numRow = opts.numRow;\n      var modelDirty = this.state.modelDirty;\n\n      if (modelDirty) {\n        this._setupModels(opts);\n\n        this.setState({\n          modelDirty: false\n        });\n      }\n\n      this._setupWeightAttributes(opts);\n\n      this.gridAggregationModel.setVertexCount(vertexCount);\n      this.gridAggregationModel.setAttributes(attributes);\n      this.allAggregationModel.setInstanceCount(numCol * numRow);\n    }\n  }], [{\n    key: \"getAggregationData\",\n    value: function getAggregationData(_ref2) {\n      var aggregationData = _ref2.aggregationData,\n          maxData = _ref2.maxData,\n          minData = _ref2.minData,\n          maxMinData = _ref2.maxMinData,\n          pixelIndex = _ref2.pixelIndex;\n      var index = pixelIndex * PIXEL_SIZE;\n      var results = {};\n\n      if (aggregationData) {\n        results.cellCount = aggregationData[index + 3];\n        results.cellWeight = aggregationData[index];\n      }\n\n      if (maxMinData) {\n        results.maxCellWieght = maxMinData[0];\n        results.minCellWeight = maxMinData[3];\n      } else {\n        if (maxData) {\n          results.maxCellWieght = maxData[0];\n          results.totalCount = maxData[3];\n        }\n\n        if (minData) {\n          results.minCellWeight = minData[0];\n          results.totalCount = maxData[3];\n        }\n      }\n\n      return results;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(_ref3) {\n      var countsData = _ref3.countsData,\n          _ref3$size = _ref3.size,\n          size = _ref3$size === void 0 ? 1 : _ref3$size;\n      var numCells = countsData.length / 4;\n      var cellWeights = new Float32Array(numCells * size);\n      var cellCounts = new Uint32Array(numCells);\n\n      for (var i = 0; i < numCells; i++) {\n        for (var sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n          cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n        }\n\n        cellCounts[i] = countsData[i * 4 + 3];\n      }\n\n      return {\n        cellCounts: cellCounts,\n        cellWeights: cellWeights\n      };\n    }\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return hasFeatures(gl, REQUIRED_FEATURES);\n    }\n  }]);\n\n  return GPUGridAggregator;\n}();\n\nexport { GPUGridAggregator as default };\n\nfunction normalizeWeightParams(weights) {\n  var result = {};\n\n  for (var id in weights) {\n    result[id] = _objectSpread(_objectSpread({}, DEFAULT_WEIGHT_PARAMS), weights[id]);\n  }\n\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(function (obj) {\n    for (var name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  var shaders = mergeShaders({\n    vs: AGGREGATE_TO_GRID_VS,\n    fs: AGGREGATE_TO_GRID_FS,\n    modules: [fp64arithmetic, project32]\n  }, shaderOptions);\n  return new Model(gl, _objectSpread({\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: 0\n  }, shaders));\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: 0,\n    isInstanced: true,\n    instanceCount: instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, _objectSpread({\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues'\n  }, opts));\n}","map":{"version":3,"mappings":"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","names":["Model","Transform","FEATURES","hasFeatures","isWebGL2","readPixelsToBuffer","withParameters","fp64arithmetic","log","project32","_mergeShaders","mergeShaders","DEFAULT_RUN_PARAMS","MAX_32_BIT_FLOAT","MIN_BLEND_EQUATION","MAX_BLEND_EQUATION","MAX_MIN_BLEND_EQUATION","EQUATION_MAP","DEFAULT_WEIGHT_PARAMS","PIXEL_SIZE","AGGREGATION_OPERATION","AGGREGATE_TO_GRID_VS","AGGREGATE_TO_GRID_FS","AGGREGATE_ALL_VS","AGGREGATE_ALL_FS","TRANSFORM_MEAN_VS","getFloatTexture","getFramebuffer","BUFFER_NAMES","ARRAY_BUFFER_MAP","maxData","minData","maxMinData","REQUIRED_FEATURES","WEBGL2","COLOR_ATTACHMENT_RGBA32F","BLEND_EQUATION_MINMAX","FLOAT_BLEND","TEXTURE_FLOAT","GPUGridAggregator","constructor","gl","opts","id","state","weightAttributes","textures","meanTextures","buffers","framebuffers","maxMinFramebuffers","minFramebuffers","maxFramebuffers","equations","resources","results","_hasGPUSupport","_setupModels","delete","gridAggregationModel","allAggregationModel","meanTransform","deleteResources","run","setState","aggregationParams","_normalizeAggregationParams","_runAggregation","getData","weightId","data","aggregationData","aggregationBuffer","arrayName","bufferName","updateShaders","shaderOptions","modelDirty","weights","normalizeWeightParams","updateObject","Object","assign","_getAggregateData","needMin","needMax","combineMaxMin","aggregationTexture","target","sourceType","maxMinBuffer","maxMinTexture","minBuffer","minTexture","maxBuffer","maxTexture","_trackGPUResultBuffers","_renderAggregateData","cellSize","projectPoints","attributes","moduleSettings","numCol","numRow","translation","scaling","gridSize","parameters","blend","depthTest","blendFunc","uniforms","_renderToWeightsTexture","_renderToMaxMinTexture","blendEquation","minOrMaxFb","clearParams","clearColor","framebuffer","viewport","clear","draw","uSampler","texture","operation","MIN","MEAN","transformOptions","_sourceTextures","aggregationValues","_targetTexture","elementCount","width","height","update","getMeanTransform","attach","_updateModels","_setupFramebuffers","framebufferSize","resize","SUM","_getMinMaxTexture","name","getAggregationModel","instanceCount","getAllAggregationModel","_setupWeightAttributes","vertexCount","setVertexCount","setAttributes","setInstanceCount","pixelIndex","index","cellCount","cellWeight","maxCellWieght","minCellWeight","totalCount","countsData","size","numCells","length","cellWeights","Float32Array","cellCounts","Uint32Array","i","sizeIndex","result","Array","isArray","forEach","obj","shaders","vs","fs","modules","drawMode","isInstanced","position","_targetTextureVarying"],"sources":["../../../../src/utils/gpu-grid-aggregation/gpu-grid-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {\n  Model,\n  Transform,\n  FEATURES,\n  hasFeatures,\n  isWebGL2,\n  readPixelsToBuffer,\n  withParameters\n} from '@luma.gl/core';\nimport {fp64arithmetic} from '@luma.gl/shadertools';\nimport {log, project32, _mergeShaders as mergeShaders} from '@deck.gl/core';\n\nimport {\n  DEFAULT_RUN_PARAMS,\n  MAX_32_BIT_FLOAT,\n  MIN_BLEND_EQUATION,\n  MAX_BLEND_EQUATION,\n  MAX_MIN_BLEND_EQUATION,\n  EQUATION_MAP,\n  DEFAULT_WEIGHT_PARAMS,\n  PIXEL_SIZE\n} from './gpu-grid-aggregator-constants';\nimport {AGGREGATION_OPERATION} from '../aggregation-operation-utils';\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS from './aggregate-all-vs.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nimport TRANSFORM_MEAN_VS from './transform-mean-vs.glsl';\nimport {getFloatTexture, getFramebuffer} from './../resource-utils.js';\n\nconst BUFFER_NAMES = ['aggregationBuffer', 'maxMinBuffer', 'minBuffer', 'maxBuffer'];\nconst ARRAY_BUFFER_MAP = {\n  maxData: 'maxBuffer',\n  minData: 'minBuffer',\n  maxMinData: 'maxMinBuffer'\n};\n\nconst REQUIRED_FEATURES = [\n  FEATURES.WEBGL2, // TODO: Remove after trannsform refactor\n  FEATURES.COLOR_ATTACHMENT_RGBA32F,\n  FEATURES.BLEND_EQUATION_MINMAX,\n  FEATURES.FLOAT_BLEND,\n  FEATURES.TEXTURE_FLOAT\n];\n\nexport default class GPUGridAggregator {\n  // Decode and return aggregation data of given pixel.\n  static getAggregationData({aggregationData, maxData, minData, maxMinData, pixelIndex}) {\n    const index = pixelIndex * PIXEL_SIZE;\n    const results = {};\n    if (aggregationData) {\n      results.cellCount = aggregationData[index + 3];\n      results.cellWeight = aggregationData[index];\n    }\n    if (maxMinData) {\n      results.maxCellWieght = maxMinData[0];\n      results.minCellWeight = maxMinData[3];\n    } else {\n      if (maxData) {\n        results.maxCellWieght = maxData[0];\n        results.totalCount = maxData[3];\n      }\n      if (minData) {\n        results.minCellWeight = minData[0];\n        results.totalCount = maxData[3];\n      }\n    }\n    return results;\n  }\n\n  // Decodes and retuns counts and weights of all cells\n  static getCellData({countsData, size = 1}) {\n    const numCells = countsData.length / 4;\n    const cellWeights = new Float32Array(numCells * size);\n    const cellCounts = new Uint32Array(numCells);\n    for (let i = 0; i < numCells; i++) {\n      // weights in RGB channels\n      for (let sizeIndex = 0; sizeIndex < size; sizeIndex++) {\n        cellWeights[i * size + sizeIndex] = countsData[i * 4 + sizeIndex];\n      }\n      // count in Alpha channel\n      cellCounts[i] = countsData[i * 4 + 3];\n    }\n    return {cellCounts, cellWeights};\n  }\n\n  static isSupported(gl) {\n    return hasFeatures(gl, REQUIRED_FEATURES);\n  }\n\n  // DEBUG ONLY\n  // static logData({aggregationBuffer, minBuffer, maxBuffer, maxMinBuffer, limit = 10}) {\n  //   if (aggregationBuffer) {\n  //     console.log('Aggregation Data:');\n  //     const agrData = aggregationBuffer.getData();\n  //     for (let index = 0; index < agrData.length && limit > 0; index += 4) {\n  //       if (agrData[index + 3] > 0) {\n  //         console.log(\n  //           `index: ${index} weights: ${agrData[index]} ${agrData[index + 1]} ${\n  //             agrData[index + 2]\n  //           } count: ${agrData[index + 3]}`\n  //         );\n  //         limit--;\n  //       }\n  //     }\n  //   }\n  //   const obj = {minBuffer, maxBuffer, maxMinBuffer};\n  //   for (const key in obj) {\n  //     if (obj[key]) {\n  //       const data = obj[key].getData();\n  //       console.log(`${key} data : R: ${data[0]} G: ${data[1]} B: ${data[2]} A: ${data[3]}`);\n  //     }\n  //   }\n  // }\n\n  constructor(gl, opts = {}) {\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.gl = gl;\n    this.state = {\n      // per weight GPU resources\n      weightAttributes: {},\n      textures: {},\n      meanTextures: {},\n      buffers: {},\n      framebuffers: {},\n      maxMinFramebuffers: {},\n      minFramebuffers: {},\n      maxFramebuffers: {},\n      equations: {},\n\n      // common resources to be deleted\n      resources: {},\n\n      // results\n      results: {}\n    };\n    this._hasGPUSupport =\n      isWebGL2(gl) && // gl_InstanceID usage in min/max calculation shaders\n      hasFeatures(\n        this.gl,\n        FEATURES.BLEND_EQUATION_MINMAX, // set min/max blend modes\n        FEATURES.COLOR_ATTACHMENT_RGBA32F, // render to float texture\n        FEATURES.TEXTURE_FLOAT // sample from a float texture\n      );\n    if (this._hasGPUSupport) {\n      this._setupModels();\n    }\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {gridAggregationModel, allAggregationModel, meanTransform} = this;\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    } = this.state;\n\n    gridAggregationModel?.delete();\n    allAggregationModel?.delete();\n    meanTransform?.delete();\n\n    deleteResources([\n      framebuffers,\n      textures,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      resources\n    ]);\n  }\n\n  // Perform aggregation and retun the results\n  run(opts = {}) {\n    // reset results\n    this.setState({results: {}});\n    const aggregationParams = this._normalizeAggregationParams(opts);\n    if (!this._hasGPUSupport) {\n      log.log(1, 'GPUGridAggregator: not supported')();\n    }\n    return this._runAggregation(aggregationParams);\n  }\n\n  // Reads aggregation data into JS Array object\n  // For WebGL1, data is available in JS Array objects already.\n  // For WebGL2, data is read from Buffer objects and cached for subsequent queries.\n  getData(weightId) {\n    const data = {};\n    const results = this.state.results;\n    if (!results[weightId].aggregationData) {\n      // cache the results if reading from the buffer (WebGL2 path)\n      results[weightId].aggregationData = results[weightId].aggregationBuffer.getData();\n    }\n    data.aggregationData = results[weightId].aggregationData;\n\n    // Check for optional results\n    for (const arrayName in ARRAY_BUFFER_MAP) {\n      const bufferName = ARRAY_BUFFER_MAP[arrayName];\n\n      if (results[weightId][arrayName] || results[weightId][bufferName]) {\n        // cache the result\n        results[weightId][arrayName] =\n          results[weightId][arrayName] || results[weightId][bufferName].getData();\n        data[arrayName] = results[weightId][arrayName];\n      }\n    }\n    return data;\n  }\n\n  updateShaders(shaderOptions = {}) {\n    this.setState({shaderOptions, modelDirty: true});\n  }\n\n  // PRIVATE\n\n  _normalizeAggregationParams(opts) {\n    const aggregationParams = {...DEFAULT_RUN_PARAMS, ...opts};\n    const {weights} = aggregationParams;\n    if (weights) {\n      aggregationParams.weights = normalizeWeightParams(weights);\n    }\n    return aggregationParams;\n  }\n\n  // Update priveate state\n  setState(updateObject) {\n    Object.assign(this.state, updateObject);\n  }\n\n  // GPU Aggregation methods\n\n  _getAggregateData(opts) {\n    const results = {};\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      resources\n    } = this.state;\n    const {weights} = opts;\n\n    for (const id in weights) {\n      results[id] = {};\n      const {needMin, needMax, combineMaxMin} = weights[id];\n      results[id].aggregationTexture = textures[id];\n      results[id].aggregationBuffer = readPixelsToBuffer(framebuffers[id], {\n        target: weights[id].aggregationBuffer, // update if a buffer is provided\n        sourceType: GL.FLOAT\n      });\n      if (needMin && needMax && combineMaxMin) {\n        results[id].maxMinBuffer = readPixelsToBuffer(maxMinFramebuffers[id], {\n          target: weights[id].maxMinBuffer, // update if a buffer is provided\n          sourceType: GL.FLOAT\n        });\n        results[id].maxMinTexture = resources[`${id}-maxMinTexture`];\n      } else {\n        if (needMin) {\n          results[id].minBuffer = readPixelsToBuffer(minFramebuffers[id], {\n            target: weights[id].minBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].minTexture = resources[`${id}-minTexture`];\n        }\n        if (needMax) {\n          results[id].maxBuffer = readPixelsToBuffer(maxFramebuffers[id], {\n            target: weights[id].maxBuffer, // update if a buffer is provided\n            sourceType: GL.FLOAT\n          });\n          results[id].maxTexture = resources[`${id}-maxTexture`];\n        }\n      }\n    }\n    this._trackGPUResultBuffers(results, weights);\n    return results;\n  }\n\n  _renderAggregateData(opts) {\n    const {\n      cellSize,\n      projectPoints,\n      attributes,\n      moduleSettings,\n      numCol,\n      numRow,\n      weights,\n      translation,\n      scaling\n    } = opts;\n    const {maxMinFramebuffers, minFramebuffers, maxFramebuffers} = this.state;\n\n    const gridSize = [numCol, numRow];\n    const parameters = {\n      blend: true,\n      depthTest: false,\n      blendFunc: [GL.ONE, GL.ONE]\n    };\n    const uniforms = {\n      cellSize,\n      gridSize,\n      projectPoints,\n      translation,\n      scaling\n    };\n\n    for (const id in weights) {\n      const {needMin, needMax} = weights[id];\n      const combineMaxMin = needMin && needMax && weights[id].combineMaxMin;\n      this._renderToWeightsTexture({\n        id,\n        parameters,\n        moduleSettings,\n        uniforms,\n        gridSize,\n        attributes,\n        weights\n      });\n      if (combineMaxMin) {\n        this._renderToMaxMinTexture({\n          id,\n          parameters: {...parameters, blendEquation: MAX_MIN_BLEND_EQUATION},\n          gridSize,\n          minOrMaxFb: maxMinFramebuffers[id],\n          clearParams: {clearColor: [0, 0, 0, MAX_32_BIT_FLOAT]},\n          combineMaxMin\n        });\n      } else {\n        if (needMin) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MIN_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: minFramebuffers[id],\n            clearParams: {clearColor: [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]},\n            combineMaxMin\n          });\n        }\n        if (needMax) {\n          this._renderToMaxMinTexture({\n            id,\n            parameters: {...parameters, blendEquation: MAX_BLEND_EQUATION},\n            gridSize,\n            minOrMaxFb: maxFramebuffers[id],\n            clearParams: {clearColor: [0, 0, 0, 0]},\n            combineMaxMin\n          });\n        }\n      }\n    }\n  }\n\n  // render all aggregated grid-cells to generate Min, Max or MaxMin data texture\n  _renderToMaxMinTexture(opts) {\n    const {id, parameters, gridSize, minOrMaxFb, combineMaxMin, clearParams = {}} = opts;\n    const {framebuffers} = this.state;\n    const {gl, allAggregationModel} = this;\n\n    withParameters(\n      gl,\n      {\n        ...clearParams,\n        framebuffer: minOrMaxFb,\n        viewport: [0, 0, gridSize[0], gridSize[1]]\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        allAggregationModel.draw({\n          parameters,\n          uniforms: {\n            uSampler: framebuffers[id].texture,\n            gridSize,\n            combineMaxMin\n          }\n        });\n      }\n    );\n  }\n\n  // render all data points to aggregate weights\n  _renderToWeightsTexture(opts) {\n    const {id, parameters, moduleSettings, uniforms, gridSize, weights} = opts;\n    const {framebuffers, equations, weightAttributes} = this.state;\n    const {gl, gridAggregationModel} = this;\n    const {operation} = weights[id];\n\n    const clearColor =\n      operation === AGGREGATION_OPERATION.MIN\n        ? [MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, MAX_32_BIT_FLOAT, 0]\n        : [0, 0, 0, 0];\n    withParameters(\n      gl,\n      {\n        framebuffer: framebuffers[id],\n        viewport: [0, 0, gridSize[0], gridSize[1]],\n        clearColor\n      },\n      () => {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        const attributes = {weights: weightAttributes[id]};\n        gridAggregationModel.draw({\n          parameters: {...parameters, blendEquation: equations[id]},\n          moduleSettings,\n          uniforms,\n          attributes\n        });\n      }\n    );\n\n    if (operation === AGGREGATION_OPERATION.MEAN) {\n      const {meanTextures, textures} = this.state;\n      const transformOptions = {\n        _sourceTextures: {aggregationValues: meanTextures[id]}, // contains aggregated data\n        _targetTexture: textures[id], // store mean values,\n        elementCount: textures[id].width * textures[id].height\n      };\n      if (this.meanTransform) {\n        this.meanTransform.update(transformOptions);\n      } else {\n        this.meanTransform = getMeanTransform(gl, transformOptions);\n      }\n      this.meanTransform.run({\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      });\n\n      // update framebuffer with mean results so readPixelsToBuffer returns mean values\n      framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: textures[id]});\n    }\n  }\n\n  _runAggregation(opts) {\n    this._updateModels(opts);\n    this._setupFramebuffers(opts);\n    this._renderAggregateData(opts);\n    const results = this._getAggregateData(opts);\n    this.setState({results});\n    return results;\n  }\n\n  // set up framebuffer for each weight\n  /* eslint-disable complexity, max-depth, max-statements*/\n  _setupFramebuffers(opts) {\n    const {\n      textures,\n      framebuffers,\n      maxMinFramebuffers,\n      minFramebuffers,\n      maxFramebuffers,\n      meanTextures,\n      equations\n    } = this.state;\n    const {weights} = opts;\n    const {numCol, numRow} = opts;\n    const framebufferSize = {width: numCol, height: numRow};\n    for (const id in weights) {\n      const {needMin, needMax, combineMaxMin, operation} = weights[id];\n      textures[id] =\n        weights[id].aggregationTexture ||\n        textures[id] ||\n        getFloatTexture(this.gl, {id: `${id}-texture`, width: numCol, height: numRow});\n      textures[id].resize(framebufferSize);\n      let texture = textures[id];\n      if (operation === AGGREGATION_OPERATION.MEAN) {\n        // For MEAN, we first aggregatet into a temp texture\n        meanTextures[id] =\n          meanTextures[id] ||\n          getFloatTexture(this.gl, {id: `${id}-mean-texture`, width: numCol, height: numRow});\n        meanTextures[id].resize(framebufferSize);\n        texture = meanTextures[id];\n      }\n      if (framebuffers[id]) {\n        framebuffers[id].attach({[GL.COLOR_ATTACHMENT0]: texture});\n      } else {\n        framebuffers[id] = getFramebuffer(this.gl, {\n          id: `${id}-fb`,\n          width: numCol,\n          height: numRow,\n          texture\n        });\n      }\n      framebuffers[id].resize(framebufferSize);\n      equations[id] = EQUATION_MAP[operation] || EQUATION_MAP.SUM;\n      // For min/max framebuffers will use default size 1X1\n      if (needMin || needMax) {\n        if (needMin && needMax && combineMaxMin) {\n          if (!maxMinFramebuffers[id]) {\n            texture = weights[id].maxMinTexture || this._getMinMaxTexture(`${id}-maxMinTexture`);\n            maxMinFramebuffers[id] = getFramebuffer(this.gl, {id: `${id}-maxMinFb`, texture});\n          }\n        } else {\n          if (needMin) {\n            if (!minFramebuffers[id]) {\n              texture = weights[id].minTexture || this._getMinMaxTexture(`${id}-minTexture`);\n              minFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-minFb`,\n                texture\n              });\n            }\n          }\n          if (needMax) {\n            if (!maxFramebuffers[id]) {\n              texture = weights[id].maxTexture || this._getMinMaxTexture(`${id}-maxTexture`);\n              maxFramebuffers[id] = getFramebuffer(this.gl, {\n                id: `${id}-maxFb`,\n                texture\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable complexity, max-depth, max-statements */\n\n  _getMinMaxTexture(name) {\n    const {resources} = this.state;\n    if (!resources[name]) {\n      resources[name] = getFloatTexture(this.gl, {id: `resourceName`});\n    }\n    return resources[name];\n  }\n\n  _setupModels({numCol = 0, numRow = 0} = {}) {\n    const {gl} = this;\n    const {shaderOptions} = this.state;\n    this.gridAggregationModel?.delete();\n    this.gridAggregationModel = getAggregationModel(gl, shaderOptions);\n    if (!this.allAggregationModel) {\n      const instanceCount = numCol * numRow;\n      this.allAggregationModel = getAllAggregationModel(gl, instanceCount);\n    }\n  }\n\n  // set up buffers for all weights\n  _setupWeightAttributes(opts) {\n    const {weightAttributes} = this.state;\n    const {weights} = opts;\n    for (const id in weights) {\n      weightAttributes[id] = opts.attributes[id];\n    }\n  }\n\n  // GPU Aggregation results are provided in Buffers, if new Buffer objects are created track them for later deletion.\n  /* eslint-disable max-depth */\n  _trackGPUResultBuffers(results, weights) {\n    const {resources} = this.state;\n    for (const id in results) {\n      if (results[id]) {\n        for (const bufferName of BUFFER_NAMES) {\n          if (results[id][bufferName] && weights[id][bufferName] !== results[id][bufferName]) {\n            // No result buffer is provided in weights object, `readPixelsToBuffer` has created a new Buffer object\n            // collect the new buffer for garabge collection\n            const name = `gpu-result-${id}-${bufferName}`;\n            if (resources[name]) {\n              resources[name].delete();\n            }\n            resources[name] = results[id][bufferName];\n          }\n        }\n      }\n    }\n  }\n  /* eslint-enable max-depth */\n\n  _updateModels(opts) {\n    const {vertexCount, attributes, numCol, numRow} = opts;\n    const {modelDirty} = this.state;\n\n    if (modelDirty) {\n      this._setupModels(opts);\n      this.setState({modelDirty: false});\n    }\n\n    // this maps color/elevation to weight name.\n    this._setupWeightAttributes(opts);\n\n    this.gridAggregationModel.setVertexCount(vertexCount);\n    this.gridAggregationModel.setAttributes(attributes);\n\n    this.allAggregationModel.setInstanceCount(numCol * numRow);\n  }\n}\n\n// HELPER METHODS\n\nfunction normalizeWeightParams(weights) {\n  const result = {};\n  for (const id in weights) {\n    result[id] = {...DEFAULT_WEIGHT_PARAMS, ...weights[id]};\n  }\n  return result;\n}\n\nfunction deleteResources(resources) {\n  resources = Array.isArray(resources) ? resources : [resources];\n  resources.forEach(obj => {\n    for (const name in obj) {\n      obj[name].delete();\n    }\n  });\n}\n\nfunction getAggregationModel(gl, shaderOptions) {\n  const shaders = mergeShaders(\n    {\n      vs: AGGREGATE_TO_GRID_VS,\n      fs: AGGREGATE_TO_GRID_FS,\n      modules: [fp64arithmetic, project32]\n    },\n    shaderOptions\n  );\n\n  return new Model(gl, {\n    id: 'Gird-Aggregation-Model',\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    ...shaders\n  });\n}\n\nfunction getAllAggregationModel(gl, instanceCount) {\n  return new Model(gl, {\n    id: 'All-Aggregation-Model',\n    vs: AGGREGATE_ALL_VS,\n    fs: AGGREGATE_ALL_FS,\n    modules: [fp64arithmetic],\n    vertexCount: 1,\n    drawMode: GL.POINTS,\n    isInstanced: true,\n    instanceCount,\n    attributes: {\n      position: [0, 0]\n    }\n  });\n}\n\nfunction getMeanTransform(gl, opts) {\n  return new Transform(gl, {\n    vs: TRANSFORM_MEAN_VS,\n    _targetTextureVarying: 'meanValues',\n    ...opts\n  });\n}\n"]},"metadata":{},"sourceType":"module"}