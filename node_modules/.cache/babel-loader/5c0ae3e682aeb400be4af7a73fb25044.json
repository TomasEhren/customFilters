{"ast":null,"code":"import GLTFScenegraph from '../../api/gltf-scenegraph';\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\nexport const name = KHR_TECHNIQUES_WEBGL;\nexport async function decode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {\n    json\n  } = gltfScenegraph;\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n\n      if (materialExtension) {\n        material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\nexport async function encode(gltfData, options) {}\n\nfunction resolveTechniques(techniquesExtension, gltfScenegraph) {\n  const {\n    programs = [],\n    shaders = [],\n    techniques = []\n  } = techniquesExtension;\n  const textDecoder = new TextDecoder();\n  shaders.forEach(shader => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));\n    } else {\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n  programs.forEach(program => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n  techniques.forEach(technique => {\n    technique.program = programs[technique.program];\n  });\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n  Object.keys(technique.uniforms || {}).forEach(uniform => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n  Object.keys(values).forEach(uniform => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n  return values;\n}","map":{"version":3,"mappings":"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","names":["GLTFScenegraph","KHR_TECHNIQUES_WEBGL","name","decode","gltfData","gltfScenegraph","json","extension","getExtension","techniques","resolveTechniques","material","materials","materialExtension","getObjectExtension","technique","Object","assign","values","resolveValues","removeObjectExtension","removeExtension","encode","options","techniquesExtension","programs","shaders","textDecoder","TextDecoder","forEach","shader","Number","isFinite","bufferView","code","getTypedArrayForBufferView","Error","program","fragmentShader","vertexShader","keys","uniforms","uniform","value","index","undefined","texture","getTexture"],"sources":["../../../../../src/lib/extensions/deprecated/KHR_techniques_webgl.ts"],"sourcesContent":["// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n"]},"metadata":{},"sourceType":"module"}