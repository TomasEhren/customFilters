{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\nimport { getOffsetOrigin } from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\n\nfunction lngLatZToWorldPosition(lngLatZ, viewport) {\n  var offsetMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var p = viewport.projectPosition(lngLatZ);\n\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    var _lngLatZ = _slicedToArray(lngLatZ, 3),\n        longitude = _lngLatZ[0],\n        latitude = _lngLatZ[1],\n        _lngLatZ$ = _lngLatZ[2],\n        z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;\n\n    var distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  var normalizedParams = _objectSpread({}, opts);\n\n  var coordinateSystem = opts.coordinateSystem;\n  var viewport = opts.viewport,\n      coordinateOrigin = opts.coordinateOrigin,\n      fromCoordinateSystem = opts.fromCoordinateSystem,\n      fromCoordinateOrigin = opts.fromCoordinateOrigin;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  normalizedParams.coordinateSystem = coordinateSystem;\n  return normalizedParams;\n}\n\nexport function getWorldPosition(position, _ref) {\n  var viewport = _ref.viewport,\n      modelMatrix = _ref.modelMatrix,\n      coordinateSystem = _ref.coordinateSystem,\n      coordinateOrigin = _ref.coordinateOrigin,\n      offsetMode = _ref.offsetMode;\n\n  var _position = _slicedToArray(position, 3),\n      x = _position[0],\n      y = _position[1],\n      _position$ = _position[2],\n      z = _position$ === void 0 ? 0 : _position$;\n\n  if (modelMatrix) {\n    var _vec4$transformMat = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n\n    var _vec4$transformMat2 = _slicedToArray(_vec4$transformMat, 3);\n\n    x = _vec4$transformMat2[0];\n    y = _vec4$transformMat2[1];\n    z = _vec4$transformMat2[2];\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);\n  }\n}\nexport function projectPosition(position, params) {\n  var _normalizeParameters = normalizeParameters(params),\n      viewport = _normalizeParameters.viewport,\n      coordinateSystem = _normalizeParameters.coordinateSystem,\n      coordinateOrigin = _normalizeParameters.coordinateOrigin,\n      modelMatrix = _normalizeParameters.modelMatrix,\n      fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem,\n      fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;\n\n  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin),\n      geospatialOrigin = _getOffsetOrigin.geospatialOrigin,\n      shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin,\n      offsetMode = _getOffsetOrigin.offsetMode;\n\n  var worldPosition = getWorldPosition(position, {\n    viewport: viewport,\n    modelMatrix: modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode: offsetMode\n  });\n\n  if (offsetMode) {\n    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}","map":{"version":3,"mappings":"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","names":["COORDINATE_SYSTEM","getOffsetOrigin","WebMercatorViewport","vec4","vec3","addMetersToLngLat","lngLatZToWorldPosition","lngLatZ","viewport","offsetMode","p","projectPosition","longitude","latitude","z","distanceScales","getDistanceScales","unitsPerMeter","normalizeParameters","opts","normalizedParams","coordinateSystem","coordinateOrigin","fromCoordinateSystem","fromCoordinateOrigin","DEFAULT","isGeospatial","LNGLAT","CARTESIAN","undefined","getWorldPosition","position","modelMatrix","x","y","transformMat4","LNGLAT_OFFSETS","METER_OFFSETS","params","geospatialOrigin","shaderCoordinateOrigin","worldPosition","positionCommonSpace","sub"],"sources":["../../../../src/shaderlib/project/project-functions.js"],"sourcesContent":["/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport {COORDINATE_SYSTEM} from '../../lib/constants';\nimport {getOffsetOrigin} from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\n\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport {addMetersToLngLat} from '@math.gl/web-mercator';\n\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n  const p = viewport.projectPosition(lngLatZ);\n\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  const normalizedParams = {...opts};\n\n  let {coordinateSystem} = opts;\n  const {viewport, coordinateOrigin, fromCoordinateSystem, fromCoordinateOrigin} = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  normalizedParams.coordinateSystem = coordinateSystem;\n\n  return normalizedParams;\n}\n\nexport function getWorldPosition(\n  position,\n  {viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode}\n) {\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition(\n        [x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(\n        addMetersToLngLat(coordinateOrigin, [x, y, z]),\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial\n        ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n        : viewport.projectPosition([x, y, z]);\n  }\n}\n\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n * @param {array} position - [x, y, z]\n * @param {object} params\n * @param {Viewport} params.viewport - the current viewport\n * @param {number} params.coordinateSystem - the reference coordinate system used\n *   align world position\n * @param {array} params.coordinateOrigin - the reference coordinate origin used\n *   to align world position\n * @param {Matrix4} [params.modelMatrix] - the model matrix of the supplied position\n * @param {number} [params.fromCoordinateSystem] - the coordinate system that the\n *   supplied position is in. Default to the same as `coordinateSystem`.\n * @param {array} [params.fromCoordinateOrigin] - the coordinate origin that the\n *   supplied position is in. Default to the same as `coordinateOrigin`.\n */\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    // optional\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}\n"]},"metadata":{},"sourceType":"module"}