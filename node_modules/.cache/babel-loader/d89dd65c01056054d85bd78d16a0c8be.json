{"ast":null,"code":"import { Schema, Field, FixedSizeList } from '../../lib/schema/schema';\nimport { getArrowTypeFromTypedArray } from '../../lib/arrow/arrow-like-type-utils';\nexport function deduceMeshSchema(attributes, metadata) {\n  var fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\nexport function deduceMeshField(attributeName, attribute, optionalMetadata) {\n  var type = getArrowTypeFromTypedArray(attribute.value);\n  var metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  var field = new Field(attributeName, new FixedSizeList(attribute.size, new Field('value', type)), false, metadata);\n  return field;\n}\n\nfunction deduceMeshFields(attributes) {\n  var fields = [];\n\n  for (var attributeName in attributes) {\n    var attribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n\n  return fields;\n}\n\nexport function makeMeshAttributeMetadata(attribute) {\n  var result = new Map();\n\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset.toString(10));\n  }\n\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride.toString(10));\n  }\n\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized.toString());\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"AACA,SAAQA,MAAR,EAAgBC,KAAhB,EAAuBC,aAAvB,QAA2C,yBAA3C;AACA,SAAQC,0BAAR,QAAyC,uCAAzC;AAQA,OAAO,SAASC,gBAAT,CACLC,UADK,EAELC,QAFK,EAGG;EACR,IAAMC,MAAM,GAAGC,gBAAgB,CAACH,UAAD,CAA/B;EACA,OAAO,IAAIL,MAAJ,CAAWO,MAAX,EAAmBD,QAAnB,CAAP;AACD;AASD,OAAO,SAASG,eAAT,CACLC,aADK,EAELC,SAFK,EAGLC,gBAHK,EAIE;EACP,IAAMC,IAAI,GAAGV,0BAA0B,CAACQ,SAAS,CAACG,KAAX,CAAvC;EACA,IAAMR,QAAQ,GAAGM,gBAAgB,GAAGA,gBAAH,GAAsBG,yBAAyB,CAACJ,SAAD,CAAhF;EACA,IAAMK,KAAK,GAAG,IAAIf,KAAJ,CACZS,aADY,EAEZ,IAAIR,aAAJ,CAAkBS,SAAS,CAACM,IAA5B,EAAkC,IAAIhB,KAAJ,CAAU,OAAV,EAAmBY,IAAnB,CAAlC,CAFY,EAGZ,KAHY,EAIZP,QAJY,CAAd;EAMA,OAAOU,KAAP;AACD;;AAOD,SAASR,gBAAT,CAA0BH,UAA1B,EAA+D;EAC7D,IAAME,MAAe,GAAG,EAAxB;;EACA,KAAK,IAAMG,aAAX,IAA4BL,UAA5B,EAAwC;IACtC,IAAMM,SAAwB,GAAGN,UAAU,CAACK,aAAD,CAA3C;IACAH,MAAM,CAACW,IAAPX,CAAYE,eAAe,CAACC,aAAD,EAAgBC,SAAhB,CAA3BJ;EACD;;EACD,OAAOA,MAAP;AACD;;AAOD,OAAO,SAASQ,yBAAT,CAAmCJ,SAAnC,EAAkF;EACvF,IAAMQ,MAAM,GAAG,IAAIC,GAAJ,EAAf;;EACA,IAAI,gBAAgBT,SAApB,EAA+B;IAC7BQ,MAAM,CAACE,GAAPF,CAAW,YAAXA,EAAyBR,SAAS,CAACW,UAAVX,CAAsBY,QAAtBZ,CAA+B,EAA/BA,CAAzBQ;EACD;;EACD,IAAI,gBAAgBR,SAApB,EAA+B;IAC7BQ,MAAM,CAACE,GAAPF,CAAW,YAAXA,EAAyBR,SAAS,CAACa,UAAVb,CAAsBY,QAAtBZ,CAA+B,EAA/BA,CAAzBQ;EACD;;EACD,IAAI,gBAAgBR,SAApB,EAA+B;IAC7BQ,MAAM,CAACE,GAAPF,CAAW,YAAXA,EAAyBR,SAAS,CAACc,UAAVd,CAAsBY,QAAtBZ,EAAzBQ;EACD;;EACD,OAAOA,MAAP;AACD","names":["Schema","Field","FixedSizeList","getArrowTypeFromTypedArray","deduceMeshSchema","attributes","metadata","fields","deduceMeshFields","deduceMeshField","attributeName","attribute","optionalMetadata","type","value","makeMeshAttributeMetadata","field","size","push","result","Map","set","byteOffset","toString","byteStride","normalized"],"sources":["../../../../src/category/mesh/deduce-mesh-schema.ts"],"sourcesContent":["import {MeshAttribute, MeshAttributes} from './mesh-types';\nimport {Schema, Field, FixedSizeList} from '../../lib/schema/schema';\nimport {getArrowTypeFromTypedArray} from '../../lib/arrow/arrow-like-type-utils';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata?: Map<string, string>\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  attributeName: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Map<string, string>\n): Field {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadata\n  );\n  return field;\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Map<string, string> {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset!.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride!.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized!.toString());\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}