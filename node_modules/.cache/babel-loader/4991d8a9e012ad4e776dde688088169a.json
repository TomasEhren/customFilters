{"ast":null,"code":"import { getPolygonSignedArea } from '@math.gl/polygon';\nexport function classifyRings(geom) {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n\n  const areas = [];\n  const polygons = [];\n  let ringAreas = [];\n  let polygon = [];\n  let ccw;\n  let offset = 0;\n\n  for (let endIndex, i = 0, startIndex; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n      offset += endIndex - startIndex;\n      continue;\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n  return {\n    type,\n    areas,\n    indices: polygons,\n    data: geom.data\n  };\n}\nexport function project(data, x0, y0, size) {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = (data[j] + x0) * 360 / size - 180;\n    const y2 = 180 - (data[j + 1] + y0) * 360 / size;\n    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n  }\n}\nexport function readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\nexport function readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n\n    const value = feature._values[pbf.readVarint()];\n\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"mappings":"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","names":["getPolygonSignedArea","classifyRings","geom","len","indices","length","type","data","areas","polygons","ringAreas","polygon","ccw","offset","endIndex","i","startIndex","shape","slice","area","before","after","concat","undefined","push","project","x0","y0","size","j","jl","y2","Math","PI","atan","exp","readFeature","tag","feature","pbf","id","readVarint","readTag","_geometry","pos","end","key","_keys","value","_values","properties"],"sources":["../../../src/helpers/binary-util-functions.ts"],"sourcesContent":["import Protobuf from 'pbf';\nimport {getPolygonSignedArea} from '@math.gl/polygon';\nimport {FlatIndexedGeometry, FlatPolygon} from '@loaders.gl/schema';\nimport VectorTileFeature from '../lib/binary-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * The function also detects holes which have zero area and\n * removes them. In doing so it modifies the input\n * `geom.data` array to remove the unneeded data\n *\n * @param geometry\n * @returns object\n */\n// eslint-disable-next-line max-statements\nexport function classifyRings(geom: FlatIndexedGeometry): FlatPolygon {\n  const len = geom.indices.length;\n  const type = 'Polygon';\n\n  if (len <= 1) {\n    return {\n      type,\n      data: geom.data,\n      areas: [[getPolygonSignedArea(geom.data)]],\n      indices: [geom.indices]\n    };\n  }\n\n  const areas: any[] = [];\n  const polygons: any[] = [];\n  let ringAreas: number[] = [];\n  let polygon: number[] = [];\n  let ccw: boolean | undefined;\n  let offset = 0;\n\n  for (let endIndex: number, i = 0, startIndex: number; i < len; i++) {\n    startIndex = geom.indices[i] - offset;\n\n    endIndex = geom.indices[i + 1] - offset || geom.data.length;\n    const shape = geom.data.slice(startIndex, endIndex);\n    const area = getPolygonSignedArea(shape);\n\n    if (area === 0) {\n      // This polygon has no area, so remove it from the shape\n      // Remove the section from the data array\n      const before = geom.data.slice(0, startIndex);\n      const after = geom.data.slice(endIndex);\n      geom.data = before.concat(after);\n\n      // Need to offset any remaining indices as we have\n      // modified the data buffer\n      offset += endIndex - startIndex;\n\n      // Do not add this index to the output and process next shape\n      continue; // eslint-disable-line no-continue\n    }\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon.length) {\n        areas.push(ringAreas);\n        polygons.push(polygon);\n      }\n      polygon = [startIndex];\n      ringAreas = [area];\n    } else {\n      ringAreas.push(area);\n      polygon.push(startIndex);\n    }\n  }\n  if (ringAreas) areas.push(ringAreas);\n  if (polygon.length) polygons.push(polygon);\n\n  return {type, areas, indices: polygons, data: geom.data};\n}\n\n/**\n *\n * @param data\n * @param x0\n * @param y0\n * @param size\n */\nexport function project(data: number[], x0: number, y0: number, size: number): void {\n  for (let j = 0, jl = data.length; j < jl; j += 2) {\n    data[j] = ((data[j] + x0) * 360) / size - 180;\n    const y2 = 180 - ((data[j + 1] + y0) * 360) / size;\n    data[j + 1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n  }\n}\n\n/**\n * All code below is unchanged from the original Mapbox implemenation\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}