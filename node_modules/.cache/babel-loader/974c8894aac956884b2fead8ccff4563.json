{"ast":null,"code":"export function padStringToByteAlignment(string, byteAlignment) {\n  var length = string.length;\n  var paddedLength = Math.ceil(length / byteAlignment) * byteAlignment;\n  var padding = paddedLength - length;\n  var whitespace = '';\n\n  for (var i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n\n  return string + whitespace;\n}\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (var i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n\n  return byteOffset + byteLength;\n}\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (var i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n\n  return byteOffset + byteLength;\n}","map":{"version":3,"mappings":"AAIA,OAAO,SAASA,wBAAT,CAAkCC,MAAlC,EAA0CC,aAA1C,EAAyD;EAC9D,IAAMC,MAAM,GAAGF,MAAM,CAACE,MAAtB;EACA,IAAMC,YAAY,GAAGC,IAAI,CAACC,IAALD,CAAUF,MAAM,GAAGD,aAAnBG,IAAoCH,aAAzD;EACA,IAAMK,OAAO,GAAGH,YAAY,GAAGD,MAA/B;EACA,IAAIK,UAAU,GAAG,EAAjB;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAApB,EAA6B,EAAEE,CAA/B,EAAkC;IAChCD,UAAU,IAAI,GAAdA;EACD;;EACD,OAAOP,MAAM,GAAGO,UAAhB;AACD;AAED,OAAO,SAASE,oBAAT,CAA8BC,QAA9B,EAAwCC,UAAxC,EAAoDX,MAApD,EAA4DY,UAA5D,EAAwE;EAC7E,IAAIF,QAAJ,EAAc;IACZ,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAApB,EAAgCJ,CAAC,EAAjC,EAAqC;MACnCE,QAAQ,CAACG,QAATH,CAAkBC,UAAU,GAAGH,CAA/BE,EAAkCV,MAAM,CAACc,UAAPd,CAAkBQ,CAAlBR,CAAlCU;IACD;EACF;;EACD,OAAOC,UAAU,GAAGC,UAApB;AACD;AAED,OAAO,SAASG,oBAAT,CAA8BL,QAA9B,EAAwCC,UAAxC,EAAoDK,MAApD,EAA4DJ,UAA5D,EAAwE;EAC7E,IAAIF,QAAJ,EAAc;IACZ,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAApB,EAAgCJ,CAAC,EAAjC,EAAqC;MACnCE,QAAQ,CAACG,QAATH,CAAkBC,UAAU,GAAGH,CAA/BE,EAAkCM,MAAM,CAACR,CAAD,CAAxCE;IACD;EACF;;EACD,OAAOC,UAAU,GAAGC,UAApB;AACD","names":["padStringToByteAlignment","string","byteAlignment","length","paddedLength","Math","ceil","padding","whitespace","i","copyStringToDataView","dataView","byteOffset","byteLength","setUint8","charCodeAt","copyBinaryToDataView","binary"],"sources":["../../../../src/lib/binary-utils/encode-utils.ts"],"sourcesContent":["// Note: These were broken out from gltf loader...\n// eslint-disable-next-line complexity\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n    }\n  }\n  return byteOffset + byteLength;\n}\n"]},"metadata":{},"sourceType":"module"}