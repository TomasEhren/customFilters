{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { log } from '@deck.gl/core';\nimport { Matrix4 } from '@math.gl/core';\nimport { MVTWorkerLoader } from '@loaders.gl/mvt';\nimport { binaryToGeojson } from '@loaders.gl/gis';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate, isURLTemplate } from '../tile-layer/utils';\nimport { transform } from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nvar WORLD_SIZE = 512;\n\nvar defaultProps = _objectSpread(_objectSpread({}, GeoJsonLayer.defaultProps), {}, {\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n});\n\nvar MVTLayer = /*#__PURE__*/function (_TileLayer) {\n  _inherits(MVTLayer, _TileLayer);\n\n  var _super = _createSuper(MVTLayer);\n\n  function MVTLayer() {\n    _classCallCheck(this, MVTLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MVTLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(MVTLayer.prototype), \"initializeState\", this).call(this);\n\n      var binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n      this.setState({\n        binary: binary,\n        data: null,\n        tileJSON: null\n      });\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this.state.data && this.state.tileset && _get(_getPrototypeOf(MVTLayer.prototype), \"isLoaded\", this);\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          context = _ref.context,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        this._updateTileData();\n      }\n\n      if (this.state.data) {\n        _get(_getPrototypeOf(MVTLayer.prototype), \"updateState\", this).call(this, {\n          props: props,\n          oldProps: oldProps,\n          context: context,\n          changeFlags: changeFlags\n        });\n\n        this._setWGS84PropertyForTiles();\n      }\n\n      var highlightColor = props.highlightColor;\n\n      if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n        this.setState({\n          highlightColor: highlightColor\n        });\n      }\n    }\n  }, {\n    key: \"_updateTileData\",\n    value: function () {\n      var _updateTileData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var data, tileJSON, _this$props, onDataLoad, fetch;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = this.props.data;\n                tileJSON = null;\n\n                if (!(typeof data === 'string' && !isURLTemplate(data))) {\n                  _context.next = 18;\n                  break;\n                }\n\n                _this$props = this.props, onDataLoad = _this$props.onDataLoad, fetch = _this$props.fetch;\n                this.setState({\n                  data: null,\n                  tileJSON: null\n                });\n                _context.prev = 5;\n                _context.next = 8;\n                return fetch(data, {\n                  propName: 'data',\n                  layer: this,\n                  loaders: []\n                });\n\n              case 8:\n                tileJSON = _context.sent;\n                _context.next = 15;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](5);\n                this.raiseError(_context.t0, 'loading TileJSON');\n                data = null;\n\n              case 15:\n                if (onDataLoad) {\n                  onDataLoad(tileJSON);\n                }\n\n                _context.next = 19;\n                break;\n\n              case 18:\n                if (data.tilejson) {\n                  tileJSON = data;\n                }\n\n              case 19:\n                if (tileJSON) {\n                  data = tileJSON.tiles;\n                }\n\n                this.setState({\n                  data: data,\n                  tileJSON: tileJSON\n                });\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 11]]);\n      }));\n\n      function _updateTileData() {\n        return _updateTileData2.apply(this, arguments);\n      }\n\n      return _updateTileData;\n    }()\n  }, {\n    key: \"_getTilesetOptions\",\n    value: function _getTilesetOptions(props) {\n      var opts = _get(_getPrototypeOf(MVTLayer.prototype), \"_getTilesetOptions\", this).call(this, props);\n\n      var tileJSON = this.state.tileJSON;\n\n      if (tileJSON) {\n        if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > props.minZoom) {\n          opts.minZoom = tileJSON.minzoom;\n        }\n\n        if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(props.maxZoom) || tileJSON.maxzoom < props.maxZoom)) {\n          opts.maxZoom = tileJSON.maxzoom;\n        }\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      if (!this.state.data) return null;\n      return _get(_getPrototypeOf(MVTLayer.prototype), \"renderLayers\", this).call(this);\n    }\n  }, {\n    key: \"getTileData\",\n    value: function getTileData(tile) {\n      var _loadOptions;\n\n      var url = getURLFromTemplate(this.state.data, tile);\n\n      if (!url) {\n        return Promise.reject('Invalid URL');\n      }\n\n      var loadOptions = this.getLoadOptions();\n      var binary = this.state.binary;\n      var fetch = this.props.fetch;\n      var signal = tile.signal,\n          x = tile.x,\n          y = tile.y,\n          z = tile.z;\n      loadOptions = _objectSpread(_objectSpread({}, loadOptions), {}, {\n        mimeType: 'application/x-protobuf',\n        mvt: _objectSpread(_objectSpread({}, (_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt), {}, {\n          coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n          tileIndex: {\n            x: x,\n            y: y,\n            z: z\n          }\n        }),\n        gis: binary ? {\n          format: 'binary'\n        } : {}\n      });\n      return fetch(url, {\n        propName: 'data',\n        layer: this,\n        loadOptions: loadOptions,\n        signal: signal\n      });\n    }\n  }, {\n    key: \"renderSubLayers\",\n    value: function renderSubLayers(props) {\n      var tile = props.tile;\n      var worldScale = Math.pow(2, tile.z);\n      var xScale = WORLD_SIZE / worldScale;\n      var yScale = -xScale;\n      var xOffset = WORLD_SIZE * tile.x / worldScale;\n      var yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n      var modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n      props.autoHighlight = false;\n\n      if (!this.context.viewport.resolution) {\n        props.modelMatrix = modelMatrix;\n        props.coordinateOrigin = [xOffset, yOffset, 0];\n        props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n        props.extensions = [].concat(_toConsumableArray(props.extensions || []), [new ClipExtension()]);\n      }\n\n      var subLayers = _get(_getPrototypeOf(MVTLayer.prototype), \"renderSubLayers\", this).call(this, props);\n\n      if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n        log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n      }\n\n      return subLayers;\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      var uniqueIdProperty = this.props.uniqueIdProperty;\n      var _this$state = this.state,\n          hoveredFeatureId = _this$state.hoveredFeatureId,\n          hoveredFeatureLayerName = _this$state.hoveredFeatureLayerName;\n      var hoveredFeature = info.object;\n      var newHoveredFeatureId;\n      var newHoveredFeatureLayerName;\n\n      if (hoveredFeature) {\n        newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n        newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n      }\n\n      var highlightColor = this.props.highlightColor;\n\n      if (typeof highlightColor === 'function') {\n        highlightColor = highlightColor(info);\n      }\n\n      if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {\n        this.setState({\n          highlightColor: highlightColor,\n          hoveredFeatureId: newHoveredFeatureId,\n          hoveredFeatureLayerName: newHoveredFeatureLayerName\n        });\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(params) {\n      var info = _get(_getPrototypeOf(MVTLayer.prototype), \"getPickingInfo\", this).call(this, params);\n\n      var isWGS84 = this.context.viewport.resolution;\n\n      if (this.state.binary && info.index !== -1) {\n        var data = params.sourceLayer.props.data;\n        info.object = binaryToGeojson(data, {\n          globalFeatureId: info.index\n        });\n      }\n\n      if (info.object && !isWGS84) {\n        info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n      }\n\n      return info;\n    }\n  }, {\n    key: \"getSubLayerPropsByTile\",\n    value: function getSubLayerPropsByTile(tile) {\n      return {\n        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n        highlightColor: this.state.highlightColor\n      };\n    }\n  }, {\n    key: \"getHighlightedObjectIndex\",\n    value: function getHighlightedObjectIndex(tile) {\n      var _this$state2 = this.state,\n          hoveredFeatureId = _this$state2.hoveredFeatureId,\n          hoveredFeatureLayerName = _this$state2.hoveredFeatureLayerName,\n          binary = _this$state2.binary;\n      var _this$props2 = this.props,\n          uniqueIdProperty = _this$props2.uniqueIdProperty,\n          highlightedFeatureId = _this$props2.highlightedFeatureId;\n      var data = tile.content;\n      var isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n      var isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n      if (!isFeatureIdPresent) {\n        return -1;\n      }\n\n      var featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n      if (Array.isArray(data)) {\n        return data.findIndex(function (feature) {\n          var isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n          var isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n          return isMatchingId && isMatchingLayer;\n        });\n      } else if (data && binary) {\n        return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"_pickObjects\",\n    value: function _pickObjects(maxObjects) {\n      var _this$context = this.context,\n          deck = _this$context.deck,\n          viewport = _this$context.viewport;\n      var width = viewport.width;\n      var height = viewport.height;\n      var x = viewport.x;\n      var y = viewport.y;\n      var layerIds = [this.id];\n      return deck.pickObjects({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layerIds: layerIds,\n        maxObjects: maxObjects\n      });\n    }\n  }, {\n    key: \"getRenderedFeatures\",\n    value: function getRenderedFeatures() {\n      var maxFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      var features = this._pickObjects(maxFeatures);\n\n      var featureCache = new Set();\n      var renderedFeatures = [];\n\n      var _iterator = _createForOfIteratorHelper(features),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var f = _step.value;\n          var featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n          if (featureId === undefined) {\n            renderedFeatures.push(f.object);\n          } else if (!featureCache.has(featureId)) {\n            featureCache.add(featureId);\n            renderedFeatures.push(f.object);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return renderedFeatures;\n    }\n  }, {\n    key: \"_setWGS84PropertyForTiles\",\n    value: function _setWGS84PropertyForTiles() {\n      var _this = this;\n\n      var propName = 'dataInWGS84';\n      var tileset = this.state.tileset;\n      tileset.selectedTiles.forEach(function (tile) {\n        if (!tile.hasOwnProperty(propName)) {\n          Object.defineProperty(tile, propName, {\n            get: function get() {\n              if (!tile.content) {\n                return null;\n              }\n\n              if (_this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n                return [];\n              }\n\n              if (tile._contentWGS84 === undefined) {\n                var content = _this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n                tile._contentWGS84 = content.map(function (feature) {\n                  return transformTileCoordsToWGS84(feature, tile.bbox, _this.context.viewport);\n                });\n              }\n\n              return tile._contentWGS84;\n            }\n          });\n        }\n      });\n    }\n  }]);\n\n  return MVTLayer;\n}(TileLayer);\n\nexport { MVTLayer as default };\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature) {\n  var _feature$properties;\n\n  return ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  var feature = _objectSpread(_objectSpread({}, object), {}, {\n    geometry: {\n      type: object.geometry.type\n    }\n  });\n\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: function get() {\n      var wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["log","Matrix4","MVTWorkerLoader","binaryToGeojson","COORDINATE_SYSTEM","ClipExtension","TileLayer","getURLFromTemplate","isURLTemplate","transform","findIndexBinary","GeoJsonLayer","WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","loaders","binary","MVTLayer","initializeState","context","viewport","resolution","undefined","props","setState","data","tileJSON","state","tileset","updateState","oldProps","changeFlags","dataChanged","_updateTileData","_setWGS84PropertyForTiles","highlightColor","Array","isArray","onDataLoad","fetch","propName","layer","raiseError","tilejson","tiles","_getTilesetOptions","opts","Number","isFinite","minzoom","minZoom","maxzoom","maxZoom","renderLayers","getTileData","tile","url","Promise","reject","loadOptions","getLoadOptions","signal","x","y","z","mimeType","mvt","_loadOptions","coordinates","tileIndex","gis","format","renderSubLayers","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","modelMatrix","scale","autoHighlight","coordinateOrigin","coordinateSystem","CARTESIAN","extensions","subLayers","warn","_updateAutoHighlight","info","hoveredFeatureId","hoveredFeatureLayerName","hoveredFeature","object","newHoveredFeatureId","newHoveredFeatureLayerName","getFeatureUniqueId","getFeatureLayerName","getPickingInfo","params","isWGS84","index","sourceLayer","globalFeatureId","transformTileCoordsToWGS84","bbox","getSubLayerPropsByTile","highlightedObjectIndex","getHighlightedObjectIndex","content","isHighlighted","isFeatureIdDefined","isFeatureIdPresent","featureIdToHighlight","findIndex","feature","isMatchingId","isMatchingLayer","_pickObjects","maxObjects","deck","width","height","layerIds","id","pickObjects","getRenderedFeatures","maxFeatures","features","featureCache","Set","renderedFeatures","f","featureId","push","has","add","selectedTiles","forEach","hasOwnProperty","Object","defineProperty","get","length","_contentWGS84","map","properties","layerName","geometry","wgs84Geom"],"sources":["../../../src/mvt-layer/mvt-layer.js"],"sourcesContent":["import {log} from '@deck.gl/core';\nimport {Matrix4} from '@math.gl/core';\nimport {MVTWorkerLoader} from '@loaders.gl/mvt';\nimport {binaryToGeojson} from '@loaders.gl/gis';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {ClipExtension} from '@deck.gl/extensions';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate, isURLTemplate} from '../tile-layer/utils';\nimport {transform} from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\n\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  ...GeoJsonLayer.defaultProps,\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n\nexport default class MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded() {\n    return this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState({props, oldProps, context, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      this._updateTileData();\n    }\n\n    if (this.state.data) {\n      super.updateState({props, oldProps, context, changeFlags});\n      this._setWGS84PropertyForTiles();\n    }\n    const {highlightColor} = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({highlightColor});\n    }\n  }\n\n  /* eslint-disable complexity */\n  async _updateTileData() {\n    let {data} = this.props;\n    let tileJSON = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {onDataLoad, fetch} = this.props;\n      this.setState({data: null, tileJSON: null});\n      try {\n        tileJSON = await fetch(data, {propName: 'data', layer: this, loaders: []});\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON);\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({data, tileJSON});\n  }\n\n  _getTilesetOptions(props) {\n    const opts = super._getTilesetOptions(props);\n    const {tileJSON} = this.state;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > props.minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n\n      if (\n        Number.isFinite(tileJSON.maxzoom) &&\n        (!Number.isFinite(props.maxZoom) || tileJSON.maxzoom < props.maxZoom)\n      ) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n    return opts;\n  }\n\n  /* eslint-disable complexity */\n\n  renderLayers() {\n    if (!this.state.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.state.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {binary} = this.state;\n    const {fetch} = this.props;\n    const {signal, x, y, z} = tile;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: {x, y, z}\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {format: 'binary'} : {}\n    };\n    return fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  _updateAutoHighlight(info) {\n    const {uniqueIdProperty} = this.props;\n\n    const {hoveredFeatureId, hoveredFeatureLayerName} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId;\n    let newHoveredFeatureLayerName;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {highlightColor} = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (\n      hoveredFeatureId !== newHoveredFeatureId ||\n      hoveredFeatureLayerName !== newHoveredFeatureLayerName\n    ) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n\n    const isWGS84 = this.context.viewport.resolution;\n\n    if (this.state.binary && info.index !== -1) {\n      const {data} = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {globalFeatureId: info.index});\n    }\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId, hoveredFeatureLayerName, binary} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const data = tile.content;\n\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer =\n          isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(\n        data,\n        uniqueIdProperty,\n        featureIdToHighlight,\n        isHighlighted ? '' : hoveredFeatureLayerName\n      );\n    }\n\n    return -1;\n  }\n\n  _pickObjects(maxObjects) {\n    const {deck, viewport} = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({x, y, width, height, layerIds, maxObjects});\n  }\n\n  getRenderedFeatures(maxFeatures = null) {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const {tileset} = this.state;\n\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n\n            if (tile._contentWGS84 === undefined) {\n              // Create a cache to transform only once\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature =>\n                transformTileCoordsToWGS84(feature, tile.bbox, this.context.viewport)\n              );\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature) {\n  return feature.properties?.layerName || null;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}