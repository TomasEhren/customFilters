{"ast":null,"code":"function systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\nconst DTYPES = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\nexport function parseNPY(arrayBuffer, options) {\n  var _header$shape;\n\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {\n    header,\n    headerEndOffset\n  } = parseHeader(view);\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n\n  if (!ArrayType) {\n    console.warn(\"Decoding of npy dtype not implemented: \".concat(numpyType));\n    return null;\n  }\n\n  const nArrayElements = (_header$shape = header.shape) === null || _header$shape === void 0 ? void 0 : _header$shape.reduce((a, b) => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  if (numpyType[0] === '>' && LITTLE_ENDIAN_OS || numpyType[0] === '<' && !LITTLE_ENDIAN_OS) {\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\nfunction parseHeader(view) {\n  const majorVersion = view.getUint8(6);\n  let offset = 8;\n  let headerLength;\n\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n  const header = JSON.parse(headerText.replace(/'/g, '\"').replace('False', 'false').replace('(', '[').replace(/,*\\),*/g, ']'));\n  return {\n    header,\n    headerEndOffset: offset\n  };\n}","map":{"version":3,"mappings":"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","names":["systemIsLittleEndian","a","Uint32Array","b","Uint8Array","buffer","byteOffset","byteLength","LITTLE_ENDIAN_OS","DTYPES","u1","i1","Int8Array","u2","Uint16Array","i2","Int16Array","u4","i4","Int32Array","f4","Float32Array","f8","Float64Array","parseNPY","arrayBuffer","options","view","DataView","header","headerEndOffset","parseHeader","numpyType","descr","ArrayType","slice","console","warn","nArrayElements","shape","_header$shape","reduce","arrayByteLength","BYTES_PER_ELEMENT","data","majorVersion","getUint8","offset","headerLength","getUint32","getUint16","encoding","decoder","TextDecoder","headerArray","headerText","decode","JSON","parse","replace"],"sources":["../../../../src/lib/parsers/parse-npy.ts"],"sourcesContent":["type NumpyHeader = {descr: string; shape: number[]};\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, any> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn(`Decoding of npy dtype not implemented: ${numpyType}`);\n    return null;\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    // eslint-disable-next-line no-console, no-undef\n    console.warn('Data is wrong endianness, byte swapping not yet implemented.');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(8, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(8, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n"]},"metadata":{},"sourceType":"module"}