{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { normalizeTransitionSettings } from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\nvar TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nvar UniformTransitionManager = /*#__PURE__*/function () {\n  function UniformTransitionManager(timeline) {\n    _classCallCheck(this, UniformTransitionManager);\n\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  _createClass(UniformTransitionManager, [{\n    key: \"active\",\n    get: function get() {\n      return this.transitions.size > 0;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, fromValue, toValue, settings) {\n      var transitions = this.transitions;\n\n      if (transitions.has(key)) {\n        var _transition = transitions.get(key);\n\n        var _transition$value = _transition.value,\n            value = _transition$value === void 0 ? _transition.settings.fromValue : _transition$value;\n        fromValue = value;\n        this.remove(key);\n      }\n\n      settings = normalizeTransitionSettings(settings);\n\n      if (!settings) {\n        return;\n      }\n\n      var TransitionType = TRANSITION_TYPES[settings.type];\n\n      if (!TransitionType) {\n        log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n        return;\n      }\n\n      var transition = new TransitionType(this.timeline);\n      transition.start(_objectSpread(_objectSpread({}, settings), {}, {\n        fromValue: fromValue,\n        toValue: toValue\n      }));\n      transitions.set(key, transition);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      var transitions = this.transitions;\n\n      if (transitions.has(key)) {\n        transitions.get(key).cancel();\n        transitions.delete(key);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var propsInTransition = {};\n\n      var _iterator = _createForOfIteratorHelper(this.transitions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              transition = _step$value[1];\n\n          transition.update();\n          propsInTransition[key] = transition.value;\n\n          if (!transition.inProgress) {\n            this.remove(key);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return propsInTransition;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _iterator2 = _createForOfIteratorHelper(this.transitions.keys()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var key = _step2.value;\n          this.remove(key);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return UniformTransitionManager;\n}();\n\nexport { UniformTransitionManager as default };","map":{"version":3,"mappings":";;;;;AAAA,SAAQA,2BAAR,QAA0C,wCAA1C;AACA,OAAOC,0BAAP,MAAuC,6CAAvC;AACA,OAAOC,mBAAP,MAAgC,sCAAhC;AACA,OAAOC,GAAP,MAAgB,cAAhB;AAEA,IAAMC,gBAAgB,GAAG;EACvBC,aAAa,EAAEJ,0BADQ;EAEvBK,MAAM,EAAEJ;AAFe,CAAzB;;IAKqBK,wB;EACnBC,kCAAYC,QAAZD,EAAsB;IAAA;;IACpB,KAAKE,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;IACA,KAAKF,QAAL,GAAgBA,QAAhB;EACD;;;;SAES,eAAG;MACX,OAAO,KAAKC,WAAL,CAAiBE,IAAjB,GAAwB,CAA/B;IACD;;;WAEDC,aAAIC,GAAJD,EAASE,SAATF,EAAoBG,OAApBH,EAA6BI,QAA7BJ,EAAuC;MACrC,IAAOH,WAAP,GAAsB,IAAtB,CAAOA,WAAP;;MACA,IAAIA,WAAW,CAACQ,GAAZR,CAAgBI,GAAhBJ,CAAJ,EAA0B;QACxB,IAAMS,WAAU,GAAGT,WAAW,CAACU,GAAZV,CAAgBI,GAAhBJ,CAAnB;;QAEA,wBAAgDS,WAAhD,CAAOE,KAAP;QAAA,IAAOA,KAAP,kCAAeF,WAAU,CAACF,QAAXE,CAAoBJ,SAAnC;QAEAA,SAAS,GAAGM,KAAZN;QACA,KAAKO,MAAL,CAAYR,GAAZ;MACD;;MAEDG,QAAQ,GAAGjB,2BAA2B,CAACiB,QAAD,CAAtCA;;MACA,IAAI,CAACA,QAAL,EAAe;QACb;MACD;;MAED,IAAMM,cAAc,GAAGnB,gBAAgB,CAACa,QAAQ,CAACO,IAAV,CAAvC;;MACA,IAAI,CAACD,cAAL,EAAqB;QACnBpB,GAAG,CAACsB,KAAJtB,wCAA0Cc,QAAQ,CAACO,IAAnD;QACA;MACD;;MACD,IAAML,UAAU,GAAG,IAAII,cAAJ,CAAmB,KAAKd,QAAxB,CAAnB;MACAU,UAAU,CAACO,KAAXP,iCACKF,QADLE;QAEEJ,SAFe,EAEfA,SAFFI;QAGEH;MAHFG;MAKAT,WAAW,CAACiB,GAAZjB,CAAgBI,GAAhBJ,EAAqBS,UAArBT;IACD;;;WAEDY,gBAAOR,GAAPQ,EAAY;MACV,IAAOZ,WAAP,GAAsB,IAAtB,CAAOA,WAAP;;MACA,IAAIA,WAAW,CAACQ,GAAZR,CAAgBI,GAAhBJ,CAAJ,EAA0B;QACxBA,WAAW,CAACU,GAAZV,CAAgBI,GAAhBJ,EAAqBkB,MAArBlB;QACAA,WAAW,CAACmB,MAAZnB,CAAmBI,GAAnBJ;MACD;IACF;;;WAEDoB,kBAAS;MACP,IAAMC,iBAAiB,GAAG,EAA1B;;MADO,2CAGyB,KAAKrB,WAH9B;MAAA;;MAAA;QAGP,oDAAkD;UAAA;UAAA,IAAtCI,GAAsC;UAAA,IAAjCK,UAAiC;;UAChDA,UAAU,CAACW,MAAXX;UACAY,iBAAiB,CAACjB,GAAD,CAAjBiB,GAAyBZ,UAAU,CAACE,KAApCU;;UACA,IAAI,CAACZ,UAAU,CAACa,UAAhB,EAA4B;YAE1B,KAAKV,MAAL,CAAYR,GAAZ;UACD;QACF;MAVM;QAAA;MAAA;QAAA;MAAA;;MAYP,OAAOiB,iBAAP;IACD;;;WAEDE,iBAAQ;MAAA,4CACY,KAAKvB,WAAL,CAAiBwB,IAAjB,EADZ;MAAA;;MAAA;QACN,uDAA2C;UAAA,IAAhCpB,GAAgC;UACzC,KAAKQ,MAAL,CAAYR,GAAZ;QACD;MAHK;QAAA;MAAA;QAAA;MAAA;IAIP;;;;;;SAnEkBP,wB","names":["normalizeTransitionSettings","CPUInterpolationTransition","CPUSpringTransition","log","TRANSITION_TYPES","interpolation","spring","UniformTransitionManager","constructor","timeline","transitions","Map","size","add","key","fromValue","toValue","settings","has","transition","get","value","remove","TransitionType","type","error","start","set","cancel","delete","update","propsInTransition","inProgress","clear","keys"],"sources":["../../../src/lib/uniform-transition-manager.js"],"sourcesContent":["import {normalizeTransitionSettings} from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      // value may not be available if `update()` has not been called. Fallback to `fromValue`\n      const {value = transition.settings.fromValue} = transition;\n      // start from interrupted position\n      fromValue = value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n    if (!TransitionType) {\n      log.error(`unsupported transition type '${settings.type}'`)();\n      return;\n    }\n    const transition = new TransitionType(this.timeline);\n    transition.start({\n      ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n      if (!transition.inProgress) {\n        // transition ended\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}