{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Matrix3, Quaternion } from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector3 = new Vector3();\nvar scratchOffset = new Vector3();\nvar scratchVectorU = new Vector3();\nvar scratchVectorV = new Vector3();\nvar scratchVectorW = new Vector3();\nvar scratchCorner = new Vector3();\nvar scratchToCenter = new Vector3();\nvar MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nvar OrientedBoundingBox = /*#__PURE__*/function () {\n  function OrientedBoundingBox() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var halfAxes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    _classCallCheck(this, OrientedBoundingBox);\n\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  _createClass(OrientedBoundingBox, [{\n    key: \"halfSize\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n    }\n  }, {\n    key: \"quaternion\",\n    get: function get() {\n      var xAxis = this.halfAxes.getColumn(0);\n      var yAxis = this.halfAxes.getColumn(1);\n      var zAxis = this.halfAxes.getColumn(2);\n      var normXAxis = new Vector3(xAxis).normalize();\n      var normYAxis = new Vector3(yAxis).normalize();\n      var normZAxis = new Vector3(zAxis).normalize();\n      return new Quaternion().fromMatrix3(new Matrix3([].concat(_toConsumableArray(normXAxis), _toConsumableArray(normYAxis), _toConsumableArray(normZAxis))));\n    }\n  }, {\n    key: \"fromCenterHalfSizeQuaternion\",\n    value: function fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n      var quaternionObject = new Quaternion(quaternion);\n      var directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n      directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n      directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n      directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n      directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n      directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n      directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n      directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n      directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n      directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n      this.center = new Vector3().from(center);\n      this.halfAxes = directionsMatrix;\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new OrientedBoundingBox(this.center, this.halfAxes);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);\n    }\n  }, {\n    key: \"getBoundingSphere\",\n    value: function getBoundingSphere() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BoundingSphere();\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var cornerVector = scratchVector3.copy(u).add(v).add(w);\n      result.center.copy(this.center);\n      result.radius = cornerVector.magnitude();\n      return result;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var normal = plane.normal;\n      var halfAxes = this.halfAxes;\n      var normalX = normal.x;\n      var normalY = normal.y;\n      var normalZ = normal.z;\n      var radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane <= -radEffective) {\n        return INTERSECTION.OUTSIDE;\n      } else if (distanceToPlane >= radEffective) {\n        return INTERSECTION.INSIDE;\n      }\n\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchOffset.from(point).subtract(this.center);\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var uHalf = u.magnitude();\n      var vHalf = v.magnitude();\n      var wHalf = w.magnitude();\n      u.normalize();\n      v.normalize();\n      w.normalize();\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.dot(u)) - uHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(v)) - vHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.dot(w)) - wHalf;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }, {\n    key: \"computePlaneDistances\",\n    value: function computePlaneDistances(position, direction) {\n      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [-0, -0];\n      var minDist = Number.POSITIVE_INFINITY;\n      var maxDist = Number.NEGATIVE_INFINITY;\n      var center = this.center;\n      var halfAxes = this.halfAxes;\n      var u = halfAxes.getColumn(0, scratchVectorU);\n      var v = halfAxes.getColumn(1, scratchVectorV);\n      var w = halfAxes.getColumn(2, scratchVectorW);\n      var corner = scratchCorner.copy(u).add(v).add(w).add(center);\n      var toCenter = scratchToCenter.copy(corner).subtract(position);\n      var mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      corner.copy(center).add(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).add(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).add(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      center.copy(corner).subtract(u).subtract(v).subtract(w);\n      toCenter.copy(corner).subtract(position);\n      mag = direction.dot(toCenter);\n      minDist = Math.min(mag, minDist);\n      maxDist = Math.max(mag, maxDist);\n      result[0] = minDist;\n      result[1] = maxDist;\n      return result;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(transformation) {\n      this.center.transformAsPoint(transformation);\n      var xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n      xAxis.transformAsPoint(transformation);\n      var yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n      yAxis.transformAsPoint(transformation);\n      var zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n      zAxis.transformAsPoint(transformation);\n      this.halfAxes = new Matrix3([].concat(_toConsumableArray(xAxis), _toConsumableArray(yAxis), _toConsumableArray(zAxis)));\n      return this;\n    }\n  }, {\n    key: \"getTransform\",\n    value: function getTransform() {\n      throw new Error('not implemented');\n    }\n  }]);\n\n  return OrientedBoundingBox;\n}();\n\nexport { OrientedBoundingBox as default };","map":{"version":3,"mappings":"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","names":["Vector3","Matrix3","Quaternion","BoundingSphere","INTERSECTION","scratchVector3","scratchOffset","scratchVectorU","scratchVectorV","scratchVectorW","scratchCorner","scratchToCenter","MATRIX3","COLUMN0ROW0","COLUMN0ROW1","COLUMN0ROW2","COLUMN1ROW0","COLUMN1ROW1","COLUMN1ROW2","COLUMN2ROW0","COLUMN2ROW1","COLUMN2ROW2","OrientedBoundingBox","constructor","center","halfAxes","from","xAxis","getColumn","yAxis","zAxis","len","normXAxis","normalize","normYAxis","normZAxis","fromMatrix3","fromCenterHalfSizeQuaternion","halfSize","quaternion","quaternionObject","directionsMatrix","fromQuaternion","clone","equals","right","Boolean","getBoundingSphere","result","u","v","w","cornerVector","copy","add","radius","magnitude","intersectPlane","plane","normal","normalX","x","normalY","y","normalZ","z","radEffective","Math","abs","distanceToPlane","dot","distance","OUTSIDE","INSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","subtract","uHalf","vHalf","wHalf","distanceSquared","d","computePlaneDistances","position","direction","minDist","Number","POSITIVE_INFINITY","maxDist","NEGATIVE_INFINITY","corner","toCenter","mag","min","max","transform","transformation","transformAsPoint","getTransform","Error"],"sources":["../../../../src/lib/bounding-volumes/oriented-bounding-box.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Quaternion} from '@math.gl/core';\nimport BoundingSphere from './bounding-sphere';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\nexport default class OrientedBoundingBox {\n  constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  get halfSize() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  get quaternion() {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  fromCenterHalfSizeQuaternion(center, halfSize, quaternion) {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  clone() {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  getBoundingSphere(result = new BoundingSphere()) {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  intersectPlane(plane) {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  distanceSquaredTo(point) {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(position, direction, result = [-0, -0]) {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform() {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}