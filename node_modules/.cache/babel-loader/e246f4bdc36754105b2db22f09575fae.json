{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { global, isBrowser, isWorker } from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport { assert } from '../env-utils/assert';\nimport { VERSION as __VERSION__ } from '../env-utils/version';\nvar LATEST = 'latest';\nvar VERSION = typeof \"3.1.8\" !== 'undefined' ? \"3.1.8\" : LATEST;\nvar loadLibraryPromises = {};\nexport function loadLibrary(_x) {\n  return _loadLibrary.apply(this, arguments);\n}\n\nfunction _loadLibrary() {\n  _loadLibrary = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(libraryUrl) {\n    var moduleName,\n        options,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            moduleName = _args.length > 1 && _args[1] !== undefined ? _args[1] : null;\n            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n\n            if (moduleName) {\n              libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n            }\n\n            loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n            _context.next = 6;\n            return loadLibraryPromises[libraryUrl];\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadLibrary.apply(this, arguments);\n}\n\nexport function getLibraryUrl(library, moduleName, options) {\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  var modules = options.modules || {};\n\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  if (!isBrowser) {\n    return \"modules/\".concat(moduleName, \"/dist/libs/\").concat(library);\n  }\n\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return \"\".concat(options.CDN, \"/\").concat(moduleName, \"@\").concat(VERSION, \"/dist/libs/\").concat(library);\n  }\n\n  if (isWorker) {\n    return \"../src/libs/\".concat(library);\n  }\n\n  return \"modules/\".concat(moduleName, \"/src/libs/\").concat(library);\n}\n\nfunction loadLibraryFromFile(_x2) {\n  return _loadLibraryFromFile.apply(this, arguments);\n}\n\nfunction _loadLibraryFromFile() {\n  _loadLibraryFromFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(libraryUrl) {\n    var _response, response, scriptSource;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!libraryUrl.endsWith('wasm')) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 3;\n            return fetch(libraryUrl);\n\n          case 3:\n            _response = _context2.sent;\n            _context2.next = 6;\n            return _response.arrayBuffer();\n\n          case 6:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 7:\n            if (isBrowser) {\n              _context2.next = 20;\n              break;\n            }\n\n            _context2.prev = 8;\n            _context2.t0 = node && node.requireFromFile;\n\n            if (!_context2.t0) {\n              _context2.next = 14;\n              break;\n            }\n\n            _context2.next = 13;\n            return node.requireFromFile(libraryUrl);\n\n          case 13:\n            _context2.t0 = _context2.sent;\n\n          case 14:\n            return _context2.abrupt(\"return\", _context2.t0);\n\n          case 17:\n            _context2.prev = 17;\n            _context2.t1 = _context2[\"catch\"](8);\n            return _context2.abrupt(\"return\", null);\n\n          case 20:\n            if (!isWorker) {\n              _context2.next = 22;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", importScripts(libraryUrl));\n\n          case 22:\n            _context2.next = 24;\n            return fetch(libraryUrl);\n\n          case 24:\n            response = _context2.sent;\n            _context2.next = 27;\n            return response.text();\n\n          case 27:\n            scriptSource = _context2.sent;\n            return _context2.abrupt(\"return\", loadLibraryFromString(scriptSource, libraryUrl));\n\n          case 29:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[8, 17]]);\n  }));\n  return _loadLibraryFromFile.apply(this, arguments);\n}\n\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    eval.call(global, scriptSource);\n    return null;\n  }\n\n  var script = document.createElement('script');\n  script.id = id;\n\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n\n  document.body.appendChild(script);\n  return null;\n}","map":{"version":3,"mappings":"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","names":["global","isBrowser","isWorker","node","assert","VERSION","__VERSION__","LATEST","loadLibraryPromises","loadLibrary","libraryUrl","moduleName","options","getLibraryUrl","loadLibraryFromFile","library","startsWith","modules","CDN","endsWith","fetch","response","arrayBuffer","requireFromFile","importScripts","text","scriptSource","loadLibraryFromString","id","requireFromString","eval","call","script","document","createElement","appendChild","createTextNode","e","body"],"sources":["../../../../src/lib/library-utils/library-utils.ts"],"sourcesContent":["/* global importScripts */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport {assert} from '../env-utils/assert';\nimport {VERSION as __VERSION__} from '../env-utils/version';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'latest';\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises: Record<string, Promise<any>> = {}; // promises\n\n/**\n * Dynamically loads a library (\"module\")\n *\n * - wasm library: Array buffer is returned\n * - js library: Parse JS is returned\n *\n * Method depends on environment\n * - browser - script element is created and installed on document\n * - worker - eval is called on global context\n * - node - file is required\n *\n * @param libraryUrl\n * @param moduleName\n * @param options\n */\nexport async function loadLibrary(\n  libraryUrl: string,\n  moduleName: string | null = null,\n  options: object = {}\n): Promise<any> {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n\n  loadLibraryPromises[libraryUrl] =\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library: string, moduleName?: string, options?: any): string {\n  // Check if already a URL\n  if (library.startsWith('http')) {\n    return library;\n  }\n\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl: string): Promise<any> {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    try {\n      return node && node.requireFromFile && (await node.requireFromFile(libraryUrl));\n    } catch {\n      return null;\n    }\n  }\n  if (isWorker) {\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource: string, id: string): null | any {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n"]},"metadata":{},"sourceType":"module"}