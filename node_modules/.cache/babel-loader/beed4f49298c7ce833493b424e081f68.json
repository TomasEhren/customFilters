{"ast":null,"code":"import { Tile3DSubtreeLoader } from '../../../tile-3d-subtree-loader';\nimport { load } from '@loaders.gl/core';\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\nexport async function parseImplicitTiles(subtree, options) {\n  let parentData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  let childIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let globalData = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n    level: 0,\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  };\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n  const tile = {\n    children: [],\n    lodMetricValue: 0,\n    contentUrl: ''\n  };\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n  const childX = childIndex & 0b01;\n  const childY = childIndex >> 1 & 0b01;\n  const childZ = childIndex >> 2 & 0b01;\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(subtree.childSubtreeAvailability, childTileMortonIndex);\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = \"\".concat(basePath, \"/\").concat(subtreesUriTemplate);\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n    subtree = childSubtree;\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(subtree.contentAvailability, tileAvailabilityIndex);\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {\n    mortonIndex: childTileMortonIndex,\n    x: childTileX,\n    y: childTileY,\n    z: childTileZ\n  };\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(subtree, options, pData, index, childTileLevel, globalData);\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {\n        childTileX,\n        childTileY,\n        childTileZ\n      };\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData, index) {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\nfunction formatTileData(tile, level, childCoordinates, options) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(\"\".concat(basePath, \"/\"), '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates);\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {\n      uri\n    },\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    boundingVolume\n  };\n}\n\nfunction calculateBoundingVolumeForChildTile(level, rootBoundingVolume, childCoordinates) {\n  if (rootBoundingVolume.region) {\n    const {\n      childTileX,\n      childTileY,\n      childTileZ\n    } = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [minimumHeight + sizeZ * childTileZ, minimumHeight + sizeZ * (childTileZ + 1)];\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\nfunction concatBits(first, second) {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\nexport function replaceContentUrlTemplate(templateUrl, level, x, y, z) {\n  const mapUrl = generateMapUrl({\n    level,\n    x,\n    y,\n    z\n  });\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, matched => mapUrl[matched]);\n}\n\nfunction generateMapUrl(items) {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[\"{\".concat(key, \"}\")] = items[key];\n  }\n\n  return mapUrl;\n}\n\nfunction getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;\n  return bitValue === 1;\n}","map":{"version":3,"mappings":"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","names":["Tile3DSubtreeLoader","load","QUADTREE_DEVISION_COUNT","OCTREE_DEVISION_COUNT","SUBDIVISION_COUNT_MAP","QUADTREE","OCTREE","parseImplicitTiles","subtree","options","parentData","mortonIndex","x","y","z","childIndex","level","globalData","subdivisionScheme","subtreeLevels","maximumLevel","contentUrlTemplate","subtreesUriTemplate","basePath","tile","children","lodMetricValue","contentUrl","childrenPerTile","childX","childY","childZ","levelOffset","childTileMortonIndex","concatBits","tileAvailabilityIndex","childTileX","childTileY","childTileZ","isChildSubtreeAvailable","getAvailabilityResult","childSubtreeAvailability","lev","subtreePath","childSubtreeUrl","replaceContentUrlTemplate","childSubtree","isTileAvailable","tileAvailability","isContentAvailable","contentAvailability","childTileLevel","pData","index","currentTile","length","globalLevel","childCoordinates","formattedTile","formatTileData","push","availabilityData","Boolean","constant","explicitBitstream","getBooleanValueFromBitstream","refine","getRefine","lodMetricType","getTileType","rootLodMetricValue","rootBoundingVolume","uri","replace","boundingVolume","calculateBoundingVolumeForChildTile","content","id","type","region","west","south","east","north","minimumHeight","maximumHeight","boundingVolumesCount","sizeX","sizeY","sizeZ","childWest","childEast","childSouth","childNorth","childMinimumHeight","childMaximumHeight","console","warn","first","second","parseInt","toString","templateUrl","mapUrl","generateMapUrl","matched","items","key","availabilityIndex","availabilityBuffer","byteIndex","Math","floor","bitIndex","bitValue"],"sources":["../../../../../src/lib/parsers/helpers/parse-3d-implicit-tiles.ts"],"sourcesContent":["import type {Availability, BoundingVolume, Subtree} from '../../../types';\nimport {Tile3DSubtreeLoader} from '../../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\n\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\n\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-params\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(\n  subtree: Subtree,\n  options: any,\n  parentData: {mortonIndex: number; x: number; y: number; z: number} = {\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  childIndex: number = 0,\n  level: number = 0,\n  globalData: {level: number; mortonIndex: number; x: number; y: number; z: number} = {\n    level: 0,\n    mortonIndex: 0,\n    x: 0,\n    y: 0,\n    z: 0\n  }\n) {\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n\n  const tile = {children: [], lodMetricValue: 0, contentUrl: ''};\n\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n\n  const childX = childIndex & 0b01;\n  const childY = (childIndex >> 1) & 0b01;\n  const childZ = (childIndex >> 2) & 0b01;\n\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n\n  // Local tile coordinates\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n\n  // TODO Remove after real implicit tileset will be tested.\n  // Degug data\n  // tile.level = level + globalData.level;\n  // tile.x = concatBits(globalData.x, childTileX);\n  // tile.y = concatBits(globalData.y, childTileY);\n  // tile.z = concatBits(globalData.z, childTileZ);\n  // tile.mortonIndex = childTileMortonIndex;\n  // End of debug data\n\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(\n      subtree.childSubtreeAvailability,\n      childTileMortonIndex\n    );\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n    subtree = childSubtree;\n\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(\n    subtree.contentAvailability,\n    tileAvailabilityIndex\n  );\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ};\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles(\n      subtree,\n      options,\n      pData,\n      index,\n      childTileLevel,\n      globalData\n    );\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {childTileX, childTileY, childTileZ};\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      // @ts-ignore\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData: Availability, index: number): boolean {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(\n  tile,\n  level: number,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number},\n  options: any\n) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(\n    level,\n    rootBoundingVolume,\n    childCoordinates\n  );\n\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {uri},\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    boundingVolume\n    // Temp debug values. Remove when real implicit tileset will be tested.\n    // x: tile.x,\n    // y: tile.y,\n    // z: tile.z,\n    // level: tile.level\n  };\n}\n\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param level\n * @param rootBoundingVolume\n * @param childCoordinates\n */\nfunction calculateBoundingVolumeForChildTile(\n  level: number,\n  rootBoundingVolume: BoundingVolume,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number}\n): BoundingVolume | null {\n  if (rootBoundingVolume.region) {\n    const {childTileX, childTileY, childTileZ} = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [\n      minimumHeight + sizeZ * childTileZ,\n      minimumHeight + sizeZ * (childTileZ + 1)\n    ];\n\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\n/**\n * Do binary concatenation\n * @param first\n * @param second\n */\nfunction concatBits(first: number, second: number): number {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(\n  templateUrl: string,\n  level: number,\n  x: number,\n  y: number,\n  z: number\n): string {\n  const mapUrl = generateMapUrl({level, x, y, z});\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items: {[key: string]: number}): {[key: string]: string} {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(\n  availabilityIndex: number,\n  availabilityBuffer: Uint8Array\n): boolean {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n\n  return bitValue === 1;\n}\n"]},"metadata":{},"sourceType":"module"}