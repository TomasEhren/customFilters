{"ast":null,"code":"import _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport BinSorter from './bin-sorter';\nimport { getScaleFunctionByScaleType } from './scale-utils';\nimport { getValueFunc, wrapGetValueFunc } from './aggregation-operation-utils';\n\nfunction nop() {}\n\nvar dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nvar _defaultDimensions = [{\n  key: 'fillColor',\n  accessor: 'getFillColor',\n  pickingInfo: 'colorValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getColorValue',\n        updateTrigger: 'getColorValue'\n      },\n      weight: {\n        prop: 'getColorWeight',\n        updateTrigger: 'getColorWeight'\n      },\n      aggregation: {\n        prop: 'colorAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'lowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'upperPercentile'\n      },\n      scaleType: {\n        prop: 'colorScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'colorDomain'\n      },\n      range: {\n        prop: 'colorRange'\n      }\n    },\n    onSet: {\n      props: 'onSetColorDomain'\n    }\n  },\n  nullValue: [0, 0, 0, 0]\n}, {\n  key: 'elevation',\n  accessor: 'getElevation',\n  pickingInfo: 'elevationValue',\n  getBins: {\n    triggers: {\n      value: {\n        prop: 'getElevationValue',\n        updateTrigger: 'getElevationValue'\n      },\n      weight: {\n        prop: 'getElevationWeight',\n        updateTrigger: 'getElevationWeight'\n      },\n      aggregation: {\n        prop: 'elevationAggregation'\n      },\n      filterData: {\n        prop: '_filterData',\n        updateTrigger: '_filterData'\n      }\n    }\n  },\n  getDomain: {\n    triggers: {\n      lowerPercentile: {\n        prop: 'elevationLowerPercentile'\n      },\n      upperPercentile: {\n        prop: 'elevationUpperPercentile'\n      },\n      scaleType: {\n        prop: 'elevationScaleType'\n      }\n    }\n  },\n  getScaleFunc: {\n    triggers: {\n      domain: {\n        prop: 'elevationDomain'\n      },\n      range: {\n        prop: 'elevationRange'\n      }\n    },\n    onSet: {\n      props: 'onSetElevationDomain'\n    }\n  },\n  nullValue: -1\n}];\n\nvar defaultGetCellSize = function defaultGetCellSize(props) {\n  return props.cellSize;\n};\n\nvar CPUAggregator = /*#__PURE__*/function () {\n  function CPUAggregator(opts) {\n    _classCallCheck(this, CPUAggregator);\n\n    this.state = {\n      layerData: {},\n      dimensions: {}\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n\n    this._addDimension(opts.dimensions || _defaultDimensions);\n  }\n\n  _createClass(CPUAggregator, [{\n    key: \"updateState\",\n    value: function updateState(opts, aggregationParams) {\n      var oldProps = opts.oldProps,\n          props = opts.props,\n          changeFlags = opts.changeFlags;\n      this.updateGetValueFuncs(oldProps, props, changeFlags);\n      var reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n      var aggregationDirty = false;\n\n      if (changeFlags.dataChanged || reprojectNeeded) {\n        this.getAggregatedData(props, aggregationParams);\n        aggregationDirty = true;\n      } else {\n        var dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n        dimensionChanges.forEach(function (f) {\n          return typeof f === 'function' && f();\n        });\n        aggregationDirty = true;\n      }\n\n      this.setState({\n        aggregationDirty: aggregationDirty\n      });\n      return this.state;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.state = _objectSpread(_objectSpread({}, this.state), updateObject);\n    }\n  }, {\n    key: \"setDimensionState\",\n    value: function setDimensionState(key, updateObject) {\n      this.setState({\n        dimensions: _objectSpread(_objectSpread({}, this.state.dimensions), {}, _defineProperty({}, key, _objectSpread(_objectSpread({}, this.state.dimensions[key]), updateObject)))\n      });\n    }\n  }, {\n    key: \"normalizeResult\",\n    value: function normalizeResult() {\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (result.hexagons) {\n        return _objectSpread({\n          data: result.hexagons\n        }, result);\n      } else if (result.layerData) {\n        return _objectSpread({\n          data: result.layerData\n        }, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAggregatedData\",\n    value: function getAggregatedData(props, aggregationParams) {\n      var aggregator = this._getAggregator(props);\n\n      var result = aggregator(props, aggregationParams);\n      this.setState({\n        layerData: this.normalizeResult(result)\n      });\n      this.changeFlags = {\n        layerData: true\n      };\n      this.getSortedBins(props);\n    }\n  }, {\n    key: \"updateGetValueFuncs\",\n    value: function updateGetValueFuncs(oldProps, props, changeFlags) {\n      for (var key in this.dimensionUpdaters) {\n        var _this$dimensionUpdate = this.dimensionUpdaters[key].getBins.triggers,\n            value = _this$dimensionUpdate.value,\n            weight = _this$dimensionUpdate.weight,\n            aggregation = _this$dimensionUpdate.aggregation;\n        var getValue = props[value.prop];\n        var getValueChanged = this.needUpdateDimensionStep(this.dimensionUpdaters[key].getBins, oldProps, props, changeFlags);\n\n        if (getValueChanged) {\n          if (getValue) {\n            getValue = wrapGetValueFunc(getValue, {\n              data: props.data\n            });\n          } else {\n            getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {\n              data: props.data\n            });\n          }\n        }\n\n        if (getValue) {\n          this.setDimensionState(key, {\n            getValue: getValue\n          });\n        }\n      }\n    }\n  }, {\n    key: \"needsReProjectPoints\",\n    value: function needsReProjectPoints(oldProps, props, changeFlags) {\n      return this._getCellSize(oldProps) !== this._getCellSize(props) || this._getAggregator(oldProps) !== this._getAggregator(props) || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition);\n    }\n  }, {\n    key: \"addDimension\",\n    value: function addDimension(dimensions) {\n      this._addDimension(dimensions);\n    }\n  }, {\n    key: \"_addDimension\",\n    value: function _addDimension() {\n      var _this = this;\n\n      var dimensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      dimensions.forEach(function (dimension) {\n        var key = dimension.key;\n        _this.dimensionUpdaters[key] = _this.getDimensionUpdaters(dimension);\n        _this.state.dimensions[key] = {\n          getValue: null,\n          domain: null,\n          sortedBins: null,\n          scaleFunc: nop\n        };\n      });\n    }\n  }, {\n    key: \"getDimensionUpdaters\",\n    value: function getDimensionUpdaters(_ref) {\n      var key = _ref.key,\n          accessor = _ref.accessor,\n          pickingInfo = _ref.pickingInfo,\n          getBins = _ref.getBins,\n          getDomain = _ref.getDomain,\n          getScaleFunc = _ref.getScaleFunc,\n          nullValue = _ref.nullValue;\n      return {\n        key: key,\n        accessor: accessor,\n        pickingInfo: pickingInfo,\n        getBins: _objectSpread({\n          updater: this.getDimensionSortedBins\n        }, getBins),\n        getDomain: _objectSpread({\n          updater: this.getDimensionValueDomain\n        }, getDomain),\n        getScaleFunc: _objectSpread({\n          updater: this.getDimensionScale\n        }, getScaleFunc),\n        attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n      };\n    }\n  }, {\n    key: \"needUpdateDimensionStep\",\n    value: function needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n      return Object.values(dimensionStep.triggers).some(function (item) {\n        if (item.updateTrigger) {\n          return changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged[item.updateTrigger]);\n        }\n\n        return oldProps[item.prop] !== props[item.prop];\n      });\n    }\n  }, {\n    key: \"getDimensionChanges\",\n    value: function getDimensionChanges(oldProps, props, changeFlags) {\n      var _this2 = this;\n\n      var updaters = [];\n\n      var _loop = function _loop(key) {\n        var needUpdate = dimensionSteps.find(function (step) {\n          return _this2.needUpdateDimensionStep(_this2.dimensionUpdaters[key][step], oldProps, props, changeFlags);\n        });\n\n        if (needUpdate) {\n          updaters.push(_this2.dimensionUpdaters[key][needUpdate].updater.bind(_this2, props, _this2.dimensionUpdaters[key]));\n        }\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop(key);\n      }\n\n      return updaters.length ? updaters : null;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers(props) {\n      var _this3 = this;\n\n      var _updateTriggers = props.updateTriggers || {};\n\n      var updateTriggers = {};\n\n      var _loop2 = function _loop2(key) {\n        var accessor = _this3.dimensionUpdaters[key].accessor;\n        updateTriggers[accessor] = {};\n        dimensionSteps.forEach(function (step) {\n          Object.values(_this3.dimensionUpdaters[key][step].triggers).forEach(function (_ref2) {\n            var prop = _ref2.prop,\n                updateTrigger = _ref2.updateTrigger;\n\n            if (updateTrigger) {\n              var fromProp = _updateTriggers[updateTrigger];\n\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          });\n        });\n      };\n\n      for (var key in this.dimensionUpdaters) {\n        _loop2(key);\n      }\n\n      return updateTriggers;\n    }\n  }, {\n    key: \"getSortedBins\",\n    value: function getSortedBins(props) {\n      for (var key in this.dimensionUpdaters) {\n        this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n      }\n    }\n  }, {\n    key: \"getDimensionSortedBins\",\n    value: function getDimensionSortedBins(props, dimensionUpdater) {\n      var key = dimensionUpdater.key;\n      var getValue = this.state.dimensions[key].getValue;\n      var sortedBins = new BinSorter(this.state.layerData.data || [], {\n        getValue: getValue,\n        filterData: props._filterData\n      });\n      this.setDimensionState(key, {\n        sortedBins: sortedBins\n      });\n      this.getDimensionValueDomain(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionValueDomain\",\n    value: function getDimensionValueDomain(props, dimensionUpdater) {\n      var getDomain = dimensionUpdater.getDomain,\n          key = dimensionUpdater.key;\n      var _getDomain$triggers = getDomain.triggers,\n          lowerPercentile = _getDomain$triggers.lowerPercentile,\n          upperPercentile = _getDomain$triggers.upperPercentile,\n          scaleType = _getDomain$triggers.scaleType;\n      var valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(props[scaleType.prop], [props[lowerPercentile.prop], props[upperPercentile.prop]]);\n      this.setDimensionState(key, {\n        valueDomain: valueDomain\n      });\n      this.getDimensionScale(props, dimensionUpdater);\n    }\n  }, {\n    key: \"getDimensionScale\",\n    value: function getDimensionScale(props, dimensionUpdater) {\n      var key = dimensionUpdater.key,\n          getScaleFunc = dimensionUpdater.getScaleFunc,\n          getDomain = dimensionUpdater.getDomain;\n      var _getScaleFunc$trigger = getScaleFunc.triggers,\n          domain = _getScaleFunc$trigger.domain,\n          range = _getScaleFunc$trigger.range;\n      var scaleType = getDomain.triggers.scaleType;\n      var onSet = getScaleFunc.onSet;\n      var dimensionRange = props[range.prop];\n      var dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n      var getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n      var scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n      if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n        props[onSet.props](scaleFunc.domain());\n      }\n\n      this.setDimensionState(key, {\n        scaleFunc: scaleFunc\n      });\n    }\n  }, {\n    key: \"getSubLayerDimensionAttribute\",\n    value: function getSubLayerDimensionAttribute(key, nullValue) {\n      var _this4 = this;\n\n      return function (cell) {\n        var _this4$state$dimensio = _this4.state.dimensions[key],\n            sortedBins = _this4$state$dimensio.sortedBins,\n            scaleFunc = _this4$state$dimensio.scaleFunc;\n        var bin = sortedBins.binMap[cell.index];\n\n        if (bin && bin.counts === 0) {\n          return nullValue;\n        }\n\n        var cv = bin && bin.value;\n        var domain = scaleFunc.domain();\n        var isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n        return isValueInDomain ? scaleFunc(cv) : nullValue;\n      };\n    }\n  }, {\n    key: \"getSubLayerAccessors\",\n    value: function getSubLayerAccessors(props) {\n      var accessors = {};\n\n      for (var key in this.dimensionUpdaters) {\n        var accessor = this.dimensionUpdaters[key].accessor;\n        accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n      }\n\n      return accessors;\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      var isPicked = info.picked && info.index > -1;\n      var object = null;\n\n      if (isPicked) {\n        var cell = this.state.layerData.data[info.index];\n        var binInfo = {};\n\n        for (var key in this.dimensionUpdaters) {\n          var pickingInfo = this.dimensionUpdaters[key].pickingInfo;\n          var sortedBins = this.state.dimensions[key].sortedBins;\n          var value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n          binInfo[pickingInfo] = value;\n        }\n\n        object = Object.assign(binInfo, cell, {\n          points: cell.filteredPoints || cell.points\n        });\n      }\n\n      info.picked = Boolean(object);\n      info.object = object;\n      return info;\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(dimensionKey) {\n      if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n        return nop;\n      }\n\n      return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n    }\n  }], [{\n    key: \"defaultDimensions\",\n    value: function defaultDimensions() {\n      return _defaultDimensions;\n    }\n  }]);\n\n  return CPUAggregator;\n}();\n\nexport { CPUAggregator as default };","map":{"version":3,"mappings":"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","names":["BinSorter","getScaleFunctionByScaleType","getValueFunc","wrapGetValueFunc","nop","dimensionSteps","defaultDimensions","key","accessor","pickingInfo","getBins","triggers","value","prop","updateTrigger","weight","aggregation","filterData","getDomain","lowerPercentile","upperPercentile","scaleType","getScaleFunc","domain","range","onSet","props","nullValue","defaultGetCellSize","cellSize","CPUAggregator","constructor","opts","state","layerData","dimensions","changeFlags","dimensionUpdaters","_getCellSize","getCellSize","_getAggregator","getAggregator","_addDimension","updateState","aggregationParams","oldProps","updateGetValueFuncs","reprojectNeeded","needsReProjectPoints","aggregationDirty","dataChanged","getAggregatedData","dimensionChanges","getDimensionChanges","forEach","f","setState","updateObject","setDimensionState","normalizeResult","result","hexagons","data","aggregator","getSortedBins","getValue","getValueChanged","needUpdateDimensionStep","updateTriggersChanged","all","getPosition","addDimension","dimension","getDimensionUpdaters","sortedBins","scaleFunc","updater","getDimensionSortedBins","getDimensionValueDomain","getDimensionScale","attributeAccessor","getSubLayerDimensionAttribute","dimensionStep","Object","values","some","item","updaters","needUpdate","find","step","push","bind","length","getUpdateTriggers","_updateTriggers","updateTriggers","fromProp","Array","isArray","assign","undefined","dimensionUpdater","_filterData","valueDomain","getValueDomainByScale","dimensionRange","dimensionDomain","getScaleFunction","cell","bin","binMap","index","counts","cv","isValueInDomain","getSubLayerAccessors","accessors","getPickingInfo","info","isPicked","picked","object","binInfo","points","filteredPoints","Boolean","getAccessor","dimensionKey","hasOwnProperty"],"sources":["../../../src/utils/cpu-aggregator.js"],"sourcesContent":["// Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport BinSorter from './bin-sorter';\nimport {getScaleFunctionByScaleType} from './scale-utils';\nimport {getValueFunc, wrapGetValueFunc} from './aggregation-operation-utils';\n\nfunction nop() {}\n\nconst dimensionSteps = ['getBins', 'getDomain', 'getScaleFunc'];\nconst defaultDimensions = [\n  {\n    key: 'fillColor',\n    accessor: 'getFillColor',\n    pickingInfo: 'colorValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getColorValue',\n          updateTrigger: 'getColorValue'\n        },\n        weight: {\n          prop: 'getColorWeight',\n          updateTrigger: 'getColorWeight'\n        },\n        aggregation: {\n          prop: 'colorAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'lowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'upperPercentile'\n        },\n        scaleType: {\n          prop: 'colorScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'colorDomain'},\n        range: {prop: 'colorRange'}\n      },\n      onSet: {\n        props: 'onSetColorDomain'\n      }\n    },\n    nullValue: [0, 0, 0, 0]\n  },\n  {\n    key: 'elevation',\n    accessor: 'getElevation',\n    pickingInfo: 'elevationValue',\n    getBins: {\n      triggers: {\n        value: {\n          prop: 'getElevationValue',\n          updateTrigger: 'getElevationValue'\n        },\n        weight: {\n          prop: 'getElevationWeight',\n          updateTrigger: 'getElevationWeight'\n        },\n        aggregation: {\n          prop: 'elevationAggregation'\n        },\n        filterData: {\n          prop: '_filterData',\n          updateTrigger: '_filterData'\n        }\n      }\n    },\n    getDomain: {\n      triggers: {\n        lowerPercentile: {\n          prop: 'elevationLowerPercentile'\n        },\n        upperPercentile: {\n          prop: 'elevationUpperPercentile'\n        },\n        scaleType: {\n          prop: 'elevationScaleType'\n        }\n      }\n    },\n    getScaleFunc: {\n      triggers: {\n        domain: {prop: 'elevationDomain'},\n        range: {prop: 'elevationRange'}\n      },\n      onSet: {\n        props: 'onSetElevationDomain'\n      }\n    },\n    nullValue: -1\n  }\n];\nconst defaultGetCellSize = props => props.cellSize;\nexport default class CPUAggregator {\n  constructor(opts) {\n    this.state = {\n      layerData: {},\n      dimensions: {\n        // color: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // },\n        // elevation: {\n        //   getValue: null,\n        //   domain: null,\n        //   sortedBins: null,\n        //   scaleFunc: nop\n        // }\n      }\n    };\n    this.changeFlags = {};\n    this.dimensionUpdaters = {};\n\n    this._getCellSize = opts.getCellSize || defaultGetCellSize;\n    this._getAggregator = opts.getAggregator;\n    this._addDimension(opts.dimensions || defaultDimensions);\n  }\n\n  static defaultDimensions() {\n    return defaultDimensions;\n  }\n\n  updateState(opts, aggregationParams) {\n    const {oldProps, props, changeFlags} = opts;\n    this.updateGetValueFuncs(oldProps, props, changeFlags);\n    const reprojectNeeded = this.needsReProjectPoints(oldProps, props, changeFlags);\n    let aggregationDirty = false;\n    if (changeFlags.dataChanged || reprojectNeeded) {\n      // project data into bin and aggregate wegiths per bin\n      this.getAggregatedData(props, aggregationParams);\n      aggregationDirty = true;\n    } else {\n      const dimensionChanges = this.getDimensionChanges(oldProps, props, changeFlags) || [];\n      // this here is layer\n      dimensionChanges.forEach(f => typeof f === 'function' && f());\n      aggregationDirty = true;\n    }\n    this.setState({aggregationDirty});\n\n    return this.state;\n  }\n\n  // Update private state\n  setState(updateObject) {\n    this.state = {...this.state, ...updateObject};\n  }\n\n  // Update private state.dimensions\n  setDimensionState(key, updateObject) {\n    this.setState({\n      dimensions: {\n        ...this.state.dimensions,\n        [key]: {...this.state.dimensions[key], ...updateObject}\n      }\n    });\n  }\n\n  normalizeResult(result = {}) {\n    // support previous hexagonAggregator API\n    if (result.hexagons) {\n      return {data: result.hexagons, ...result};\n    } else if (result.layerData) {\n      return {data: result.layerData, ...result};\n    }\n\n    return result;\n  }\n\n  getAggregatedData(props, aggregationParams) {\n    const aggregator = this._getAggregator(props);\n\n    const result = aggregator(props, aggregationParams);\n    this.setState({\n      layerData: this.normalizeResult(result)\n    });\n    this.changeFlags = {\n      layerData: true\n    };\n    this.getSortedBins(props);\n  }\n\n  updateGetValueFuncs(oldProps, props, changeFlags) {\n    for (const key in this.dimensionUpdaters) {\n      const {value, weight, aggregation} = this.dimensionUpdaters[key].getBins.triggers;\n      let getValue = props[value.prop];\n      const getValueChanged = this.needUpdateDimensionStep(\n        this.dimensionUpdaters[key].getBins,\n        oldProps,\n        props,\n        changeFlags\n      );\n\n      if (getValueChanged) {\n        if (getValue) {\n          getValue = wrapGetValueFunc(getValue, {data: props.data});\n        } else {\n          // If `getValue` is not provided from props, build it with aggregation and weight.\n          getValue = getValueFunc(props[aggregation.prop], props[weight.prop], {data: props.data});\n        }\n      }\n\n      if (getValue) {\n        this.setDimensionState(key, {getValue});\n      }\n    }\n  }\n\n  needsReProjectPoints(oldProps, props, changeFlags) {\n    return (\n      this._getCellSize(oldProps) !== this._getCellSize(props) ||\n      this._getAggregator(oldProps) !== this._getAggregator(props) ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPosition))\n    );\n  }\n\n  // Adds dimensions\n  addDimension(dimensions) {\n    this._addDimension(dimensions);\n  }\n\n  _addDimension(dimensions = []) {\n    dimensions.forEach(dimension => {\n      const {key} = dimension;\n      this.dimensionUpdaters[key] = this.getDimensionUpdaters(dimension);\n      this.state.dimensions[key] = {\n        getValue: null,\n        domain: null,\n        sortedBins: null,\n        scaleFunc: nop\n      };\n    });\n  }\n\n  getDimensionUpdaters({key, accessor, pickingInfo, getBins, getDomain, getScaleFunc, nullValue}) {\n    return {\n      key,\n      accessor,\n      pickingInfo,\n      getBins: {updater: this.getDimensionSortedBins, ...getBins},\n      getDomain: {updater: this.getDimensionValueDomain, ...getDomain},\n      getScaleFunc: {updater: this.getDimensionScale, ...getScaleFunc},\n      attributeAccessor: this.getSubLayerDimensionAttribute(key, nullValue)\n    };\n  }\n\n  needUpdateDimensionStep(dimensionStep, oldProps, props, changeFlags) {\n    // whether need to update current dimension step\n    // dimension step is the value, domain, scaleFunction of each dimension\n    // each step is an object with properties links to layer prop and whether the prop is\n    // controlled by updateTriggers\n    // getBins: {\n    //   value: {\n    //     prop: 'getElevationValue',\n    //     updateTrigger: 'getElevationValue'\n    //   },\n    //   weight: {\n    //     prop: 'getElevationWeight',\n    //     updateTrigger: 'getElevationWeight'\n    //   },\n    //   aggregation: {\n    //     prop: 'elevationAggregation'\n    //   }\n    // }\n    return Object.values(dimensionStep.triggers).some(item => {\n      if (item.updateTrigger) {\n        // check based on updateTriggers change first\n        // if data has changed, always update value\n        return (\n          changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged &&\n            (changeFlags.updateTriggersChanged.all ||\n              changeFlags.updateTriggersChanged[item.updateTrigger]))\n        );\n      }\n      // fallback to direct comparison\n      return oldProps[item.prop] !== props[item.prop];\n    });\n  }\n\n  getDimensionChanges(oldProps, props, changeFlags) {\n    // const {dimensionUpdaters} = this.state;\n    const updaters = [];\n\n    // get dimension to be updated\n    for (const key in this.dimensionUpdaters) {\n      // return the first triggered updater for each dimension\n      const needUpdate = dimensionSteps.find(step =>\n        this.needUpdateDimensionStep(\n          this.dimensionUpdaters[key][step],\n          oldProps,\n          props,\n          changeFlags\n        )\n      );\n\n      if (needUpdate) {\n        updaters.push(\n          this.dimensionUpdaters[key][needUpdate].updater.bind(\n            this,\n            props,\n            this.dimensionUpdaters[key]\n          )\n        );\n      }\n    }\n\n    return updaters.length ? updaters : null;\n  }\n\n  getUpdateTriggers(props) {\n    const _updateTriggers = props.updateTriggers || {};\n    const updateTriggers = {};\n\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      // fold dimension triggers into each accessor\n      updateTriggers[accessor] = {};\n\n      dimensionSteps.forEach(step => {\n        Object.values(this.dimensionUpdaters[key][step].triggers).forEach(\n          ({prop, updateTrigger}) => {\n            if (updateTrigger) {\n              // if prop is based on updateTrigger e.g. getColorValue, getColorWeight\n              // and updateTriggers is passed in from layer prop\n              // fold the updateTriggers into accessor\n              const fromProp = _updateTriggers[updateTrigger];\n              if (typeof fromProp === 'object' && !Array.isArray(fromProp)) {\n                // if updateTrigger is an object spread it\n                Object.assign(updateTriggers[accessor], fromProp);\n              } else if (fromProp !== undefined) {\n                updateTriggers[accessor][prop] = fromProp;\n              }\n            } else {\n              // if prop is not based on updateTrigger\n              updateTriggers[accessor][prop] = props[prop];\n            }\n          }\n        );\n      });\n    }\n\n    return updateTriggers;\n  }\n\n  getSortedBins(props) {\n    for (const key in this.dimensionUpdaters) {\n      this.getDimensionSortedBins(props, this.dimensionUpdaters[key]);\n    }\n  }\n\n  getDimensionSortedBins(props, dimensionUpdater) {\n    const {key} = dimensionUpdater;\n    const {getValue} = this.state.dimensions[key];\n\n    const sortedBins = new BinSorter(this.state.layerData.data || [], {\n      getValue,\n      filterData: props._filterData\n    });\n    this.setDimensionState(key, {sortedBins});\n    this.getDimensionValueDomain(props, dimensionUpdater);\n  }\n\n  getDimensionValueDomain(props, dimensionUpdater) {\n    const {getDomain, key} = dimensionUpdater;\n    const {\n      triggers: {lowerPercentile, upperPercentile, scaleType}\n    } = getDomain;\n    const valueDomain = this.state.dimensions[key].sortedBins.getValueDomainByScale(\n      props[scaleType.prop],\n      [props[lowerPercentile.prop], props[upperPercentile.prop]]\n    );\n\n    this.setDimensionState(key, {valueDomain});\n    this.getDimensionScale(props, dimensionUpdater);\n  }\n\n  getDimensionScale(props, dimensionUpdater) {\n    const {key, getScaleFunc, getDomain} = dimensionUpdater;\n    const {domain, range} = getScaleFunc.triggers;\n    const {scaleType} = getDomain.triggers;\n    const {onSet} = getScaleFunc;\n    const dimensionRange = props[range.prop];\n    const dimensionDomain = props[domain.prop] || this.state.dimensions[key].valueDomain;\n    const getScaleFunction = getScaleFunctionByScaleType(scaleType && props[scaleType.prop]);\n    const scaleFunc = getScaleFunction(dimensionDomain, dimensionRange);\n\n    if (typeof onSet === 'object' && typeof props[onSet.props] === 'function') {\n      props[onSet.props](scaleFunc.domain());\n    }\n\n    this.setDimensionState(key, {scaleFunc});\n  }\n\n  getSubLayerDimensionAttribute(key, nullValue) {\n    return cell => {\n      const {sortedBins, scaleFunc} = this.state.dimensions[key];\n      const bin = sortedBins.binMap[cell.index];\n\n      if (bin && bin.counts === 0) {\n        // no points left in bin after filtering\n        return nullValue;\n      }\n      const cv = bin && bin.value;\n      const domain = scaleFunc.domain();\n\n      const isValueInDomain = cv >= domain[0] && cv <= domain[domain.length - 1];\n\n      // if cell value is outside domain, set alpha to 0\n      return isValueInDomain ? scaleFunc(cv) : nullValue;\n    };\n  }\n\n  getSubLayerAccessors(props) {\n    const accessors = {};\n    for (const key in this.dimensionUpdaters) {\n      const {accessor} = this.dimensionUpdaters[key];\n      accessors[accessor] = this.getSubLayerDimensionAttribute(props, key);\n    }\n\n    return accessors;\n  }\n\n  getPickingInfo({info}) {\n    const isPicked = info.picked && info.index > -1;\n    let object = null;\n\n    if (isPicked) {\n      // const {sortedColorBins, sortedElevationBins} = this.state;\n\n      const cell = this.state.layerData.data[info.index];\n\n      const binInfo = {};\n      for (const key in this.dimensionUpdaters) {\n        const {pickingInfo} = this.dimensionUpdaters[key];\n        const {sortedBins} = this.state.dimensions[key];\n        const value = sortedBins.binMap[cell.index] && sortedBins.binMap[cell.index].value;\n        binInfo[pickingInfo] = value;\n      }\n\n      object = Object.assign(binInfo, cell, {\n        points: cell.filteredPoints || cell.points\n      });\n    }\n\n    // override object with picked cell\n    info.picked = Boolean(object);\n    info.object = object;\n\n    return info;\n  }\n\n  getAccessor(dimensionKey) {\n    if (!this.dimensionUpdaters.hasOwnProperty(dimensionKey)) {\n      return nop;\n    }\n    return this.dimensionUpdaters[dimensionKey].attributeAccessor;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}