{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"type\", \"data\", \"clientId\", \"credentials\"];\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { CompositeLayer, log } from '@deck.gl/core';\nimport CartoTileLayer from './carto-tile-layer';\nimport { MVTLayer } from '@deck.gl/geo-layers';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { fetchLayerData, getDataV2, API_VERSIONS } from '../api';\nimport { COLUMNS_SUPPORT, FORMATS, GEO_COLUMN_SUPPORT, MAP_TYPES, TILE_FORMATS } from '../api/maps-api-common';\nimport { getDefaultCredentials } from '../config';\nvar defaultProps = {\n  data: null,\n  type: null,\n  onDataLoad: {\n    type: 'function',\n    value: function value(data) {},\n    compare: false\n  },\n  onDataError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  },\n  uniqueIdProperty: 'cartodb_id',\n  credentials: null,\n  connection: null,\n  format: null,\n  formatTiles: null,\n  clientId: null,\n  geoColumn: null,\n  columns: {\n    type: 'array',\n    value: null\n  }\n};\n\nvar CartoLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(CartoLayer, _CompositeLayer);\n\n  var _super = _createSuper(CartoLayer);\n\n  function CartoLayer() {\n    _classCallCheck(this, CartoLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(CartoLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        data: null,\n        apiVersion: null\n      };\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this.getSubLayers().length > 0 && _get(_getPrototypeOf(CartoLayer.prototype), \"isLoaded\", this);\n    }\n  }, {\n    key: \"_checkProps\",\n    value: function _checkProps(props) {\n      var type = props.type,\n          credentials = props.credentials,\n          connection = props.connection,\n          geoColumn = props.geoColumn,\n          columns = props.columns;\n\n      var localCreds = _objectSpread(_objectSpread({}, getDefaultCredentials()), credentials);\n\n      var apiVersion = localCreds.apiVersion;\n      log.assert(Object.values(API_VERSIONS).includes(apiVersion), \"Invalid apiVersion \".concat(apiVersion, \". Use API_VERSIONS enum.\"));\n\n      if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        log.assert(type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET, \"Invalid type \".concat(type, \". Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion \").concat(apiVersion));\n        log.assert(!connection, \"Connection prop is not supported for apiVersion \".concat(apiVersion));\n        log.assert(!geoColumn, \"geoColumn prop is not supported for apiVersion \".concat(apiVersion));\n        log.assert(!columns, \"columns prop is not supported for apiVersion \".concat(apiVersion));\n      } else if (apiVersion === API_VERSIONS.V3) {\n        log.assert(connection, 'Missing mandatory connection parameter');\n        log.assert(Object.values(MAP_TYPES).includes(type), \"Invalid type \".concat(type, \". Use MAP_TYPES enum.\"));\n\n        if (!COLUMNS_SUPPORT.includes(type)) {\n          log.assert(!columns, \"columns prop is only supported for types: \".concat(COLUMNS_SUPPORT.join()));\n        }\n\n        if (!GEO_COLUMN_SUPPORT.includes(type)) {\n          log.assert(!geoColumn, \"geoColumn prop is only supported for types: \".concat(GEO_COLUMN_SUPPORT.join()));\n        }\n\n        if (columns) {\n          log.assert(Array.isArray(columns), 'columns prop must be an Array');\n        }\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      this._checkProps(props);\n\n      var shouldUpdateData = changeFlags.dataChanged || props.connection !== oldProps.connection || props.geoColumn !== oldProps.geoColumn || props.format !== oldProps.format || props.formatTiles !== oldProps.formatTiles || props.type !== oldProps.type || JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) || JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n      if (shouldUpdateData) {\n        this.setState({\n          data: null,\n          apiVersion: null\n        });\n\n        this._updateData();\n      }\n    }\n  }, {\n    key: \"_updateData\",\n    value: function () {\n      var _updateData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this$props, type, source, clientId, credentials, rest, localConfig, apiVersion, result;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _this$props = this.props, type = _this$props.type, source = _this$props.data, clientId = _this$props.clientId, credentials = _this$props.credentials, rest = _objectWithoutProperties(_this$props, _excluded);\n                localConfig = _objectSpread(_objectSpread({}, getDefaultCredentials()), credentials);\n                apiVersion = localConfig.apiVersion;\n\n                if (!(apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 7;\n                return getDataV2({\n                  type: type,\n                  source: source,\n                  credentials: credentials\n                });\n\n              case 7:\n                _context.t0 = _context.sent;\n                result = {\n                  data: _context.t0\n                };\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.next = 13;\n                return fetchLayerData(_objectSpread({\n                  type: type,\n                  source: source,\n                  clientId: clientId,\n                  credentials: credentials\n                }, rest));\n\n              case 13:\n                result = _context.sent;\n\n              case 14:\n                this.setState(_objectSpread(_objectSpread({}, result), {}, {\n                  apiVersion: apiVersion\n                }));\n                this.props.onDataLoad(result.data);\n                _context.next = 25;\n                break;\n\n              case 18:\n                _context.prev = 18;\n                _context.t1 = _context[\"catch\"](0);\n\n                if (!this.props.onDataError) {\n                  _context.next = 24;\n                  break;\n                }\n\n                this.props.onDataError(_context.t1);\n                _context.next = 25;\n                break;\n\n              case 24:\n                throw _context.t1;\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 18]]);\n      }));\n\n      function _updateData() {\n        return _updateData2.apply(this, arguments);\n      }\n\n      return _updateData;\n    }()\n  }, {\n    key: \"_getSubLayerAndProps\",\n    value: function _getSubLayerAndProps() {\n      var _this$state = this.state,\n          data = _this$state.data,\n          format = _this$state.format,\n          apiVersion = _this$state.apiVersion;\n      var uniqueIdProperty = defaultProps.uniqueIdProperty;\n\n      var props = _objectSpread({\n        uniqueIdProperty: uniqueIdProperty\n      }, this.props);\n\n      delete props.data;\n\n      if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        return [MVTLayer, props];\n      }\n\n      if (format === FORMATS.TILEJSON) {\n        var tileUrl = new URL(data.tiles[0]);\n        props.formatTiles = props.formatTiles || tileUrl.searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n        return props.formatTiles === TILE_FORMATS.MVT ? [MVTLayer, props] : [CartoTileLayer, props];\n      }\n\n      return [GeoJsonLayer, props];\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var data = this.state.data;\n      if (!data) return null;\n      var updateTriggers = this.props.updateTriggers;\n\n      var _this$_getSubLayerAnd = this._getSubLayerAndProps(),\n          _this$_getSubLayerAnd2 = _slicedToArray(_this$_getSubLayerAnd, 2),\n          layer = _this$_getSubLayerAnd2[0],\n          props = _this$_getSubLayerAnd2[1];\n\n      return new layer(props, this.getSubLayerProps({\n        id: \"carto-\".concat(layer.layerName),\n        data: data,\n        updateTriggers: updateTriggers\n      }));\n    }\n  }]);\n\n  return CartoLayer;\n}(CompositeLayer);\n\nexport { CartoLayer as default };\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["CompositeLayer","log","CartoTileLayer","MVTLayer","GeoJsonLayer","fetchLayerData","getDataV2","API_VERSIONS","COLUMNS_SUPPORT","FORMATS","GEO_COLUMN_SUPPORT","MAP_TYPES","TILE_FORMATS","getDefaultCredentials","defaultProps","data","type","onDataLoad","value","compare","onDataError","optional","uniqueIdProperty","credentials","connection","format","formatTiles","clientId","geoColumn","columns","CartoLayer","initializeState","state","apiVersion","getSubLayers","length","_checkProps","props","localCreds","assert","Object","values","includes","V1","V2","QUERY","TILESET","V3","join","Array","isArray","updateState","oldProps","changeFlags","shouldUpdateData","dataChanged","JSON","stringify","setState","_updateData","source","rest","localConfig","result","_getSubLayerAndProps","TILEJSON","tileUrl","URL","tiles","searchParams","get","MVT","renderLayers","updateTriggers","layer","getSubLayerProps","id","layerName"],"sources":["../../../src/layers/carto-layer.js"],"sourcesContent":["import {CompositeLayer, log} from '@deck.gl/core';\nimport CartoTileLayer from './carto-tile-layer';\nimport {MVTLayer} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {fetchLayerData, getDataV2, API_VERSIONS} from '../api';\nimport {\n  COLUMNS_SUPPORT,\n  FORMATS,\n  GEO_COLUMN_SUPPORT,\n  MAP_TYPES,\n  TILE_FORMATS\n} from '../api/maps-api-common';\nimport {getDefaultCredentials} from '../config';\n\nconst defaultProps = {\n  // (String, required): data resource to load. table name, sql query or tileset name.\n  data: null,\n  // (Enum (MAP_TYPES), required)\n  type: null,\n  onDataLoad: {type: 'function', value: data => {}, compare: false},\n  onDataError: {type: 'function', value: null, compare: false, optional: true},\n  uniqueIdProperty: 'cartodb_id',\n\n  // override carto credentials for the layer, set to null to read from default\n  credentials: null,\n\n  /*********************/\n  /* API v3 PARAMETERS */\n  /**********************/\n  // (String, required): connection name at CARTO platform\n  connection: null,\n\n  // (String, optional): format of data\n  format: null,\n\n  // (String, optional): force format of data for tiles\n  formatTiles: null,\n\n  // (String, optional): clientId identifier used for internal tracing, place here a string to identify the client who is doing the request.\n  clientId: null,\n\n  // (String, optional): name of the `geo_column` in the CARTO platform. Use this override the default column ('geom'), from which the geometry information should be fetched.\n  geoColumn: null,\n\n  // (Array<String>, optional): names of columns to fetch. By default, all columns are fetched.\n  columns: {type: 'array', value: null}\n};\n\nexport default class CartoLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      data: null,\n      apiVersion: null\n    };\n  }\n\n  get isLoaded() {\n    return this.getSubLayers().length > 0 && super.isLoaded;\n  }\n\n  _checkProps(props) {\n    const {type, credentials, connection, geoColumn, columns} = props;\n    const localCreds = {...getDefaultCredentials(), ...credentials};\n    const {apiVersion} = localCreds;\n\n    log.assert(\n      Object.values(API_VERSIONS).includes(apiVersion),\n      `Invalid apiVersion ${apiVersion}. Use API_VERSIONS enum.`\n    );\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      log.assert(\n        type === MAP_TYPES.QUERY || type === MAP_TYPES.TILESET,\n        `Invalid type ${type}. Use type MAP_TYPES.QUERY or MAP_TYPES.TILESET for apiVersion ${apiVersion}`\n      );\n      log.assert(!connection, `Connection prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!geoColumn, `geoColumn prop is not supported for apiVersion ${apiVersion}`);\n      log.assert(!columns, `columns prop is not supported for apiVersion ${apiVersion}`);\n    } else if (apiVersion === API_VERSIONS.V3) {\n      log.assert(connection, 'Missing mandatory connection parameter');\n      log.assert(\n        Object.values(MAP_TYPES).includes(type),\n        `Invalid type ${type}. Use MAP_TYPES enum.`\n      );\n      if (!COLUMNS_SUPPORT.includes(type)) {\n        log.assert(!columns, `columns prop is only supported for types: ${COLUMNS_SUPPORT.join()}`);\n      }\n      if (!GEO_COLUMN_SUPPORT.includes(type)) {\n        log.assert(\n          !geoColumn,\n          `geoColumn prop is only supported for types: ${GEO_COLUMN_SUPPORT.join()}`\n        );\n      }\n      if (columns) {\n        log.assert(Array.isArray(columns), 'columns prop must be an Array');\n      }\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    this._checkProps(props);\n    const shouldUpdateData =\n      changeFlags.dataChanged ||\n      props.connection !== oldProps.connection ||\n      props.geoColumn !== oldProps.geoColumn ||\n      props.format !== oldProps.format ||\n      props.formatTiles !== oldProps.formatTiles ||\n      props.type !== oldProps.type ||\n      JSON.stringify(props.columns) !== JSON.stringify(oldProps.columns) ||\n      JSON.stringify(props.credentials) !== JSON.stringify(oldProps.credentials);\n\n    if (shouldUpdateData) {\n      this.setState({data: null, apiVersion: null});\n      this._updateData();\n    }\n  }\n\n  async _updateData() {\n    try {\n      const {type, data: source, clientId, credentials, ...rest} = this.props;\n      const localConfig = {...getDefaultCredentials(), ...credentials};\n      const {apiVersion} = localConfig;\n\n      let result;\n      if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n        result = {data: await getDataV2({type, source, credentials})};\n      } else {\n        result = await fetchLayerData({type, source, clientId, credentials, ...rest});\n      }\n\n      this.setState({...result, apiVersion});\n      this.props.onDataLoad(result.data);\n    } catch (err) {\n      if (this.props.onDataError) {\n        this.props.onDataError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _getSubLayerAndProps() {\n    const {data, format, apiVersion} = this.state;\n\n    const {uniqueIdProperty} = defaultProps;\n    const props = {uniqueIdProperty, ...this.props};\n    delete props.data;\n\n    if (apiVersion === API_VERSIONS.V1 || apiVersion === API_VERSIONS.V2) {\n      return [MVTLayer, props];\n    }\n\n    if (format === FORMATS.TILEJSON) {\n      /* global URL */\n      const tileUrl = new URL(data.tiles[0]);\n\n      props.formatTiles =\n        props.formatTiles || tileUrl.searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n\n      return props.formatTiles === TILE_FORMATS.MVT ? [MVTLayer, props] : [CartoTileLayer, props];\n    }\n\n    // It's a geojson layer\n    return [GeoJsonLayer, props];\n  }\n\n  renderLayers() {\n    const {data} = this.state;\n\n    if (!data) return null;\n\n    const {updateTriggers} = this.props;\n\n    const [layer, props] = this._getSubLayerAndProps();\n\n    // eslint-disable-next-line new-cap\n    return new layer(\n      props,\n      this.getSubLayerProps({\n        id: `carto-${layer.layerName}`,\n        data,\n        updateTriggers\n      })\n    );\n  }\n}\n\nCartoLayer.layerName = 'CartoLayer';\nCartoLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}