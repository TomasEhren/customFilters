{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _constants = require(\"../constants\");\n\nvar _editableLayer = _interopRequireDefault(require(\"./editable-layer\"));\n\nvar _editablePathLayer = _interopRequireDefault(require(\"./editable-path-layer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_LINE_COLOR = [0x0, 0x0, 0x0, 0x99];\nvar DEFAULT_FILL_COLOR = [0x0, 0x0, 0x0, 0x90];\nvar DEFAULT_SELECTED_LINE_COLOR = [0x0, 0x0, 0x0, 0xff];\nvar DEFAULT_SELECTED_FILL_COLOR = [0x0, 0x0, 0x90, 0x90];\nvar DEFAULT_TENTATIVE_LINE_COLOR = [0x90, 0x90, 0x90, 0xff];\nvar DEFAULT_TENTATIVE_FILL_COLOR = [0x90, 0x90, 0x90, 0x90];\nvar DEFAULT_EDITING_EXISTING_POINT_COLOR = [0xc0, 0x0, 0x0, 0xff];\nvar DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR = [0x0, 0x0, 0x0, 0x80];\nvar DEFAULT_EDITING_SNAP_POINT_COLOR = [0x7c, 0x00, 0xc0, 0xff];\nvar DEFAULT_EDITING_POINT_OUTLINE_COLOR = [0xff, 0xff, 0xff, 0xff];\nvar DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nvar DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nvar DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\nvar DEFAULT_TOOLTIP_FONT_SIZE = 32 * _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER;\nvar DEFAULT_EDIT_MODE = _editModes.DrawPolygonMode;\n\nfunction guideAccessor(accessor) {\n  if (!accessor || typeof accessor !== 'function') {\n    return accessor;\n  }\n\n  return function (guideMaybeWrapped) {\n    return accessor(unwrapGuide(guideMaybeWrapped));\n  };\n} // The object handed to us from deck.gl is different depending on the version of deck.gl used, unwrap as necessary\n\n\nfunction unwrapGuide(guideMaybeWrapped) {\n  if (guideMaybeWrapped.__source) {\n    return guideMaybeWrapped.__source.object;\n  } else if (guideMaybeWrapped.sourceFeature) {\n    return guideMaybeWrapped.sourceFeature.feature;\n  } // It is not wrapped, return as is\n\n\n  return guideMaybeWrapped;\n}\n\nfunction getEditHandleColor(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n\n    case 'snap-source':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleOutlineColor(handle) {\n  return DEFAULT_EDITING_POINT_OUTLINE_COLOR;\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nvar defaultProps = {\n  mode: DEFAULT_EDIT_MODE,\n  // Edit and interaction events\n  onEdit: function onEdit() {},\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  pickingLineWidthExtraPixels: 0,\n  lineWidthUnits: 'pixels',\n  lineJointRounded: false,\n  lineCapRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  getLineColor: function getLineColor(feature, isSelected, mode) {\n    return isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR;\n  },\n  getFillColor: function getFillColor(feature, isSelected, mode) {\n    return isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR;\n  },\n  getRadius: function getRadius(f) {\n    return f && f.properties && f.properties.radius || f && f.properties && f.properties.size || 1;\n  },\n  getLineWidth: function getLineWidth(f) {\n    return f && f.properties && f.properties.lineWidth || 3;\n  },\n  // Tentative feature rendering\n  getTentativeLineColor: function getTentativeLineColor(f) {\n    return DEFAULT_TENTATIVE_LINE_COLOR;\n  },\n  getTentativeFillColor: function getTentativeFillColor(f) {\n    return DEFAULT_TENTATIVE_FILL_COLOR;\n  },\n  getTentativeLineWidth: function getTentativeLineWidth(f) {\n    return f && f.properties && f.properties.lineWidth || 3;\n  },\n  editHandleType: 'point',\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: true,\n  editHandlePointStrokeWidth: 2,\n  editHandlePointRadiusUnits: 'pixels',\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointOutlineColor: getEditHandleOutlineColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  editHandleIconSizeUnits: 'pixels',\n  getEditHandleIcon: function getEditHandleIcon(handle) {\n    return handle.properties.editHandleType;\n  },\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n  // misc\n  billboard: true\n}; // Mapping of mode name to mode class (for legacy purposes)\n\nvar modeNameMapping = {\n  view: _editModes.ViewMode,\n  // Alter modes\n  modify: _editModes.ModifyMode,\n  translate: new _editModes.SnappableMode(new _editModes.TranslateMode()),\n  transform: new _editModes.SnappableMode(new _editModes.TransformMode()),\n  scale: _editModes.ScaleMode,\n  rotate: _editModes.RotateMode,\n  duplicate: _editModes.DuplicateMode,\n  split: _editModes.SplitPolygonMode,\n  extrude: _editModes.ExtrudeMode,\n  elevation: _editModes.ElevationMode,\n  // Draw modes\n  drawPoint: _editModes.DrawPointMode,\n  drawLineString: _editModes.DrawLineStringMode,\n  drawPolygon: _editModes.DrawPolygonMode,\n  drawRectangle: _editModes.DrawRectangleMode,\n  drawSquare: _editModes.DrawSquareMode,\n  drawRectangleFromCenter: _editModes.DrawRectangleFromCenterMode,\n  drawSquareFromCenter: _editModes.DrawSquareFromCenterMode,\n  drawCircleFromCenter: _editModes.DrawCircleFromCenterMode,\n  drawCircleByBoundingBox: _editModes.DrawCircleByDiameterMode,\n  drawEllipseByBoundingBox: _editModes.DrawEllipseByBoundingBoxMode,\n  drawRectangleUsing3Points: _editModes.DrawRectangleUsingThreePointsMode,\n  drawEllipseUsing3Points: _editModes.DrawEllipseUsingThreePointsMode,\n  draw90DegreePolygon: _editModes.Draw90DegreePolygonMode,\n  drawPolygonByDragging: _editModes.DrawPolygonByDraggingMode\n}; // type State = {\n//   mode: GeoJsonEditMode,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nvar EditableGeoJsonLayer = /*#__PURE__*/function (_EditableLayer) {\n  _inherits(EditableGeoJsonLayer, _EditableLayer);\n\n  var _super = _createSuper(EditableGeoJsonLayer);\n\n  function EditableGeoJsonLayer() {\n    _classCallCheck(this, EditableGeoJsonLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditableGeoJsonLayer, [{\n    key: \"renderLayers\",\n    // setState: ($Shape<State>) => void;\n    value: function renderLayers() {\n      var subLayerProps = this.getSubLayerProps({\n        id: 'geojson',\n        // Proxy most GeoJsonLayer props as-is\n        data: this.props.data,\n        fp64: this.props.fp64,\n        filled: this.props.filled,\n        stroked: this.props.stroked,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineCapRounded: this.props.lineCapRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        pointRadiusScale: this.props.pointRadiusScale,\n        pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n        pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n        getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n        getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n        getPointRadius: this.selectionAwareAccessor(this.props.getRadius),\n        getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n        _subLayerProps: {\n          linestrings: {\n            billboard: this.props.billboard,\n            updateTriggers: {\n              // required to update dashed array attribute\n              all: [this.props.selectedFeatureIndexes, this.props.mode]\n            }\n          },\n          'polygons-stroke': {\n            billboard: this.props.billboard,\n            pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels,\n            type: _editablePathLayer[\"default\"],\n            updateTriggers: {\n              // required to update dashed array attribute\n              all: [this.props.selectedFeatureIndexes, this.props.mode]\n            }\n          }\n        },\n        updateTriggers: {\n          getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n          getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n          getPointRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n          getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode]\n        }\n      });\n      var layers = [new _layers.GeoJsonLayer(subLayerProps)];\n      layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());\n      return layers;\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        selectedFeatures: [],\n        editHandles: []\n      });\n    } // TODO: is this the best way to properly update state from an outside event handler?\n\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(opts) {\n      // console.log(\n      //   'shouldUpdateState',\n      //   opts.changeFlags.propsOrDataChanged,\n      //   opts.changeFlags.stateChanged\n      // );\n      return _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"shouldUpdateState\", this).call(this, opts) || opts.changeFlags.stateChanged;\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags,\n          context = _ref.context;\n\n      _get(_getPrototypeOf(EditableGeoJsonLayer.prototype), \"updateState\", this).call(this, {\n        oldProps: oldProps,\n        props: props,\n        changeFlags: changeFlags,\n        context: context\n      });\n\n      if (changeFlags.propsOrDataChanged) {\n        var modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;\n\n        if (modePropChanged) {\n          var _mode;\n\n          if (typeof props.mode === 'function') {\n            // They passed a constructor/class, so new it up\n            var ModeConstructor = props.mode;\n            _mode = new ModeConstructor();\n          } else if (typeof props.mode === 'string') {\n            // Lookup the mode based on its name (for backwards compatibility)\n            _mode = modeNameMapping[props.mode]; // eslint-disable-next-line no-console\n\n            console.warn(\"Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.\");\n          } else {\n            // Should be an instance of EditMode in this case\n            _mode = props.mode;\n          }\n\n          if (!_mode) {\n            console.warn(\"No mode configured for \".concat(String(props.mode))); // eslint-disable-line no-console,no-undef\n            // Use default mode\n\n            _mode = new DEFAULT_EDIT_MODE();\n          }\n\n          if (_mode !== this.state.mode) {\n            this.setState({\n              mode: _mode,\n              cursor: null\n            });\n          }\n        }\n      }\n\n      var selectedFeatures = [];\n\n      if (Array.isArray(props.selectedFeatureIndexes)) {\n        // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n        selectedFeatures = props.selectedFeatureIndexes.map(function (elem) {\n          return props.data.features[elem];\n        });\n      }\n\n      this.setState({\n        selectedFeatures: selectedFeatures\n      });\n    }\n  }, {\n    key: \"getModeProps\",\n    value: function getModeProps(props) {\n      var _this = this;\n\n      return {\n        modeConfig: props.modeConfig,\n        data: props.data,\n        selectedIndexes: props.selectedFeatureIndexes,\n        lastPointerMoveEvent: this.state.lastPointerMoveEvent,\n        cursor: this.state.cursor,\n        onEdit: function onEdit(editAction) {\n          // Force a re-render\n          // This supports double-click where we need to ensure that there's a re-render between the two clicks\n          // even though the data wasn't changed, just the internal tentative feature.\n          _this.setNeedsUpdate();\n\n          props.onEdit(editAction);\n        },\n        onUpdateCursor: function onUpdateCursor(cursor) {\n          _this.setState({\n            cursor: cursor\n          });\n        }\n      };\n    }\n  }, {\n    key: \"selectionAwareAccessor\",\n    value: function selectionAwareAccessor(accessor) {\n      var _this2 = this;\n\n      if (typeof accessor !== 'function') {\n        return accessor;\n      }\n\n      return function (feature) {\n        return accessor(feature, _this2.isFeatureSelected(feature), _this2.props.mode);\n      };\n    }\n  }, {\n    key: \"isFeatureSelected\",\n    value: function isFeatureSelected(feature) {\n      if (!this.props.data || !this.props.selectedFeatureIndexes) {\n        return false;\n      }\n\n      if (!this.props.selectedFeatureIndexes.length) {\n        return false;\n      }\n\n      var featureIndex = this.props.data.features.indexOf(feature);\n      return this.props.selectedFeatureIndexes.includes(featureIndex);\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n          sourceLayer = _ref2.sourceLayer;\n\n      if (sourceLayer.id.endsWith('guides')) {\n        // If user is picking an editing handle, add additional data to the info\n        info.isGuide = true;\n      }\n\n      return info;\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      // Extra handling for guides\n      if (info === null || info === void 0 ? void 0 : info.sourceLayer) {\n        if (info.isGuide) {\n          var _iterator = _createForOfIteratorHelper(info.sourceLayer.getSubLayers()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var layer = _step.value;\n              layer.updateAutoHighlight(info);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          info.sourceLayer.updateAutoHighlight(info);\n        }\n      }\n    }\n  }, {\n    key: \"createGuidesLayers\",\n    value: function createGuidesLayers() {\n      var mode = this.getActiveMode();\n      var guides = mode.getGuides(this.getModeProps(this.props));\n\n      if (!guides || !guides.features.length) {\n        return [];\n      }\n\n      var subLayerProps = {\n        linestrings: {\n          billboard: this.props.billboard,\n          autoHighlight: false\n        },\n        'polygons-fill': {\n          autoHighlight: false\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard\n        }\n      };\n\n      if (this.props.editHandleType === 'icon') {\n        subLayerProps['points-icon'] = {\n          type: _layers.IconLayer,\n          iconAtlas: this.props.editHandleIconAtlas,\n          iconMapping: this.props.editHandleIconMapping,\n          sizeUnits: this.props.editHandleIconSizeUnits,\n          sizeScale: this.props.editHandleIconSizeScale,\n          getIcon: guideAccessor(this.props.getEditHandleIcon),\n          getSize: guideAccessor(this.props.getEditHandleIconSize),\n          getColor: guideAccessor(this.props.getEditHandleIconColor),\n          getAngle: guideAccessor(this.props.getEditHandleIconAngle)\n        };\n      } else {\n        subLayerProps['points-circle'] = {\n          type: _layers.ScatterplotLayer,\n          radiusScale: this.props.editHandlePointRadiusScale,\n          stroked: this.props.editHandlePointOutline,\n          getLineWidth: this.props.editHandlePointStrokeWidth,\n          radiusUnits: this.props.editHandlePointRadiusUnits,\n          radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n          radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n          getRadius: guideAccessor(this.props.getEditHandlePointRadius),\n          getFillColor: guideAccessor(this.props.getEditHandlePointColor),\n          getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor)\n        };\n      }\n\n      var layer = new _layers.GeoJsonLayer(this.getSubLayerProps({\n        id: \"guides\",\n        data: guides,\n        fp64: this.props.fp64,\n        _subLayerProps: subLayerProps,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineCapRounded: this.props.lineCapRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        getLineColor: guideAccessor(this.props.getTentativeLineColor),\n        getLineWidth: guideAccessor(this.props.getTentativeLineWidth),\n        getFillColor: guideAccessor(this.props.getTentativeFillColor),\n        pointType: this.props.editHandleType === 'icon' ? 'icon' : 'circle',\n        iconAtlas: this.props.editHandleIconAtlas\n      }));\n      return [layer];\n    }\n  }, {\n    key: \"createTooltipsLayers\",\n    value: function createTooltipsLayers() {\n      var mode = this.getActiveMode();\n      var tooltips = mode.getTooltips(this.getModeProps(this.props));\n      var layer = new _layers.TextLayer(_objectSpread({\n        getSize: DEFAULT_TOOLTIP_FONT_SIZE\n      }, this.getSubLayerProps({\n        id: \"tooltips\",\n        data: tooltips\n      })));\n      return [layer];\n    }\n  }, {\n    key: \"onLayerClick\",\n    value: function onLayerClick(event) {\n      this.getActiveMode().handleClick(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onLayerKeyUp\",\n    value: function onLayerKeyUp(event) {\n      this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onStartDragging\",\n    value: function onStartDragging(event) {\n      this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onDragging\",\n    value: function onDragging(event) {\n      this.getActiveMode().handleDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onStopDragging\",\n    value: function onStopDragging(event) {\n      this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(event) {\n      this.setState({\n        lastPointerMoveEvent: event\n      });\n      this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(_ref3) {\n      var isDragging = _ref3.isDragging;\n\n      if (this.state === null) {\n        // Layer in 'Awaiting state'\n        return null;\n      }\n\n      var cursor = this.state.cursor;\n\n      if (!cursor) {\n        // default cursor\n        cursor = isDragging ? 'grabbing' : 'grab';\n      }\n\n      return cursor;\n    }\n  }, {\n    key: \"getActiveMode\",\n    value: function getActiveMode() {\n      return this.state.mode;\n    }\n  }]);\n\n  return EditableGeoJsonLayer;\n}(_editableLayer[\"default\"]);\n\nexports[\"default\"] = EditableGeoJsonLayer;\n\n_defineProperty(EditableGeoJsonLayer, \"layerName\", 'EditableGeoJsonLayer');\n\n_defineProperty(EditableGeoJsonLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["DEFAULT_LINE_COLOR","DEFAULT_FILL_COLOR","DEFAULT_SELECTED_LINE_COLOR","DEFAULT_SELECTED_FILL_COLOR","DEFAULT_TENTATIVE_LINE_COLOR","DEFAULT_TENTATIVE_FILL_COLOR","DEFAULT_EDITING_EXISTING_POINT_COLOR","DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR","DEFAULT_EDITING_SNAP_POINT_COLOR","DEFAULT_EDITING_POINT_OUTLINE_COLOR","DEFAULT_EDITING_EXISTING_POINT_RADIUS","DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS","DEFAULT_EDITING_SNAP_POINT_RADIUS","DEFAULT_TOOLTIP_FONT_SIZE","PROJECTED_PIXEL_SIZE_MULTIPLIER","DEFAULT_EDIT_MODE","DrawPolygonMode","guideAccessor","accessor","guideMaybeWrapped","unwrapGuide","__source","object","sourceFeature","feature","getEditHandleColor","handle","properties","editHandleType","getEditHandleOutlineColor","getEditHandleRadius","defaultProps","mode","onEdit","pickable","pickingRadius","pickingDepth","fp64","filled","stroked","lineWidthScale","lineWidthMinPixels","lineWidthMaxPixels","Number","MAX_SAFE_INTEGER","pickingLineWidthExtraPixels","lineWidthUnits","lineJointRounded","lineCapRounded","lineMiterLimit","pointRadiusScale","pointRadiusMinPixels","pointRadiusMaxPixels","getLineColor","isSelected","getFillColor","getRadius","f","radius","size","getLineWidth","lineWidth","getTentativeLineColor","getTentativeFillColor","getTentativeLineWidth","editHandlePointRadiusScale","editHandlePointOutline","editHandlePointStrokeWidth","editHandlePointRadiusUnits","editHandlePointRadiusMinPixels","editHandlePointRadiusMaxPixels","getEditHandlePointColor","getEditHandlePointOutlineColor","getEditHandlePointRadius","editHandleIconAtlas","editHandleIconMapping","editHandleIconSizeScale","editHandleIconSizeUnits","getEditHandleIcon","getEditHandleIconSize","getEditHandleIconColor","getEditHandleIconAngle","billboard","modeNameMapping","view","ViewMode","modify","ModifyMode","translate","SnappableMode","TranslateMode","transform","TransformMode","scale","ScaleMode","rotate","RotateMode","duplicate","DuplicateMode","split","SplitPolygonMode","extrude","ExtrudeMode","elevation","ElevationMode","drawPoint","DrawPointMode","drawLineString","DrawLineStringMode","drawPolygon","drawRectangle","DrawRectangleMode","drawSquare","DrawSquareMode","drawRectangleFromCenter","DrawRectangleFromCenterMode","drawSquareFromCenter","DrawSquareFromCenterMode","drawCircleFromCenter","DrawCircleFromCenterMode","drawCircleByBoundingBox","DrawCircleByDiameterMode","drawEllipseByBoundingBox","DrawEllipseByBoundingBoxMode","drawRectangleUsing3Points","DrawRectangleUsingThreePointsMode","drawEllipseUsing3Points","DrawEllipseUsingThreePointsMode","draw90DegreePolygon","Draw90DegreePolygonMode","drawPolygonByDragging","DrawPolygonByDraggingMode","EditableGeoJsonLayer","subLayerProps","getSubLayerProps","id","data","props","selectionAwareAccessor","getPointRadius","_subLayerProps","linestrings","updateTriggers","all","selectedFeatureIndexes","type","EditablePathLayer","layers","GeoJsonLayer","concat","createGuidesLayers","createTooltipsLayers","_get","setState","selectedFeatures","editHandles","opts","changeFlags","stateChanged","oldProps","context","propsOrDataChanged","modePropChanged","Object","keys","length","ModeConstructor","console","warn","String","state","cursor","Array","isArray","map","elem","features","modeConfig","selectedIndexes","lastPointerMoveEvent","editAction","_this","setNeedsUpdate","onUpdateCursor","_this2","isFeatureSelected","featureIndex","indexOf","includes","info","sourceLayer","endsWith","isGuide","getSubLayers","layer","updateAutoHighlight","_iterator","getActiveMode","guides","getGuides","getModeProps","autoHighlight","IconLayer","iconAtlas","iconMapping","sizeUnits","sizeScale","getIcon","getSize","getColor","getAngle","ScatterplotLayer","radiusScale","radiusUnits","radiusMinPixels","radiusMaxPixels","pointType","tooltips","getTooltips","TextLayer","event","handleClick","handleKeyUp","handleStartDragging","handleDragging","handleStopDragging","handlePointerMove","isDragging","EditableLayer"],"sources":["../../src/layers/editable-geojson-layer.ts"],"sourcesContent":["/* eslint-env browser */\n\nimport { RGBAColor } from '@deck.gl/core';\nimport { GeoJsonLayer, ScatterplotLayer, IconLayer, TextLayer } from '@deck.gl/layers';\n\nimport {\n  ViewMode,\n  ModifyMode,\n  TranslateMode,\n  ScaleMode,\n  RotateMode,\n  DuplicateMode,\n  SplitPolygonMode,\n  ExtrudeMode,\n  ElevationMode,\n  DrawPointMode,\n  DrawLineStringMode,\n  DrawPolygonMode,\n  DrawRectangleMode,\n  DrawSquareMode,\n  DrawRectangleFromCenterMode,\n  DrawSquareFromCenterMode,\n  DrawCircleFromCenterMode,\n  DrawCircleByDiameterMode,\n  DrawEllipseByBoundingBoxMode,\n  DrawRectangleUsingThreePointsMode,\n  DrawEllipseUsingThreePointsMode,\n  Draw90DegreePolygonMode,\n  DrawPolygonByDraggingMode,\n  SnappableMode,\n  TransformMode,\n  EditAction,\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  PointerMoveEvent,\n  GeoJsonEditModeType,\n  FeatureCollection,\n} from '@nebula.gl/edit-modes';\n\nimport { PROJECTED_PIXEL_SIZE_MULTIPLIER } from '../constants';\n\nimport EditableLayer, { EditableLayerProps } from './editable-layer';\nimport EditablePathLayer from './editable-path-layer';\n\nconst DEFAULT_LINE_COLOR: RGBAColor = [0x0, 0x0, 0x0, 0x99];\nconst DEFAULT_FILL_COLOR: RGBAColor = [0x0, 0x0, 0x0, 0x90];\nconst DEFAULT_SELECTED_LINE_COLOR: RGBAColor = [0x0, 0x0, 0x0, 0xff];\nconst DEFAULT_SELECTED_FILL_COLOR: RGBAColor = [0x0, 0x0, 0x90, 0x90];\nconst DEFAULT_TENTATIVE_LINE_COLOR: RGBAColor = [0x90, 0x90, 0x90, 0xff];\nconst DEFAULT_TENTATIVE_FILL_COLOR: RGBAColor = [0x90, 0x90, 0x90, 0x90];\nconst DEFAULT_EDITING_EXISTING_POINT_COLOR: RGBAColor = [0xc0, 0x0, 0x0, 0xff];\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR: RGBAColor = [0x0, 0x0, 0x0, 0x80];\nconst DEFAULT_EDITING_SNAP_POINT_COLOR: RGBAColor = [0x7c, 0x00, 0xc0, 0xff];\nconst DEFAULT_EDITING_POINT_OUTLINE_COLOR: RGBAColor = [0xff, 0xff, 0xff, 0xff];\nconst DEFAULT_EDITING_EXISTING_POINT_RADIUS = 5;\nconst DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS = 3;\nconst DEFAULT_EDITING_SNAP_POINT_RADIUS = 7;\nconst DEFAULT_TOOLTIP_FONT_SIZE = 32 * PROJECTED_PIXEL_SIZE_MULTIPLIER;\n\nconst DEFAULT_EDIT_MODE = DrawPolygonMode;\n\nfunction guideAccessor(accessor) {\n  if (!accessor || typeof accessor !== 'function') {\n    return accessor;\n  }\n  return (guideMaybeWrapped) => accessor(unwrapGuide(guideMaybeWrapped));\n}\n\n// The object handed to us from deck.gl is different depending on the version of deck.gl used, unwrap as necessary\nfunction unwrapGuide(guideMaybeWrapped) {\n  if (guideMaybeWrapped.__source) {\n    return guideMaybeWrapped.__source.object;\n  } else if (guideMaybeWrapped.sourceFeature) {\n    return guideMaybeWrapped.sourceFeature.feature;\n  }\n  // It is not wrapped, return as is\n  return guideMaybeWrapped;\n}\n\nfunction getEditHandleColor(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_COLOR;\n    case 'snap-source':\n      return DEFAULT_EDITING_SNAP_POINT_COLOR;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_COLOR;\n  }\n}\n\nfunction getEditHandleOutlineColor(handle) {\n  return DEFAULT_EDITING_POINT_OUTLINE_COLOR;\n}\n\nfunction getEditHandleRadius(handle) {\n  switch (handle.properties.editHandleType) {\n    case 'existing':\n      return DEFAULT_EDITING_EXISTING_POINT_RADIUS;\n    case 'snap':\n      return DEFAULT_EDITING_SNAP_POINT_RADIUS;\n    case 'intermediate':\n    default:\n      return DEFAULT_EDITING_INTERMEDIATE_POINT_RADIUS;\n  }\n}\n\nexport interface EditableGeojsonLayerProps<D> extends EditableLayerProps<D> {\n  mode?: any;\n  modeConfig?: any;\n  selectedFeatureIndexes?: number[];\n  onEdit?: (updatedData?, editType?: string, featureIndexes?: number[], editContext?) => void;\n\n  pickable?: boolean;\n  pickingRadius?: number;\n  pickingDepth?: number;\n  fp64?: boolean;\n  filled?: boolean;\n  stroked?: boolean;\n  lineWidthScale?: number;\n  lineWidthMinPixels?: number;\n  lineWidthMaxPixels?: number;\n  pickingLineWidthExtraPixels?: number;\n  lineWidthUnits?: string;\n  lineJointRounded?: boolean;\n  lineCapRounded?: boolean;\n  lineMiterLimit?: number;\n  pointRadiusScale?: number;\n  pointRadiusMinPixels?: number;\n  pointRadiusMaxPixels?: number;\n\n  getLineColor?: RGBAColor | ((feature, isSelected, mode) => RGBAColor);\n  getFillColor?: RGBAColor | ((feature, isSelected, mode) => RGBAColor);\n  getRadius?: number | ((f) => number);\n  getLineWidth?: number | ((f) => number);\n\n  getTentativeLineColor?: RGBAColor | ((feature, isSelected, mode) => RGBAColor);\n  getTentativeFillColor?: RGBAColor | ((feature, isSelected, mode) => RGBAColor);\n  getTentativeLineWidth?: number | ((f) => number);\n\n  editHandleType?: string;\n\n  editHandlePointRadiusScale?: number;\n  editHandlePointOutline?: boolean;\n  editHandlePointStrokeWidth?: number;\n  editHandlePointRadiusUnits?: string;\n  editHandlePointRadiusMinPixels?: number;\n  editHandlePointRadiusMaxPixels?: number;\n  getEditHandlePointColor?: RGBAColor | ((handle) => RGBAColor);\n  getEditHandlePointOutlineColor?: RGBAColor | ((handle) => RGBAColor);\n  getEditHandlePointRadius?: number | ((handle) => number);\n\n  // icon handles\n  editHandleIconAtlas?: any;\n  editHandleIconMapping?: any;\n  editHandleIconSizeScale?: number;\n  editHandleIconSizeUnits?: string;\n  getEditHandleIcon?: (handle) => string;\n  getEditHandleIconSize?: number;\n  getEditHandleIconColor?: RGBAColor | ((handle) => RGBAColor);\n  getEditHandleIconAngle?: number | ((handle) => number);\n\n  // misc\n  billboard?: boolean;\n}\n\nconst defaultProps: EditableGeojsonLayerProps<any> = {\n  mode: DEFAULT_EDIT_MODE,\n\n  // Edit and interaction events\n  onEdit: () => {},\n\n  pickable: true,\n  pickingRadius: 10,\n  pickingDepth: 5,\n  fp64: false,\n  filled: true,\n  stroked: true,\n  lineWidthScale: PROJECTED_PIXEL_SIZE_MULTIPLIER,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  pickingLineWidthExtraPixels: 0,\n  lineWidthUnits: 'pixels',\n  lineJointRounded: false,\n  lineCapRounded: false,\n  lineMiterLimit: 4,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 2,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  getLineColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_LINE_COLOR : DEFAULT_LINE_COLOR,\n  getFillColor: (feature, isSelected, mode) =>\n    isSelected ? DEFAULT_SELECTED_FILL_COLOR : DEFAULT_FILL_COLOR,\n  getRadius: (f) =>\n    (f && f.properties && f.properties.radius) || (f && f.properties && f.properties.size) || 1,\n  getLineWidth: (f) => (f && f.properties && f.properties.lineWidth) || 3,\n\n  // Tentative feature rendering\n  getTentativeLineColor: (f) => DEFAULT_TENTATIVE_LINE_COLOR,\n  getTentativeFillColor: (f) => DEFAULT_TENTATIVE_FILL_COLOR,\n  getTentativeLineWidth: (f) => (f && f.properties && f.properties.lineWidth) || 3,\n\n  editHandleType: 'point',\n\n  // point handles\n  editHandlePointRadiusScale: 1,\n  editHandlePointOutline: true,\n  editHandlePointStrokeWidth: 2,\n  editHandlePointRadiusUnits: 'pixels',\n  editHandlePointRadiusMinPixels: 4,\n  editHandlePointRadiusMaxPixels: 8,\n  getEditHandlePointColor: getEditHandleColor,\n  getEditHandlePointOutlineColor: getEditHandleOutlineColor,\n  getEditHandlePointRadius: getEditHandleRadius,\n\n  // icon handles\n  editHandleIconAtlas: null,\n  editHandleIconMapping: null,\n  editHandleIconSizeScale: 1,\n  editHandleIconSizeUnits: 'pixels',\n  getEditHandleIcon: (handle) => handle.properties.editHandleType,\n  getEditHandleIconSize: 10,\n  getEditHandleIconColor: getEditHandleColor,\n  getEditHandleIconAngle: 0,\n\n  // misc\n  billboard: true,\n};\n\n// Mapping of mode name to mode class (for legacy purposes)\nconst modeNameMapping = {\n  view: ViewMode,\n\n  // Alter modes\n  modify: ModifyMode,\n  translate: new SnappableMode(new TranslateMode()),\n\n  transform: new SnappableMode(new TransformMode()),\n  scale: ScaleMode,\n  rotate: RotateMode,\n  duplicate: DuplicateMode,\n  split: SplitPolygonMode,\n  extrude: ExtrudeMode,\n  elevation: ElevationMode,\n\n  // Draw modes\n  drawPoint: DrawPointMode,\n  drawLineString: DrawLineStringMode,\n  drawPolygon: DrawPolygonMode,\n  drawRectangle: DrawRectangleMode,\n  drawSquare: DrawSquareMode,\n  drawRectangleFromCenter: DrawRectangleFromCenterMode,\n  drawSquareFromCenter: DrawSquareFromCenterMode,\n  drawCircleFromCenter: DrawCircleFromCenterMode,\n  drawCircleByBoundingBox: DrawCircleByDiameterMode,\n  drawEllipseByBoundingBox: DrawEllipseByBoundingBoxMode,\n  drawRectangleUsing3Points: DrawRectangleUsingThreePointsMode,\n  drawEllipseUsing3Points: DrawEllipseUsingThreePointsMode,\n  draw90DegreePolygon: Draw90DegreePolygonMode,\n  drawPolygonByDragging: DrawPolygonByDraggingMode,\n};\n\n// type State = {\n//   mode: GeoJsonEditMode,\n//   tentativeFeature: ?Feature,\n//   editHandles: any[],\n//   selectedFeatures: Feature[]\n// };\n\nexport default class EditableGeoJsonLayer extends EditableLayer<\n  any,\n  EditableGeojsonLayerProps<any>\n> {\n  static layerName = 'EditableGeoJsonLayer';\n  static defaultProps = defaultProps;\n\n  // setState: ($Shape<State>) => void;\n  renderLayers() {\n    const subLayerProps = this.getSubLayerProps({\n      id: 'geojson',\n\n      // Proxy most GeoJsonLayer props as-is\n      data: this.props.data,\n      fp64: this.props.fp64,\n      filled: this.props.filled,\n      stroked: this.props.stroked,\n      lineWidthScale: this.props.lineWidthScale,\n      lineWidthMinPixels: this.props.lineWidthMinPixels,\n      lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n      lineWidthUnits: this.props.lineWidthUnits,\n      lineJointRounded: this.props.lineJointRounded,\n      lineCapRounded: this.props.lineCapRounded,\n      lineMiterLimit: this.props.lineMiterLimit,\n      pointRadiusScale: this.props.pointRadiusScale,\n      pointRadiusMinPixels: this.props.pointRadiusMinPixels,\n      pointRadiusMaxPixels: this.props.pointRadiusMaxPixels,\n      getLineColor: this.selectionAwareAccessor(this.props.getLineColor),\n      getFillColor: this.selectionAwareAccessor(this.props.getFillColor),\n      getPointRadius: this.selectionAwareAccessor(this.props.getRadius),\n      getLineWidth: this.selectionAwareAccessor(this.props.getLineWidth),\n\n      _subLayerProps: {\n        linestrings: {\n          billboard: this.props.billboard,\n          updateTriggers: {\n            // required to update dashed array attribute\n            all: [this.props.selectedFeatureIndexes, this.props.mode],\n          },\n        },\n        'polygons-stroke': {\n          billboard: this.props.billboard,\n          pickingLineWidthExtraPixels: this.props.pickingLineWidthExtraPixels,\n          type: EditablePathLayer,\n          updateTriggers: {\n            // required to update dashed array attribute\n            all: [this.props.selectedFeatureIndexes, this.props.mode],\n          },\n        },\n      },\n\n      updateTriggers: {\n        getLineColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getFillColor: [this.props.selectedFeatureIndexes, this.props.mode],\n        getPointRadius: [this.props.selectedFeatureIndexes, this.props.mode],\n        getLineWidth: [this.props.selectedFeatureIndexes, this.props.mode],\n      },\n    });\n\n    let layers: any = [new GeoJsonLayer(subLayerProps)];\n\n    layers = layers.concat(this.createGuidesLayers(), this.createTooltipsLayers());\n\n    return layers;\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      selectedFeatures: [],\n      editHandles: [],\n    });\n  }\n\n  // TODO: is this the best way to properly update state from an outside event handler?\n  shouldUpdateState(opts: any) {\n    // console.log(\n    //   'shouldUpdateState',\n    //   opts.changeFlags.propsOrDataChanged,\n    //   opts.changeFlags.stateChanged\n    // );\n    return super.shouldUpdateState(opts) || opts.changeFlags.stateChanged;\n  }\n\n  updateState({\n    props,\n    oldProps,\n    changeFlags,\n    context,\n  }: {\n    props: EditableGeojsonLayerProps<any>;\n    oldProps: EditableGeojsonLayerProps<any>;\n    changeFlags: any;\n    context: any;\n    s;\n  }) {\n    super.updateState({ oldProps, props, changeFlags, context });\n\n    if (changeFlags.propsOrDataChanged) {\n      const modePropChanged = Object.keys(oldProps).length === 0 || props.mode !== oldProps.mode;\n      if (modePropChanged) {\n        let mode;\n        if (typeof props.mode === 'function') {\n          // They passed a constructor/class, so new it up\n          const ModeConstructor = props.mode;\n          mode = new ModeConstructor();\n        } else if (typeof props.mode === 'string') {\n          // Lookup the mode based on its name (for backwards compatibility)\n          mode = modeNameMapping[props.mode];\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"Deprecated use of passing `mode` as a string. Pass the mode's class constructor instead.\"\n          );\n        } else {\n          // Should be an instance of EditMode in this case\n          mode = props.mode;\n        }\n\n        if (!mode) {\n          console.warn(`No mode configured for ${String(props.mode)}`); // eslint-disable-line no-console,no-undef\n          // Use default mode\n          mode = new DEFAULT_EDIT_MODE();\n        }\n\n        if (mode !== this.state.mode) {\n          this.setState({ mode, cursor: null });\n        }\n      }\n    }\n\n    let selectedFeatures = [];\n    if (Array.isArray(props.selectedFeatureIndexes)) {\n      // TODO: needs improved testing, i.e. checking for duplicates, NaNs, out of range numbers, ...\n      selectedFeatures = props.selectedFeatureIndexes.map((elem) => props.data.features[elem]);\n    }\n\n    this.setState({ selectedFeatures });\n  }\n\n  getModeProps(props: EditableGeojsonLayerProps<any>) {\n    return {\n      modeConfig: props.modeConfig,\n      data: props.data,\n      selectedIndexes: props.selectedFeatureIndexes,\n      lastPointerMoveEvent: this.state.lastPointerMoveEvent,\n      cursor: this.state.cursor,\n      onEdit: (editAction: EditAction<FeatureCollection>) => {\n        // Force a re-render\n        // This supports double-click where we need to ensure that there's a re-render between the two clicks\n        // even though the data wasn't changed, just the internal tentative feature.\n        this.setNeedsUpdate();\n        props.onEdit(editAction);\n      },\n      onUpdateCursor: (cursor: string | null | undefined) => {\n        this.setState({ cursor });\n      },\n    };\n  }\n\n  selectionAwareAccessor(accessor: any) {\n    if (typeof accessor !== 'function') {\n      return accessor;\n    }\n    return (feature: Record<string, any>) =>\n      accessor(feature, this.isFeatureSelected(feature), this.props.mode);\n  }\n\n  isFeatureSelected(feature: Record<string, any>) {\n    if (!this.props.data || !this.props.selectedFeatureIndexes) {\n      return false;\n    }\n    if (!this.props.selectedFeatureIndexes.length) {\n      return false;\n    }\n    const featureIndex = this.props.data.features.indexOf(feature);\n    return this.props.selectedFeatureIndexes.includes(featureIndex);\n  }\n\n  getPickingInfo({ info, sourceLayer }: Record<string, any>) {\n    if (sourceLayer.id.endsWith('guides')) {\n      // If user is picking an editing handle, add additional data to the info\n      info.isGuide = true;\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info) {\n    // Extra handling for guides\n    if (info?.sourceLayer) {\n      if (info.isGuide) {\n        for (const layer of info.sourceLayer.getSubLayers()) {\n          layer.updateAutoHighlight(info);\n        }\n      } else {\n        info.sourceLayer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  createGuidesLayers() {\n    const mode = this.getActiveMode();\n    const guides: FeatureCollection = mode.getGuides(this.getModeProps(this.props));\n\n    if (!guides || !guides.features.length) {\n      return [];\n    }\n\n    const subLayerProps = {\n      linestrings: {\n        billboard: this.props.billboard,\n        autoHighlight: false,\n      },\n      'polygons-fill': {\n        autoHighlight: false,\n      },\n      'polygons-stroke': {\n        billboard: this.props.billboard,\n      },\n    };\n\n    if (this.props.editHandleType === 'icon') {\n      subLayerProps['points-icon'] = {\n        type: IconLayer,\n        iconAtlas: this.props.editHandleIconAtlas,\n        iconMapping: this.props.editHandleIconMapping,\n        sizeUnits: this.props.editHandleIconSizeUnits,\n        sizeScale: this.props.editHandleIconSizeScale,\n        getIcon: guideAccessor(this.props.getEditHandleIcon),\n        getSize: guideAccessor(this.props.getEditHandleIconSize),\n        getColor: guideAccessor(this.props.getEditHandleIconColor),\n        getAngle: guideAccessor(this.props.getEditHandleIconAngle),\n      };\n    } else {\n      subLayerProps['points-circle'] = {\n        type: ScatterplotLayer,\n        radiusScale: this.props.editHandlePointRadiusScale,\n        stroked: this.props.editHandlePointOutline,\n        getLineWidth: this.props.editHandlePointStrokeWidth,\n        radiusUnits: this.props.editHandlePointRadiusUnits,\n        radiusMinPixels: this.props.editHandlePointRadiusMinPixels,\n        radiusMaxPixels: this.props.editHandlePointRadiusMaxPixels,\n        getRadius: guideAccessor(this.props.getEditHandlePointRadius),\n        getFillColor: guideAccessor(this.props.getEditHandlePointColor),\n        getLineColor: guideAccessor(this.props.getEditHandlePointOutlineColor),\n      };\n    }\n\n    const layer = new GeoJsonLayer(\n      this.getSubLayerProps({\n        id: `guides`,\n        data: guides,\n        fp64: this.props.fp64,\n        _subLayerProps: subLayerProps,\n        lineWidthScale: this.props.lineWidthScale,\n        lineWidthMinPixels: this.props.lineWidthMinPixels,\n        lineWidthMaxPixels: this.props.lineWidthMaxPixels,\n        lineWidthUnits: this.props.lineWidthUnits,\n        lineJointRounded: this.props.lineJointRounded,\n        lineCapRounded: this.props.lineCapRounded,\n        lineMiterLimit: this.props.lineMiterLimit,\n        getLineColor: guideAccessor(this.props.getTentativeLineColor),\n        getLineWidth: guideAccessor(this.props.getTentativeLineWidth),\n        getFillColor: guideAccessor(this.props.getTentativeFillColor),\n        pointType: this.props.editHandleType === 'icon' ? 'icon' : 'circle',\n        iconAtlas: this.props.editHandleIconAtlas,\n      })\n    );\n\n    return [layer];\n  }\n\n  createTooltipsLayers() {\n    const mode = this.getActiveMode();\n    const tooltips = mode.getTooltips(this.getModeProps(this.props));\n\n    const layer = new TextLayer({\n      getSize: DEFAULT_TOOLTIP_FONT_SIZE,\n      ...this.getSubLayerProps({\n        id: `tooltips`,\n        data: tooltips,\n      }),\n    });\n\n    return [layer];\n  }\n\n  onLayerClick(event: ClickEvent) {\n    this.getActiveMode().handleClick(event, this.getModeProps(this.props));\n  }\n\n  onLayerKeyUp(event: KeyboardEvent) {\n    this.getActiveMode().handleKeyUp(event, this.getModeProps(this.props));\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    this.getActiveMode().handleStartDragging(event, this.getModeProps(this.props));\n  }\n\n  onDragging(event: DraggingEvent) {\n    this.getActiveMode().handleDragging(event, this.getModeProps(this.props));\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    this.getActiveMode().handleStopDragging(event, this.getModeProps(this.props));\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    this.setState({ lastPointerMoveEvent: event });\n    this.getActiveMode().handlePointerMove(event, this.getModeProps(this.props));\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    if (this.state === null) {\n      // Layer in 'Awaiting state'\n      return null;\n    }\n\n    let { cursor } = this.state;\n    if (!cursor) {\n      // default cursor\n      cursor = isDragging ? 'grabbing' : 'grab';\n    }\n    return cursor;\n  }\n\n  getActiveMode(): GeoJsonEditModeType {\n    return this.state.mode;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}