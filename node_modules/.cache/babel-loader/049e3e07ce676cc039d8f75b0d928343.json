{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { readFeature, classifyRings } from '../../helpers/mapbox-util-functions';\nexport default class VectorTileFeature {\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(pbf, end, extent, keys, values) {\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extent\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"_pbf\", void 0);\n\n    _defineProperty(this, \"_geometry\", void 0);\n\n    _defineProperty(this, \"_keys\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    pbf.readFields(readFeature, this, end);\n  }\n\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines = [];\n    let line;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          if (line) lines.push(line);\n          line = [];\n        }\n\n        if (line) line.push([x, y]);\n      } else if (cmd === 7) {\n        if (line) {\n          line.push(line[0].slice());\n        }\n      } else {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    if (line) lines.push(line);\n    return lines;\n  }\n\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  _toGeoJSON(transform) {\n    let coords = this.loadGeometry();\n    let type = VectorTileFeature.types[this.type];\n    let i;\n    let j;\n\n    switch (this.type) {\n      case 1:\n        const points = [];\n\n        for (i = 0; i < coords.length; i++) {\n          points[i] = coords[i][0];\n        }\n\n        coords = points;\n        transform(coords, this);\n        break;\n\n      case 2:\n        for (i = 0; i < coords.length; i++) {\n          transform(coords[i], this);\n        }\n\n        break;\n\n      case 3:\n        coords = classifyRings(coords);\n\n        for (i = 0; i < coords.length; i++) {\n          for (j = 0; j < coords[i].length; j++) {\n            transform(coords[i][j], this);\n          }\n        }\n\n        break;\n    }\n\n    if (coords.length === 1) {\n      coords = coords[0];\n    } else {\n      type = \"Multi\".concat(type);\n    }\n\n    const result = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates: coords\n      },\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toGeoJSON(options) {\n    if (typeof options === 'function') {\n      return this._toGeoJSON(options);\n    }\n\n    const {\n      x,\n      y,\n      z\n    } = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    function project(line) {\n      for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = (p[0] + x0) * 360 / size - 180;\n        const y2 = 180 - (p[1] + y0) * 360 / size;\n        p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n      }\n    }\n\n    return this._toGeoJSON(project);\n  }\n\n}","map":{"version":3,"mappings":";AAGA,SAAQA,WAAR,EAAqBC,aAArB,QAAyC,qCAAzC;AAEA,eAAe,MAAMC,iBAAN,CAAwB;EASrB,WAALC,KAAK,GAAG;IACjB,OAAO,CAAC,SAAD,EAAY,OAAZ,EAAqB,YAArB,EAAmC,SAAnC,CAAP;EACD;;EAEDC,WAAW,CACTC,GADS,EAETC,GAFS,EAGTC,MAHS,EAITC,IAJS,EAKTC,MALS,EAMT;IAAAC;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAAAA;;IAEA,KAAKC,UAAL,GAAkB,EAAlB;IACA,KAAKJ,MAAL,GAAcA,MAAd;IACA,KAAKK,IAAL,GAAY,CAAZ;IACA,KAAKC,EAAL,GAAU,IAAV;IAGA,KAAKC,IAAL,GAAYT,GAAZ;IACA,KAAKU,SAAL,GAAiB,CAAC,CAAlB;IACA,KAAKC,KAAL,GAAaR,IAAb;IACA,KAAKS,OAAL,GAAeR,MAAf;IAEAJ,GAAG,CAACa,UAAJb,CAAeL,WAAfK,EAA4B,IAA5BA,EAAkCC,GAAlCD;EACD;;EAGDc,YAAY,GAAsB;IAChC,MAAMd,GAAG,GAAG,KAAKS,IAAjB;IACAT,GAAG,CAACe,GAAJf,GAAU,KAAKU,SAAfV;IAEA,MAAMC,GAAG,GAAGD,GAAG,CAACgB,UAAJhB,KAAmBA,GAAG,CAACe,GAAnC;IACA,IAAIE,GAAG,GAAG,CAAV;IACA,IAAIC,MAAM,GAAG,CAAb;IACA,IAAIC,CAAC,GAAG,CAAR;IACA,IAAIC,CAAC,GAAG,CAAR;IACA,MAAMC,KAAmB,GAAG,EAA5B;IACA,IAAIC,IAAJ;;IAEA,OAAOtB,GAAG,CAACe,GAAJf,GAAUC,GAAjB,EAAsB;MACpB,IAAIiB,MAAM,IAAI,CAAd,EAAiB;QACf,MAAMK,MAAM,GAAGvB,GAAG,CAACgB,UAAJhB,EAAf;QACAiB,GAAG,GAAGM,MAAM,GAAG,GAAfN;QACAC,MAAM,GAAGK,MAAM,IAAI,CAAnBL;MACD;;MAEDA,MAAM;;MAEN,IAAID,GAAG,KAAK,CAARA,IAAaA,GAAG,KAAK,CAAzB,EAA4B;QAC1BE,CAAC,IAAInB,GAAG,CAACwB,WAAJxB,EAALmB;QACAC,CAAC,IAAIpB,GAAG,CAACwB,WAAJxB,EAALoB;;QAEA,IAAIH,GAAG,KAAK,CAAZ,EAAe;UAEb,IAAIK,IAAJ,EAAUD,KAAK,CAACI,IAANJ,CAAWC,IAAXD;UACVC,IAAI,GAAG,EAAPA;QACD;;QACD,IAAIA,IAAJ,EAAUA,IAAI,CAACG,IAALH,CAAU,CAACH,CAAD,EAAIC,CAAJ,CAAVE;MATZ,OAUO,IAAIL,GAAG,KAAK,CAAZ,EAAe;QAEpB,IAAIK,IAAJ,EAAU;UACRA,IAAI,CAACG,IAALH,CAAUA,IAAI,CAAC,CAAD,CAAJA,CAAQI,KAARJ,EAAVA;QACD;MAJI,OAKA;QACL,MAAM,IAAIK,KAAJ,2BAA6BV,GAA7B,EAAN;MACD;IACF;;IAED,IAAIK,IAAJ,EAAUD,KAAK,CAACI,IAANJ,CAAWC,IAAXD;IAEV,OAAOA,KAAP;EACD;;EAGDO,IAAI,GAAG;IACL,MAAM5B,GAAG,GAAG,KAAKS,IAAjB;IACAT,GAAG,CAACe,GAAJf,GAAU,KAAKU,SAAfV;IAEA,MAAMC,GAAG,GAAGD,GAAG,CAACgB,UAAJhB,KAAmBA,GAAG,CAACe,GAAnC;IACA,IAAIE,GAAG,GAAG,CAAV;IACA,IAAIC,MAAM,GAAG,CAAb;IACA,IAAIC,CAAC,GAAG,CAAR;IACA,IAAIC,CAAC,GAAG,CAAR;IACA,IAAIS,EAAE,GAAGC,QAAT;IACA,IAAIC,EAAE,GAAG,CAACD,QAAV;IACA,IAAIE,EAAE,GAAGF,QAAT;IACA,IAAIG,EAAE,GAAG,CAACH,QAAV;;IAEA,OAAO9B,GAAG,CAACe,GAAJf,GAAUC,GAAjB,EAAsB;MACpB,IAAIiB,MAAM,IAAI,CAAd,EAAiB;QACf,MAAMK,MAAM,GAAGvB,GAAG,CAACgB,UAAJhB,EAAf;QACAiB,GAAG,GAAGM,MAAM,GAAG,GAAfN;QACAC,MAAM,GAAGK,MAAM,IAAI,CAAnBL;MACD;;MAEDA,MAAM;;MAEN,IAAID,GAAG,KAAK,CAARA,IAAaA,GAAG,KAAK,CAAzB,EAA4B;QAC1BE,CAAC,IAAInB,GAAG,CAACwB,WAAJxB,EAALmB;QACAC,CAAC,IAAIpB,GAAG,CAACwB,WAAJxB,EAALoB;QACA,IAAID,CAAC,GAAGU,EAAR,EAAYA,EAAE,GAAGV,CAALU;QACZ,IAAIV,CAAC,GAAGY,EAAR,EAAYA,EAAE,GAAGZ,CAALY;QACZ,IAAIX,CAAC,GAAGY,EAAR,EAAYA,EAAE,GAAGZ,CAALY;QACZ,IAAIZ,CAAC,GAAGa,EAAR,EAAYA,EAAE,GAAGb,CAALa;MANd,OAOO,IAAIhB,GAAG,KAAK,CAAZ,EAAe;QACpB,MAAM,IAAIU,KAAJ,2BAA6BV,GAA7B,EAAN;MACD;IACF;;IAED,OAAO,CAACY,EAAD,EAAKG,EAAL,EAASD,EAAT,EAAaE,EAAb,CAAP;EACD;;EAEDC,UAAU,CAACC,SAAD,EAAY;IACpB,IAAIC,MAAM,GAAG,KAAKtB,YAAL,EAAb;IACA,IAAIP,IAAI,GAAGV,iBAAiB,CAACC,KAAlBD,CAAwB,KAAKU,IAA7BV,CAAX;IACA,IAAIwC,CAAJ;IACA,IAAIC,CAAJ;;IAGA,QAAQ,KAAK/B,IAAb;MACE,KAAK,CAAL;QACE,MAAMgC,MAAgB,GAAG,EAAzB;;QACA,KAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAM,CAAClB,MAAvB,EAA+BmB,CAAC,EAAhC,EAAoC;UAClCE,MAAM,CAACF,CAAD,CAANE,GAAYH,MAAM,CAACC,CAAD,CAAND,CAAU,CAAVA,CAAZG;QACD;;QACDH,MAAM,GAAGG,MAATH;QACAD,SAAS,CAACC,MAAD,EAAS,IAAT,CAATD;QACA;;MAEF,KAAK,CAAL;QACE,KAAKE,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAM,CAAClB,MAAvB,EAA+BmB,CAAC,EAAhC,EAAoC;UAClCF,SAAS,CAACC,MAAM,CAACC,CAAD,CAAP,EAAY,IAAZ,CAATF;QACD;;QACD;;MAEF,KAAK,CAAL;QACEC,MAAM,GAAGxC,aAAa,CAACwC,MAAD,CAAtBA;;QACA,KAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,MAAM,CAAClB,MAAvB,EAA+BmB,CAAC,EAAhC,EAAoC;UAClC,KAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,MAAM,CAACC,CAAD,CAAND,CAAUlB,MAA1B,EAAkCoB,CAAC,EAAnC,EAAuC;YACrCH,SAAS,CAACC,MAAM,CAACC,CAAD,CAAND,CAAUE,CAAVF,CAAD,EAAe,IAAf,CAATD;UACD;QACF;;QACD;IAvBJ;;IA0BA,IAAIC,MAAM,CAAClB,MAAPkB,KAAkB,CAAtB,EAAyB;MACvBA,MAAM,GAAGA,MAAM,CAAC,CAAD,CAAfA;IADF,OAEO;MACL7B,IAAI,kBAAWA,IAAX,CAAJA;IACD;;IAED,MAAMiC,MAA4B,GAAG;MACnCjC,IAAI,EAAE,SAD6B;MAEnCkC,QAAQ,EAAE;QACRlC,IADQ;QAERmC,WAAW,EAAEN;MAFL,CAFyB;MAMnC9B,UAAU,EAAE,KAAKA;IANkB,CAArC;;IASA,IAAI,KAAKE,EAAL,KAAY,IAAhB,EAAsB;MACpBgC,MAAM,CAAChC,EAAPgC,GAAY,KAAKhC,EAAjBgC;IACD;;IAED,OAAOA,MAAP;EACD;;EAEDG,SAAS,CACPC,OADO,EAEe;IACtB,IAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;MACjC,OAAO,KAAKV,UAAL,CAAgBU,OAAhB,CAAP;IACD;;IACD,MAAM;MAACzB,CAAD;MAAIC,CAAJ;MAAOyB;IAAP,IAAYD,OAAlB;IACA,MAAME,IAAI,GAAG,KAAK5C,MAAL,GAAc6C,IAAI,CAACC,GAALD,CAAS,CAATA,EAAYF,CAAZE,CAA3B;IACA,MAAME,EAAE,GAAG,KAAK/C,MAAL,GAAciB,CAAzB;IACA,MAAM+B,EAAE,GAAG,KAAKhD,MAAL,GAAckB,CAAzB;;IAEA,SAAS+B,OAAT,CAAiB7B,IAAjB,EAAiC;MAC/B,KAAK,IAAIgB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,IAAI,CAACJ,MAAzB,EAAiCoB,CAAC,EAAlC,EAAsC;QACpC,MAAMc,CAAC,GAAG9B,IAAI,CAACgB,CAAD,CAAd;QACAc,CAAC,CAAC,CAAD,CAADA,GAAQ,CAACA,CAAC,CAAC,CAAD,CAADA,GAAOH,EAAR,IAAc,GAAd,GAAqBH,IAArB,GAA4B,GAApCM;QACA,MAAMnB,EAAE,GAAG,MAAO,CAACmB,CAAC,CAAC,CAAD,CAADA,GAAOF,EAAR,IAAc,GAAd,GAAqBJ,IAAvC;QACAM,CAAC,CAAC,CAAD,CAADA,GAAQ,MAAML,IAAI,CAACM,EAAX,GAAiBN,IAAI,CAACO,IAALP,CAAUA,IAAI,CAACQ,GAALR,CAAUd,EAAE,GAAGc,IAAI,CAACM,EAAVpB,GAAgB,GAA1Bc,CAAVA,CAAjB,GAA6D,EAArEK;MACD;IACF;;IACD,OAAO,KAAKlB,UAAL,CAAgBiB,OAAhB,CAAP;EACD;;AApMoC","names":["readFeature","classifyRings","VectorTileFeature","types","constructor","pbf","end","extent","keys","values","_defineProperty","properties","type","id","_pbf","_geometry","_keys","_values","readFields","loadGeometry","pos","readVarint","cmd","length","x","y","lines","line","cmdLen","readSVarint","push","slice","Error","bbox","x1","Infinity","x2","y1","y2","_toGeoJSON","transform","coords","i","j","points","result","geometry","coordinates","toGeoJSON","options","z","size","Math","pow","x0","y0","project","p","PI","atan","exp"],"sources":["../../../../src/lib/mapbox-vector-tile/vector-tile-feature.ts"],"sourcesContent":["// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\nimport Protobuf from 'pbf';\nimport {MvtMapboxCoordinates, MvtMapboxGeometry} from '../types';\nimport {readFeature, classifyRings} from '../../helpers/mapbox-util-functions';\n\nexport default class VectorTileFeature {\n  properties: {[x: string]: string | number | boolean | null};\n  extent: any;\n  type: number;\n  id: number | null;\n  _pbf: Protobuf;\n  _geometry: number;\n  _keys: string[];\n  _values: (string | number | boolean | null)[];\n  static get types() {\n    return ['Unknown', 'Point', 'LineString', 'Polygon'];\n  }\n\n  constructor(\n    pbf: Protobuf,\n    end: number,\n    extent: any,\n    keys: string[],\n    values: (string | number | boolean | null)[]\n  ) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n\n    pbf.readFields(readFeature, this, end);\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry(): MvtMapboxGeometry {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    const lines: number[][][] = [];\n    let line: number[][] | undefined;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // moveTo\n          if (line) lines.push(line);\n          line = [];\n        }\n        if (line) line.push([x, y]);\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (line) {\n          line.push(line[0].slice()); // closePolygon\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n  }\n\n  // eslint-disable-next-line max-statements\n  bbox() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    const end = pbf.readVarint() + pbf.pos;\n    let cmd = 1;\n    let length = 0;\n    let x = 0;\n    let y = 0;\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n\n    while (pbf.pos < end) {\n      if (length <= 0) {\n        const cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      } else if (cmd !== 7) {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  _toGeoJSON(transform) {\n    let coords = this.loadGeometry();\n    let type = VectorTileFeature.types[this.type];\n    let i: number;\n    let j: number;\n\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1:\n        const points: number[] = [];\n        for (i = 0; i < coords.length; i++) {\n          points[i] = coords[i][0];\n        }\n        coords = points;\n        transform(coords, this);\n        break;\n\n      case 2:\n        for (i = 0; i < coords.length; i++) {\n          transform(coords[i], this);\n        }\n        break;\n\n      case 3:\n        coords = classifyRings(coords);\n        for (i = 0; i < coords.length; i++) {\n          for (j = 0; j < coords[i].length; j++) {\n            transform(coords[i][j], this);\n          }\n        }\n        break;\n    }\n\n    if (coords.length === 1) {\n      coords = coords[0];\n    } else {\n      type = `Multi${type}`;\n    }\n\n    const result: MvtMapboxCoordinates = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates: coords\n      },\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toGeoJSON(\n    options: {x: number; y: number; z: number} | ((data: number[], feature: {extent: any}) => void)\n  ): MvtMapboxCoordinates {\n    if (typeof options === 'function') {\n      return this._toGeoJSON(options);\n    }\n    const {x, y, z} = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    function project(line: number[]) {\n      for (let j = 0; j < line.length; j++) {\n        const p = line[j];\n        p[0] = ((p[0] + x0) * 360) / size - 180;\n        const y2 = 180 - ((p[1] + y0) * 360) / size;\n        p[1] = (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n      }\n    }\n    return this._toGeoJSON(project);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}