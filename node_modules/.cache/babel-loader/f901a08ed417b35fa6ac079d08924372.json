{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport { Matrix4 } from '@math.gl/core';\nimport { MVTWorkerLoader } from '@loaders.gl/mvt';\nimport { binaryToGeojson } from '@loaders.gl/gis';\nimport { COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ClipExtension } from '@deck.gl/extensions';\nimport TileLayer from '../tile-layer/tile-layer';\nimport { getURLFromTemplate, isURLTemplate } from '../tile-layer/utils';\nimport { transform } from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nconst WORLD_SIZE = 512;\nconst defaultProps = { ...GeoJsonLayer.defaultProps,\n  uniqueIdProperty: {\n    type: 'string',\n    value: ''\n  },\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\nexport default class MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded() {\n    return this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      context,\n      changeFlags\n    } = _ref;\n\n    if (changeFlags.dataChanged) {\n      this._updateTileData();\n    }\n\n    if (this.state.data) {\n      super.updateState({\n        props,\n        oldProps,\n        context,\n        changeFlags\n      });\n\n      this._setWGS84PropertyForTiles();\n    }\n\n    const {\n      highlightColor\n    } = props;\n\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({\n        highlightColor\n      });\n    }\n  }\n\n  async _updateTileData() {\n    let {\n      data\n    } = this.props;\n    let tileJSON = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {\n        onDataLoad,\n        fetch\n      } = this.props;\n      this.setState({\n        data: null,\n        tileJSON: null\n      });\n\n      try {\n        tileJSON = await fetch(data, {\n          propName: 'data',\n          layer: this,\n          loaders: []\n        });\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON);\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({\n      data,\n      tileJSON\n    });\n  }\n\n  _getTilesetOptions(props) {\n    const opts = super._getTilesetOptions(props);\n\n    const {\n      tileJSON\n    } = this.state;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > props.minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n\n      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(props.maxZoom) || tileJSON.maxzoom < props.maxZoom)) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n\n    return opts;\n  }\n\n  renderLayers() {\n    if (!this.state.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(tile) {\n    var _loadOptions;\n\n    const url = getURLFromTemplate(this.state.data, tile);\n\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    let loadOptions = this.getLoadOptions();\n    const {\n      binary\n    } = this.state;\n    const {\n      fetch\n    } = this.props;\n    const {\n      signal,\n      x,\n      y,\n      z\n    } = tile;\n    loadOptions = { ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.mvt),\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: {\n          x,\n          y,\n          z\n        }\n      },\n      gis: binary ? {\n        format: 'binary'\n      } : {}\n    };\n    return fetch(url, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n  }\n\n  renderSubLayers(props) {\n    const {\n      tile\n    } = props;\n    const worldScale = Math.pow(2, tile.z);\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n    const xOffset = WORLD_SIZE * tile.x / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  _updateAutoHighlight(info) {\n    const {\n      uniqueIdProperty\n    } = this.props;\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName\n    } = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId;\n    let newHoveredFeatureLayerName;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n\n    let {\n      highlightColor\n    } = this.props;\n\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const isWGS84 = this.context.viewport.resolution;\n\n    if (this.state.binary && info.index !== -1) {\n      const {\n        data\n      } = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {\n        globalFeatureId: info.index\n      });\n    }\n\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {\n      hoveredFeatureId,\n      hoveredFeatureLayerName,\n      binary\n    } = this.state;\n    const {\n      uniqueIdProperty,\n      highlightedFeatureId\n    } = this.props;\n    const data = tile.content;\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n    } else if (data && binary) {\n      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? '' : hoveredFeatureLayerName);\n    }\n\n    return -1;\n  }\n\n  _pickObjects(maxObjects) {\n    const {\n      deck,\n      viewport\n    } = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({\n      x,\n      y,\n      width,\n      height,\n      layerIds,\n      maxObjects\n    });\n  }\n\n  getRenderedFeatures() {\n    let maxFeatures = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    const features = this._pickObjects(maxFeatures);\n\n    const featureCache = new Set();\n    const renderedFeatures = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const {\n      tileset\n    } = this.state;\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              return [];\n            }\n\n            if (tile._contentWGS84 === undefined) {\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature => transformTileCoordsToWGS84(feature, tile.bbox, this.context.viewport));\n            }\n\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature) {\n  var _feature$properties;\n\n  return ((_feature$properties = feature.properties) === null || _feature$properties === void 0 ? void 0 : _feature$properties.layerName) || null;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = { ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["log","Matrix4","MVTWorkerLoader","binaryToGeojson","COORDINATE_SYSTEM","ClipExtension","TileLayer","getURLFromTemplate","isURLTemplate","transform","findIndexBinary","GeoJsonLayer","WORLD_SIZE","defaultProps","uniqueIdProperty","type","value","highlightedFeatureId","loaders","binary","MVTLayer","initializeState","context","viewport","resolution","undefined","props","setState","data","tileJSON","isLoaded","state","tileset","updateState","oldProps","changeFlags","dataChanged","_updateTileData","_setWGS84PropertyForTiles","highlightColor","Array","isArray","onDataLoad","fetch","propName","layer","error","raiseError","tilejson","tiles","_getTilesetOptions","opts","Number","isFinite","minzoom","minZoom","maxzoom","maxZoom","renderLayers","getTileData","tile","url","Promise","reject","loadOptions","getLoadOptions","signal","x","y","z","mimeType","mvt","_loadOptions","coordinates","tileIndex","gis","format","renderSubLayers","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","modelMatrix","scale","autoHighlight","coordinateOrigin","coordinateSystem","CARTESIAN","extensions","subLayers","warn","_updateAutoHighlight","info","hoveredFeatureId","hoveredFeatureLayerName","hoveredFeature","object","newHoveredFeatureId","newHoveredFeatureLayerName","getFeatureUniqueId","getFeatureLayerName","getPickingInfo","params","isWGS84","index","sourceLayer","globalFeatureId","transformTileCoordsToWGS84","bbox","getSubLayerPropsByTile","highlightedObjectIndex","getHighlightedObjectIndex","content","isHighlighted","isFeatureIdDefined","isFeatureIdPresent","featureIdToHighlight","findIndex","feature","isMatchingId","isMatchingLayer","_pickObjects","maxObjects","deck","width","height","layerIds","id","pickObjects","getRenderedFeatures","maxFeatures","features","featureCache","Set","renderedFeatures","f","featureId","push","has","add","selectedTiles","forEach","hasOwnProperty","Object","defineProperty","get","length","_contentWGS84","map","properties","layerName","geometry","wgs84Geom"],"sources":["../../../src/mvt-layer/mvt-layer.js"],"sourcesContent":["import {log} from '@deck.gl/core';\nimport {Matrix4} from '@math.gl/core';\nimport {MVTWorkerLoader} from '@loaders.gl/mvt';\nimport {binaryToGeojson} from '@loaders.gl/gis';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {ClipExtension} from '@deck.gl/extensions';\n\nimport TileLayer from '../tile-layer/tile-layer';\nimport {getURLFromTemplate, isURLTemplate} from '../tile-layer/utils';\nimport {transform} from './coordinate-transform';\nimport findIndexBinary from './find-index-binary';\n\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nconst WORLD_SIZE = 512;\n\nconst defaultProps = {\n  ...GeoJsonLayer.defaultProps,\n  uniqueIdProperty: {type: 'string', value: ''},\n  highlightedFeatureId: null,\n  loaders: [MVTWorkerLoader],\n  binary: true\n};\n\nexport default class MVTLayer extends TileLayer {\n  initializeState() {\n    super.initializeState();\n    // GlobeView doesn't work well with binary data\n    const binary = this.context.viewport.resolution !== undefined ? false : this.props.binary;\n    this.setState({\n      binary,\n      data: null,\n      tileJSON: null\n    });\n  }\n\n  get isLoaded() {\n    return this.state.data && this.state.tileset && super.isLoaded;\n  }\n\n  updateState({props, oldProps, context, changeFlags}) {\n    if (changeFlags.dataChanged) {\n      this._updateTileData();\n    }\n\n    if (this.state.data) {\n      super.updateState({props, oldProps, context, changeFlags});\n      this._setWGS84PropertyForTiles();\n    }\n    const {highlightColor} = props;\n    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {\n      this.setState({highlightColor});\n    }\n  }\n\n  /* eslint-disable complexity */\n  async _updateTileData() {\n    let {data} = this.props;\n    let tileJSON = null;\n\n    if (typeof data === 'string' && !isURLTemplate(data)) {\n      const {onDataLoad, fetch} = this.props;\n      this.setState({data: null, tileJSON: null});\n      try {\n        tileJSON = await fetch(data, {propName: 'data', layer: this, loaders: []});\n      } catch (error) {\n        this.raiseError(error, 'loading TileJSON');\n        data = null;\n      }\n\n      if (onDataLoad) {\n        onDataLoad(tileJSON);\n      }\n    } else if (data.tilejson) {\n      tileJSON = data;\n    }\n\n    if (tileJSON) {\n      data = tileJSON.tiles;\n    }\n\n    this.setState({data, tileJSON});\n  }\n\n  _getTilesetOptions(props) {\n    const opts = super._getTilesetOptions(props);\n    const {tileJSON} = this.state;\n\n    if (tileJSON) {\n      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > props.minZoom) {\n        opts.minZoom = tileJSON.minzoom;\n      }\n\n      if (\n        Number.isFinite(tileJSON.maxzoom) &&\n        (!Number.isFinite(props.maxZoom) || tileJSON.maxzoom < props.maxZoom)\n      ) {\n        opts.maxZoom = tileJSON.maxzoom;\n      }\n    }\n    return opts;\n  }\n\n  /* eslint-disable complexity */\n\n  renderLayers() {\n    if (!this.state.data) return null;\n    return super.renderLayers();\n  }\n\n  getTileData(tile) {\n    const url = getURLFromTemplate(this.state.data, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n    let loadOptions = this.getLoadOptions();\n    const {binary} = this.state;\n    const {fetch} = this.props;\n    const {signal, x, y, z} = tile;\n    loadOptions = {\n      ...loadOptions,\n      mimeType: 'application/x-protobuf',\n      mvt: {\n        ...loadOptions?.mvt,\n        coordinates: this.context.viewport.resolution ? 'wgs84' : 'local',\n        tileIndex: {x, y, z}\n        // Local worker debug\n        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`\n        // Set worker to null to skip web workers\n        // workerUrl: null\n      },\n      gis: binary ? {format: 'binary'} : {}\n    };\n    return fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n  }\n\n  renderSubLayers(props) {\n    const {tile} = props;\n    const worldScale = Math.pow(2, tile.z);\n\n    const xScale = WORLD_SIZE / worldScale;\n    const yScale = -xScale;\n\n    const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n    const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n    const modelMatrix = new Matrix4().scale([xScale, yScale, 1]);\n\n    props.autoHighlight = false;\n\n    if (!this.context.viewport.resolution) {\n      props.modelMatrix = modelMatrix;\n      props.coordinateOrigin = [xOffset, yOffset, 0];\n      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;\n      props.extensions = [...(props.extensions || []), new ClipExtension()];\n    }\n\n    const subLayers = super.renderSubLayers(props);\n\n    if (this.state.binary && !(subLayers instanceof GeoJsonLayer)) {\n      log.warn('renderSubLayers() must return GeoJsonLayer when using binary:true')();\n    }\n\n    return subLayers;\n  }\n\n  _updateAutoHighlight(info) {\n    const {uniqueIdProperty} = this.props;\n\n    const {hoveredFeatureId, hoveredFeatureLayerName} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId;\n    let newHoveredFeatureLayerName;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);\n      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);\n    }\n    let {highlightColor} = this.props;\n    if (typeof highlightColor === 'function') {\n      highlightColor = highlightColor(info);\n    }\n\n    if (\n      hoveredFeatureId !== newHoveredFeatureId ||\n      hoveredFeatureLayerName !== newHoveredFeatureLayerName\n    ) {\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId,\n        hoveredFeatureLayerName: newHoveredFeatureLayerName\n      });\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n\n    const isWGS84 = this.context.viewport.resolution;\n\n    if (this.state.binary && info.index !== -1) {\n      const {data} = params.sourceLayer.props;\n      info.object = binaryToGeojson(data, {globalFeatureId: info.index});\n    }\n    if (info.object && !isWGS84) {\n      info.object = transformTileCoordsToWGS84(info.object, info.tile.bbox, this.context.viewport);\n    }\n\n    return info;\n  }\n\n  getSubLayerPropsByTile(tile) {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile) {\n    const {hoveredFeatureId, hoveredFeatureLayerName, binary} = this.state;\n    const {uniqueIdProperty, highlightedFeatureId} = this.props;\n    const data = tile.content;\n\n    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;\n\n    if (!isFeatureIdPresent) {\n      return -1;\n    }\n\n    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;\n\n    // Iterable data\n    if (Array.isArray(data)) {\n      return data.findIndex(feature => {\n        const isMatchingId = getFeatureUniqueId(feature, uniqueIdProperty) === featureIdToHighlight;\n        const isMatchingLayer =\n          isHighlighted || getFeatureLayerName(feature) === hoveredFeatureLayerName;\n        return isMatchingId && isMatchingLayer;\n      });\n\n      // Non-iterable data\n    } else if (data && binary) {\n      // Get the feature index of the selected item to highlight\n      return findIndexBinary(\n        data,\n        uniqueIdProperty,\n        featureIdToHighlight,\n        isHighlighted ? '' : hoveredFeatureLayerName\n      );\n    }\n\n    return -1;\n  }\n\n  _pickObjects(maxObjects) {\n    const {deck, viewport} = this.context;\n    const width = viewport.width;\n    const height = viewport.height;\n    const x = viewport.x;\n    const y = viewport.y;\n    const layerIds = [this.id];\n    return deck.pickObjects({x, y, width, height, layerIds, maxObjects});\n  }\n\n  getRenderedFeatures(maxFeatures = null) {\n    const features = this._pickObjects(maxFeatures);\n    const featureCache = new Set();\n    const renderedFeatures = [];\n\n    for (const f of features) {\n      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);\n\n      if (featureId === undefined) {\n        // we have no id for the feature, we just add to the list\n        renderedFeatures.push(f.object);\n      } else if (!featureCache.has(featureId)) {\n        // Add removing duplicates\n        featureCache.add(featureId);\n        renderedFeatures.push(f.object);\n      }\n    }\n\n    return renderedFeatures;\n  }\n\n  _setWGS84PropertyForTiles() {\n    const propName = 'dataInWGS84';\n    const {tileset} = this.state;\n\n    tileset.selectedTiles.forEach(tile => {\n      if (!tile.hasOwnProperty(propName)) {\n        // eslint-disable-next-line accessor-pairs\n        Object.defineProperty(tile, propName, {\n          get: () => {\n            // Still loading or encountered an error\n            if (!tile.content) {\n              return null;\n            }\n\n            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {\n              // TODO: @loaders.gl/mvt returns [] when no content. It should return a valid empty binary.\n              // https://github.com/visgl/loaders.gl/pull/1137\n              return [];\n            }\n\n            if (tile._contentWGS84 === undefined) {\n              // Create a cache to transform only once\n              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;\n              tile._contentWGS84 = content.map(feature =>\n                transformTileCoordsToWGS84(feature, tile.bbox, this.context.viewport)\n              );\n            }\n            return tile._contentWGS84;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction getFeatureUniqueId(feature, uniqueIdProperty) {\n  if (uniqueIdProperty) {\n    return feature.properties[uniqueIdProperty];\n  }\n\n  if ('id' in feature) {\n    return feature.id;\n  }\n\n  return undefined;\n}\n\nfunction getFeatureLayerName(feature) {\n  return feature.properties?.layerName || null;\n}\n\nfunction isFeatureIdDefined(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\nfunction transformTileCoordsToWGS84(object, bbox, viewport) {\n  const feature = {\n    ...object,\n    geometry: {\n      type: object.geometry.type\n    }\n  };\n\n  // eslint-disable-next-line accessor-pairs\n  Object.defineProperty(feature.geometry, 'coordinates', {\n    get: () => {\n      const wgs84Geom = transform(object.geometry, bbox, viewport);\n      return wgs84Geom.coordinates;\n    }\n  });\n\n  return feature;\n}\n\nMVTLayer.layerName = 'MVTLayer';\nMVTLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}