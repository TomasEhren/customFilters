{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _core = require(\"@deck.gl/core\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar EVENT_TYPES = ['anyclick', 'pointermove', 'panstart', 'panmove', 'panend', 'keyup'];\n\nvar EditableLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(EditableLayer, _CompositeLayer);\n\n  var _super = _createSuper(EditableLayer);\n\n  function EditableLayer() {\n    _classCallCheck(this, EditableLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditableLayer, [{\n    key: \"onLayerClick\",\n    // Overridable interaction event handlers\n    value: function onLayerClick(event) {// default implementation - do nothing\n    }\n  }, {\n    key: \"onStartDragging\",\n    value: function onStartDragging(event) {// default implementation - do nothing\n    }\n  }, {\n    key: \"onStopDragging\",\n    value: function onStopDragging(event) {// default implementation - do nothing\n    }\n  }, {\n    key: \"onDragging\",\n    value: function onDragging(event) {// default implementation - do nothing\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(event) {// default implementation - do nothing\n    }\n  }, {\n    key: \"onLayerKeyUp\",\n    value: function onLayerKeyUp(event) {} // default implementation - do nothing;\n    // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.setState({\n        _editableLayerState: {\n          // Picked objects at the time the pointer went down\n          pointerDownPicks: null,\n          // Screen coordinates where the pointer went down\n          pointerDownScreenCoords: null,\n          // Ground coordinates where the pointer went down\n          pointerDownMapCoords: null,\n          // Keep track of the mjolnir.js event handler so it can be deregistered\n          eventHandler: this._forwardEventToCurrentLayer.bind(this)\n        }\n      });\n\n      this._addEventHandlers();\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      this._removeEventHandlers();\n    }\n  }, {\n    key: \"_addEventHandlers\",\n    value: function _addEventHandlers() {\n      // @ts-ignore\n      var eventManager = this.context.deck.eventManager;\n      var eventHandler = this.state._editableLayerState.eventHandler;\n\n      var _iterator = _createForOfIteratorHelper(EVENT_TYPES),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var eventType = _step.value;\n          eventManager.on(eventType, eventHandler, {\n            // give nebula a higher priority so that it can stop propagation to deck.gl's map panning handlers\n            priority: 100\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_removeEventHandlers\",\n    value: function _removeEventHandlers() {\n      // @ts-ignore\n      var eventManager = this.context.deck.eventManager;\n      var eventHandler = this.state._editableLayerState.eventHandler;\n\n      var _iterator2 = _createForOfIteratorHelper(EVENT_TYPES),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var eventType = _step2.value;\n          eventManager.off(eventType, eventHandler);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } // A new layer instance is created on every render, so forward the event to the current layer\n    // This means that the first layer instance will stick around to be the event listener, but will forward the event\n    // to the latest layer instance.\n\n  }, {\n    key: \"_forwardEventToCurrentLayer\",\n    value: function _forwardEventToCurrentLayer(event) {\n      var currentLayer = this.getCurrentLayer(); // Use a naming convention to find the event handling function for this event type\n\n      var func = currentLayer[\"_on\".concat(event.type)].bind(currentLayer);\n\n      if (!func) {\n        console.warn(\"no handler for mjolnir.js event \".concat(event.type)); // eslint-disable-line\n\n        return;\n      }\n\n      func(event);\n    }\n  }, {\n    key: \"_onanyclick\",\n    value: function _onanyclick(_ref) {\n      var srcEvent = _ref.srcEvent;\n      var screenCoords = this.getScreenCoords(srcEvent);\n      var mapCoords = this.getMapCoords(screenCoords); // @ts-ignore\n\n      var picks = this.getPicks(screenCoords);\n      this.onLayerClick({\n        mapCoords: mapCoords,\n        // @ts-ignore\n        screenCoords: screenCoords,\n        picks: picks,\n        sourceEvent: srcEvent\n      });\n    }\n  }, {\n    key: \"_onkeyup\",\n    value: function _onkeyup(_ref2) {\n      var srcEvent = _ref2.srcEvent;\n      this.onLayerKeyUp(srcEvent);\n    }\n  }, {\n    key: \"_onpanstart\",\n    value: function _onpanstart(event) {\n      var screenCoords = this.getScreenCoords(event.srcEvent);\n      var mapCoords = this.getMapCoords(screenCoords); // @ts-ignore\n\n      var picks = this.getPicks(screenCoords);\n      this.setState({\n        _editableLayerState: _objectSpread({}, this.state._editableLayerState, {\n          pointerDownScreenCoords: screenCoords,\n          pointerDownMapCoords: mapCoords,\n          pointerDownPicks: picks\n        })\n      });\n      this.onStartDragging({\n        picks: picks,\n        // @ts-ignore\n        screenCoords: screenCoords,\n        // @ts-ignore\n        mapCoords: mapCoords,\n        // @ts-ignore\n        pointerDownScreenCoords: screenCoords,\n        pointerDownMapCoords: mapCoords,\n        cancelPan: event.stopImmediatePropagation,\n        sourceEvent: event.srcEvent\n      });\n    }\n  }, {\n    key: \"_onpanmove\",\n    value: function _onpanmove(event) {\n      var srcEvent = event.srcEvent;\n      var screenCoords = this.getScreenCoords(srcEvent);\n      var mapCoords = this.getMapCoords(screenCoords);\n      var _this$state$_editable = this.state._editableLayerState,\n          pointerDownPicks = _this$state$_editable.pointerDownPicks,\n          pointerDownScreenCoords = _this$state$_editable.pointerDownScreenCoords,\n          pointerDownMapCoords = _this$state$_editable.pointerDownMapCoords; // @ts-ignore\n\n      var picks = this.getPicks(screenCoords);\n      this.onDragging({\n        // @ts-ignore\n        screenCoords: screenCoords,\n        mapCoords: mapCoords,\n        picks: picks,\n        pointerDownPicks: pointerDownPicks,\n        pointerDownScreenCoords: pointerDownScreenCoords,\n        pointerDownMapCoords: pointerDownMapCoords,\n        sourceEvent: srcEvent,\n        cancelPan: event.stopImmediatePropagation // another (hacky) approach for cancelling map panning\n        // const controller = this.context.deck.viewManager.controllers[\n        //   Object.keys(this.context.deck.viewManager.controllers)[0]\n        // ];\n        // controller._state.isDragging = false;\n\n      });\n    }\n  }, {\n    key: \"_onpanend\",\n    value: function _onpanend(_ref3) {\n      var srcEvent = _ref3.srcEvent;\n      var screenCoords = this.getScreenCoords(srcEvent);\n      var mapCoords = this.getMapCoords(screenCoords);\n      var _this$state$_editable2 = this.state._editableLayerState,\n          pointerDownPicks = _this$state$_editable2.pointerDownPicks,\n          pointerDownScreenCoords = _this$state$_editable2.pointerDownScreenCoords,\n          pointerDownMapCoords = _this$state$_editable2.pointerDownMapCoords; // @ts-ignore\n\n      var picks = this.getPicks(screenCoords);\n      this.onStopDragging({\n        picks: picks,\n        // @ts-ignore\n        screenCoords: screenCoords,\n        mapCoords: mapCoords,\n        pointerDownPicks: pointerDownPicks,\n        pointerDownScreenCoords: pointerDownScreenCoords,\n        pointerDownMapCoords: pointerDownMapCoords,\n        sourceEvent: srcEvent\n      });\n      this.setState({\n        _editableLayerState: _objectSpread({}, this.state._editableLayerState, {\n          pointerDownScreenCoords: null,\n          pointerDownMapCoords: null,\n          pointerDownPicks: null\n        })\n      });\n    }\n  }, {\n    key: \"_onpointermove\",\n    value: function _onpointermove(event) {\n      var srcEvent = event.srcEvent;\n      var screenCoords = this.getScreenCoords(srcEvent);\n      var mapCoords = this.getMapCoords(screenCoords);\n      var _this$state$_editable3 = this.state._editableLayerState,\n          pointerDownPicks = _this$state$_editable3.pointerDownPicks,\n          pointerDownScreenCoords = _this$state$_editable3.pointerDownScreenCoords,\n          pointerDownMapCoords = _this$state$_editable3.pointerDownMapCoords; // @ts-ignore\n\n      var picks = this.getPicks(screenCoords);\n      this.onPointerMove({\n        // @ts-ignore\n        screenCoords: screenCoords,\n        mapCoords: mapCoords,\n        picks: picks,\n        pointerDownPicks: pointerDownPicks,\n        pointerDownScreenCoords: pointerDownScreenCoords,\n        pointerDownMapCoords: pointerDownMapCoords,\n        sourceEvent: srcEvent\n      });\n    }\n  }, {\n    key: \"getPicks\",\n    value: function getPicks(screenCoords) {\n      // @ts-ignore\n      return this.context.deck.pickMultipleObjects({\n        x: screenCoords[0],\n        y: screenCoords[1],\n        layerIds: [this.props.id],\n        radius: this.props.pickingRadius,\n        depth: this.props.pickingDepth\n      });\n    }\n  }, {\n    key: \"getScreenCoords\",\n    value: function getScreenCoords(pointerEvent) {\n      return [pointerEvent.clientX - this.context.gl.canvas.getBoundingClientRect().left, pointerEvent.clientY - this.context.gl.canvas.getBoundingClientRect().top];\n    }\n  }, {\n    key: \"getMapCoords\",\n    value: function getMapCoords(screenCoords) {\n      // @ts-ignore\n      return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n    }\n  }]);\n\n  return EditableLayer;\n}(_core.CompositeLayer);\n\nexports[\"default\"] = EditableLayer;\n\n_defineProperty(EditableLayer, \"layerName\", 'EditableLayer');","map":{"version":3,"mappings":"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","names":["EVENT_TYPES","EditableLayer","event","setState","_editableLayerState","pointerDownPicks","pointerDownScreenCoords","pointerDownMapCoords","eventHandler","_forwardEventToCurrentLayer","bind","_addEventHandlers","_removeEventHandlers","eventManager","context","deck","state","eventType","on","priority","_iterator","off","_iterator2","currentLayer","getCurrentLayer","func","type","console","warn","srcEvent","screenCoords","getScreenCoords","mapCoords","getMapCoords","picks","getPicks","onLayerClick","sourceEvent","onLayerKeyUp","onStartDragging","cancelPan","stopImmediatePropagation","onDragging","onStopDragging","onPointerMove","pickMultipleObjects","x","y","layerIds","props","id","radius","pickingRadius","depth","pickingDepth","pointerEvent","clientX","gl","canvas","getBoundingClientRect","left","clientY","top","viewport","unproject","CompositeLayer"],"sources":["../../src/layers/editable-layer.ts"],"sourcesContent":["/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { CompositeLayerProps } from '@deck.gl/core/lib/composite-layer';\nimport {\n  ClickEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  PointerMoveEvent,\n  Position,\n} from '@nebula.gl/edit-modes';\n\nconst EVENT_TYPES = ['anyclick', 'pointermove', 'panstart', 'panmove', 'panend', 'keyup'];\n\nexport interface EditableLayerProps<D> extends CompositeLayerProps<D> {\n  pickingRadius?: number;\n  pickingDepth?: number;\n}\n\nexport default class EditableLayer<\n  D,\n  P extends EditableLayerProps<D> = EditableLayerProps<D>\n> extends CompositeLayer<D, P> {\n  static layerName = 'EditableLayer';\n\n  // Overridable interaction event handlers\n  onLayerClick(event: ClickEvent) {\n    // default implementation - do nothing\n  }\n\n  onStartDragging(event: StartDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onStopDragging(event: StopDraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onDragging(event: DraggingEvent) {\n    // default implementation - do nothing\n  }\n\n  onPointerMove(event: PointerMoveEvent) {\n    // default implementation - do nothing\n  }\n\n  onLayerKeyUp(event: KeyboardEvent): void {\n    // default implementation - do nothing;\n  }\n  // TODO: implement onCancelDragging (e.g. drag off screen)\n\n  initializeState() {\n    this.setState({\n      _editableLayerState: {\n        // Picked objects at the time the pointer went down\n        pointerDownPicks: null,\n        // Screen coordinates where the pointer went down\n        pointerDownScreenCoords: null,\n        // Ground coordinates where the pointer went down\n        pointerDownMapCoords: null,\n\n        // Keep track of the mjolnir.js event handler so it can be deregistered\n        eventHandler: this._forwardEventToCurrentLayer.bind(this),\n      },\n    });\n\n    this._addEventHandlers();\n  }\n\n  finalizeState() {\n    this._removeEventHandlers();\n  }\n\n  _addEventHandlers() {\n    // @ts-ignore\n    const { eventManager } = this.context.deck;\n    const { eventHandler } = this.state._editableLayerState;\n\n    for (const eventType of EVENT_TYPES) {\n      eventManager.on(eventType, eventHandler, {\n        // give nebula a higher priority so that it can stop propagation to deck.gl's map panning handlers\n        priority: 100,\n      });\n    }\n  }\n\n  _removeEventHandlers() {\n    // @ts-ignore\n    const { eventManager } = this.context.deck;\n    const { eventHandler } = this.state._editableLayerState;\n\n    for (const eventType of EVENT_TYPES) {\n      eventManager.off(eventType, eventHandler);\n    }\n  }\n\n  // A new layer instance is created on every render, so forward the event to the current layer\n  // This means that the first layer instance will stick around to be the event listener, but will forward the event\n  // to the latest layer instance.\n  _forwardEventToCurrentLayer(event: any) {\n    const currentLayer = this.getCurrentLayer();\n\n    // Use a naming convention to find the event handling function for this event type\n    const func = currentLayer[`_on${event.type}`].bind(currentLayer);\n    if (!func) {\n      console.warn(`no handler for mjolnir.js event ${event.type}`); // eslint-disable-line\n      return;\n    }\n    func(event);\n  }\n\n  _onanyclick({ srcEvent }: any) {\n    const screenCoords = this.getScreenCoords(srcEvent);\n    const mapCoords = this.getMapCoords(screenCoords);\n    // @ts-ignore\n    const picks = this.getPicks(screenCoords);\n\n    this.onLayerClick({\n      mapCoords,\n      // @ts-ignore\n      screenCoords,\n      picks,\n      sourceEvent: srcEvent,\n    });\n  }\n\n  _onkeyup({ srcEvent }: { srcEvent: KeyboardEvent }) {\n    this.onLayerKeyUp(srcEvent);\n  }\n\n  _onpanstart(event: any) {\n    const screenCoords = this.getScreenCoords(event.srcEvent);\n    const mapCoords = this.getMapCoords(screenCoords);\n    // @ts-ignore\n    const picks = this.getPicks(screenCoords);\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: screenCoords,\n        pointerDownMapCoords: mapCoords,\n        pointerDownPicks: picks,\n      },\n    });\n\n    this.onStartDragging({\n      picks,\n      // @ts-ignore\n      screenCoords,\n      // @ts-ignore\n      mapCoords,\n      // @ts-ignore\n      pointerDownScreenCoords: screenCoords,\n      pointerDownMapCoords: mapCoords,\n      cancelPan: event.stopImmediatePropagation,\n      sourceEvent: event.srcEvent,\n    });\n  }\n\n  _onpanmove(event: any) {\n    const { srcEvent } = event;\n    const screenCoords = this.getScreenCoords(srcEvent);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n    } = this.state._editableLayerState;\n    // @ts-ignore\n    const picks = this.getPicks(screenCoords);\n\n    this.onDragging({\n      // @ts-ignore\n      screenCoords,\n      mapCoords,\n      picks,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      sourceEvent: srcEvent,\n      cancelPan: event.stopImmediatePropagation,\n      // another (hacky) approach for cancelling map panning\n      // const controller = this.context.deck.viewManager.controllers[\n      //   Object.keys(this.context.deck.viewManager.controllers)[0]\n      // ];\n      // controller._state.isDragging = false;\n    });\n  }\n\n  _onpanend({ srcEvent }: any) {\n    const screenCoords = this.getScreenCoords(srcEvent);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n    } = this.state._editableLayerState;\n    // @ts-ignore\n    const picks = this.getPicks(screenCoords);\n\n    this.onStopDragging({\n      picks,\n      // @ts-ignore\n      screenCoords,\n      mapCoords,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      sourceEvent: srcEvent,\n    });\n\n    this.setState({\n      _editableLayerState: {\n        ...this.state._editableLayerState,\n        pointerDownScreenCoords: null,\n        pointerDownMapCoords: null,\n        pointerDownPicks: null,\n      },\n    });\n  }\n\n  _onpointermove(event: any) {\n    const { srcEvent } = event;\n    const screenCoords = this.getScreenCoords(srcEvent);\n    const mapCoords = this.getMapCoords(screenCoords);\n\n    const {\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n    } = this.state._editableLayerState;\n    // @ts-ignore\n    const picks = this.getPicks(screenCoords);\n\n    this.onPointerMove({\n      // @ts-ignore\n      screenCoords,\n      mapCoords,\n      picks,\n      pointerDownPicks,\n      pointerDownScreenCoords,\n      pointerDownMapCoords,\n      sourceEvent: srcEvent,\n    });\n  }\n\n  getPicks(screenCoords: [number, number]) {\n    // @ts-ignore\n    return this.context.deck.pickMultipleObjects({\n      x: screenCoords[0],\n      y: screenCoords[1],\n      layerIds: [this.props.id],\n      radius: this.props.pickingRadius,\n      depth: this.props.pickingDepth,\n    });\n  }\n\n  getScreenCoords(pointerEvent: any): Position {\n    return [\n      pointerEvent.clientX -\n        (this.context.gl.canvas as HTMLCanvasElement).getBoundingClientRect().left,\n      pointerEvent.clientY -\n        (this.context.gl.canvas as HTMLCanvasElement).getBoundingClientRect().top,\n    ];\n  }\n\n  getMapCoords(screenCoords: Position): Position {\n    // @ts-ignore\n    return this.context.viewport.unproject([screenCoords[0], screenCoords[1]]);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}