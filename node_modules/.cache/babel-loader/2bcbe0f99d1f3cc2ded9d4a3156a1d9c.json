{"ast":null,"code":"import { earcut } from '@math.gl/polygon';\nexport function flatGeojsonToBinary(features, geometryInfo, options) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter(k => propArrayTypes[k] !== Array);\n  return fillArrays(features, {\n    propArrayTypes,\n    ...geometryInfo\n  }, {\n    numericPropKeys: options && options.numericPropKeys || numericPropKeys,\n    PositionDataType: options ? options.PositionDataType : Float32Array\n  });\n}\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n\nfunction extractNumericPropTypes(features) {\n  const propArrayTypes = {};\n\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\nfunction fillArrays(features, geometryInfo, options) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {\n    numericPropKeys = [],\n    PositionDataType = Float32Array\n  } = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines = {\n    type: 'LineString',\n    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons = {\n    type: 'Polygon',\n    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength);\n    }\n  }\n\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          points.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.pointFeature++;\n        break;\n\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          lines.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.lineFeature++;\n        break;\n\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n\n        if (hasGlobalId) {\n          polygons.fields.push({\n            id: feature.id\n          });\n        }\n\n        indexMap.polygonFeature++;\n        break;\n\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\nfunction handlePoint(geometry, points, indexMap, coordLength, properties) {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);\n  indexMap.pointPosition += nPositions;\n}\n\nfunction handleLineString(geometry, lines, indexMap, coordLength, properties) {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);\n  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);\n\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    const start = geometry.indices[i];\n    const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\nfunction handlePolygon(geometry, polygons, indexMap, coordLength, properties) {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);\n\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end = i === il - 1 ? nextIndices === undefined ? geometry.data.length : nextIndices[0] : indices[i + 1];\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {\n      startPosition,\n      endPosition,\n      coordLength\n    });\n  }\n}\n\nfunction triangulatePolygon(polygons, areas, indices, _ref) {\n  let {\n    startPosition,\n    endPosition,\n    coordLength\n  } = _ref;\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n  const polygonPositions = polygons.positions.subarray(start, end);\n  const offset = indices[0];\n  const holes = indices.slice(1).map(n => (n - offset) / coordLength);\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\nfunction wrapProps(obj, size) {\n  const returnObj = {};\n\n  for (const key in obj) {\n    returnObj[key] = {\n      value: obj[key],\n      size\n    };\n  }\n\n  return returnObj;\n}\n\nfunction makeAccessorObjects(points, lines, polygons, coordLength) {\n  return {\n    points: { ...points,\n      positions: {\n        value: points.positions,\n        size: coordLength\n      },\n      globalFeatureIds: {\n        value: points.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: points.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: { ...lines,\n      positions: {\n        value: lines.positions,\n        size: coordLength\n      },\n      pathIndices: {\n        value: lines.pathIndices,\n        size: 1\n      },\n      globalFeatureIds: {\n        value: lines.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: lines.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: { ...polygons,\n      positions: {\n        value: polygons.positions,\n        size: coordLength\n      },\n      polygonIndices: {\n        value: polygons.polygonIndices,\n        size: 1\n      },\n      primitivePolygonIndices: {\n        value: polygons.primitivePolygonIndices,\n        size: 1\n      },\n      triangles: {\n        value: new Uint32Array(polygons.triangles),\n        size: 1\n      },\n      globalFeatureIds: {\n        value: polygons.globalFeatureIds,\n        size: 1\n      },\n      featureIds: {\n        value: polygons.featureIds,\n        size: 1\n      },\n      numericProps: wrapProps(polygons.numericProps, 1)\n    }\n  };\n}\n\nfunction fillNumericProperties(object, properties, index, length) {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName];\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\nfunction keepStringProperties(properties, numericKeys) {\n  const props = {};\n\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n\n  return props;\n}\n\nfunction deduceArrayType(x, constructor) {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}","map":{"version":3,"mappings":"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","names":["earcut","flatGeojsonToBinary","features","geometryInfo","options","propArrayTypes","extractNumericPropTypes","numericPropKeys","Object","keys","filter","k","Array","fillArrays","PositionDataType","Float32Array","TEST_EXPORTS","feature","properties","key","val","deduceArrayType","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","coordLength","hasGlobalId","GlobalFeatureIdsDataType","length","Uint32Array","Uint16Array","points","type","positions","globalFeatureIds","featureIds","numericProps","fields","lines","pathIndices","polygons","polygonIndices","primitivePolygonIndices","triangles","object","propName","T","indexMap","pointPosition","pointFeature","linePosition","linePath","lineFeature","polygonPosition","polygonObject","polygonRing","polygonFeature","geometry","handlePoint","push","keepStringProperties","id","handleLineString","handlePolygon","Error","makeAccessorObjects","set","data","nPositions","fillNumericProperties","fill","i","il","indices","start","end","l","ll","startPosition","areas","nextIndices","undefined","endPosition","triangulatePolygon","polygonPositions","subarray","offset","holes","slice","map","n","t","tl","wrapProps","obj","size","returnObj","value","index","numericPropName","numericKeys","props","includes","x","constructor","Number","isFinite","Float64Array","Math","fround"],"sources":["../../../src/lib/flat-geojson-to-binary.ts"],"sourcesContent":["/* eslint-disable indent */\nimport {earcut} from '@math.gl/polygon';\nimport type {\n  BinaryAttribute,\n  BinaryFeatures,\n  FlatFeature,\n  FlatPoint,\n  FlatLineString,\n  FlatPolygon,\n  GeojsonGeometryInfo,\n  TypedArray\n} from '@loaders.gl/schema';\nimport {PropArrayConstructor, Lines, Points, Polygons} from './flat-geojson-to-binary-types';\n\n/**\n * Convert binary features to flat binary arrays. Similar to\n * `geojsonToBinary` helper function, except that it expects\n * a binary representation of the feature data, which enables\n * 2X-3X speed increase in parse speed, compared to using\n * geoJSON. See `binary-vector-tile/VectorTileFeature` for\n * data format detais\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns filled arrays\n */\nexport function flatGeojsonToBinary(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo,\n  options?: FlatGeojsonToBinaryOptions\n) {\n  const propArrayTypes = extractNumericPropTypes(features);\n  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);\n  return fillArrays(\n    features,\n    {\n      propArrayTypes,\n      ...geometryInfo\n    },\n    {\n      numericPropKeys: (options && options.numericPropKeys) || numericPropKeys,\n      PositionDataType: options ? options.PositionDataType : Float32Array\n    }\n  );\n}\n\n/**\n * Options for `flatGeojsonToBinary`\n */\nexport type FlatGeojsonToBinaryOptions = {\n  numericPropKeys?: string[];\n  PositionDataType?: Float32ArrayConstructor | Float64ArrayConstructor;\n};\n\nexport const TEST_EXPORTS = {\n  extractNumericPropTypes\n};\n\n/**\n * Extracts properties that are always numeric\n *\n * @param features\n * @returns object with numeric types\n */\nfunction extractNumericPropTypes(features: FlatFeature[]): {\n  [key: string]: PropArrayConstructor;\n} {\n  const propArrayTypes = {};\n  for (const feature of features) {\n    if (feature.properties) {\n      for (const key in feature.properties) {\n        // If property has not been seen before, or if property has been numeric\n        // in all previous features, check if numeric in this feature\n        // If not numeric, Array is stored to prevent rechecking in the future\n        // Additionally, detects if 64 bit precision is required\n        const val = feature.properties[key];\n        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);\n      }\n    }\n  }\n\n  return propArrayTypes;\n}\n\n/**\n * Fills coordinates into pre-allocated typed arrays\n *\n * @param features\n * @param geometryInfo\n * @param options\n * @returns an accessor object with value and size keys\n */\n// eslint-disable-next-line complexity\nfunction fillArrays(\n  features: FlatFeature[],\n  geometryInfo: GeojsonGeometryInfo & {\n    propArrayTypes: {[key: string]: PropArrayConstructor};\n  },\n  options: FlatGeojsonToBinaryOptions\n) {\n  const {\n    pointPositionsCount,\n    pointFeaturesCount,\n    linePositionsCount,\n    linePathsCount,\n    lineFeaturesCount,\n    polygonPositionsCount,\n    polygonObjectsCount,\n    polygonRingsCount,\n    polygonFeaturesCount,\n    propArrayTypes,\n    coordLength\n  } = geometryInfo;\n  const {numericPropKeys = [], PositionDataType = Float32Array} = options;\n  const hasGlobalId = features[0] && 'id' in features[0];\n  const GlobalFeatureIdsDataType = features.length > 65535 ? Uint32Array : Uint16Array;\n  const points: Points = {\n    type: 'Point',\n    positions: new PositionDataType(pointPositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),\n    featureIds:\n      pointFeaturesCount > 65535\n        ? new Uint32Array(pointPositionsCount)\n        : new Uint16Array(pointPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const lines: Lines = {\n    type: 'LineString',\n    pathIndices:\n      linePositionsCount > 65535\n        ? new Uint32Array(linePathsCount + 1)\n        : new Uint16Array(linePathsCount + 1),\n    positions: new PositionDataType(linePositionsCount * coordLength),\n    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),\n    featureIds:\n      lineFeaturesCount > 65535\n        ? new Uint32Array(linePositionsCount)\n        : new Uint16Array(linePositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n  const polygons: Polygons = {\n    type: 'Polygon',\n    polygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonObjectsCount + 1)\n        : new Uint16Array(polygonObjectsCount + 1),\n    primitivePolygonIndices:\n      polygonPositionsCount > 65535\n        ? new Uint32Array(polygonRingsCount + 1)\n        : new Uint16Array(polygonRingsCount + 1),\n    positions: new PositionDataType(polygonPositionsCount * coordLength),\n    triangles: [],\n    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),\n    featureIds:\n      polygonFeaturesCount > 65535\n        ? new Uint32Array(polygonPositionsCount)\n        : new Uint16Array(polygonPositionsCount),\n    numericProps: {},\n    properties: [],\n    fields: []\n  };\n\n  // Instantiate numeric properties arrays; one value per vertex\n  for (const object of [points, lines, polygons]) {\n    for (const propName of numericPropKeys) {\n      // If property has been numeric in all previous features in which the property existed, check\n      // if numeric in this feature\n      const T = propArrayTypes[propName];\n      object.numericProps[propName] = new T(object.positions.length / coordLength) as TypedArray;\n    }\n  }\n\n  // Set last element of path/polygon indices as positions length\n  lines.pathIndices[linePathsCount] = linePositionsCount;\n  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;\n  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;\n\n  const indexMap = {\n    pointPosition: 0,\n    pointFeature: 0,\n    linePosition: 0,\n    linePath: 0,\n    lineFeature: 0,\n    polygonPosition: 0,\n    polygonObject: 0,\n    polygonRing: 0,\n    polygonFeature: 0,\n    feature: 0\n  };\n\n  for (const feature of features) {\n    const geometry = feature.geometry;\n    const properties = feature.properties || {};\n\n    switch (geometry.type) {\n      case 'Point':\n        handlePoint(geometry, points, indexMap, coordLength, properties);\n        points.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          points.fields.push({id: feature.id});\n        }\n        indexMap.pointFeature++;\n        break;\n      case 'LineString':\n        handleLineString(geometry, lines, indexMap, coordLength, properties);\n        lines.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          lines.fields.push({id: feature.id});\n        }\n        indexMap.lineFeature++;\n        break;\n      case 'Polygon':\n        handlePolygon(geometry, polygons, indexMap, coordLength, properties);\n        polygons.properties.push(keepStringProperties(properties, numericPropKeys));\n        if (hasGlobalId) {\n          polygons.fields.push({id: feature.id});\n        }\n        indexMap.polygonFeature++;\n        break;\n      default:\n        throw new Error('Invalid geometry type');\n    }\n\n    indexMap.feature++;\n  }\n\n  // Wrap each array in an accessor object with value and size keys\n  return makeAccessorObjects(points, lines, polygons, coordLength);\n}\n\n/**\n * Fills (Multi)Point coordinates into points object of arrays\n *\n * @param geometry\n * @param points\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePoint(\n  geometry: FlatPoint,\n  points: Points,\n  indexMap: {\n    pointPosition: number;\n    pointFeature: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);\n  points.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n  points.featureIds.fill(\n    indexMap.pointFeature,\n    indexMap.pointPosition,\n    indexMap.pointPosition + nPositions\n  );\n\n  indexMap.pointPosition += nPositions;\n}\n\n/**\n * Fills (Multi)LineString coordinates into lines object of arrays\n *\n * @param geometry\n * @param lines\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handleLineString(\n  geometry: FlatLineString,\n  lines: Lines,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition: number;\n    linePath: number;\n    lineFeature: number;\n    polygonPosition?: number;\n    polygonObject?: number;\n    polygonRing?: number;\n    polygonFeature?: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);\n\n  lines.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n  lines.featureIds.fill(\n    indexMap.lineFeature,\n    indexMap.linePosition,\n    indexMap.linePosition + nPositions\n  );\n\n  for (let i = 0, il = geometry.indices.length; i < il; ++i) {\n    // Extract range of data we are working with, defined by start\n    // and end indices (these index into the geometry.data array)\n    const start = geometry.indices[i];\n    const end =\n      i === il - 1\n        ? geometry.data.length // last line, so read to end of data\n        : geometry.indices[i + 1]; // start index for next line\n\n    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;\n    indexMap.linePosition += (end - start) / coordLength;\n  }\n}\n\n/**\n * Fills (Multi)Polygon coordinates into polygons object of arrays\n *\n * @param geometry\n * @param polygons\n * @param indexMap\n * @param coordLength\n * @param properties\n */\nfunction handlePolygon(\n  geometry: FlatPolygon,\n  polygons: Polygons,\n  indexMap: {\n    pointPosition?: number;\n    pointFeature?: number;\n    linePosition?: number;\n    linePath?: number;\n    lineFeature?: number;\n    polygonPosition: number;\n    polygonObject: number;\n    polygonRing: number;\n    polygonFeature: number;\n    feature: number;\n  },\n  coordLength: number,\n  properties: {[x: string]: string | number | boolean | null}\n): void {\n  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);\n\n  const nPositions = geometry.data.length / coordLength;\n  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);\n  polygons.globalFeatureIds.fill(\n    indexMap.feature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n  polygons.featureIds.fill(\n    indexMap.polygonFeature,\n    indexMap.polygonPosition,\n    indexMap.polygonPosition + nPositions\n  );\n\n  // Unlike Point & LineString geometry.indices is a 2D array\n  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {\n    const startPosition = indexMap.polygonPosition;\n    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;\n\n    const areas = geometry.areas[l];\n    const indices = geometry.indices[l];\n    const nextIndices = geometry.indices[l + 1];\n\n    for (let i = 0, il = indices.length; i < il; ++i) {\n      const start = indices[i];\n      const end =\n        i === il - 1\n          ? // last line, so either read to:\n            nextIndices === undefined\n            ? geometry.data.length // end of data (no next indices)\n            : nextIndices[0] // start of first line in nextIndices\n          : indices[i + 1]; // start index for next line\n\n      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;\n      indexMap.polygonPosition += (end - start) / coordLength;\n    }\n\n    const endPosition = indexMap.polygonPosition;\n    triangulatePolygon(polygons, areas, indices, {startPosition, endPosition, coordLength});\n  }\n}\n\n/**\n * Triangulate polygon using earcut\n *\n * @param polygons\n * @param areas\n * @param indices\n * @param param3\n */\nfunction triangulatePolygon(\n  polygons: Polygons,\n  areas: number[],\n  indices: number[],\n  {\n    startPosition,\n    endPosition,\n    coordLength\n  }: {startPosition: number; endPosition: number; coordLength: number}\n): void {\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const offset = indices[0];\n  const holes = indices.slice(1).map((n: number) => (n - offset) / coordLength);\n\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength, areas);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    polygons.triangles.push(startPosition + triangles[t]);\n  }\n}\n\n/**\n * Wraps an object containing array into accessors\n *\n * @param obj\n * @param size\n */\nfunction wrapProps(\n  obj: {[key: string]: TypedArray},\n  size: number\n): {[key: string]: BinaryAttribute} {\n  const returnObj = {};\n  for (const key in obj) {\n    returnObj[key] = {value: obj[key], size};\n  }\n  return returnObj;\n}\n\n/**\n * Wrap each array in an accessor object with value and size keys\n *\n * @param points\n * @param lines\n * @param polygons\n * @param coordLength\n * @returns object\n */\nfunction makeAccessorObjects(\n  points: Points,\n  lines: Lines,\n  polygons: Polygons,\n  coordLength: number\n): BinaryFeatures {\n  return {\n    points: {\n      ...points,\n      positions: {value: points.positions, size: coordLength},\n      globalFeatureIds: {value: points.globalFeatureIds, size: 1},\n      featureIds: {value: points.featureIds, size: 1},\n      numericProps: wrapProps(points.numericProps, 1)\n    },\n    lines: {\n      ...lines,\n      positions: {value: lines.positions, size: coordLength},\n      pathIndices: {value: lines.pathIndices, size: 1},\n      globalFeatureIds: {value: lines.globalFeatureIds, size: 1},\n      featureIds: {value: lines.featureIds, size: 1},\n      numericProps: wrapProps(lines.numericProps, 1)\n    },\n    polygons: {\n      ...polygons,\n      positions: {value: polygons.positions, size: coordLength},\n      polygonIndices: {value: polygons.polygonIndices, size: 1},\n      primitivePolygonIndices: {value: polygons.primitivePolygonIndices, size: 1},\n      triangles: {value: new Uint32Array(polygons.triangles), size: 1},\n      globalFeatureIds: {value: polygons.globalFeatureIds, size: 1},\n      featureIds: {value: polygons.featureIds, size: 1},\n      numericProps: wrapProps(polygons.numericProps, 1)\n    }\n  };\n}\n\n/**\n * Add numeric properties to object\n *\n * @param object\n * @param properties\n * @param index\n * @param length\n */\nfunction fillNumericProperties(\n  object: Points | Lines | Polygons,\n  properties: {[x: string]: string | number | boolean | null},\n  index: number,\n  length: number\n): void {\n  for (const numericPropName in object.numericProps) {\n    if (numericPropName in properties) {\n      const value = properties[numericPropName] as number;\n      object.numericProps[numericPropName].fill(value, index, index + length);\n    }\n  }\n}\n\n/**\n * Keep string properties in object\n *\n * @param properties\n * @param numericKeys\n * @returns object\n */\nfunction keepStringProperties(\n  properties: {[x: string]: string | number | boolean | null},\n  numericKeys: string[]\n) {\n  const props = {};\n  for (const key in properties) {\n    if (!numericKeys.includes(key)) {\n      props[key] = properties[key];\n    }\n  }\n  return props;\n}\n\n/**\n *\n * Deduce correct array constructor to use for a given value\n *\n * @param x value to test\n * @param constructor previous constructor deduced\n * @returns PropArrayConstructor\n */\nfunction deduceArrayType(x: any, constructor: PropArrayConstructor): PropArrayConstructor {\n  if (constructor === Array || !Number.isFinite(x)) {\n    return Array;\n  }\n\n  // If this or previous value required 64bits use Float64Array\n  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;\n}\n"]},"metadata":{},"sourceType":"module"}