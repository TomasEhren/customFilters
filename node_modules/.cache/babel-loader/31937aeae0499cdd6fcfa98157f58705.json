{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { createIterable, getAccessorFromBuffer } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\nimport { Buffer } from '@luma.gl/core';\n\nvar Tesselator = /*#__PURE__*/function () {\n  function Tesselator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Tesselator);\n\n    var _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      Object.assign(this.opts, opts);\n      var _this$opts = this.opts,\n          data = _this$opts.data,\n          _this$opts$buffers = _this$opts.buffers,\n          buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers,\n          getGeometry = _this$opts.getGeometry,\n          geometryBuffer = _this$opts.geometryBuffer,\n          positionFormat = _this$opts.positionFormat,\n          dataChanged = _this$opts.dataChanged,\n          _this$opts$normalize = _this$opts.normalize,\n          normalize = _this$opts$normalize === void 0 ? true : _this$opts$normalize;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);\n      this.buffers = buffers;\n      this.normalize = normalize;\n\n      if (geometryBuffer) {\n        assert(data.startIndices);\n        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n        if (!normalize) {\n          buffers.positions = geometryBuffer;\n        }\n      }\n\n      this.geometryBuffer = buffers.positions;\n\n      if (Array.isArray(dataChanged)) {\n        var _iterator = _createForOfIteratorHelper(dataChanged),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var dataRange = _step.value;\n\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref) {\n      var startRow = _ref.startRow,\n          endRow = _ref.endRow;\n\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(geometryBuffer) {\n      var value = geometryBuffer.value || geometryBuffer;\n      assert(ArrayBuffer.isView(value));\n      return getAccessorFromBuffer(value, {\n        size: this.positionSize,\n        offset: geometryBuffer.offset,\n        stride: geometryBuffer.stride,\n        startIndices: this.data.startIndices\n      });\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(instanceCount, copy) {\n      var attributes = this.attributes,\n          buffers = this.buffers,\n          _attributeDefs = this._attributeDefs,\n          typedArrayManager = this.typedArrayManager;\n\n      for (var name in _attributeDefs) {\n        if (name in buffers) {\n          typedArrayManager.release(attributes[name]);\n          attributes[name] = null;\n        } else {\n          var def = _attributeDefs[name];\n          def.copy = copy;\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n          getGeometry = this.getGeometry;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iterator2 = _createForOfIteratorHelper(iterable),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n\n      var indexStarts = this.indexStarts,\n          vertexStarts = this.vertexStarts,\n          instanceCount = this.instanceCount;\n      var data = this.data,\n          geometryBuffer = this.geometryBuffer;\n\n      var _ref2 = dataRange || {},\n          _ref2$startRow = _ref2.startRow,\n          startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow,\n          _ref2$endRow = _ref2.endRow,\n          endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;\n\n      var normalizedData = {};\n\n      if (!dataRange) {\n        indexStarts = [0];\n        vertexStarts = [0];\n      }\n\n      if (this.normalize || !geometryBuffer) {\n        this._forEachGeometry(function (geometry, dataIndex) {\n          geometry = _this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);\n        }, startRow, endRow);\n\n        instanceCount = vertexStarts[vertexStarts.length - 1];\n      } else if (geometryBuffer.buffer instanceof Buffer) {\n        var byteStride = geometryBuffer.stride || this.positionSize * 4;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n      } else {\n        var bufferValue = geometryBuffer.value || geometryBuffer;\n        var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n        vertexStarts = data.startIndices;\n        instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n      }\n\n      this._allocate(instanceCount, Boolean(dataRange));\n\n      this.indexStarts = indexStarts;\n      this.vertexStarts = vertexStarts;\n      this.instanceCount = instanceCount;\n      var context = {};\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n\n        _this.updateGeometryAttributes(geometry, context);\n      }, startRow, endRow);\n\n      this.vertexCount = indexStarts[indexStarts.length - 1];\n    }\n  }]);\n\n  return Tesselator;\n}();\n\nexport { Tesselator as default };","map":{"version":3,"mappings":"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","names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","normalizeGeometry","geometry","updateGeometryAttributes","startIndex","Error","getGeometrySize","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","dataIndex","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex"],"sources":["../../../src/utils/tesselator.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices); // binary data missing startIndices\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value)); // invalid binary geometries\n\n    // @ts-expect-error\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}