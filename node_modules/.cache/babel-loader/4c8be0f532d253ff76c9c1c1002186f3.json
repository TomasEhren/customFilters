{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { CullingVolume, Plane } from '@math.gl/culling';\nimport { Ellipsoid } from '@math.gl/geospatial';\nvar scratchVector = new Vector3();\nvar scratchPosition = new Vector3();\nvar cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\nexport function getFrameState(viewport, frameNumber) {\n  var cameraDirection = viewport.cameraDirection,\n      cameraUp = viewport.cameraUp,\n      height = viewport.height;\n  var metersPerUnit = viewport.distanceScales.metersPerUnit;\n  var viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  var viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(viewportCenterCartographic, new Vector3());\n  var enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n  var cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  var cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  var cameraDirectionCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))).normalize();\n  var cameraUpCartesian = new Vector3(enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))).normalize();\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport: viewport,\n    height: height,\n    cullingVolume: cullingVolume,\n    frameNumber: frameNumber,\n    sseDenominator: 1.15\n  };\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  var frustumPlanes = viewport.getFrustumPlanes();\n  var i = 0;\n\n  for (var dir in frustumPlanes) {\n    var plane = frustumPlanes[dir];\n    var distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition.copy(plane.normal).scale(plane.distance - distanceToCenter).add(viewport.center);\n    var cartographicPos = viewport.unprojectPosition(scratchPosition);\n    var cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n    cullingVolume.planes[i++].fromPointNormal(cartesianPos, scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos));\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","CullingVolume","Plane","Ellipsoid","scratchVector","scratchPosition","cullingVolume","getFrameState","viewport","frameNumber","cameraDirection","cameraUp","height","metersPerUnit","distanceScales","viewportCenterCartographic","unprojectPosition","center","viewportCenterCartesian","WGS84","cartographicToCartesian","enuToFixedTransform","eastNorthUpToFixedFrame","cameraPositionCartographic","cameraPosition","cameraPositionCartesian","cameraDirectionCartesian","transformAsVector","scale","normalize","cameraUpCartesian","commonSpacePlanesToWGS84","camera","position","direction","up","sseDenominator","frustumPlanes","getFrustumPlanes","i","dir","plane","distanceToCenter","normal","dot","copy","distance","add","cartographicPos","cartesianPos","planes","fromPointNormal","subtract"],"sources":["../../../../src/tileset/helpers/frame-state.ts"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: {[key: string]: any};\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  const viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    viewportCenterCartographic,\n    new Vector3()\n  );\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n  let i = 0;\n  for (const dir in frustumPlanes) {\n    const plane = frustumPlanes[dir];\n    const distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition\n      .copy(plane.normal)\n      .scale(plane.distance - distanceToCenter)\n      .add(viewport.center);\n    const cartographicPos = viewport.unprojectPosition(scratchPosition);\n\n    const cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}