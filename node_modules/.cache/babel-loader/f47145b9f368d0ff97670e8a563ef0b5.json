{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\nvar requestId = 0;\nvar inputBatches;\nvar options;\nexport function createWorker(process, processInBatches) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  var context = {\n    process: processOnMainThread\n  };\n\n  WorkerBody.onmessage = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, payload) {\n      var result, resultIterator, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, batch, message;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.t0 = type;\n              _context.next = _context.t0 === 'process' ? 4 : _context.t0 === 'process-in-batches' ? 11 : _context.t0 === 'input-batch' ? 46 : _context.t0 === 'input-done' ? 48 : 50;\n              break;\n\n            case 4:\n              if (process) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('Worker does not support atomic processing');\n\n            case 6:\n              _context.next = 8;\n              return process(payload.input, payload.options || {}, context);\n\n            case 8:\n              result = _context.sent;\n              WorkerBody.postMessage('done', {\n                result: result\n              });\n              return _context.abrupt(\"break\", 50);\n\n            case 11:\n              if (processInBatches) {\n                _context.next = 13;\n                break;\n              }\n\n              throw new Error('Worker does not support batched processing');\n\n            case 13:\n              inputBatches = new AsyncQueue();\n              options = payload.options || {};\n              resultIterator = processInBatches(inputBatches, options, context);\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context.prev = 18;\n              _iterator = _asyncIterator(resultIterator);\n\n            case 20:\n              _context.next = 22;\n              return _iterator.next();\n\n            case 22:\n              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n                _context.next = 28;\n                break;\n              }\n\n              batch = _step.value;\n              WorkerBody.postMessage('output-batch', {\n                result: batch\n              });\n\n            case 25:\n              _iteratorAbruptCompletion = false;\n              _context.next = 20;\n              break;\n\n            case 28:\n              _context.next = 34;\n              break;\n\n            case 30:\n              _context.prev = 30;\n              _context.t1 = _context[\"catch\"](18);\n              _didIteratorError = true;\n              _iteratorError = _context.t1;\n\n            case 34:\n              _context.prev = 34;\n              _context.prev = 35;\n\n              if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n                _context.next = 39;\n                break;\n              }\n\n              _context.next = 39;\n              return _iterator.return();\n\n            case 39:\n              _context.prev = 39;\n\n              if (!_didIteratorError) {\n                _context.next = 42;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 42:\n              return _context.finish(39);\n\n            case 43:\n              return _context.finish(34);\n\n            case 44:\n              WorkerBody.postMessage('done', {});\n              return _context.abrupt(\"break\", 50);\n\n            case 46:\n              inputBatches.push(payload.input);\n              return _context.abrupt(\"break\", 50);\n\n            case 48:\n              inputBatches.close();\n              return _context.abrupt(\"break\", 50);\n\n            case 50:\n              _context.next = 56;\n              break;\n\n            case 52:\n              _context.prev = 52;\n              _context.t2 = _context[\"catch\"](0);\n              message = _context.t2 instanceof Error ? _context.t2.message : '';\n              WorkerBody.postMessage('error', {\n                error: message\n              });\n\n            case 56:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 52], [18, 30, 34, 44], [35,, 39, 43]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction processOnMainThread(arrayBuffer) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (resolve, reject) {\n    var id = requestId++;\n\n    var onMessage = function onMessage(type, payload) {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    var payload = {\n      id: id,\n      input: arrayBuffer,\n      options: options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}","map":{"version":3,"mappings":";;;AAOA,OAAOA,UAAP,MAAuB,4BAAvB;AACA,OAAOC,UAAP,MAAuB,4BAAvB;AAIA,IAAIC,SAAS,GAAG,CAAhB;AACA,IAAIC,YAAJ;AACA,IAAIC,OAAJ;AAWA,OAAO,SAASC,YAAT,CAAsBC,OAAtB,EAAwCC,gBAAxC,EAAmF;EAExF,IAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;IAC/B;EACD;;EAED,IAAMC,OAAsB,GAAG;IAC7BH,OAAO,EAAEI;EADoB,CAA/B;;EAKAT,UAAU,CAACU,SAAXV;IAAAA,oEAAuB,iBAAOW,IAAP,EAAgCC,OAAhC;MAAA;;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA,cAEXD,IAFW;cAAA,gCAGZ,SAHY,uBAWZ,oBAXY,wBAwBZ,aAxBY,wBA4BZ,YA5BY;cAAA;;YAAA;cAAA,IAIVN,OAJU;gBAAA;gBAAA;cAAA;;cAAA,MAKP,IAAIQ,KAAJ,CAAU,2CAAV,CALO;;YAAA;cAAA;cAAA,OAOMR,OAAO,CAACO,OAAO,CAACE,KAAT,EAAgBF,OAAO,CAACT,OAARS,IAAmB,EAAnC,EAAuCJ,OAAvC,CAPb;;YAAA;cAOTO,MAPS;cAQff,UAAU,CAACgB,WAAXhB,CAAuB,MAAvBA,EAA+B;gBAACe;cAAD,CAA/Bf;cARe;;YAAA;cAAA,IAYVM,gBAZU;gBAAA;gBAAA;cAAA;;cAAA,MAaP,IAAIO,KAAJ,CAAU,4CAAV,CAbO;;YAAA;cAefX,YAAY,GAAG,IAAIH,UAAJ,EAAfG;cACAC,OAAO,GAAGS,OAAO,CAACT,OAARS,IAAmB,EAA7BT;cACMc,cAjBS,GAiBQX,gBAAgB,CAACJ,YAAD,EAAeC,OAAf,EAAwBK,OAAxB,CAjBxB;cAAA;cAAA;cAAA;cAAA,2BAkBWS,cAlBX;;YAAA;cAAA;cAAA;;YAAA;cAAA;gBAAA;gBAAA;cAAA;;cAkBEC,KAlBF;cAmBblB,UAAU,CAACgB,WAAXhB,CAAuB,cAAvBA,EAAuC;gBAACe,MAAM,EAAEG;cAAT,CAAvClB;;YAnBa;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;cAAA;;YAAA;cAAA;;cAAA;gBAAA;gBAAA;cAAA;;cAAA;;YAAA;cAAA;;YAAA;cAAA;;YAAA;cAqBfA,UAAU,CAACgB,WAAXhB,CAAuB,MAAvBA,EAA+B,EAA/BA;cArBe;;YAAA;cAyBfE,YAAY,CAACiB,IAAbjB,CAAkBU,OAAO,CAACE,KAA1BZ;cAzBe;;YAAA;cA6BfA,YAAY,CAACkB,KAAblB;cA7Be;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;cAmCbmB,OAnCa,GAmCHC,uBAAiBT,KAAjBS,GAAyBA,YAAMD,OAA/BC,GAAyC,EAnCtC;cAoCnBtB,UAAU,CAACgB,WAAXhB,CAAuB,OAAvBA,EAAgC;gBAACsB,KAAK,EAAED;cAAR,CAAhCrB;;YApCmB;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAvBA;;IAAAA;MAAAA;IAAAA;EAAAA;AAuCD;;AAED,SAASS,mBAAT,CAA6Bc,WAA7B,EAAqE;EAAA,IAAdpB,OAAc,uEAAJ,EAAI;EACnE,OAAO,IAAIqB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;IACtC,IAAMC,EAAE,GAAG1B,SAAS,EAApB;;IAIA,IAAM2B,SAAS,GAAG,SAAZA,SAAY,CAACjB,IAAD,EAAeC,OAAf,EAAiD;MACjE,IAAIA,OAAO,CAACe,EAARf,KAAee,EAAnB,EAAuB;QAErB;MACD;;MAED,QAAQhB,IAAR;QACE,KAAK,MAAL;UACEX,UAAU,CAAC6B,mBAAX7B,CAA+B4B,SAA/B5B;UACAyB,OAAO,CAACb,OAAO,CAACG,MAAT,CAAPU;UACA;;QAEF,KAAK,OAAL;UACEzB,UAAU,CAAC6B,mBAAX7B,CAA+B4B,SAA/B5B;UACA0B,MAAM,CAACd,OAAO,CAACU,KAAT,CAANI;UACA;;QAEF;MAXF;IANF;;IAsBA1B,UAAU,CAAC8B,gBAAX9B,CAA4B4B,SAA5B5B;IAGA,IAAMY,OAAO,GAAG;MAACe,EAAD,EAACA,EAAD;MAAKb,KAAK,EAAES,WAAZ;MAAyBpB;IAAzB,CAAhB;IACAH,UAAU,CAACgB,WAAXhB,CAAuB,SAAvBA,EAAkCY,OAAlCZ;EA/BK,EAAP;AAiCD","names":["AsyncQueue","WorkerBody","requestId","inputBatches","options","createWorker","process","processInBatches","self","context","processOnMainThread","onmessage","type","payload","Error","input","result","postMessage","resultIterator","batch","push","close","message","error","arrayBuffer","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener"],"sources":["../../../../src/lib/worker-api/create-worker.ts"],"sourcesContent":["import type {\n  WorkerMessageType,\n  WorkerMessagePayload,\n  WorkerContext,\n  Process,\n  ProcessInBatches\n} from '../../types';\nimport AsyncQueue from '../async-queue/async-queue';\nimport WorkerBody from '../worker-farm/worker-body';\n// import {validateWorkerVersion} from './validate-worker-version';\n\n/** Counter for jobs */\nlet requestId = 0;\nlet inputBatches: AsyncQueue<any>;\nlet options: {[key: string]: any};\n\nexport type ProcessOnMainThread = (\n  data: any,\n  options?: {[key: string]: any},\n  context?: WorkerContext\n) => any;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n */\nexport function createWorker(process: Process, processInBatches?: ProcessInBatches): void {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  const context: WorkerContext = {\n    process: processOnMainThread\n  };\n\n  // eslint-disable-next-line complexity\n  WorkerBody.onmessage = async (type: WorkerMessageType, payload: WorkerMessagePayload) => {\n    try {\n      switch (type) {\n        case 'process':\n          if (!process) {\n            throw new Error('Worker does not support atomic processing');\n          }\n          const result = await process(payload.input, payload.options || {}, context);\n          WorkerBody.postMessage('done', {result});\n          break;\n\n        case 'process-in-batches':\n          if (!processInBatches) {\n            throw new Error('Worker does not support batched processing');\n          }\n          inputBatches = new AsyncQueue<any>();\n          options = payload.options || {};\n          const resultIterator = processInBatches(inputBatches, options, context);\n          for await (const batch of resultIterator) {\n            WorkerBody.postMessage('output-batch', {result: batch});\n          }\n          WorkerBody.postMessage('done', {});\n          break;\n\n        case 'input-batch':\n          inputBatches.push(payload.input);\n          break;\n\n        case 'input-done':\n          inputBatches.close();\n          break;\n\n        default:\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : '';\n      WorkerBody.postMessage('error', {error: message});\n    }\n  };\n}\n\nfunction processOnMainThread(arrayBuffer: ArrayBuffer, options = {}) {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type: string, payload: WorkerMessagePayload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}