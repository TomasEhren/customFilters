{"ast":null,"code":"export function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: { ...data.properties[propertiesIndex]\n    }\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}","map":{"version":3,"mappings":"AAUA,OAAO,SAASA,yBAAT,CAAmCC,IAAnC,EAAyCC,KAAzC,EAAgD;EACrD,IAAI,CAACD,IAAL,EAAW;IACT,OAAO,IAAP;EACD;;EAED,MAAME,YAAY,GAAG,kBAAkBF,IAAlB,GAAyBA,IAAI,CAACG,YAALH,CAAkBC,KAAlBD,CAAzB,GAAoDC,KAAzE;EACA,MAAMG,aAAa,GAAGJ,IAAI,CAACK,UAALL,CAAgBM,KAAhBN,CAAsBE,YAAtBF,CAAtB;;EAEA,IAAIE,YAAY,KAAK,CAAC,CAAtB,EAAyB;IACvB,OAAOK,qBAAqB,CAACP,IAAD,EAAOI,aAAP,EAAsBF,YAAtB,CAA5B;EACD;;EAED,OAAO,IAAP;AACD;;AAED,SAASK,qBAAT,CAA+BP,IAA/B,EAAqCQ,eAArC,EAAsDC,iBAAtD,EAAyE;EACvE,MAAMC,OAAO,GAAG;IACdC,UAAU,EAAE,EAAC,GAAGX,IAAI,CAACW,UAALX,CAAgBQ,eAAhBR;IAAJ;EADE,CAAhB;;EAIA,KAAK,MAAMY,IAAX,IAAmBZ,IAAI,CAACa,YAAxB,EAAsC;IACpCH,OAAO,CAACC,UAARD,CAAmBE,IAAnBF,IAA2BV,IAAI,CAACa,YAALb,CAAkBY,IAAlBZ,EAAwBM,KAAxBN,CAA8BS,iBAA9BT,CAA3BU;EACD;;EAED,OAAOA,OAAP;AACD;;AAGD,OAAO,SAASI,sBAAT,CAAgCC,aAAhC,EAA+CC,kBAA/C,EAAmE;EACxE,MAAMC,aAAa,GAAG;IACpBC,MAAM,EAAE,IADY;IAEpBC,KAAK,EAAE,IAFa;IAGpBC,QAAQ,EAAE;EAHU,CAAtB;;EAKA,KAAK,MAAMC,GAAX,IAAkBJ,aAAlB,EAAiC;IAC/B,MAAMZ,UAAU,GAAGU,aAAa,CAACM,GAAD,CAAbN,CAAmBO,gBAAnBP,CAAoCT,KAAvD;IACAW,aAAa,CAACI,GAAD,CAAbJ,GAAqB,IAAIM,iBAAJ,CAAsBlB,UAAU,CAACmB,MAAXnB,GAAoB,CAA1C,CAArBY;IACA,MAAMQ,YAAY,GAAG,EAArB;;IACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,UAAU,CAACmB,MAA/B,EAAuCE,CAAC,EAAxC,EAA4C;MAC1CV,kBAAkB,CAACX,UAAU,CAACqB,CAAD,CAAX,EAAgBD,YAAhB,CAAlBT;MACAC,aAAa,CAACI,GAAD,CAAbJ,CAAmBS,CAAC,GAAG,CAAJA,GAAQ,CAA3BT,IAAgCQ,YAAY,CAAC,CAAD,CAA5CR;MACAA,aAAa,CAACI,GAAD,CAAbJ,CAAmBS,CAAC,GAAG,CAAJA,GAAQ,CAA3BT,IAAgCQ,YAAY,CAAC,CAAD,CAA5CR;MACAA,aAAa,CAACI,GAAD,CAAbJ,CAAmBS,CAAC,GAAG,CAAJA,GAAQ,CAA3BT,IAAgCQ,YAAY,CAAC,CAAD,CAA5CR;IACD;EACF;;EAED,OAAOA,aAAP;AACD","names":["binaryToFeatureForAccesor","data","index","featureIndex","startIndices","geometryIndex","featureIds","value","getPropertiesForIndex","propertiesIndex","numericPropsIndex","feature","properties","prop","numericProps","calculatePickingColors","geojsonBinary","encodePickingColor","pickingColors","points","lines","polygons","key","globalFeatureIds","Uint8ClampedArray","length","pickingColor","i"],"sources":["../../../src/geojson-layer/geojson-binary.js"],"sourcesContent":["// This module implement some utility functions to work with\n// the geojson-binary format defined at loaders.gl:\n// https://github.com/visgl/loaders.gl/blob/master/modules/gis/docs/api-reference/geojson-to-binary.md\n\n/**\n * Return the feature for an accesor\n *\n * @param {Object} data - The data in binary format\n * @param {Number} index - The requested index\n */\nexport function binaryToFeatureForAccesor(data, index) {\n  if (!data) {\n    return null;\n  }\n\n  const featureIndex = 'startIndices' in data ? data.startIndices[index] : index;\n  const geometryIndex = data.featureIds.value[featureIndex];\n\n  if (featureIndex !== -1) {\n    return getPropertiesForIndex(data, geometryIndex, featureIndex);\n  }\n\n  return null;\n}\n\nfunction getPropertiesForIndex(data, propertiesIndex, numericPropsIndex) {\n  const feature = {\n    properties: {...data.properties[propertiesIndex]}\n  };\n\n  for (const prop in data.numericProps) {\n    feature.properties[prop] = data.numericProps[prop].value[numericPropsIndex];\n  }\n\n  return feature;\n}\n\n// Custom picking color to keep binary indexes\nexport function calculatePickingColors(geojsonBinary, encodePickingColor) {\n  const pickingColors = {\n    points: null,\n    lines: null,\n    polygons: null\n  };\n  for (const key in pickingColors) {\n    const featureIds = geojsonBinary[key].globalFeatureIds.value;\n    pickingColors[key] = new Uint8ClampedArray(featureIds.length * 3);\n    const pickingColor = [];\n    for (let i = 0; i < featureIds.length; i++) {\n      encodePickingColor(featureIds[i], pickingColor);\n      pickingColors[key][i * 3 + 0] = pickingColor[0];\n      pickingColors[key][i * 3 + 1] = pickingColor[1];\n      pickingColors[key][i * 3 + 2] = pickingColor[2];\n    }\n  }\n\n  return pickingColors;\n}\n"]},"metadata":{},"sourceType":"module"}