{"ast":null,"code":"import * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\nexport const EXTENSIONS = [EXT_meshopt_compression, EXT_texture_webp, KHR_texture_basisu, KHR_draco_mesh_compression, KHR_lights_punctual, KHR_materials_unlit, KHR_techniques_webgl];\nexport function preprocessExtensions(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n\n  for (const extension of extensions) {\n    var _extension$preprocess;\n\n    (_extension$preprocess = extension.preprocess) === null || _extension$preprocess === void 0 ? void 0 : _extension$preprocess.call(extension, gltf, options, context);\n  }\n}\nexport async function decodeExtensions(gltf) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let context = arguments.length > 2 ? arguments[2] : undefined;\n  const extensions = EXTENSIONS.filter(extension => useExtension(extension.name, options));\n\n  for (const extension of extensions) {\n    var _extension$decode;\n\n    await ((_extension$decode = extension.decode) === null || _extension$decode === void 0 ? void 0 : _extension$decode.call(extension, gltf, options, context));\n  }\n}\n\nfunction useExtension(extensionName, options) {\n  var _options$gltf;\n\n  const excludes = (options === null || options === void 0 ? void 0 : (_options$gltf = options.gltf) === null || _options$gltf === void 0 ? void 0 : _options$gltf.excludeExtensions) || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}","map":{"version":3,"mappings":"AAQA,OAAO,KAAKA,uBAAZ,MAAyC,uCAAzC;AACA,OAAO,KAAKC,gBAAZ,MAAkC,gCAAlC;AACA,OAAO,KAAKC,kBAAZ,MAAoC,kCAApC;AACA,OAAO,KAAKC,0BAAZ,MAA4C,0CAA5C;AAGA,OAAO,KAAKC,mBAAZ,MAAqC,8CAArC;AACA,OAAO,KAAKC,mBAAZ,MAAqC,8CAArC;AACA,OAAO,KAAKC,oBAAZ,MAAsC,+CAAtC;AAgBA,OAAO,MAAMC,UAAiC,GAAG,CAM/CP,uBAN+C,EAO/CC,gBAP+C,EAS/CC,kBAT+C,EAU/CC,0BAV+C,EAW/CC,mBAX+C,EAY/CC,mBAZ+C,EAa/CC,oBAb+C,CAA1C;AAiBP,OAAO,SAASE,oBAAT,CAA8BC,IAA9B,EAA+E;EAAA,IAA3CC,OAA2C,uEAAd,EAAc;EAAA,IAAVC,OAAU;EACpF,MAAMC,UAAU,GAAGL,UAAU,CAACM,MAAXN,CAAmBO,SAAD,IAAeC,YAAY,CAACD,SAAS,CAACE,IAAX,EAAiBN,OAAjB,CAA7CH,CAAnB;;EACA,KAAK,MAAMO,SAAX,IAAwBF,UAAxB,EAAoC;IAAA;;IAClC,kCAAS,CAACK,UAAV,gGAAuBR,IAAvB,EAA6BC,OAA7B,EAAsCC,OAAtC;EACD;AACF;AAGD,OAAO,eAAeO,gBAAf,CAAgCT,IAAhC,EAAiF;EAAA,IAA3CC,OAA2C,uEAAd,EAAc;EAAA,IAAVC,OAAU;EACtF,MAAMC,UAAU,GAAGL,UAAU,CAACM,MAAXN,CAAmBO,SAAD,IAAeC,YAAY,CAACD,SAAS,CAACE,IAAX,EAAiBN,OAAjB,CAA7CH,CAAnB;;EACA,KAAK,MAAMO,SAAX,IAAwBF,UAAxB,EAAoC;IAAA;;IAGlC,4BAAME,SAAS,CAACK,MAAhB,sDAAMC,kCAAmBX,IAAnB,EAAyBC,OAAzB,EAAkCC,OAAlC,CAAN;EACD;AACF;;AAED,SAASI,YAAT,CAAsBM,aAAtB,EAA6CX,OAA7C,EAAyE;EAAA;;EACvE,MAAMY,QAAQ,GAAG,QAAO,SAAPZ,WAAO,WAAPA,oCAAO,CAAED,IAAT,gEAAec,iBAAf,KAAoC,EAArD;EACA,MAAMC,OAAO,GAAGH,aAAa,IAAIC,QAAjBD,IAA6B,CAACC,QAAQ,CAACD,aAAD,CAAtD;EACA,OAAO,CAACG,OAAR;AACD","names":["EXT_meshopt_compression","EXT_texture_webp","KHR_texture_basisu","KHR_draco_mesh_compression","KHR_lights_punctual","KHR_materials_unlit","KHR_techniques_webgl","EXTENSIONS","preprocessExtensions","gltf","options","context","extensions","filter","extension","useExtension","name","preprocess","decodeExtensions","decode","_extension$decode","extensionName","excludes","excludeExtensions","exclude"],"sources":["../../../../src/lib/api/gltf-extensions.ts"],"sourcesContent":["/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\n\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\n\n// Vendor extensions\n\ntype GLTFExtensionPlugin = {\n  name: string;\n  preprocess?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => void;\n  decode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => Promise<void>;\n  encode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: GLTFExtensionPlugin[] = [\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  EXT_meshopt_compression,\n  EXT_texture_webp,\n  // Basisu should come after webp, we want basisu to be preferred if both are provided\n  KHR_texture_basisu,\n  KHR_draco_mesh_compression,\n  KHR_lights_punctual,\n  KHR_materials_unlit,\n  KHR_techniques_webgl\n];\n\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    extension.preprocess?.(gltf, options, context);\n  }\n}\n\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    // Note: We decode async extensions sequentially, this might not be necessary\n    // Currently we only have Draco, but when we add Basis we may revisit\n    await extension.decode?.(gltf, options, context);\n  }\n}\n\nfunction useExtension(extensionName: string, options: GLTFLoaderOptions) {\n  const excludes = options?.gltf?.excludeExtensions || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n"]},"metadata":{},"sourceType":"module"}