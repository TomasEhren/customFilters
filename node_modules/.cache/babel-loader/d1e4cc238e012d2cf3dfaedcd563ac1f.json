{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3, Vector4, assert } from '@math.gl/core';\nimport { INTERSECTION } from '../constants';\nimport Plane from './plane';\nvar faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\nvar scratchPlaneCenter = new Vector3();\nvar scratchPlaneNormal = new Vector3();\nvar scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\nvar CullingVolume = /*#__PURE__*/function () {\n  function CullingVolume() {\n    var planes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, CullingVolume);\n\n    this.planes = planes;\n    assert(this.planes.every(function (plane) {\n      return plane instanceof Plane;\n    }));\n  }\n\n  _createClass(CullingVolume, [{\n    key: \"fromBoundingSphere\",\n    value: function fromBoundingSphere(boundingSphere) {\n      this.planes.length = 2 * faces.length;\n      var center = boundingSphere.center;\n      var radius = boundingSphere.radius;\n      var planeIndex = 0;\n\n      var _iterator = _createForOfIteratorHelper(faces),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var faceNormal = _step.value;\n          var plane0 = this.planes[planeIndex];\n          var plane1 = this.planes[planeIndex + 1];\n\n          if (!plane0) {\n            plane0 = this.planes[planeIndex] = new Plane();\n          }\n\n          if (!plane1) {\n            plane1 = this.planes[planeIndex + 1] = new Plane();\n          }\n\n          var plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n          var plane0Distance = -faceNormal.dot(plane0Center);\n          plane0.fromPointNormal(plane0Center, faceNormal);\n          var plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n          var negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n          var plane1Distance = -negatedFaceNormal.dot(plane1Center);\n          plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n          planeIndex += 2;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"computeVisibility\",\n    value: function computeVisibility(boundingVolume) {\n      assert(boundingVolume);\n      var intersect = INTERSECTION.INSIDE;\n\n      var _iterator2 = _createForOfIteratorHelper(this.planes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var plane = _step2.value;\n          var result = boundingVolume.intersectPlane(plane);\n\n          switch (result) {\n            case INTERSECTION.OUTSIDE:\n              return INTERSECTION.OUTSIDE;\n\n            case INTERSECTION.INTERSECTING:\n              intersect = INTERSECTION.INTERSECTING;\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return intersect;\n    }\n  }, {\n    key: \"computeVisibilityWithPlaneMask\",\n    value: function computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n      assert(boundingVolume, 'boundingVolume is required.');\n      assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n      if (parentPlaneMask === CullingVolume.MASK_OUTSIDE || parentPlaneMask === CullingVolume.MASK_INSIDE) {\n        return parentPlaneMask;\n      }\n\n      var mask = CullingVolume.MASK_INSIDE;\n      var planes = this.planes;\n\n      for (var k = 0; k < this.planes.length; ++k) {\n        var flag = k < 31 ? 1 << k : 0;\n\n        if (k < 31 && (parentPlaneMask & flag) === 0) {\n          continue;\n        }\n\n        var plane = planes[k];\n        var result = boundingVolume.intersectPlane(plane);\n\n        if (result === INTERSECTION.OUTSIDE) {\n          return CullingVolume.MASK_OUTSIDE;\n        } else if (result === INTERSECTION.INTERSECTING) {\n          mask |= flag;\n        }\n      }\n\n      return mask;\n    }\n  }], [{\n    key: \"MASK_OUTSIDE\",\n    get: function get() {\n      return 0xffffffff;\n    }\n  }, {\n    key: \"MASK_INSIDE\",\n    get: function get() {\n      return 0x00000000;\n    }\n  }, {\n    key: \"MASK_INDETERMINATE\",\n    get: function get() {\n      return 0x7fffffff;\n    }\n  }]);\n\n  return CullingVolume;\n}();\n\nexport { CullingVolume as default };","map":{"version":3,"mappings":"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","names":["Vector3","Vector4","assert","INTERSECTION","Plane","faces","scratchPlaneCenter","scratchPlaneNormal","scratchPlane","CullingVolume","constructor","planes","every","plane","fromBoundingSphere","boundingSphere","length","center","radius","planeIndex","faceNormal","plane0","plane1","plane0Center","copy","scale","add","plane0Distance","dot","fromPointNormal","plane1Center","negatedFaceNormal","negate","plane1Distance","computeVisibility","boundingVolume","intersect","INSIDE","result","intersectPlane","OUTSIDE","INTERSECTING","computeVisibilityWithPlaneMask","parentPlaneMask","Number","isFinite","MASK_OUTSIDE","MASK_INSIDE","mask","k","flag"],"sources":["../../../src/lib/culling-volume.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Vector4, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport Plane from './plane';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nconst scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n// A culling volume defined by planes.\nexport default class CullingVolume {\n  // For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n  // represents the case where the object bounding volume is entirely outside the culling volume.\n  static get MASK_OUTSIDE() {\n    return 0xffffffff;\n  }\n\n  // For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n  // represents the case where the object bounding volume is entirely inside the culling volume.\n  static get MASK_INSIDE() {\n    return 0x00000000;\n  }\n\n  // For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n  // represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n  static get MASK_INDETERMINATE() {\n    return 0x7fffffff;\n  }\n\n  constructor(planes = []) {\n    // {Cartesian4[]} [planes] An array of clipping planes.\n    this.planes = planes;\n    assert(this.planes.every((plane) => plane instanceof Plane));\n  }\n\n  // Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n  // The planes are aligned to the x, y, and z axes in world coordinates.\n  fromBoundingSphere(boundingSphere) {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  // Determines whether a bounding volume intersects the culling volume.\n  computeVisibility(boundingVolume) {\n    assert(boundingVolume);\n    // const planes = this.planes;\n    let intersect = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  // Determines whether a bounding volume intersects the culling volume.\n  /*\n   * @param {Number} parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *                                 volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *                                 the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *                                 and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {\n    assert(boundingVolume, 'boundingVolume is required.');\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}