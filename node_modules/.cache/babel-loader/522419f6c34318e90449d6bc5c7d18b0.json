{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Manager } from './utils/hammer';\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\nimport EventRegistrar from './utils/event-registrar';\nimport { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';\nvar DEFAULT_OPTIONS = {\n  events: null,\n  recognizers: null,\n  recognizerOptions: {},\n  Manager: Manager,\n  touchAction: 'none',\n  tabIndex: 0\n};\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager() {\n    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, EventManager);\n\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.events = new Map();\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.setElement(element);\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  _createClass(EventManager, [{\n    key: \"setElement\",\n    value: function setElement(element) {\n      var _this = this;\n\n      if (this.element) {\n        this.destroy();\n      }\n\n      this.element = element;\n\n      if (!element) {\n        return;\n      }\n\n      var options = this.options;\n      var ManagerClass = options.Manager;\n      this.manager = new ManagerClass(element, {\n        touchAction: options.touchAction,\n        recognizers: options.recognizers || RECOGNIZERS\n      }).on('hammer.input', this._onBasicInput);\n\n      if (!options.recognizers) {\n        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {\n          var recognizer = _this.manager.get(name);\n\n          if (recognizer) {\n            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {\n              recognizer.recognizeWith(otherName);\n            });\n          }\n        });\n      }\n\n      for (var recognizerName in options.recognizerOptions) {\n        var recognizer = this.manager.get(recognizerName);\n\n        if (recognizer) {\n          var recognizerOption = options.recognizerOptions[recognizerName];\n          delete recognizerOption.enable;\n          recognizer.set(recognizerOption);\n        }\n      }\n\n      this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.moveInput = new MoveInput(element, this._onOtherEvent, {\n        enable: false\n      });\n      this.keyInput = new KeyInput(element, this._onOtherEvent, {\n        enable: false,\n        tabIndex: options.tabIndex\n      });\n      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n        enable: false\n      });\n\n      var _iterator = _createForOfIteratorHelper(this.events),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              eventAlias = _step$value[0],\n              eventRegistrar = _step$value[1];\n\n          if (!eventRegistrar.isEmpty()) {\n            this._toggleRecognizer(eventRegistrar.recognizerName, true);\n\n            this.manager.on(eventAlias, eventRegistrar.handleEvent);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.element) {\n        this.wheelInput.destroy();\n        this.moveInput.destroy();\n        this.keyInput.destroy();\n        this.contextmenuInput.destroy();\n        this.manager.destroy();\n        this.wheelInput = null;\n        this.moveInput = null;\n        this.keyInput = null;\n        this.contextmenuInput = null;\n        this.manager = null;\n        this.element = null;\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false);\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, true);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(event, handler, opts) {\n      this._addEventHandler(event, handler, opts, false, true);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, handler) {\n      this._removeEventHandler(event, handler);\n    }\n  }, {\n    key: \"_toggleRecognizer\",\n    value: function _toggleRecognizer(name, enabled) {\n      var manager = this.manager;\n\n      if (!manager) {\n        return;\n      }\n\n      var recognizer = manager.get(name);\n\n      if (recognizer && recognizer.options.enable !== enabled) {\n        recognizer.set({\n          enable: enabled\n        });\n        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n\n        if (fallbackRecognizers && !this.options.recognizers) {\n          fallbackRecognizers.forEach(function (otherName) {\n            var otherRecognizer = manager.get(otherName);\n\n            if (enabled) {\n              otherRecognizer.requireFailure(name);\n              recognizer.dropRequireFailure(otherName);\n            } else {\n              otherRecognizer.dropRequireFailure(name);\n            }\n          });\n        }\n      }\n\n      this.wheelInput.enableEventType(name, enabled);\n      this.moveInput.enableEventType(name, enabled);\n      this.keyInput.enableEventType(name, enabled);\n      this.contextmenuInput.enableEventType(name, enabled);\n    }\n  }, {\n    key: \"_addEventHandler\",\n    value: function _addEventHandler(event, handler, opts, once, passive) {\n      if (typeof event !== 'string') {\n        opts = handler;\n\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName], opts, once, passive);\n        }\n\n        return;\n      }\n\n      var manager = this.manager,\n          events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        eventRegistrar = new EventRegistrar(this);\n        events.set(eventAlias, eventRegistrar);\n        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n\n        if (manager) {\n          manager.on(eventAlias, eventRegistrar.handleEvent);\n        }\n      }\n\n      eventRegistrar.add(event, handler, opts, once, passive);\n\n      if (!eventRegistrar.isEmpty()) {\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n      }\n    }\n  }, {\n    key: \"_removeEventHandler\",\n    value: function _removeEventHandler(event, handler) {\n      if (typeof event !== 'string') {\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n\n        return;\n      }\n\n      var events = this.events;\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n      var eventRegistrar = events.get(eventAlias);\n\n      if (!eventRegistrar) {\n        return;\n      }\n\n      eventRegistrar.remove(event, handler);\n\n      if (eventRegistrar.isEmpty()) {\n        var recognizerName = eventRegistrar.recognizerName;\n        var isRecognizerUsed = false;\n\n        var _iterator2 = _createForOfIteratorHelper(events.values()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var eh = _step2.value;\n\n            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n              isRecognizerUsed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n  }, {\n    key: \"_onBasicInput\",\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        this.manager.emit(alias, event);\n      }\n    }\n  }, {\n    key: \"_onOtherEvent\",\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n\n  return EventManager;\n}();\n\nexport { EventManager as default };","map":{"version":3,"mappings":"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","names":["Manager","WheelInput","MoveInput","KeyInput","ContextmenuInput","EventRegistrar","BASIC_EVENT_ALIASES","EVENT_RECOGNIZER_MAP","GESTURE_EVENT_ALIASES","RECOGNIZERS","RECOGNIZER_COMPATIBLE_MAP","RECOGNIZER_FALLBACK_MAP","DEFAULT_OPTIONS","events","recognizers","recognizerOptions","touchAction","tabIndex","EventManager","constructor","element","options","Object","assign","Map","_onBasicInput","bind","_onOtherEvent","setElement","on","destroy","ManagerClass","manager","keys","forEach","name","recognizer","get","otherName","recognizeWith","recognizerName","recognizerOption","enable","set","wheelInput","moveInput","keyInput","contextmenuInput","eventAlias","eventRegistrar","isEmpty","_toggleRecognizer","handleEvent","event","handler","opts","_addEventHandler","once","watch","off","_removeEventHandler","enabled","fallbackRecognizers","otherRecognizer","requireFailure","dropRequireFailure","enableEventType","passive","eventName","add","remove","isRecognizerUsed","values","eh","srcEvent","alias","type","emit"],"sources":["../../src/event-manager.js"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Manager} from './utils/hammer';\n\nimport WheelInput from './inputs/wheel-input';\nimport MoveInput from './inputs/move-input';\nimport KeyInput from './inputs/key-input';\nimport ContextmenuInput from './inputs/contextmenu-input';\n\nimport EventRegistrar from './utils/event-registrar';\n\nimport {\n  BASIC_EVENT_ALIASES,\n  EVENT_RECOGNIZER_MAP,\n  GESTURE_EVENT_ALIASES,\n  RECOGNIZERS,\n  RECOGNIZER_COMPATIBLE_MAP,\n  RECOGNIZER_FALLBACK_MAP\n} from './constants';\n\nconst DEFAULT_OPTIONS = {\n  // event handlers\n  events: null,\n  // custom recognizers\n  recognizers: null,\n  recognizerOptions: {},\n  // Manager class\n  Manager,\n  // allow browser default touch action\n  // https://github.com/uber/react-map-gl/issues/506\n  touchAction: 'none',\n  tabIndex: 0\n};\n\n// Unified API for subscribing to events about both\n// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n// and gestural input (e.g. 'click', 'tap', 'panstart').\n// Delegates gesture related event registration and handling to Hammer.js.\nexport default class EventManager {\n  constructor(element = null, options = {}) {\n    this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this.events = new Map();\n\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n\n    this.setElement(element);\n\n    // Register all passed events.\n    const {events} = options;\n    if (events) {\n      this.on(events);\n    }\n  }\n\n  setElement(element) {\n    if (this.element) {\n      // unregister all events\n      this.destroy();\n    }\n    this.element = element;\n    if (!element) {\n      return;\n    }\n\n    const {options} = this;\n    const ManagerClass = options.Manager;\n\n    this.manager = new ManagerClass(element, {\n      touchAction: options.touchAction,\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n\n    if (!options.recognizers) {\n      // Set default recognize withs\n      // http://hammerjs.github.io/recognize-with/\n      Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {\n        const recognizer = this.manager.get(name);\n        if (recognizer) {\n          RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {\n            recognizer.recognizeWith(otherName);\n          });\n        }\n      });\n    }\n\n    // Set recognizer options\n    for (const recognizerName in options.recognizerOptions) {\n      const recognizer = this.manager.get(recognizerName);\n      if (recognizer) {\n        const recognizerOption = options.recognizerOptions[recognizerName];\n        // `enable` is managed by the event registrations\n        delete recognizerOption.enable;\n        recognizer.set(recognizerOption);\n      }\n    }\n\n    // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.keyInput = new KeyInput(element, this._onOtherEvent, {\n      enable: false,\n      tabIndex: options.tabIndex\n    });\n    this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {\n      enable: false\n    });\n\n    // Register all existing events\n    for (const [eventAlias, eventRegistrar] of this.events) {\n      if (!eventRegistrar.isEmpty()) {\n        // Enable recognizer for this event.\n        this._toggleRecognizer(eventRegistrar.recognizerName, true);\n        this.manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n  }\n\n  // Tear down internal event management implementations.\n  destroy() {\n    if (this.element) {\n      // wheelInput etc. are created in setElement() and therefore\n      // cannot exist if there is no element\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.keyInput.destroy();\n      this.contextmenuInput.destroy();\n      this.manager.destroy();\n\n      this.wheelInput = null;\n      this.moveInput = null;\n      this.keyInput = null;\n      this.contextmenuInput = null;\n      this.manager = null;\n      this.element = null;\n    }\n  }\n\n  // Register an event handler function to be called on `event`.\n  on(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false);\n  }\n\n  // Register an event handler function to be called on `event`, then remove it\n  once(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, true);\n  }\n\n  // Register an event handler function to be called on `event`\n  // This handler does not ask the event to be recognized at all times.\n  // Instead, it only \"intercepts\" the event if some other handler is getting it.\n  watch(event, handler, opts) {\n    this._addEventHandler(event, handler, opts, false, true);\n  }\n\n  /**\n   * Deregister a previously-registered event handler.\n   * @param {string|Object} event   An event name (String) or map of event names to handlers\n   * @param {Function} [handler]    The function to be called on `event`.\n   */\n  off(event, handler) {\n    this._removeEventHandler(event, handler);\n  }\n\n  /*\n   * Enable/disable recognizer for the given event\n   */\n  _toggleRecognizer(name, enabled) {\n    const {manager} = this;\n    if (!manager) {\n      return;\n    }\n    const recognizer = manager.get(name);\n    if (recognizer && recognizer.options.enable !== enabled) {\n      recognizer.set({enable: enabled});\n\n      const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];\n      if (fallbackRecognizers && !this.options.recognizers) {\n        // Set default require failures\n        // http://hammerjs.github.io/require-failure/\n        fallbackRecognizers.forEach(otherName => {\n          const otherRecognizer = manager.get(otherName);\n          if (enabled) {\n            // Wait for this recognizer to fail\n            otherRecognizer.requireFailure(name);\n            /**\n             * This seems to be a bug in hammerjs:\n             * requireFailure() adds both ways\n             * dropRequireFailure() only drops one way\n             * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/\n               recognizer-constructor.js#L136\n             */\n            recognizer.dropRequireFailure(otherName);\n          } else {\n            // Do not wait for this recognizer to fail\n            otherRecognizer.dropRequireFailure(name);\n          }\n        });\n      }\n    }\n    this.wheelInput.enableEventType(name, enabled);\n    this.moveInput.enableEventType(name, enabled);\n    this.keyInput.enableEventType(name, enabled);\n    this.contextmenuInput.enableEventType(name, enabled);\n  }\n\n  /**\n   * Process the event registration for a single event + handler.\n   */\n  _addEventHandler(event, handler, opts, once, passive) {\n    if (typeof event !== 'string') {\n      opts = handler;\n      // If `event` is a map, call `on()` for each entry.\n      for (const eventName in event) {\n        this._addEventHandler(eventName, event[eventName], opts, once, passive);\n      }\n      return;\n    }\n\n    const {manager, events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    let eventRegistrar = events.get(eventAlias);\n    if (!eventRegistrar) {\n      eventRegistrar = new EventRegistrar(this);\n      events.set(eventAlias, eventRegistrar);\n      // Enable recognizer for this event.\n      eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;\n      // Listen to the event\n      if (manager) {\n        manager.on(eventAlias, eventRegistrar.handleEvent);\n      }\n    }\n    eventRegistrar.add(event, handler, opts, once, passive);\n    if (!eventRegistrar.isEmpty()) {\n      this._toggleRecognizer(eventRegistrar.recognizerName, true);\n    }\n  }\n\n  /**\n   * Process the event deregistration for a single event + handler.\n   */\n  _removeEventHandler(event, handler) {\n    if (typeof event !== 'string') {\n      // If `event` is a map, call `off()` for each entry.\n      for (const eventName in event) {\n        this._removeEventHandler(eventName, event[eventName]);\n      }\n      return;\n    }\n\n    const {events} = this;\n    // Alias to a recognized gesture as necessary.\n    const eventAlias = GESTURE_EVENT_ALIASES[event] || event;\n\n    const eventRegistrar = events.get(eventAlias);\n\n    if (!eventRegistrar) {\n      return;\n    }\n\n    eventRegistrar.remove(event, handler);\n\n    if (eventRegistrar.isEmpty()) {\n      const {recognizerName} = eventRegistrar;\n      // Disable recognizer if no more handlers are attached to its events\n      let isRecognizerUsed = false;\n      for (const eh of events.values()) {\n        if (eh.recognizerName === recognizerName && !eh.isEmpty()) {\n          isRecognizerUsed = true;\n          break;\n        }\n      }\n      if (!isRecognizerUsed) {\n        this._toggleRecognizer(recognizerName, false);\n      }\n    }\n  }\n\n  /**\n   * Handle basic events using the 'hammer.input' Hammer.js API:\n   * Before running Recognizers, Hammer emits a 'hammer.input' event\n   * with the basic event info. This function emits all basic events\n   * aliased to the \"class\" of event received.\n   * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n   */\n  _onBasicInput(event) {\n    const {srcEvent} = event;\n    const alias = BASIC_EVENT_ALIASES[srcEvent.type];\n    if (alias) {\n      // fire all events aliased to srcEvent.type\n      this.manager.emit(alias, event);\n    }\n  }\n\n  /**\n   * Handle events not supported by Hammer.js,\n   * and pipe back out through same (Hammer) channel used by other events.\n   */\n  _onOtherEvent(event) {\n    // console.log('onotherevent', event.type, event)\n    this.manager.emit(event.type, event);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}