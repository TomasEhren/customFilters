{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nexport default function fetchProgress(_x, _x2) {\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction _fetchProgress() {\n  _fetchProgress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(response, onProgress) {\n    var onDone,\n        onError,\n        body,\n        contentLength,\n        totalBytes,\n        progressStream,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            onDone = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : function () {};\n            onError = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : function () {};\n            _context2.next = 4;\n            return response;\n\n          case 4:\n            response = _context2.sent;\n\n            if (response.ok) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 7:\n            body = response.body;\n\n            if (body) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 10:\n            contentLength = response.headers.get('content-length') || 0;\n            totalBytes = contentLength && parseInt(contentLength);\n\n            if (contentLength > 0) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 14:\n            if (!(typeof ReadableStream === 'undefined' || !body.getReader)) {\n              _context2.next = 16;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", response);\n\n          case 16:\n            progressStream = new ReadableStream({\n              start: function start(controller) {\n                return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var reader;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          reader = body.getReader();\n                          _context.next = 3;\n                          return read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }))();\n              }\n            });\n            return _context2.abrupt(\"return\", new Response(progressStream));\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchProgress.apply(this, arguments);\n}\n\nfunction read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {\n  return _read.apply(this, arguments);\n}\n\nfunction _read() {\n  _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n    var _yield$reader$read, done, value, percent;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return reader.read();\n\n          case 3:\n            _yield$reader$read = _context3.sent;\n            done = _yield$reader$read.done;\n            value = _yield$reader$read.value;\n\n            if (!done) {\n              _context3.next = 10;\n              break;\n            }\n\n            onDone();\n            controller.close();\n            return _context3.abrupt(\"return\");\n\n          case 10:\n            loadedBytes += value.byteLength;\n            percent = Math.round(loadedBytes / totalBytes * 100);\n            onProgress(percent, {\n              loadedBytes: loadedBytes,\n              totalBytes: totalBytes\n            });\n            controller.enqueue(value);\n            _context3.next = 16;\n            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n\n          case 16:\n            _context3.next = 22;\n            break;\n\n          case 18:\n            _context3.prev = 18;\n            _context3.t0 = _context3[\"catch\"](0);\n            controller.error(_context3.t0);\n            onError(_context3.t0);\n\n          case 22:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 18]]);\n  }));\n  return _read.apply(this, arguments);\n}","map":{"version":3,"mappings":";;AAKA,wBAA8BA,aAA9B;EAAA;AAAA;;;4EAAe,kBACbC,QADa,EAEbC,UAFa;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;MAAA;QAAA;UAAA;YAGbC,MAHa,8DAGJ,YAAM,CAHF;YAIbC,OAJa,8DAIH,YAAM,CAJH;YAAA;YAAA,OAMIH,QANJ;;UAAA;YAMbA,QANa;;YAAA,IAORA,QAAQ,CAACI,EAPD;cAAA;cAAA;YAAA;;YAAA,kCASJJ,QATI;;UAAA;YAWPK,IAXO,GAWAL,QAAQ,CAACK,IAXT;;YAAA,IAYRA,IAZQ;cAAA;cAAA;YAAA;;YAAA,kCAcJL,QAdI;;UAAA;YAgBPM,aAhBO,GAgBSN,QAAQ,CAACO,OAATP,CAAiBQ,GAAjBR,CAAqB,gBAArBA,KAA0C,CAhBnD;YAiBPS,UAjBO,GAiBMH,aAAa,IAAII,QAAQ,CAACJ,aAAD,CAjB/B;;YAAA,IAkBPA,aAAa,GAAG,CAlBT;cAAA;cAAA;YAAA;;YAAA,kCAmBJN,QAnBI;;UAAA;YAAA,MAsBT,OAAOW,cAAP,KAA0B,WAA1B,IAAyC,CAACN,IAAI,CAACO,SAtBtC;cAAA;cAAA;YAAA;;YAAA,kCAuBJZ,QAvBI;;UAAA;YA2BPa,cA3BO,GA2BU,IAAIF,cAAJ,CAAmB;cAClCG,KADkC,iBAC5BC,UAD4B,EAChB;gBAAA;kBAAA;kBAAA;oBAAA;sBAAA;wBAAA;0BAChBC,MADgB,GACPX,IAAI,CAACO,SAALP,EADO;0BAAA;0BAAA,OAEhBY,IAAI,CAACF,UAAD,EAAaC,MAAb,EAAqB,CAArB,EAAwBP,UAAxB,EAAoCR,UAApC,EAAgDC,MAAhD,EAAwDC,OAAxD,CAFY;;wBAAA;wBAAA;0BAAA;sBAAA;oBAAA;kBAAA;gBAAA;cAGvB;YAJuC,CAAnB,CA3BV;YAAA,kCAkCN,IAAIe,QAAJ,CAAaL,cAAb,CAlCM;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;SAwCAI,I;;;;;mEAAf,kBAAoBF,UAApB,EAAgCC,MAAhC,EAAwCG,WAAxC,EAAqDV,UAArD,EAAiER,UAAjE,EAA6EC,MAA7E,EAAqFC,OAArF;IAAA;;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA;YAAA,OAEgCa,MAAM,CAACC,IAAPD,EAFhC;;UAAA;YAAA;YAEWI,IAFX,sBAEWA,IAFX;YAEiBC,KAFjB,sBAEiBA,KAFjB;;YAAA,KAGQD,IAHR;cAAA;cAAA;YAAA;;YAIMlB,MAAM;YACNa,UAAU,CAACO,KAAXP;YALN;;UAAA;YAQII,WAAW,IAAIE,KAAK,CAACE,UAArBJ;YACMK,OATV,GASoBC,IAAI,CAACC,KAALD,CAAYN,WAAW,GAAGV,UAAdU,GAA4B,GAAxCM,CATpB;YAUIxB,UAAU,CAACuB,OAAD,EAAU;cAACL,WAAD,EAACA,WAAD;cAAcV;YAAd,CAAV,CAAVR;YACAc,UAAU,CAACY,OAAXZ,CAAmBM,KAAnBN;YAXJ;YAAA,OAYUE,IAAI,CAACF,UAAD,EAAaC,MAAb,EAAqBG,WAArB,EAAkCV,UAAlC,EAA8CR,UAA9C,EAA0DC,MAA1D,EAAkEC,OAAlE,CAZd;;UAAA;YAAA;YAAA;;UAAA;YAAA;YAAA;YAcIY,UAAU,CAACa,KAAXb;YACAZ,OAAO,cAAPA;;UAfJ;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["fetchProgress","response","onProgress","onDone","onError","ok","body","contentLength","headers","get","totalBytes","parseInt","ReadableStream","getReader","progressStream","start","controller","reader","read","Response","loadedBytes","done","value","close","byteLength","percent","Math","round","enqueue","error"],"sources":["../../../../src/lib/progress/fetch-progress.ts"],"sourcesContent":["// Forked from github AnthumChris/fetch-progress-indicators under MIT license\n\n/**\n * Intercepts the Response stream and creates a new Response\n */\nexport default async function fetchProgress(\n  response: Response | Promise<Response>,\n  onProgress: any, // TODO better callback types\n  onDone = () => {},\n  onError = () => {}\n) {\n  response = await response;\n  if (!response.ok) {\n    // ERROR checking needs to be done separately\n    return response;\n  }\n  const body = response.body;\n  if (!body) {\n    // 'ReadableStream not yet supported in this browser.\n    return response;\n  }\n  const contentLength = response.headers.get('content-length') || 0;\n  const totalBytes = contentLength && parseInt(contentLength);\n  if (!(contentLength > 0)) {\n    return response;\n  }\n  // Currently override only implemented in browser\n  if (typeof ReadableStream === 'undefined' || !body.getReader) {\n    return response;\n  }\n\n  // Create a new stream that invisbly wraps original stream\n  const progressStream = new ReadableStream({\n    async start(controller) {\n      const reader = body.getReader();\n      await read(controller, reader, 0, totalBytes, onProgress, onDone, onError);\n    }\n  });\n\n  return new Response(progressStream);\n}\n\n// Forward to original streams controller\n// TODO - this causes a crazy deep \"async stack\"... rewrite as async iterator?\n// eslint-disable-next-line max-params\nasync function read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {\n  try {\n    const {done, value} = await reader.read();\n    if (done) {\n      onDone();\n      controller.close();\n      return;\n    }\n    loadedBytes += value.byteLength;\n    const percent = Math.round((loadedBytes / totalBytes) * 100);\n    onProgress(percent, {loadedBytes, totalBytes});\n    controller.enqueue(value);\n    await read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);\n  } catch (error) {\n    controller.error(error);\n    onError(error);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}