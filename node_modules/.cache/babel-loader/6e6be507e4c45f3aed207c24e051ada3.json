{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nimport parseImage from '../parsers/parse-image';\nimport { getImageSize } from '../category-api/parsed-image-api';\nimport { generateUrl } from './generate-url';\nimport { deepLoad, shallowLoad } from './deep-load';\nexport async function loadImage(getUrl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\nexport async function getImageUrls(getUrl, options) {\n  let urlOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const mipLevels = options && options.image && options.image.mipLevels || 0;\n  return mipLevels !== 0 ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, { ...urlOptions,\n      lod: 0\n    });\n    const image = await shallowLoad(url, parseImage, options);\n    const {\n      width,\n      height\n    } = getImageSize(image);\n    mipLevels = getMipLevels({\n      width,\n      height\n    });\n    urls.push(url);\n  }\n\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, { ...urlOptions,\n      lod: mipLevel\n    });\n    urls.push(url);\n  }\n\n  return urls;\n}\n\nexport function getMipLevels(_ref) {\n  let {\n    width,\n    height\n  } = _ref;\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}","map":{"version":3,"mappings":"AAAA,SAAQA,MAAR,QAAqB,0BAArB;AACA,OAAOC,UAAP,MAAuB,wBAAvB;AACA,SAAQC,YAAR,QAA2B,kCAA3B;AACA,SAAQC,WAAR,QAA0B,gBAA1B;AACA,SAAQC,QAAR,EAAkBC,WAAlB,QAAoC,aAApC;AAEA,OAAO,eAAeC,SAAf,CAAyBC,MAAzB,EAA+C;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EACpD,MAAMC,SAAS,GAAG,MAAMC,YAAY,CAACH,MAAD,EAASC,OAAT,CAApC;EACA,OAAO,MAAMJ,QAAQ,CAACK,SAAD,EAAYR,UAAZ,EAAwBO,OAAxB,CAArB;AACD;AAED,OAAO,eAAeE,YAAf,CAA4BH,MAA5B,EAAoCC,OAApC,EAA8D;EAAA,IAAjBG,UAAiB,uEAAJ,EAAI;EACnE,MAAMC,SAAS,GAAIJ,OAAO,IAAIA,OAAO,CAACK,KAAnBL,IAA4BA,OAAO,CAACK,KAARL,CAAcI,SAA1CJ,IAAwD,CAA3E;EACA,OAAOI,SAAS,KAAK,CAAdA,GACH,MAAME,qBAAqB,CAACP,MAAD,EAASK,SAAT,EAAoBJ,OAApB,EAA6BG,UAA7B,CADxBC,GAEHT,WAAW,CAACI,MAAD,EAASC,OAAT,EAAkBG,UAAlB,CAFf;AAGD;;AAED,eAAeG,qBAAf,CAAqCP,MAArC,EAA6CK,SAA7C,EAAwDJ,OAAxD,EAAiEG,UAAjE,EAA6E;EAC3E,MAAMI,IAAc,GAAG,EAAvB;;EAGA,IAAIH,SAAS,KAAK,MAAlB,EAA0B;IACxB,MAAMI,GAAG,GAAGb,WAAW,CAACI,MAAD,EAASC,OAAT,EAAkB,EAAC,GAAGG,UAAJ;MAAgBM,GAAG,EAAE;IAArB,CAAlB,CAAvB;IACA,MAAMJ,KAAK,GAAG,MAAMR,WAAW,CAACW,GAAD,EAAMf,UAAN,EAAkBO,OAAlB,CAA/B;IAEA,MAAM;MAACU,KAAD;MAAQC;IAAR,IAAkBjB,YAAY,CAACW,KAAD,CAApC;IACAD,SAAS,GAAGQ,YAAY,CAAC;MAACF,KAAD;MAAQC;IAAR,CAAD,CAAxBP;IAGAG,IAAI,CAACM,IAALN,CAAUC,GAAVD;EACD;;EAGDf,MAAM,CAACY,SAAS,GAAG,CAAb,CAANZ;;EAEA,KAAK,IAAIsB,QAAQ,GAAGP,IAAI,CAACQ,MAAzB,EAAiCD,QAAQ,GAAGV,SAA5C,EAAuD,EAAEU,QAAzD,EAAmE;IACjE,MAAMN,GAAG,GAAGb,WAAW,CAACI,MAAD,EAASC,OAAT,EAAkB,EAAC,GAAGG,UAAJ;MAAgBM,GAAG,EAAEK;IAArB,CAAlB,CAAvB;IACAP,IAAI,CAACM,IAALN,CAAUC,GAAVD;EACD;;EAED,OAAOA,IAAP;AACD;;AAGD,OAAO,SAASK,YAAT,OAAuC;EAAA,IAAjB;IAACF,KAAD;IAAQC;EAAR,CAAiB;EAC5C,OAAO,IAAIK,IAAI,CAACC,KAALD,CAAWA,IAAI,CAACE,IAALF,CAAUA,IAAI,CAACG,GAALH,CAASN,KAATM,EAAgBL,MAAhBK,CAAVA,CAAXA,CAAX;AACD","names":["assert","parseImage","getImageSize","generateUrl","deepLoad","shallowLoad","loadImage","getUrl","options","imageUrls","getImageUrls","urlOptions","mipLevels","image","getMipmappedImageUrls","urls","url","lod","width","height","getMipLevels","push","mipLevel","length","Math","floor","log2","max"],"sources":["../../../../src/lib/texture-api/load-image.ts"],"sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls: string[] = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"]},"metadata":{},"sourceType":"module"}