{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport DoublyLinkedList from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nexport default class TilesetCache {\n  constructor() {\n    _defineProperty(this, \"_list\", void 0);\n\n    _defineProperty(this, \"_sentinel\", void 0);\n\n    _defineProperty(this, \"_trimTiles\", void 0);\n\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback) {\n    const node = tile._cacheNode;\n\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n\n    tile._cacheNode = undefined;\n\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n    const list = this._list;\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {\n      const tile = node.item;\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n\n}","map":{"version":3,"mappings":";AAGA,OAAOA,gBAAP,MAA6B,6BAA7B;;AAEA,SAASC,OAAT,CAAiBC,CAAjB,EAAoB;EAClB,OAAOA,CAAC,KAAKC,SAAND,IAAmBA,CAAC,KAAK,IAAhC;AACD;;AAOD,eAAe,MAAME,YAAN,CAAmB;EAKhCC,WAAW,GAAG;IAAAC;;IAAAA;;IAAAA;;IAGZ,KAAKC,KAAL,GAAa,IAAIP,gBAAJ,EAAb;IACA,KAAKQ,SAAL,GAAiB,KAAKD,KAAL,CAAWE,GAAX,CAAe,UAAf,CAAjB;IACA,KAAKC,UAAL,GAAkB,KAAlB;EACD;;EAEDC,KAAK,GAAG;IAIN,KAAKJ,KAAL,CAAWK,MAAX,CAAkB,KAAKL,KAAL,CAAWM,IAA7B,EAAmC,KAAKL,SAAxC;EACD;;EAEDM,KAAK,CAACC,IAAD,EAAO;IACV,MAAMC,IAAI,GAAGD,IAAI,CAACE,UAAlB;;IACA,IAAIhB,OAAO,CAACe,IAAD,CAAX,EAAmB;MACjB,KAAKT,KAAL,CAAWK,MAAX,CAAkB,KAAKJ,SAAvB,EAAkCQ,IAAlC;IACD;EACF;;EAEDP,GAAG,CAACS,OAAD,EAAUH,IAAV,EAAgBI,WAAhB,EAA6B;IAC9B,IAAI,CAAClB,OAAO,CAACc,IAAI,CAACE,UAAN,CAAZ,EAA+B;MAC7BF,IAAI,CAACE,UAALF,GAAkB,KAAKR,KAAL,CAAWE,GAAX,CAAeM,IAAf,CAAlBA;;MAEA,IAAII,WAAJ,EAAiB;QACfA,WAAW,CAACD,OAAD,EAAUH,IAAV,CAAXI;MACD;IACF;EACF;;EAEDC,UAAU,CAACF,OAAD,EAAUH,IAAV,EAAgBM,cAAhB,EAAiC;IACzC,MAAML,IAAI,GAAGD,IAAI,CAACE,UAAlB;;IACA,IAAI,CAAChB,OAAO,CAACe,IAAD,CAAZ,EAAoB;MAClB;IACD;;IAED,KAAKT,KAAL,CAAWe,MAAX,CAAkBN,IAAlB;;IACAD,IAAI,CAACE,UAALF,GAAkBZ,SAAlBY;;IACA,IAAIM,cAAJ,EAAoB;MAClBA,cAAc,CAACH,OAAD,EAAUH,IAAV,CAAdM;IACD;EACF;;EAEDE,WAAW,CAACL,OAAD,EAAUG,cAAV,EAA0B;IACnC,MAAMG,SAAS,GAAG,KAAKd,UAAvB;IACA,KAAKA,UAAL,GAAkB,KAAlB;IAEA,MAAMe,IAAI,GAAG,KAAKlB,KAAlB;IAEA,MAAMmB,yBAAyB,GAAGR,OAAO,CAACS,kBAART,GAA6B,IAA7BA,GAAoC,IAAtE;IAKA,MAAMU,QAAQ,GAAG,KAAKpB,SAAtB;IACA,IAAIQ,IAAI,GAAGS,IAAI,CAACI,IAAhB;;IAEA,OACEb,IAAI,KAAKY,QAATZ,KACCE,OAAO,CAACY,qBAARZ,GAAgCQ,yBAAhCR,IAA6DM,SAD9DR,CADF,EAGE;MAEA,MAAMD,IAAI,GAAGC,IAAI,CAACe,IAAlB;MAEAf,IAAI,GAAGA,IAAI,CAACgB,IAAZhB;MACA,KAAKI,UAAL,CAAgBF,OAAhB,EAAyBH,IAAzB,EAA+BM,cAA/B;IACD;EACF;;EAEDY,IAAI,GAAG;IACL,KAAKvB,UAAL,GAAkB,IAAlB;EACD;;AA9E+B","names":["DoublyLinkedList","defined","x","undefined","TilesetCache","constructor","_defineProperty","_list","_sentinel","add","_trimTiles","reset","splice","tail","touch","tile","node","_cacheNode","tileset","addCallback","unloadTile","unloadCallback","remove","unloadTiles","trimTiles","list","maximumMemoryUsageInBytes","maximumMemoryUsage","sentinel","head","gpuMemoryUsageInBytes","item","next","trim"],"sources":["../../../src/tileset/tileset-cache.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport DoublyLinkedList from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * Stores tiles with content loaded.\n *\n * @private\n */\nexport default class TilesetCache {\n  private _list: DoublyLinkedList;\n  private _sentinel: any;\n  private _trimTiles: boolean;\n\n  constructor() {\n    // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache\n    // (sentinel, tail] -> tiles that were selected this frame\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    // Move sentinel node to the tail so, at the start of the frame, all tiles\n    // may be potentially replaced.  Tiles are moved to the right of the sentinel\n    // when they are selected so they will not be replaced.\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback?) {\n    const node = tile._cacheNode;\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n    tile._cacheNode = undefined;\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n\n    const list = this._list;\n\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n\n    // Traverse the list only to the sentinel since tiles/nodes to the\n    // right of the sentinel were used this frame.\n    // The sub-list to the left of the sentinel is ordered from LRU to MRU.\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (\n      node !== sentinel &&\n      (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)\n    ) {\n      // @ts-expect-error\n      const tile = node.item;\n      // @ts-expect-error\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}