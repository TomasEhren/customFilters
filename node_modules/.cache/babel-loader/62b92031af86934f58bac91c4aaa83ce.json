{"ast":null,"code":"import { Vector3 } from '@math.gl/core';\nimport { BoundingSphere, OrientedBoundingBox } from '@math.gl/culling';\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\nconst scratchVector = new Vector3();\nexport function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    const {\n      halfAxes\n    } = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    const {\n      radius\n    } = boundingVolume;\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    const {\n      width,\n      height\n    } = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}","map":{"version":3,"mappings":"AAAA,SAAQA,OAAR,QAAsB,eAAtB;AACA,SAAQC,cAAR,EAAwBC,mBAAxB,QAAkD,kBAAlD;AAGA,MAAMC,cAAc,GAAG,SAAvB;AACA,MAAMC,cAAc,GAAG,SAAvB;AACA,MAAMC,cAAc,GAAG,kBAAvB;AAEA,MAAMC,aAAa,GAAG,IAAIN,OAAJ,EAAtB;AAQA,OAAO,SAASO,yBAAT,CACLC,cADK,EAELC,mBAFK,EAGL;EACA,IAAID,cAAc,YAAYN,mBAA9B,EAAmD;IAEjD,MAAM;MAACQ;IAAD,IAAaF,cAAnB;IACA,MAAMG,OAAO,GAAGC,UAAU,CAACF,QAAD,CAA1B;IAGA,OAAOG,IAAI,CAACC,IAALD,CAAUR,cAAc,IAAIM,OAAO,GAAGF,mBAAmB,CAAC,CAAD,CAAjC,CAAxBI,CAAP;EANF,OAOO,IAAIL,cAAc,YAAYP,cAA9B,EAA8C;IAEnD,MAAM;MAACc;IAAD,IAAWP,cAAjB;IAEA,OAAOK,IAAI,CAACC,IAALD,CAAUR,cAAc,IAAIU,MAAM,GAAGN,mBAAmB,CAAC,CAAD,CAAhC,CAAxBI,CAAP;EAJK,OAKA,IAAIL,cAAc,CAACQ,KAAfR,IAAwBA,cAAc,CAACS,MAA3C,EAAmD;IAExD,MAAM;MAACD,KAAD;MAAQC;IAAR,IAAkBT,cAAxB;IACA,MAAMU,KAAK,GAAGL,IAAI,CAACC,IAALD,CAAUV,cAAc,GAAGa,KAA3BH,CAAd;IACA,MAAMM,KAAK,GAAGN,IAAI,CAACC,IAALD,CAAUT,cAAc,GAAGa,MAA3BJ,CAAd;IAEA,OAAO,CAACK,KAAK,GAAGC,KAAT,IAAkB,CAAzB;EACD;;EAED,OAAO,CAAP;AACD;;AAED,SAASP,UAAT,CAAoBF,QAApB,EAA8B;EAC5BA,QAAQ,CAACU,SAATV,CAAmB,CAAnBA,EAAsBJ,aAAtBI;EACA,MAAMW,IAAI,GAAGX,QAAQ,CAACU,SAATV,CAAmB,CAAnBA,CAAb;EACA,MAAMY,IAAI,GAAGZ,QAAQ,CAACU,SAATV,CAAmB,CAAnBA,CAAb;EACA,MAAMa,cAAc,GAAGjB,aAAa,CAACkB,GAAdlB,CAAkBe,IAAlBf,EAAwBkB,GAAxBlB,CAA4BgB,IAA5BhB,CAAvB;EACA,MAAMmB,IAAI,GAAGF,cAAc,CAACG,GAAfH,EAAb;EACA,OAAOE,IAAP;AACD","names":["Vector3","BoundingSphere","OrientedBoundingBox","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","scratchVector","getZoomFromBoundingVolume","boundingVolume","cartorgraphicCenter","halfAxes","obbSize","getObbSize","Math","log2","radius","width","height","zoomX","zoomY","getColumn","axeY","axeZ","farthestVertex","add","size","len"],"sources":["../../../../src/tileset/helpers/zoom.ts"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {BoundingRectangle} from '../../types';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(\n  boundingVolume: BoundingSphere | OrientedBoundingBox | BoundingRectangle,\n  cartorgraphicCenter: Vector3\n) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    // OrientedBoundingBox\n    const {halfAxes} = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    // BoundingSphere\n    const {radius} = boundingVolume;\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    // BoundingRectangle\n    const {width, height} = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n"]},"metadata":{},"sourceType":"module"}