{"ast":null,"code":"import * as cartoColors from 'cartocolor';\nimport { assert } from './utils';\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR = [204, 204, 204];\nexport const OTHERS_COLOR = [119, 119, 119];\nexport default function getPalette(name, numCategories) {\n  const palette = cartoColors[name];\n  let paletteIndex = numCategories;\n  assert(palette, \"Palette \\\"\".concat(name, \"\\\" not found. Expected a CARTOColors string\"));\n  const palettesColorVariants = Object.keys(palette).filter(p => p !== 'tags').map(Number);\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\nexport function hexToRgb(hex) {\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), 255];\n  }\n\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16), parseInt(result[4] + result[4], 16)];\n  }\n\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  assert(result, \"Hexadecimal color \\\"\".concat(hex, \"\\\" was not parsed correctly\"));\n  return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), parseInt(result[4], 16)];\n}","map":{"version":3,"mappings":"AAAA,OAAO,KAAKA,WAAZ,MAA6B,YAA7B;AACA,SAAQC,MAAR,QAAqB,SAArB;AAIA,OAAO,MAAMC,eAAe,GAAG,QAAxB;AACP,OAAO,MAAMC,UAAiB,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAA1B;AACP,OAAO,MAAMC,YAAmB,GAAG,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAA5B;AAOP,eAAe,SAASC,UAAT,CAAoBC,IAApB,EAAkCC,aAAlC,EAAkE;EAC/E,MAAMC,OAAuC,GAAGR,WAAW,CAACM,IAAD,CAA3D;EACA,IAAIG,YAAY,GAAGF,aAAnB;EAEAN,MAAM,CAACO,OAAD,sBAAsBF,IAAtB,iDAANL;EAEA,MAAMS,qBAAqB,GAAGC,MAAM,CAACC,IAAPD,CAAYH,OAAZG,EAC3BE,MAD2BF,CACpBG,CAAC,IAAIA,CAAC,KAAK,MADSH,EAE3BI,GAF2BJ,CAEvBK,MAFuBL,CAA9B;EAIA,MAAMM,mBAAmB,GAAGC,IAAI,CAACC,GAALD,CAAS,GAAGR,qBAAZQ,CAA5B;EACA,MAAME,oBAAoB,GAAGF,IAAI,CAACG,GAALH,CAAS,GAAGR,qBAAZQ,CAA7B;;EAEA,IAAI,CAACF,MAAM,CAACM,SAAPN,CAAiBT,aAAjBS,CAAD,IAAoCT,aAAa,GAAGU,mBAAxD,EAA6E;IAC3ER,YAAY,GAAGQ,mBAAfR;EADF,OAEO,IAAIF,aAAa,GAAGa,oBAApB,EAA0C;IAC/CX,YAAY,GAAGW,oBAAfX;EACD;;EAED,IAAIc,MAAM,GAAGf,OAAO,CAACC,YAAD,CAApB;;EAEA,IAAID,OAAO,CAACgB,IAARhB,IAAgBA,OAAO,CAACgB,IAARhB,CAAaiB,QAAbjB,CAAsB,aAAtBA,CAApB,EAA0D;IACxDe,MAAM,GAAGA,MAAM,CAACG,KAAPH,CAAa,CAAbA,EAAgB,CAAC,CAAjBA,CAATA;EACD;;EAED,OAAOA,MAAM,CAACR,GAAPQ,CAAWI,CAAC,IAAIC,QAAQ,CAACD,CAAD,CAAxBJ,CAAP;AACD;AAED,OAAO,SAASK,QAAT,CAAkBC,GAAlB,EAAsC;EAE3C,IAAIC,MAAM,GAAG,4CAA4CC,IAA5C,CAAiDF,GAAjD,CAAb;;EAEA,IAAIC,MAAJ,EAAY;IACV,OAAO,CACLE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CADH,EAELE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CAFH,EAGLE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CAHH,EAIL,GAJK,CAAP;EAMD;;EAGDA,MAAM,GAAG,wDAAwDC,IAAxD,CAA6DF,GAA7D,CAATC;;EAEA,IAAIA,MAAJ,EAAY;IACV,OAAO,CACLE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CADH,EAELE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CAFH,EAGLE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CAHH,EAILE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAANA,GAAYA,MAAM,CAAC,CAAD,CAAnB,EAAwB,EAAxB,CAJH,CAAP;EAMD;;EAGDA,MAAM,GAAG,4CAA4CC,IAA5C,CAAiDF,GAAjD,CAATC;;EAEA,IAAIA,MAAJ,EAAY;IACV,OAAO,CAACE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAT,EAA0BE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAlC,EAAmDE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAA3D,EAA4E,GAA5E,CAAP;EACD;;EAGDA,MAAM,GAAG,wDAAwDC,IAAxD,CAA6DF,GAA7D,CAATC;EAEA7B,MAAM,CAAC6B,MAAD,gCAA+BD,GAA/B,iCAAN5B;EAEA,OAAO,CACL+B,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CADH,EAELE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAFH,EAGLE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAHH,EAILE,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAJH,CAAP;AAMD","names":["cartoColors","assert","DEFAULT_PALETTE","NULL_COLOR","OTHERS_COLOR","getPalette","name","numCategories","palette","paletteIndex","palettesColorVariants","Object","keys","filter","p","map","Number","longestPaletteIndex","Math","max","smallestPaletteIndex","min","isInteger","colors","tags","includes","slice","c","hexToRgb","hex","result","exec","parseInt"],"sources":["../../../src/style/palette.ts"],"sourcesContent":["import * as cartoColors from 'cartocolor';\nimport {assert} from './utils';\n\nexport type Color = [r: number, b: number, g: number, a?: number];\n\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR: Color = [204, 204, 204];\nexport const OTHERS_COLOR: Color = [119, 119, 119];\n\ninterface CartoColorsPalette {\n  tags?: string[];\n  [key: number]: string[];\n}\n\nexport default function getPalette(name: string, numCategories: number): Color[] {\n  const palette: CartoColorsPalette | undefined = cartoColors[name];\n  let paletteIndex = numCategories;\n\n  assert(palette, `Palette \"${name}\" not found. Expected a CARTOColors string`);\n\n  const palettesColorVariants = Object.keys(palette)\n    .filter(p => p !== 'tags')\n    .map(Number);\n\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\n\nexport function hexToRgb(hex: string): Color {\n  // Evaluate #ABC\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      255\n    ];\n  }\n\n  // Evaluate #ABCD\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16)\n    ];\n  }\n\n  // Evaluate #ABCDEF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  // Evaluate #ABCDEFAF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  assert(result, `Hexadecimal color \"${hex}\" was not parsed correctly`);\n\n  return [\n    parseInt(result[1], 16),\n    parseInt(result[2], 16),\n    parseInt(result[3], 16),\n    parseInt(result[4], 16)\n  ];\n}\n"]},"metadata":{},"sourceType":"module"}