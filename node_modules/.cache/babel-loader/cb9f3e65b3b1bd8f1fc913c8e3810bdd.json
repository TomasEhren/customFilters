{"ast":null,"code":"import { Vector3, Matrix4, assert } from '@math.gl/core';\nimport CullingVolume from './culling-volume';\nimport Plane from './plane';\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nexport default class PerspectiveOffCenterFrustum {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options = {\n      near: 1.0,\n      far: 500000000.0,\n      ...options\n    };\n    this.left = options.left;\n    this._left = undefined;\n    this.right = options.right;\n    this._right = undefined;\n    this.top = options.top;\n    this._top = undefined;\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n    this.near = options.near;\n    this._near = this.near;\n    this.far = options.far;\n    this._far = this.far;\n    this._cullingVolume = new CullingVolume([new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n  }\n\n  clone() {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  equals(other) {\n    return other && other instanceof PerspectiveOffCenterFrustum && this.right === other.right && this.left === other.left && this.top === other.top && this.bottom === other.bottom && this.near === other.near && this.far === other.far;\n  }\n\n  get projectionMatrix() {\n    update(this);\n    return this._perspectiveMatrix;\n  }\n\n  get infiniteProjectionMatrix() {\n    update(this);\n    return this._infinitePerspective;\n  }\n\n  computeCullingVolume(position, direction, up) {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n    const planes = this._cullingVolume.planes;\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n    const nearCenter = scratchPlaneNearCenter.copy(direction).multiplyByScalar(this.near).add(position);\n    const farCenter = scratchPlaneFarCenter.copy(direction).multiplyByScalar(this.far).add(position);\n    let normal = scratchPlaneNormal;\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n    planes[0].fromPointNormal(position, normal);\n    normal.copy(right).multiplyByScalar(this.right).add(nearCenter).subtract(position).cross(up).negate();\n    planes[1].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.bottom).add(nearCenter).subtract(position).cross(right).negate();\n    planes[2].fromPointNormal(position, normal);\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n    planes[3].fromPointNormal(position, normal);\n    normal = new Vector3().copy(direction);\n    planes[4].fromPointNormal(nearCenter, normal);\n    normal.negate();\n    planes[5].fromPointNormal(farCenter, normal);\n    return this._cullingVolume;\n  }\n\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    update(this);\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    assert(drawingBufferWidth > 0);\n    assert(drawingBufferHeight > 0);\n    assert(distance > 0);\n    assert(result);\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = 2.0 * distance * tanTheta / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = 2.0 * distance * tanTheta / drawingBufferWidth;\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n}\n\nfunction update(frustum) {\n  assert(Number.isFinite(frustum.right) && Number.isFinite(frustum.left) && Number.isFinite(frustum.top) && Number.isFinite(frustum.bottom) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));\n  const {\n    top,\n    bottom,\n    right,\n    left,\n    near,\n    far\n  } = frustum;\n\n  if (top !== frustum._top || bottom !== frustum._bottom || left !== frustum._left || right !== frustum._right || near !== frustum._near || far !== frustum._far) {\n    assert(frustum.near > 0 && frustum.near < frustum.far, 'near must be greater than zero and less than far.');\n    frustum._left = left;\n    frustum._right = right;\n    frustum._top = top;\n    frustum._bottom = bottom;\n    frustum._near = near;\n    frustum._far = far;\n    frustum._perspectiveMatrix = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    frustum._infinitePerspective = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far: Infinity\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Matrix4","assert","CullingVolume","Plane","scratchPlaneUpVector","scratchPlaneRightVector","scratchPlaneNearCenter","scratchPlaneFarCenter","scratchPlaneNormal","PerspectiveOffCenterFrustum","constructor","options","near","far","left","_left","undefined","right","_right","top","_top","bottom","_bottom","_near","_far","_cullingVolume","_perspectiveMatrix","_infinitePerspective","clone","equals","other","projectionMatrix","update","infiniteProjectionMatrix","computeCullingVolume","position","direction","up","planes","copy","normalize","cross","nearCenter","multiplyByScalar","add","farCenter","normal","subtract","fromPointNormal","negate","getPixelDimensions","drawingBufferWidth","drawingBufferHeight","distance","result","Number","isFinite","inverseNear","tanTheta","pixelHeight","pixelWidth","x","y","frustum","Infinity"],"sources":["../../../src/lib/perspective-off-center-frustum.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\n// @ts-nocheck\n\nimport {Vector3, Matrix4, assert} from '@math.gl/core';\nimport CullingVolume from './culling-volume';\nimport Plane from './plane';\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n\nexport default class PerspectiveOffCenterFrustum {\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   * @constructor\n   *\n   * @param {Object} [options] An object with the following properties:\n   * @param {Number} [options.left] The left clipping plane distance.\n   * @param {Number} [options.right] The right clipping plane distance.\n   * @param {Number} [options.top] The top clipping plane distance.\n   * @param {Number} [options.bottom] The bottom clipping plane distance.\n   * @param {Number} [options.near=1.0] The near clipping plane distance.\n   * @param {Number} [options.far=500000000.0] The far clipping plane distance.\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options = {}) {\n    options = {near: 1.0, far: 500000000.0, ...options};\n\n    /**\n     * Defines the left clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.left = options.left;\n    this._left = undefined;\n\n    /**\n     * Defines the right clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.right = options.right;\n    this._right = undefined;\n\n    /**\n     * Defines the top clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.top = options.top;\n    this._top = undefined;\n\n    /**\n     * Defines the bottom clipping plane.\n     * @type {Number}\n     * @default undefined\n     */\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n\n    /**\n     * The distance of the near plane.\n     * @type {Number}\n     * @default 1.0\n     */\n    this.near = options.near;\n    this._near = this.near;\n\n    /**\n     * The distance of the far plane.\n     * @type {Number}\n     * @default 500000000.0\n     */\n    this.far = options.far;\n    this._far = this.far;\n\n    this._cullingVolume = new CullingVolume([\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane(),\n      new Plane()\n    ]);\n    this._perspectiveMatrix = new Matrix4();\n    this._infinitePerspective = new Matrix4();\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone() {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other) {\n    return (\n      other &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      this.right === other.right &&\n      this.left === other.left &&\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.near === other.near &&\n      this.far === other.far\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix() {\n    update(this);\n    return this._perspectiveMatrix;\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   * @readonly\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix() {\n    update(this);\n    return this._infinitePerspective;\n  }\n\n  /**\n   * Creates a culling volume for this frustum.\n   *\n   * @param {Vector3} position The eye position.\n   * @param {Vector3} direction The view direction.\n   * @param {Vector3} up The up direction.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(position, direction, up) {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n\n    const planes = this._cullingVolume.planes;\n\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n\n    const nearCenter = scratchPlaneNearCenter\n      .copy(direction)\n      .multiplyByScalar(this.near)\n      .add(position);\n\n    const farCenter = scratchPlaneFarCenter\n      .copy(direction)\n      .multiplyByScalar(this.far)\n      .add(position);\n\n    let normal = scratchPlaneNormal;\n\n    // Left plane computation\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n\n    planes[0].fromPointNormal(position, normal);\n\n    // Right plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.right)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up)\n      .negate();\n\n    planes[1].fromPointNormal(position, normal);\n\n    // Bottom plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.bottom)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right)\n      .negate();\n\n    planes[2].fromPointNormal(position, normal);\n\n    // Top plane computation\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n\n    planes[3].fromPointNormal(position, normal);\n\n    normal = new Vector3().copy(direction);\n\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n\n    // Far plane computation\n    normal.negate();\n\n    planes[5].fromPointNormal(farCenter, normal);\n\n    return this._cullingVolume;\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @param {Number} drawingBufferWidth The width of the drawing buffer.\n   * @param {Number} drawingBufferHeight The height of the drawing buffer.\n   * @param {Number} distance The distance to the near plane in meters.\n   * @param {Vector2} result The object onto which to store the result.\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {\n    update(this);\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nfunction update(frustum) {\n  assert(\n    Number.isFinite(frustum.right) &&\n      Number.isFinite(frustum.left) &&\n      Number.isFinite(frustum.top) &&\n      Number.isFinite(frustum.bottom) &&\n      Number.isFinite(frustum.near) &&\n      Number.isFinite(frustum.far)\n  );\n  // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n\n  const {top, bottom, right, left, near, far} = frustum;\n\n  if (\n    top !== frustum._top ||\n    bottom !== frustum._bottom ||\n    left !== frustum._left ||\n    right !== frustum._right ||\n    near !== frustum._near ||\n    far !== frustum._far\n  ) {\n    assert(\n      frustum.near > 0 && frustum.near < frustum.far,\n      'near must be greater than zero and less than far.'\n    );\n\n    frustum._left = left;\n    frustum._right = right;\n    frustum._top = top;\n    frustum._bottom = bottom;\n    frustum._near = near;\n    frustum._far = far;\n    frustum._perspectiveMatrix = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far\n    });\n    frustum._infinitePerspective = new Matrix4().frustum({\n      left,\n      right,\n      bottom,\n      top,\n      near,\n      far: Infinity\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}