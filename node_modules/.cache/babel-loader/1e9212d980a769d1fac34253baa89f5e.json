{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3 } from '@math.gl/core';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector = new Vector3();\nvar scratchNormal = new Vector3();\n\nvar AxisAlignedBoundingBox = /*#__PURE__*/function () {\n  function AxisAlignedBoundingBox() {\n    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\n    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, AxisAlignedBoundingBox);\n\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n    this.minimum = new Vector3(minimum);\n    this.maximum = new Vector3(maximum);\n  }\n\n  _createClass(AxisAlignedBoundingBox, [{\n    key: \"clone\",\n    value: function clone() {\n      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(transformation) {\n      this.center.transformAsPoint(transformation);\n      this.halfDiagonal.transform(transformation);\n      this.minimum.transform(transformation);\n      this.maximum.transform(transformation);\n      return this;\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var halfDiagonal = this.halfDiagonal;\n      var normal = scratchNormal.from(plane.normal);\n      var e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);\n      var s = this.center.dot(normal) + plane.distance;\n\n      if (s - e > 0) {\n        return INTERSECTION.INSIDE;\n      }\n\n      if (s + e < 0) {\n        return INTERSECTION.OUTSIDE;\n      }\n\n      return INTERSECTION.INTERSECTING;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      return Math.sqrt(this.distanceSquaredTo(point));\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var offset = scratchVector.from(point).subtract(this.center);\n      var halfDiagonal = this.halfDiagonal;\n      var distanceSquared = 0.0;\n      var d;\n      d = Math.abs(offset.x) - halfDiagonal.x;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.y) - halfDiagonal.y;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      d = Math.abs(offset.z) - halfDiagonal.z;\n\n      if (d > 0) {\n        distanceSquared += d * d;\n      }\n\n      return distanceSquared;\n    }\n  }]);\n\n  return AxisAlignedBoundingBox;\n}();\n\nexport { AxisAlignedBoundingBox as default };","map":{"version":3,"mappings":"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","names":["Vector3","INTERSECTION","scratchVector","scratchNormal","AxisAlignedBoundingBox","constructor","minimum","maximum","center","copy","add","scale","halfDiagonal","subtract","clone","equals","right","Boolean","transform","transformation","transformAsPoint","intersectPlane","plane","normal","from","e","x","Math","abs","y","z","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","distanceTo","point","sqrt","distanceSquaredTo","offset","distanceSquared","d"],"sources":["../../../../src/lib/bounding-volumes/axis-aligned-bounding-box.js"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\nexport default class AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center = null) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  transform(transformation) {\n    this.center.transformAsPoint(transformation);\n    // TODO - this.halfDiagonal.transformAsVector(transformation);\n    this.halfDiagonal.transform(transformation);\n    this.minimum.transform(transformation);\n    this.maximum.transform(transformation);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane) {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // A simplified version of OrientedBoundingBox.distanceSquaredTo\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}