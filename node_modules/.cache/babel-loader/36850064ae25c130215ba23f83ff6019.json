{"ast":null,"code":"export class TypedArrayManager {\n  constructor(props) {\n    this._pool = [];\n    this.props = {\n      overAlloc: 2,\n      poolSize: 100\n    };\n    this.setProps(props);\n  }\n\n  setProps(props) {\n    Object.assign(this.props, props);\n  }\n\n  allocate(typedArray, count, _ref) {\n    let {\n      size = 1,\n      type,\n      padding = 0,\n      copy = false,\n      initialize = false,\n      maxCount\n    } = _ref;\n    const Type = type || typedArray && typedArray.constructor || Float32Array;\n    const newSize = count * size + padding;\n\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize;\n\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    let sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i >= 0) {\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n\n      if (initialize) {\n        array.fill(0);\n      }\n\n      return array;\n    }\n\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n\n    const pool = this._pool;\n    const {\n      buffer\n    } = typedArray;\n    const {\n      byteLength\n    } = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.props.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n\n    if (pool.length > this.props.poolSize) {\n      pool.shift();\n    }\n  }\n\n}\nexport default new TypedArrayManager();","map":{"version":3,"mappings":"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","names":["TypedArrayManager","constructor","props","_pool","overAlloc","poolSize","setProps","Object","assign","allocate","typedArray","count","size","type","padding","copy","initialize","maxCount","Type","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","newArray","_allocate","set","fill","_release","release","sizeToAllocate","Math","max","ceil","pool","i","findIndex","b","array","splice","push","shift"],"sources":["../../../src/utils/typed-array-manager.js"],"sourcesContent":["export class TypedArrayManager {\n  constructor(props) {\n    this._pool = [];\n    this.props = {overAlloc: 2, poolSize: 100};\n    this.setProps(props);\n  }\n\n  setProps(props) {\n    Object.assign(this.props, props);\n  }\n\n  allocate(\n    typedArray,\n    count,\n    {size = 1, type, padding = 0, copy = false, initialize = false, maxCount}\n  ) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.props.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.props.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}