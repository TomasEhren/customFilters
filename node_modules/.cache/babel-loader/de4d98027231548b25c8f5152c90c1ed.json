{"ast":null,"code":"import View from './view';\nimport Viewport from '../viewports/viewport';\nimport { Matrix4 } from '@math.gl/core';\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nimport * as vec2 from 'gl-matrix/vec2';\nimport OrthographicController from '../controllers/orthographic-controller';\nconst viewMatrix = new Matrix4().lookAt({\n  eye: [0, 0, 1]\n});\n\nfunction getProjectionMatrix(_ref) {\n  let {\n    width,\n    height,\n    near,\n    far\n  } = _ref;\n  width = width || 1;\n  height = height || 1;\n  return new Matrix4().ortho({\n    left: -width / 2,\n    right: width / 2,\n    bottom: -height / 2,\n    top: height / 2,\n    near,\n    far\n  });\n}\n\nclass OrthographicViewport extends Viewport {\n  constructor(props) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n    let distanceScales;\n\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n\n    super({ ...props,\n      longitude: null,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({\n        width,\n        height,\n        near,\n        far\n      }),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n\n  projectFlat(_ref2) {\n    let [X, Y] = _ref2;\n    const {\n      unitsPerMeter\n    } = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n\n  unprojectFlat(_ref3) {\n    let [x, y] = _ref3;\n    const {\n      metersPerUnit\n    } = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n\n  panByPosition(coords, pixel) {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n    return {\n      target: this.unprojectFlat(newCenter)\n    };\n  }\n\n}\n\nexport default class OrthographicView extends View {\n  constructor(props) {\n    super({ ...props,\n      type: OrthographicViewport\n    });\n  }\n\n  get controller() {\n    return this._getControllerProps({\n      type: OrthographicController\n    });\n  }\n\n}\nOrthographicView.displayName = 'OrthographicView';","map":{"version":3,"mappings":"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","names":["View","Viewport","Matrix4","pixelsToWorld","vec2","OrthographicController","viewMatrix","lookAt","eye","getProjectionMatrix","width","height","near","far","ortho","left","right","bottom","top","OrthographicViewport","constructor","props","zoom","target","flipY","zoomX","Array","isArray","zoomY","zoom_","Math","min","scale","pow","distanceScales","scaleX","scaleY","unitsPerMeter","metersPerUnit","longitude","position","clone","projectionMatrix","projectFlat","X","Y","unprojectFlat","x","y","panByPosition","coords","pixel","fromLocation","pixelUnprojectionMatrix","toLocation","translate","add","negate","newCenter","center","OrthographicView","type","controller","_getControllerProps","displayName"],"sources":["../../../src/views/orthographic-view.js"],"sourcesContent":["import View from './view';\nimport Viewport from '../viewports/viewport';\n\nimport {Matrix4} from '@math.gl/core';\nimport {pixelsToWorld} from '@math.gl/web-mercator';\nimport * as vec2 from 'gl-matrix/vec2';\nimport OrthographicController from '../controllers/orthographic-controller';\n\nconst viewMatrix = new Matrix4().lookAt({eye: [0, 0, 1]});\n\nfunction getProjectionMatrix({width, height, near, far}) {\n  // Make sure Matrix4.ortho doesn't crash on 0 width/height\n  width = width || 1;\n  height = height || 1;\n\n  return new Matrix4().ortho({\n    left: -width / 2,\n    right: width / 2,\n    bottom: -height / 2,\n    top: height / 2,\n    near,\n    far\n  });\n}\n\nclass OrthographicViewport extends Viewport {\n  constructor(props) {\n    const {\n      width,\n      height,\n      near = 0.1,\n      far = 1000,\n      zoom = 0,\n      target = [0, 0, 0],\n      flipY = true\n    } = props;\n    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;\n    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;\n    const zoom_ = Math.min(zoomX, zoomY);\n    const scale = Math.pow(2, zoom_);\n\n    let distanceScales;\n    if (zoomX !== zoomY) {\n      const scaleX = Math.pow(2, zoomX);\n      const scaleY = Math.pow(2, zoomY);\n\n      distanceScales = {\n        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],\n        metersPerUnit: [scale / scaleX, scale / scaleY, 1]\n      };\n    }\n\n    super({\n      ...props,\n      // in case viewState contains longitude/latitude values,\n      // make sure that the base Viewport class does not treat this as a geospatial viewport\n      longitude: null,\n      position: target,\n      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),\n      projectionMatrix: getProjectionMatrix({width, height, near, far}),\n      zoom: zoom_,\n      distanceScales\n    });\n  }\n\n  projectFlat([X, Y]) {\n    const {unitsPerMeter} = this.distanceScales;\n    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];\n  }\n\n  unprojectFlat([x, y]) {\n    const {metersPerUnit} = this.distanceScales;\n    return [x * metersPerUnit[0], y * metersPerUnit[1]];\n  }\n\n  /* Needed by LinearInterpolator */\n  panByPosition(coords, pixel) {\n    const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);\n    const toLocation = this.projectFlat(coords);\n\n    const translate = vec2.add([], toLocation, vec2.negate([], fromLocation));\n    const newCenter = vec2.add([], this.center, translate);\n\n    return {target: this.unprojectFlat(newCenter)};\n  }\n}\n\nexport default class OrthographicView extends View {\n  constructor(props) {\n    super({\n      ...props,\n      type: OrthographicViewport\n    });\n  }\n\n  get controller() {\n    return this._getControllerProps({\n      type: OrthographicController\n    });\n  }\n}\n\nOrthographicView.displayName = 'OrthographicView';\n"]},"metadata":{},"sourceType":"module"}