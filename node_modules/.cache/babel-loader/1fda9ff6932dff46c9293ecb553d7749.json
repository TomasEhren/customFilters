{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { GL, GLType } from '@loaders.gl/math';\nexport default class Tile3DFeatureTable {\n  constructor(featureTableJson, featureTableBinary) {\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"buffer\", void 0);\n\n    _defineProperty(this, \"featuresLength\", 0);\n\n    _defineProperty(this, \"_cachedTypedArrays\", {});\n\n    this.json = featureTableJson;\n    this.buffer = featureTableBinary;\n  }\n\n  getExtension(extensionName) {\n    return this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  hasProperty(propertyName) {\n    return Boolean(this.json[propertyName]);\n  }\n\n  getGlobalProperty(propertyName) {\n    let componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GL.UNSIGNED_INT;\n    let componentLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);\n    }\n\n    return jsonValue;\n  }\n\n  getPropertyArray(propertyName, componentType, componentLength) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      if ('componentType' in jsonValue) {\n        componentType = GLType.fromName(jsonValue.componentType);\n      }\n\n      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);\n    }\n\n    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n  }\n\n  getProperty(propertyName, componentType, componentLength, featureId, result) {\n    const jsonValue = this.json[propertyName];\n\n    if (!jsonValue) {\n      return jsonValue;\n    }\n\n    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n\n    if (componentLength === 1) {\n      return typedArray[featureId];\n    }\n\n    for (let i = 0; i < componentLength; ++i) {\n      result[i] = typedArray[componentLength * featureId + i];\n    }\n\n    return result;\n  }\n\n  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n\n    return typedArray;\n  }\n\n  _getTypedArrayFromArray(propertyName, componentType, array) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, array);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n\n    return typedArray;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["GL","GLType","Tile3DFeatureTable","constructor","featureTableJson","featureTableBinary","_defineProperty","json","buffer","getExtension","extensionName","extensions","hasProperty","propertyName","Boolean","getGlobalProperty","componentType","UNSIGNED_INT","componentLength","jsonValue","Number","isFinite","byteOffset","_getTypedArrayFromBinary","getPropertyArray","fromName","featuresLength","_getTypedArrayFromArray","getProperty","featureId","result","typedArray","i","count","cachedTypedArrays","_cachedTypedArrays","createTypedArray","array"],"sources":["../../../../src/lib/classes/tile-3d-feature-table.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {GL, GLType} from '@loaders.gl/math';\n\n// Reference:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/1de96d087f0b17575eb1a3f736407b348c765d59/Source/Scene/Cesium3DTileFeatureTable.js\nexport default class Tile3DFeatureTable {\n  json;\n  buffer;\n  featuresLength = 0;\n  _cachedTypedArrays = {};\n\n  constructor(featureTableJson, featureTableBinary) {\n    this.json = featureTableJson;\n    this.buffer = featureTableBinary;\n  }\n\n  getExtension(extensionName) {\n    return this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  hasProperty(propertyName) {\n    return Boolean(this.json[propertyName]);\n  }\n\n  getGlobalProperty(propertyName, componentType = GL.UNSIGNED_INT, componentLength = 1) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        1,\n        jsonValue.byteOffset\n      );\n    }\n\n    return jsonValue;\n  }\n\n  getPropertyArray(propertyName, componentType, componentLength) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      if ('componentType' in jsonValue) {\n        componentType = GLType.fromName(jsonValue.componentType);\n      }\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        this.featuresLength,\n        jsonValue.byteOffset\n      );\n    }\n\n    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n  }\n\n  getProperty(propertyName, componentType, componentLength, featureId, result) {\n    const jsonValue = this.json[propertyName];\n    if (!jsonValue) {\n      return jsonValue;\n    }\n\n    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n\n    if (componentLength === 1) {\n      return typedArray[featureId];\n    }\n\n    for (let i = 0; i < componentLength; ++i) {\n      result[i] = typedArray[componentLength * featureId + i];\n    }\n\n    return result;\n  }\n\n  // HELPERS\n\n  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(\n        componentType,\n        this.buffer.buffer,\n        this.buffer.byteOffset + byteOffset,\n        count * componentLength\n      );\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n\n  _getTypedArrayFromArray(propertyName, componentType, array) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, array);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}