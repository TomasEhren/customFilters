{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport earcut from 'earcut';\nimport { modifyPolygonWindingDirection, WINDING } from '@math.gl/polygon';\nvar OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nvar HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\nvar windingOptions = {\n  isClosed: true\n};\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  var windingDirection = arguments.length > 6 ? arguments[6] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  var targetIndex = targetStartIndex;\n\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n  return targetIndex;\n}\n\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n  var positions = [];\n  var holeIndices = [];\n\n  if (polygon.positions) {\n    var _polygon = polygon,\n        srcPositions = _polygon.positions,\n        srcHoleIndices = _polygon.holeIndices;\n\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i], i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n\n    var _iterator = _createForOfIteratorHelper(polygon.entries()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            polygonIndex = _step$value[0],\n            simplePolygon = _step$value[1];\n\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize, polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  var holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n\n  var positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    var n = positions.length;\n    positions = positions.slice();\n    var p = [];\n\n    for (var i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      var xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  return earcut(positions, holeIndices, positionSize);\n}","map":{"version":3,"mappings":"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","names":["earcut","modifyPolygonWindingDirection","WINDING","OUTER_POLYGON_WINDING","CLOCKWISE","HOLE_POLYGON_WINDING","COUNTER_CLOCKWISE","windingOptions","isClosed","validate","polygon","positions","Array","isArray","ArrayBuffer","isView","Error","isSimple","length","Number","isFinite","isNestedRingClosed","simplePolygon","p0","p1","isFlatRingClosed","size","startIndex","endIndex","i","copyNestedRing","target","targetStartIndex","windingDirection","targetIndex","len","j","start","end","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","normalize","positionSize","holeIndices","srcPositions","srcHoleIndices","push","pop","entries","polygonIndex","getSurfaceIndices","normalizedPolygon","preproject","map","positionIndex","n","slice","p","xy"],"sources":["../../../src/solid-polygon-layer/polygon.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\nimport {modifyPolygonWindingDirection, WINDING} from '@math.gl/polygon';\n\nconst OUTER_POLYGON_WINDING = WINDING.CLOCKWISE;\nconst HOLE_POLYGON_WINDING = WINDING.COUNTER_CLOCKWISE;\n\nconst windingOptions = {\n  isClosed: true\n};\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [windingDirection] - modify polygon to be of the specified winding direction\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size, windingDirection) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @param {Number} [windingDirection] - modify polygon to be of the specified winding direction\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(\n  target,\n  targetStartIndex,\n  positions,\n  size,\n  srcStartIndex = 0,\n  srcEndIndex,\n  windingDirection\n) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n\n  windingOptions.start = targetStartIndex;\n  windingOptions.end = targetIndex;\n  windingOptions.size = size;\n  modifyPolygonWindingDirection(target, windingDirection, windingOptions);\n\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n\n  const positions = [];\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i],\n          i === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize, 0, positions.length, OUTER_POLYGON_WINDING);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const [polygonIndex, simplePolygon] of polygon.entries()) {\n      targetIndex = copyNestedRing(\n        positions,\n        targetIndex,\n        simplePolygon,\n        positionSize,\n        polygonIndex === 0 ? OUTER_POLYGON_WINDING : HOLE_POLYGON_WINDING\n      );\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize, OUTER_POLYGON_WINDING);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    const p = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n"]},"metadata":{},"sourceType":"module"}