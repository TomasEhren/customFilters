{"ast":null,"code":"const GEOM_TYPES = ['points', 'lines', 'polygons'];\nexport default function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  let featureIndex = -1;\n\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(geomData.properties, elem => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);\n  } else {\n    featureIndex = findIndex(geomData.fields, elem => elem.id === featureId, startFeatureIndex, endFeatureIndex);\n  }\n\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    const layerNames = {};\n    const {\n      properties\n    } = geomData;\n\n    for (let i = 0; i < properties.length; i++) {\n      const {\n        layerName: key\n      } = properties[i];\n\n      if (!key) {} else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n\n    geomData.__layers = layerNames;\n  }\n\n  return geomData.__layers[layerName];\n}\n\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n\n    geomData.__ids = result;\n  }\n\n  return geomData.__ids[featureIndex];\n}\n\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}","map":{"version":3,"mappings":"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","names":["GEOM_TYPES","findIndexBinary","data","uniqueIdProperty","featureId","layerName","gt","index","findIndexByType","geomData","featureIds","value","length","startFeatureIndex","endFeatureIndex","layerRange","getLayerRange","featureIndex","numericProps","vertexIndex","findIndex","x","i","globalFeatureIds","properties","elem","fields","id","getGlobalFeatureId","__layers","layerNames","key","__ids","result","array","predicate","startIndex","endIndex"],"sources":["../../../src/mvt-layer/find-index-binary.js"],"sourcesContent":["const GEOM_TYPES = ['points', 'lines', 'polygons'];\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n * @param {Object} data - The data in binary format\n * @param {String} uniqueIdProperty - Name of the unique id property\n * @param {Number|String} featureId - feature id to find\n * @param {String} layerName - the layer to search in\n */\nexport default function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(\n      (x, i) =>\n        x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex\n    );\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(\n      geomData.properties,\n      elem => elem[uniqueIdProperty] === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  } else {\n    featureIndex = findIndex(\n      geomData.fields,\n      elem => elem.id === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames = {};\n    const {properties} = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {layerName: key} = properties[i];\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n\n// Like array.findIndex, but only search within a range\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"]},"metadata":{},"sourceType":"module"}