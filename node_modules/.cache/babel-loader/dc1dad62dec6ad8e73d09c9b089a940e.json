{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isAsyncIterable } from '../utils/iterable-utils';\nimport { ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL } from './constants';\nconst EMPTY_PROPS = Object.freeze({});\nexport default class ComponentState {\n  constructor(component) {\n    _defineProperty(this, \"component\", void 0);\n\n    _defineProperty(this, \"onAsyncPropUpdated\", void 0);\n\n    _defineProperty(this, \"asyncProps\", void 0);\n\n    _defineProperty(this, \"oldProps\", void 0);\n\n    _defineProperty(this, \"oldAsyncProps\", void 0);\n\n    this.component = component;\n    this.asyncProps = {};\n\n    this.onAsyncPropUpdated = () => {};\n\n    this.oldProps = null;\n    this.oldAsyncProps = null;\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n  }\n\n  getOldProps() {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  hasAsyncProp(propName) {\n    return propName in this.asyncProps;\n  }\n\n  getAsyncProp(propName) {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName) {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n    }\n\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reloadAsyncProp(propName, value) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  setAsyncProps(props) {\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n\n      this._createAsyncPropData(propName, defaultValues[propName]);\n\n      this._updateAsyncProp(propName, value);\n\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n\n      this._createAsyncPropData(propName, defaultValues[propName]);\n\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  _fetch(propName, url) {\n    return url;\n  }\n\n  _onResolve(propName, value) {}\n\n  _onError(propName, error) {}\n\n  _updateAsyncProp(propName, value) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value);\n\n      return;\n    }\n\n    this._setPropValue(propName, value);\n  }\n\n  _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      this.oldAsyncProps = Object.create(this.oldProps);\n\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  _didAsyncInputValueChange(propName, value) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  _setPropValue(propName, value) {\n    this._freezeAsyncOldProps();\n\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n\n  _setAsyncPropValue(propName, value, loadCount) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      this._freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  _watchPromise(propName, promise) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise.then(data => {\n        data = this._postProcessValue(asyncProp, data);\n\n        this._setAsyncPropValue(propName, data, loadCount);\n\n        this._onResolve(propName, data);\n      }).catch(error => {\n        this._onError(propName, error);\n      });\n    }\n  }\n\n  async _resolveAsyncIterable(propName, iterable) {\n    if (propName !== 'data') {\n      this._setPropValue(propName, iterable);\n\n      return;\n    }\n\n    const asyncProp = this.asyncProps[propName];\n\n    if (!asyncProp) {\n      return;\n    }\n\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      const {\n        dataTransform\n      } = this.component.props;\n\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{\n          startRow: count,\n          endRow: data.length\n        }]\n      });\n      count = data.length;\n\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    this._onResolve(propName, data);\n  }\n\n  _postProcessValue(asyncProp, value) {\n    const propType = asyncProp.type;\n\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n\n    return value;\n  }\n\n  _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n\n    if (!asyncProp) {\n      const propTypes = this.component && this.component.constructor._propTypes;\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null,\n        resolvedValue: defaultValue,\n        pendingLoadCount: 0,\n        resolvedLoadCount: 0\n      };\n    }\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isAsyncIterable","ASYNC_ORIGINAL_SYMBOL","ASYNC_RESOLVED_SYMBOL","ASYNC_DEFAULTS_SYMBOL","EMPTY_PROPS","Object","freeze","ComponentState","constructor","component","_defineProperty","asyncProps","onAsyncPropUpdated","oldProps","oldAsyncProps","finalize","propName","asyncProp","type","release","resolvedValue","getOldProps","resetOldProps","props","hasAsyncProp","getAsyncProp","isAsyncPropLoading","Boolean","pendingLoadCount","resolvedLoadCount","key","reloadAsyncProp","value","_watchPromise","Promise","resolve","setAsyncProps","resolvedValues","originalValues","defaultValues","_createAsyncPropData","_updateAsyncProp","_fetch","url","_onResolve","_onError","error","_didAsyncInputValueChange","_resolveAsyncIterable","_setPropValue","_freezeAsyncOldProps","create","defineProperty","enumerable","lastValue","_postProcessValue","_setAsyncPropValue","loadCount","undefined","promise","then","data","catch","iterable","count","chunk","dataTransform","concat","startRow","endRow","length","propType","transform","defaultValue","propTypes","_propTypes"],"sources":["../../../src/lifecycle/component-state.ts"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {isAsyncIterable} from '../utils/iterable-utils';\nimport {ASYNC_ORIGINAL_SYMBOL, ASYNC_RESOLVED_SYMBOL, ASYNC_DEFAULTS_SYMBOL} from './constants';\nimport type Component from './component';\nimport {ComponentProps, StatefulComponentProps} from './component';\nimport {PropType} from './prop-types';\n\nconst EMPTY_PROPS = Object.freeze({});\n\ntype AsyncPropState = {\n  type: PropType;\n  lastValue: any;\n  resolvedValue: any;\n  pendingLoadCount: number;\n  resolvedLoadCount: number;\n};\n\nexport default class ComponentState<PropsT extends ComponentProps> {\n  component: Component<PropsT>;\n  onAsyncPropUpdated: (propName: keyof PropsT, value: any) => void;\n\n  private asyncProps: Partial<Record<keyof PropsT, AsyncPropState>>;\n  private oldProps: StatefulComponentProps<PropsT> | null;\n  private oldAsyncProps: StatefulComponentProps<PropsT> | null;\n\n  constructor(component: Component<PropsT>) {\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n    this.onAsyncPropUpdated = () => {};\n    this.oldProps = null; // Last props before update\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  finalize() {\n    for (const propName in this.asyncProps) {\n      const asyncProp = this.asyncProps[propName];\n      if (asyncProp && asyncProp.type && asyncProp.type.release) {\n        // Release any resources created by transforms\n        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);\n      }\n    }\n  }\n\n  /* Layer-facing props API */\n\n  getOldProps(): StatefulComponentProps<PropsT> | typeof EMPTY_PROPS {\n    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;\n  }\n\n  resetOldProps() {\n    this.oldAsyncProps = null;\n    this.oldProps = this.component.props;\n  }\n\n  // Checks if a prop is overridden\n  hasAsyncProp(propName: keyof PropsT): boolean {\n    return propName in this.asyncProps;\n  }\n\n  // Returns value of an overriden prop\n  getAsyncProp(propName: keyof PropsT): any {\n    const asyncProp = this.asyncProps[propName];\n    return asyncProp && asyncProp.resolvedValue;\n  }\n\n  isAsyncPropLoading(propName: keyof PropsT): boolean {\n    if (propName) {\n      const asyncProp = this.asyncProps[propName];\n      return Boolean(\n        asyncProp &&\n          asyncProp.pendingLoadCount > 0 &&\n          asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount\n      );\n    }\n    for (const key in this.asyncProps) {\n      if (this.isAsyncPropLoading(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Without changing the original prop value, swap out the data resolution under the hood\n  reloadAsyncProp(propName: keyof PropsT, value: any) {\n    this._watchPromise(propName, Promise.resolve(value));\n  }\n\n  // Updates all async/overridden props (when new props come in)\n  // Checks if urls have changed, starts loading, or removes override\n  setAsyncProps(props: StatefulComponentProps<PropsT>) {\n    // NOTE: prop param and default values are only support for testing\n    const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};\n    const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;\n    const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};\n\n    // TODO - use async props from the layer's prop types\n    for (const propName in resolvedValues) {\n      const value = resolvedValues[propName];\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n      // Use transformed value\n      resolvedValues[propName] = this.getAsyncProp(propName);\n    }\n\n    for (const propName in originalValues) {\n      const value = originalValues[propName];\n      // Makes sure a record exists for this prop\n      this._createAsyncPropData(propName, defaultValues[propName]);\n      this._updateAsyncProp(propName, value);\n    }\n  }\n\n  /* Placeholder methods for subclassing */\n\n  protected _fetch(propName: keyof PropsT, url: string): any {\n    return url;\n  }\n\n  protected _onResolve(propName: keyof PropsT, value: any) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  protected _onError(propName: keyof PropsT, error: Error) {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n  // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n  private _updateAsyncProp(propName: keyof PropsT, value: any) {\n    if (!this._didAsyncInputValueChange(propName, value)) {\n      return;\n    }\n\n    // interpret value string as url and start a new load tracked by a promise\n    if (typeof value === 'string') {\n      value = this._fetch(propName, value);\n    }\n\n    // interprets promise and track the \"loading\"\n    if (value instanceof Promise) {\n      this._watchPromise(propName, value);\n      return;\n    }\n\n    if (isAsyncIterable(value)) {\n      this._resolveAsyncIterable(propName, value); // eslint-disable-line @typescript-eslint/no-floating-promises\n      return;\n    }\n\n    // else, normal, non-async value. Just store value for now\n    this._setPropValue(propName, value);\n  }\n\n  // Whenever async props are changing, we need to make a copy of oldProps\n  // otherwise the prop rewriting will affect the value both in props and oldProps.\n  // While the copy is relatively expensive, this only happens on load completion.\n  private _freezeAsyncOldProps() {\n    if (!this.oldAsyncProps && this.oldProps) {\n      // 1. inherit all synchronous props from oldProps\n      // 2. reconfigure the async prop descriptors to fixed values\n      this.oldAsyncProps = Object.create(this.oldProps);\n      for (const propName in this.asyncProps) {\n        Object.defineProperty(this.oldAsyncProps, propName, {\n          enumerable: true,\n          value: this.oldProps[propName]\n        });\n      }\n    }\n  }\n\n  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n  private _didAsyncInputValueChange(propName: keyof PropsT, value: any): boolean {\n    // @ts-ignore\n    const asyncProp: AsyncPropState = this.asyncProps[propName];\n    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {\n      return false;\n    }\n    asyncProp.lastValue = value;\n    return true;\n  }\n\n  // Set normal, non-async value\n  private _setPropValue(propName: keyof PropsT, value: any) {\n    // Save the current value before overwriting so that diffProps can access both\n    this._freezeAsyncOldProps();\n\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      value = this._postProcessValue(asyncProp, value);\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    }\n  }\n\n  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n  private _setAsyncPropValue(propName: keyof PropsT, value: any, loadCount: number) {\n    // Only update if loadCount is larger or equal to resolvedLoadCount\n    // otherwise a more recent load has already completed\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {\n      // Save the current value before overwriting so that diffProps can access both\n      this._freezeAsyncOldProps();\n\n      asyncProp.resolvedValue = value;\n      asyncProp.resolvedLoadCount = loadCount;\n\n      // Call callback to inform listener\n      this.onAsyncPropUpdated(propName, value);\n    }\n  }\n\n  // Tracks a promise, sets the prop when loaded, handles load count\n  private _watchPromise(propName: keyof PropsT, promise: Promise<any>) {\n    const asyncProp = this.asyncProps[propName];\n    if (asyncProp) {\n      asyncProp.pendingLoadCount++;\n      const loadCount = asyncProp.pendingLoadCount;\n      promise\n        .then(data => {\n          data = this._postProcessValue(asyncProp, data);\n          this._setAsyncPropValue(propName, data, loadCount);\n          this._onResolve(propName, data);\n        })\n        .catch(error => {\n          this._onError(propName, error);\n        });\n    }\n  }\n\n  private async _resolveAsyncIterable(\n    propName: keyof PropsT,\n    iterable: AsyncIterable<any>\n  ): Promise<void> {\n    if (propName !== 'data') {\n      // we only support data as async iterable\n      this._setPropValue(propName, iterable);\n      return;\n    }\n\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      return;\n    }\n\n    asyncProp.pendingLoadCount++;\n    const loadCount = asyncProp.pendingLoadCount;\n    let data = [];\n    let count = 0;\n\n    for await (const chunk of iterable) {\n      // @ts-expect-error\n      const {dataTransform} = this.component.props;\n      if (dataTransform) {\n        data = dataTransform(chunk, data);\n      } else {\n        data = data.concat(chunk);\n      }\n\n      // Used by the default _dataDiff function\n      Object.defineProperty(data, '__diff', {\n        enumerable: false,\n        value: [{startRow: count, endRow: data.length}]\n      });\n\n      count = data.length;\n      this._setAsyncPropValue(propName, data, loadCount);\n    }\n\n    this._onResolve(propName, data);\n  }\n\n  // Give the app a chance to post process the loaded data\n  private _postProcessValue(asyncProp, value: any) {\n    const propType = asyncProp.type;\n    if (propType) {\n      if (propType.release) {\n        propType.release(asyncProp.resolvedValue, propType, this.component);\n      }\n      if (propType.transform) {\n        return propType.transform(value, propType, this.component);\n      }\n    }\n    return value;\n  }\n\n  // Creating an asyncProp record if needed\n  private _createAsyncPropData(propName, defaultValue) {\n    const asyncProp = this.asyncProps[propName];\n    if (!asyncProp) {\n      // @ts-expect-error\n      const propTypes = this.component && this.component.constructor._propTypes;\n      // assert(defaultValue !== undefined);\n      this.asyncProps[propName] = {\n        type: propTypes && propTypes[propName],\n        lastValue: null, // Supplied prop value (can be url/promise, not visible to layer)\n        resolvedValue: defaultValue, // Resolved prop value (valid data, can be \"shown\" to layer)\n        pendingLoadCount: 0, // How many loads have been issued\n        resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n      };\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}