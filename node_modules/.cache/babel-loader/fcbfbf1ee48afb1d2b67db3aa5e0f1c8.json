{"ast":null,"code":"export function classifyRings(rings) {\n  const len = rings.length;\n  if (len <= 1) return [rings];\n  const polygons = [];\n  let polygon;\n  let ccw;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue;\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n\n  if (polygon) polygons.push(polygon);\n  return polygons;\n}\nexport function signedArea(ring) {\n  let sum = 0;\n\n  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n\n  return sum;\n}\nexport function readFeature(tag, feature, pbf) {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();else if (tag === 2) readTag(pbf, feature);else if (tag === 3) feature.type = pbf.readVarint();else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\nexport function readTag(pbf, feature) {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n\n    const value = feature._values[pbf.readVarint()];\n\n    feature.properties[key] = value;\n  }\n}","map":{"version":3,"mappings":"AASA,OAAO,SAASA,aAAT,CAAuBC,KAAvB,EAAiD;EACtD,MAAMC,GAAG,GAAGD,KAAK,CAACE,MAAlB;EAEA,IAAID,GAAG,IAAI,CAAX,EAAc,OAAO,CAACD,KAAD,CAAP;EAEd,MAAMG,QAAsB,GAAG,EAA/B;EACA,IAAIC,OAAJ;EACA,IAAIC,GAAJ;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAApB,EAAyBK,CAAC,EAA1B,EAA8B;IAC5B,MAAMC,IAAI,GAAGC,UAAU,CAACR,KAAK,CAACM,CAAD,CAAN,CAAvB;IACA,IAAIC,IAAI,KAAK,CAAb,EAAgB;IAEhB,IAAIF,GAAG,KAAKI,SAAZ,EAAuBJ,GAAG,GAAGE,IAAI,GAAG,CAAbF;;IAEvB,IAAIA,GAAG,KAAKE,IAAI,GAAG,CAAnB,EAAsB;MACpB,IAAIH,OAAJ,EAAaD,QAAQ,CAACO,IAATP,CAAcC,OAAdD;MACbC,OAAO,GAAG,CAACJ,KAAK,CAACM,CAAD,CAAN,CAAVF;IAFF,OAGO,IAAIA,OAAJ,EAAaA,OAAO,CAACM,IAARN,CAAaJ,KAAK,CAACM,CAAD,CAAlBF;EACrB;;EACD,IAAIA,OAAJ,EAAaD,QAAQ,CAACO,IAATP,CAAcC,OAAdD;EAEb,OAAOA,QAAP;AACD;AAOD,OAAO,SAASK,UAAT,CAAoBG,IAApB,EAAsC;EAC3C,IAAIC,GAAG,GAAG,CAAV;;EACA,KAAK,IAAIN,CAAC,GAAG,CAAR,EAAWO,CAAC,GAAGF,IAAI,CAACT,MAALS,GAAc,CAA7B,EAAgCG,EAAhC,EAA8CC,EAAnD,EAAiET,CAAC,GAAGK,IAAI,CAACT,MAA1E,EAAkFW,CAAC,GAAGP,CAAC,EAAvF,EAA2F;IACzFQ,EAAE,GAAGH,IAAI,CAACL,CAAD,CAATQ;IACAC,EAAE,GAAGJ,IAAI,CAACE,CAAD,CAATE;IACAH,GAAG,IAAI,CAACG,EAAE,CAAC,CAAD,CAAFA,GAAQD,EAAE,CAAC,CAAD,CAAX,KAAmBA,EAAE,CAAC,CAAD,CAAFA,GAAQC,EAAE,CAAC,CAAD,CAA7B,CAAPH;EACD;;EACD,OAAOA,GAAP;AACD;AAQD,OAAO,SAASI,WAAT,CAAqBC,GAArB,EAAkCC,OAAlC,EAA+DC,GAA/D,EAAqF;EAC1F,IAAID,OAAO,IAAIC,GAAf,EAAoB;IAClB,IAAIF,GAAG,KAAK,CAAZ,EAAeC,OAAO,CAACE,EAARF,GAAaC,GAAG,CAACE,UAAJF,EAAbD,CAAf,KACK,IAAID,GAAG,KAAK,CAAZ,EAAeK,OAAO,CAACH,GAAD,EAAMD,OAAN,CAAPI,CAAf,KACA,IAAIL,GAAG,KAAK,CAAZ,EAAeC,OAAO,CAACK,IAARL,GAAeC,GAAG,CAACE,UAAJF,EAAfD,CAAf,KACA,IAAID,GAAG,KAAK,CAAZ,EAAeC,OAAO,CAACM,SAARN,GAAoBC,GAAG,CAACM,GAAxBP;EACrB;AACF;AAOD,OAAO,SAASI,OAAT,CAAiBH,GAAjB,EAAgCD,OAAhC,EAAkE;EACvE,MAAMQ,GAAG,GAAGP,GAAG,CAACE,UAAJF,KAAmBA,GAAG,CAACM,GAAnC;;EAEA,OAAON,GAAG,CAACM,GAAJN,GAAUO,GAAjB,EAAsB;IACpB,MAAMC,GAAG,GAAGT,OAAO,CAACU,KAARV,CAAcC,GAAG,CAACE,UAAJF,EAAdD,CAAZ;;IACA,MAAMW,KAAK,GAAGX,OAAO,CAACY,OAARZ,CAAgBC,GAAG,CAACE,UAAJF,EAAhBD,CAAd;;IACAA,OAAO,CAACa,UAARb,CAAmBS,GAAnBT,IAA0BW,KAA1BX;EACD;AACF","names":["classifyRings","rings","len","length","polygons","polygon","ccw","i","area","signedArea","undefined","push","ring","sum","j","p1","p2","readFeature","tag","feature","pbf","id","readVarint","readTag","type","_geometry","pos","end","key","_keys","value","_values","properties"],"sources":["../../../src/helpers/mapbox-util-functions.ts"],"sourcesContent":["import Protobuf from 'pbf';\nimport {MvtMapboxGeometry} from '../lib/types';\nimport VectorTileFeature from '../lib/mapbox-vector-tile/vector-tile-feature';\n\n/**\n * Classifies an array of rings into polygons with outer rings and holes\n * @param rings\n * @returns polygons\n */\nexport function classifyRings(rings: MvtMapboxGeometry) {\n  const len = rings.length;\n\n  if (len <= 1) return [rings];\n\n  const polygons: number[][][] = [];\n  let polygon: number[][] | undefined;\n  let ccw: boolean | undefined;\n\n  for (let i = 0; i < len; i++) {\n    const area = signedArea(rings[i]);\n    if (area === 0) continue; // eslint-disable-line no-continue\n\n    if (ccw === undefined) ccw = area < 0;\n\n    if (ccw === area < 0) {\n      if (polygon) polygons.push(polygon);\n      polygon = [rings[i]];\n    } else if (polygon) polygon.push(rings[i]);\n  }\n  if (polygon) polygons.push(polygon);\n\n  return polygons;\n}\n\n/**\n *\n * @param ring\n * @returns sum\n */\nexport function signedArea(ring: number[][]) {\n  let sum = 0;\n  for (let i = 0, j = ring.length - 1, p1: number[], p2: number[]; i < ring.length; j = i++) {\n    p1 = ring[i];\n    p2 = ring[j];\n    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);\n  }\n  return sum;\n}\n\n/**\n *\n * @param tag\n * @param feature\n * @param pbf\n */\nexport function readFeature(tag: number, feature?: VectorTileFeature, pbf?: Protobuf): void {\n  if (feature && pbf) {\n    if (tag === 1) feature.id = pbf.readVarint();\n    else if (tag === 2) readTag(pbf, feature);\n    else if (tag === 3) feature.type = pbf.readVarint();\n    else if (tag === 4) feature._geometry = pbf.pos;\n  }\n}\n\n/**\n *\n * @param pbf\n * @param feature\n */\nexport function readTag(pbf: Protobuf, feature: VectorTileFeature): void {\n  const end = pbf.readVarint() + pbf.pos;\n\n  while (pbf.pos < end) {\n    const key = feature._keys[pbf.readVarint()];\n    const value = feature._values[pbf.readVarint()];\n    feature.properties[key] = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}