{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Layer, project32, picking, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport createMesh from './create-mesh';\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\nvar defaultProps = {\n  image: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  bounds: {\n    type: 'array',\n    value: [1, 0, 0, 1],\n    compare: true\n  },\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n  desaturate: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0\n  },\n  transparentColor: {\n    type: 'color',\n    value: [0, 0, 0, 0]\n  },\n  tintColor: {\n    type: 'color',\n    value: [255, 255, 255]\n  }\n};\n\nvar BitmapLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(BitmapLayer, _Layer);\n\n  var _super = _createSuper(BitmapLayer);\n\n  function BitmapLayer() {\n    _classCallCheck(this, BitmapLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BitmapLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(BitmapLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var attributeManager = this.getAttributeManager();\n      attributeManager.remove(['instancePickingColors']);\n      var noAlloc = true;\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.indices;\n          },\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.positions;\n          },\n          noAlloc: noAlloc\n        },\n        texCoords: {\n          size: 2,\n          update: function update(attribute) {\n            return attribute.value = _this.state.mesh.texCoords;\n          },\n          noAlloc: noAlloc\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.extensionsChanged) {\n        var _this$state$model;\n\n        var gl = this.context.gl;\n        (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n        this.state.model = this._getModel(gl);\n        this.getAttributeManager().invalidateAll();\n      }\n\n      var attributeManager = this.getAttributeManager();\n\n      if (props.bounds !== oldProps.bounds) {\n        var oldMesh = this.state.mesh;\n\n        var mesh = this._createMesh();\n\n        this.state.model.setVertexCount(mesh.vertexCount);\n\n        for (var key in mesh) {\n          if (oldMesh && oldMesh[key] !== mesh[key]) {\n            attributeManager.invalidate(key);\n          }\n        }\n\n        this.setState(_objectSpread({\n          mesh: mesh\n        }, this._getCoordinateUniforms()));\n      } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n        this.setState(this._getCoordinateUniforms());\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info;\n      var image = this.props.image;\n\n      if (!info.color || !image) {\n        info.bitmap = null;\n        return info;\n      }\n\n      var width = image.width,\n          height = image.height;\n      info.index = 0;\n      var uv = unpackUVsFromRGB(info.color);\n      var pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n      info.bitmap = {\n        size: {\n          width: width,\n          height: height\n        },\n        uv: uv,\n        pixel: pixel\n      };\n      return info;\n    }\n  }, {\n    key: \"disablePickingIndex\",\n    value: function disablePickingIndex() {\n      this.setState({\n        disablePicking: true\n      });\n    }\n  }, {\n    key: \"restorePickingColors\",\n    value: function restorePickingColors() {\n      this.setState({\n        disablePicking: false\n      });\n    }\n  }, {\n    key: \"_updateAutoHighlight\",\n    value: function _updateAutoHighlight(info) {\n      _get(_getPrototypeOf(BitmapLayer.prototype), \"_updateAutoHighlight\", this).call(this, _objectSpread(_objectSpread({}, info), {}, {\n        color: this.encodePickingColor(0)\n      }));\n    }\n  }, {\n    key: \"_createMesh\",\n    value: function _createMesh() {\n      var bounds = this.props.bounds;\n      var normalizedBounds = bounds;\n\n      if (Number.isFinite(bounds[0])) {\n        normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];\n      }\n\n      return createMesh(normalizedBounds, this.context.viewport.resolution);\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      if (!gl) {\n        return null;\n      }\n\n      return new Model(gl, _objectSpread(_objectSpread({}, this.getShaders()), {}, {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var uniforms = opts.uniforms,\n          moduleParameters = opts.moduleParameters;\n      var _this$state = this.state,\n          model = _this$state.model,\n          coordinateConversion = _this$state.coordinateConversion,\n          bounds = _this$state.bounds,\n          disablePicking = _this$state.disablePicking;\n      var _this$props = this.props,\n          image = _this$props.image,\n          desaturate = _this$props.desaturate,\n          transparentColor = _this$props.transparentColor,\n          tintColor = _this$props.tintColor;\n\n      if (moduleParameters.pickingActive && disablePicking) {\n        return;\n      }\n\n      if (image && model) {\n        model.setUniforms(uniforms).setUniforms({\n          bitmapTexture: image,\n          desaturate: desaturate,\n          transparentColor: transparentColor.map(function (x) {\n            return x / 255;\n          }),\n          tintColor: tintColor.slice(0, 3).map(function (x) {\n            return x / 255;\n          }),\n          coordinateConversion: coordinateConversion,\n          bounds: bounds\n        }).draw();\n      }\n    }\n  }, {\n    key: \"_getCoordinateUniforms\",\n    value: function _getCoordinateUniforms() {\n      var LNGLAT = COORDINATE_SYSTEM.LNGLAT,\n          CARTESIAN = COORDINATE_SYSTEM.CARTESIAN,\n          DEFAULT = COORDINATE_SYSTEM.DEFAULT;\n      var imageCoordinateSystem = this.props._imageCoordinateSystem;\n\n      if (imageCoordinateSystem !== DEFAULT) {\n        var bounds = this.props.bounds;\n\n        if (!Number.isFinite(bounds[0])) {\n          throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n        }\n\n        var defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n        imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n        if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n          return {\n            coordinateConversion: -1,\n            bounds: bounds\n          };\n        }\n\n        if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n          var bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n          var topRight = lngLatToWorld([bounds[2], bounds[3]]);\n          return {\n            coordinateConversion: 1,\n            bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n          };\n        }\n      }\n\n      return {\n        coordinateConversion: 0,\n        bounds: [0, 0, 0, 0]\n      };\n    }\n  }]);\n\n  return BitmapLayer;\n}(Layer);\n\nexport { BitmapLayer as default };\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n\nfunction unpackUVsFromRGB(color) {\n  var _color = _slicedToArray(color, 3),\n      u = _color[0],\n      v = _color[1],\n      fracUV = _color[2];\n\n  var vFrac = (fracUV & 0xf0) / 256;\n  var uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}","map":{"version":3,"mappings":"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","names":["Layer","project32","picking","COORDINATE_SYSTEM","Model","Geometry","lngLatToWorld","createMesh","vs","fs","defaultProps","image","type","value","async","bounds","compare","_imageCoordinateSystem","DEFAULT","desaturate","min","max","transparentColor","tintColor","BitmapLayer","getShaders","modules","initializeState","attributeManager","getAttributeManager","remove","noAlloc","add","indices","size","isIndexed","update","attribute","state","mesh","positions","fp64","use64bitPositions","texCoords","updateState","props","oldProps","changeFlags","extensionsChanged","gl","context","model","delete","_getModel","invalidateAll","oldMesh","_createMesh","setVertexCount","vertexCount","key","invalidate","setState","_getCoordinateUniforms","getPickingInfo","info","color","bitmap","width","height","index","uv","unpackUVsFromRGB","pixel","Math","floor","disablePickingIndex","disablePicking","restorePickingColors","_updateAutoHighlight","encodePickingColor","normalizedBounds","Number","isFinite","viewport","resolution","id","geometry","drawMode","isInstanced","draw","opts","uniforms","moduleParameters","coordinateConversion","pickingActive","setUniforms","bitmapTexture","map","x","slice","LNGLAT","CARTESIAN","imageCoordinateSystem","Error","defaultImageCoordinateSystem","bottomLeft","topRight","layerName","u","v","fracUV","vFrac","uFrac"],"sources":["../../../src/bitmap-layer/bitmap-layer.js"],"sourcesContent":["// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport {Layer, project32, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {Model, Geometry} from '@luma.gl/core';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\n\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst defaultProps = {\n  image: {type: 'image', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n  _imageCoordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/*\n * @class\n * @param {object} props\n * @param {number} props.transparentColor - color to interpret transparency to\n * @param {number} props.tintColor - color bias\n */\nexport default class BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    // setup model first\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      this.getAttributeManager().invalidateAll();\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh, ...this._getCoordinateUniforms()});\n    } else if (props._imageCoordinateSystem !== oldProps._imageCoordinateSystem) {\n      this.setState(this._getCoordinateUniforms());\n    }\n  }\n\n  getPickingInfo({info}) {\n    const {image} = this.props;\n\n    if (!info.color || !image) {\n      info.bitmap = null;\n      return info;\n    }\n\n    const {width, height} = image;\n\n    // Picking color doesn't represent object index in this layer\n    info.index = 0;\n\n    // Calculate uv and pixel in bitmap\n    const uv = unpackUVsFromRGB(info.color);\n\n    const pixel = [Math.floor(uv[0] * width), Math.floor(uv[1] * height)];\n\n    info.bitmap = {\n      size: {width, height}, // Size of bitmap\n      uv, // Floating point precision in 0-1 range\n      pixel // Truncated to integer and scaled to pixel size\n    };\n\n    return info;\n  }\n\n  // Override base Layer multi-depth picking logic\n  disablePickingIndex() {\n    this.setState({disablePicking: true});\n  }\n\n  restorePickingColors() {\n    this.setState({disablePicking: false});\n  }\n\n  _updateAutoHighlight(info) {\n    super._updateAutoHighlight({\n      ...info,\n      color: this.encodePickingColor(0)\n    });\n  }\n\n  _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (Number.isFinite(bounds[0])) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLES,\n        vertexCount: 6\n      }),\n      isInstanced: false\n    });\n  }\n\n  draw(opts) {\n    const {uniforms, moduleParameters} = opts;\n    const {model, coordinateConversion, bounds, disablePicking} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    if (moduleParameters.pickingActive && disablePicking) {\n      return;\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (image && model) {\n      model\n        .setUniforms(uniforms)\n        .setUniforms({\n          bitmapTexture: image,\n          desaturate,\n          transparentColor: transparentColor.map(x => x / 255),\n          tintColor: tintColor.slice(0, 3).map(x => x / 255),\n          coordinateConversion,\n          bounds\n        })\n        .draw();\n    }\n  }\n\n  _getCoordinateUniforms() {\n    const {LNGLAT, CARTESIAN, DEFAULT} = COORDINATE_SYSTEM;\n    let {_imageCoordinateSystem: imageCoordinateSystem} = this.props;\n    if (imageCoordinateSystem !== DEFAULT) {\n      const {bounds} = this.props;\n      if (!Number.isFinite(bounds[0])) {\n        throw new Error('_imageCoordinateSystem only supports rectangular bounds');\n      }\n\n      // The default behavior (linearly interpolated tex coords)\n      const defaultImageCoordinateSystem = this.context.viewport.resolution ? LNGLAT : CARTESIAN;\n      imageCoordinateSystem = imageCoordinateSystem === LNGLAT ? LNGLAT : CARTESIAN;\n\n      if (imageCoordinateSystem === LNGLAT && defaultImageCoordinateSystem === CARTESIAN) {\n        // LNGLAT in Mercator, e.g. display LNGLAT-encoded image in WebMercator projection\n        return {coordinateConversion: -1, bounds};\n      }\n      if (imageCoordinateSystem === CARTESIAN && defaultImageCoordinateSystem === LNGLAT) {\n        // Mercator in LNGLAT, e.g. display WebMercator encoded image in Globe projection\n        const bottomLeft = lngLatToWorld([bounds[0], bounds[1]]);\n        const topRight = lngLatToWorld([bounds[2], bounds[3]]);\n        return {\n          coordinateConversion: 1,\n          bounds: [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]]\n        };\n      }\n    }\n    return {\n      coordinateConversion: 0,\n      bounds: [0, 0, 0, 0]\n    };\n  }\n}\n\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n\n/**\n * Decode uv floats from rgb bytes where b contains 4-bit fractions of uv\n * @param {number[]} color\n * @returns {number[]} uvs\n * https://stackoverflow.com/questions/30242013/glsl-compressing-packing-multiple-0-1-colours-var4-into-a-single-var4-variab\n */\nfunction unpackUVsFromRGB(color) {\n  const [u, v, fracUV] = color;\n  const vFrac = (fracUV & 0xf0) / 256;\n  const uFrac = (fracUV & 0x0f) / 16;\n  return [(u + uFrac) / 256, (v + vFrac) / 256];\n}\n"]},"metadata":{},"sourceType":"module"}