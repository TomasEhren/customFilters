{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport { isMeshoptSupported, meshoptDecodeGltfBuffer } from '../../meshopt/meshopt-decoder';\nvar DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\nvar EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport var name = EXT_MESHOPT_COMPRESSION;\nexport function preprocess(gltfData) {\n  var scenegraph = new GLTFScenegraph(gltfData);\n\n  if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) && !isMeshoptSupported()) {\n    throw new Error(\"gltf: Required extension \".concat(EXT_MESHOPT_COMPRESSION, \" not supported by browser\"));\n  }\n}\nexport function decode(_x, _x2) {\n  return _decode.apply(this, arguments);\n}\n\nfunction _decode() {\n  _decode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gltfData, options) {\n    var _options$gltf, scenegraph, promises, _iterator, _step, bufferViewIndex;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            scenegraph = new GLTFScenegraph(gltfData);\n\n            if (options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 3:\n            promises = [];\n            _iterator = _createForOfIteratorHelper(gltfData.json.bufferViews || []);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                bufferViewIndex = _step.value;\n                promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            _context.next = 8;\n            return Promise.all(promises);\n\n          case 8:\n            scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _decode.apply(this, arguments);\n}\n\nfunction decodeMeshoptBufferView(_x3, _x4) {\n  return _decodeMeshoptBufferView.apply(this, arguments);\n}\n\nfunction _decodeMeshoptBufferView() {\n  _decodeMeshoptBufferView = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(scenegraph, bufferView) {\n    var meshoptExtension, buffer, _meshoptExtension$byt, byteOffset, _meshoptExtension$byt2, byteLength, byteStride, count, mode, _meshoptExtension$fil, filter, source, result;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n\n            if (!meshoptExtension) {\n              _context2.next = 9;\n              break;\n            }\n\n            buffer = bufferView.buffer;\n            _meshoptExtension$byt = meshoptExtension.byteOffset, byteOffset = _meshoptExtension$byt === void 0 ? 0 : _meshoptExtension$byt, _meshoptExtension$byt2 = meshoptExtension.byteLength, byteLength = _meshoptExtension$byt2 === void 0 ? 0 : _meshoptExtension$byt2, byteStride = meshoptExtension.byteStride, count = meshoptExtension.count, mode = meshoptExtension.mode, _meshoptExtension$fil = meshoptExtension.filter, filter = _meshoptExtension$fil === void 0 ? 'NONE' : _meshoptExtension$fil;\n            source = new Uint8Array(buffer, byteOffset, byteLength);\n            result = new ArrayBuffer(count * byteStride);\n            _context2.next = 8;\n            return meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n\n          case 8:\n            return _context2.abrupt(\"return\", result);\n\n          case 9:\n            return _context2.abrupt(\"return\", null);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _decodeMeshoptBufferView.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;AAGA,OAAOA,cAAP,MAA2B,wBAA3B;AACA,SAAQC,kBAAR,EAA4BC,uBAA5B,QAA0D,+BAA1D;AAIA,IAAMC,uBAAuB,GAAG;EAC9BC,UAAU,EAAE,CADkB;EAE9BC,MAAM,EAAE;AAFsB,CAAhC;AAMA,IAAMC,uBAAuB,GAAG,yBAAhC;AAEA,OAAO,IAAMC,IAAI,GAAGD,uBAAb;AAEP,OAAO,SAASE,UAAT,CAAoBC,QAApB,EAA4C;EACjD,IAAMC,UAAU,GAAG,IAAIV,cAAJ,CAAmBS,QAAnB,CAAnB;;EACA,IACEC,UAAU,CAACC,qBAAXD,GAAmCE,QAAnCF,CAA4CJ,uBAA5CI,KACA,CAACT,kBAAkB,EAFrB,EAGE;IACA,MAAM,IAAIY,KAAJ,oCAAsCP,uBAAtC,+BAAN;EACD;AACF;AAED,gBAAsBQ,MAAtB;EAAA;AAAA;;;qEAAO,iBAAsBL,QAAtB,EAA8CM,OAA9C;IAAA;;IAAA;MAAA;QAAA;UAAA;YACCL,UADD,GACc,IAAIV,cAAJ,CAAmBS,QAAnB,CADd;;YAAA,IAGAM,OAAD,SAACA,WAAD,WAACA,IAAD,iBAACA,OAAO,CAAEC,IAAV,UAACD,IAADE,wBAACF,kBAAeG,gBAHf;cAAA;cAAA;YAAA;;YAAA;;UAAA;YAOCC,QAPD,GAO4B,EAP5B;YAAA,uCAQyBV,QAAQ,CAACW,IAATX,CAAcY,WAAdZ,IAA6B,EARtD;;YAAA;cAQL,oDAA+D;gBAApDa,eAAoD;gBAC7DH,QAAQ,CAACI,IAATJ,CAAcK,uBAAuB,CAACd,UAAD,EAAaY,eAAb,CAArCH;cACD;YAVI;cAAA;YAAA;cAAA;YAAA;;YAAA;YAAA,OAaCM,OAAO,CAACC,GAARD,CAAYN,QAAZM,CAbD;;UAAA;YAgBLf,UAAU,CAACiB,eAAXjB,CAA2BJ,uBAA3BI;;UAhBK;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;SAoBQc,uB;;;;;sFAAf,kBACEd,UADF,EAEEkB,UAFF;IAAA;;IAAA;MAAA;QAAA;UAAA;YAIQC,gBAJR,GAI2BnB,UAAU,CAACoB,kBAAXpB,CACvBkB,UADuBlB,EAEvBJ,uBAFuBI,CAJ3B;;YAAA,KAQMmB,gBARN;cAAA;cAAA;YAAA;;YASUE,MATV,GASmBH,UAAU,CAACG,MAT9B;YAAA,wBAkBQF,gBAlBR,CAYMzB,UAZN,EAYMA,UAZN,sCAYmB,CAZnB,mDAkBQyB,gBAlBR,CAaMG,UAbN,EAaMA,UAbN,uCAamB,CAbnB,2BAcMC,UAdN,GAkBQJ,gBAlBR,CAcMI,UAdN,EAeMC,KAfN,GAkBQL,gBAlBR,CAeMK,KAfN,EAgBMC,IAhBN,GAkBQN,gBAlBR,CAgBMM,IAhBN,0BAkBQN,gBAlBR,CAiBMxB,MAjBN,EAiBMA,MAjBN,sCAiBe,MAjBf;YAqBU+B,MArBV,GAqBmB,IAAIC,UAAJ,CAAeN,MAAf,EAAuB3B,UAAvB,EAAmC4B,UAAnC,CArBnB;YAsBUM,MAtBV,GAsBmB,IAAIC,WAAJ,CAAgBL,KAAK,GAAGD,UAAxB,CAtBnB;YAAA;YAAA,OAuBU/B,uBAAuB,CAAC,IAAImC,UAAJ,CAAeC,MAAf,CAAD,EAAyBJ,KAAzB,EAAgCD,UAAhC,EAA4CG,MAA5C,EAAoDD,IAApD,EAA0D9B,MAA1D,CAvBjC;;UAAA;YAAA,kCAwBWiC,MAxBX;;UAAA;YAAA,kCA2BS,IA3BT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["GLTFScenegraph","isMeshoptSupported","meshoptDecodeGltfBuffer","DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","EXT_MESHOPT_COMPRESSION","name","preprocess","gltfData","scenegraph","getRequiredExtensions","includes","Error","decode","options","gltf","_options$gltf","decompressMeshes","promises","json","bufferViews","bufferViewIndex","push","decodeMeshoptBufferView","Promise","all","removeExtension","bufferView","meshoptExtension","getObjectExtension","buffer","byteLength","byteStride","count","mode","source","Uint8Array","result","ArrayBuffer"],"sources":["../../../../src/lib/extensions/EXT_meshopt_compression.ts"],"sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {isMeshoptSupported, meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport function preprocess(gltfData: {json: GLTF}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (\n    scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) &&\n    !isMeshoptSupported()\n  ) {\n    throw new Error(`gltf: Required extension ${EXT_MESHOPT_COMPRESSION} not supported by browser`);\n  }\n}\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n\n    // @ts-expect-error TODO - fix buffer handling\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}