{"ast":null,"code":"import { log } from '@deck.gl/core';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport { AGGREGATION_OPERATION, getValueFunc } from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport { getFloatTexture } from '../utils/resource-utils.js';\nconst defaultProps = { ...ScreenGridCellLayer.defaultProps,\n  getPosition: {\n    type: 'accessor',\n    value: d => d.position\n  },\n  getWeight: {\n    type: 'accessor',\n    value: 1\n  },\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {\n      gl\n    } = this.context;\n\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      this.setState({\n        supported: false\n      });\n      log.error(\"ScreenGridLayer: \".concat(this.id, \" is not supported on this browser\"))();\n      return;\n    }\n\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {\n          id: \"\".concat(this.id, \"-max-texture\")\n        })\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true,\n      weights,\n      subLayerData: {\n        attributes: {}\n      },\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 5130,\n        fp64: this.use64bitPositions()\n      },\n      count: {\n        size: 3,\n        accessor: 'getWeight'\n      }\n    });\n  }\n\n  shouldUpdateState(_ref) {\n    let {\n      changeFlags\n    } = _ref;\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n\n    const {\n      maxTexture,\n      numRow,\n      numCol,\n      weights\n    } = this.state;\n    const {\n      updateTriggers\n    } = this.props;\n    const {\n      aggregationBuffer\n    } = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    return new CellLayerClass(this.props, this.getSubLayerProps({\n      id: 'cell-layer',\n      updateTriggers\n    }), {\n      data: {\n        attributes: {\n          instanceCounts: aggregationBuffer\n        }\n      },\n      maxTexture,\n      numInstances: numRow * numCol\n    });\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    const {\n      aggregationBuffer,\n      maxBuffer,\n      maxTexture\n    } = this.state;\n    aggregationBuffer === null || aggregationBuffer === void 0 ? void 0 : aggregationBuffer.delete();\n    maxBuffer === null || maxBuffer === void 0 ? void 0 : maxBuffer.delete();\n    maxTexture === null || maxTexture === void 0 ? void 0 : maxTexture.delete();\n  }\n\n  getPickingInfo(_ref2) {\n    let {\n      info,\n      mode\n    } = _ref2;\n    const {\n      index\n    } = info;\n\n    if (index >= 0) {\n      const {\n        gpuGridAggregator,\n        gpuAggregation,\n        weights\n      } = this.state;\n      const aggregationResults = gpuAggregation ? gpuGridAggregator.getData('count') : weights.count;\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  updateResults(_ref3) {\n    let {\n      aggregationData,\n      maxData\n    } = _ref3;\n    const {\n      count\n    } = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({\n      data: aggregationData\n    });\n    count.maxData = maxData;\n    count.maxTexture.setImageData({\n      data: maxData\n    });\n  }\n\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {\n      viewportChanged\n    } = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n    const {\n      dimensions\n    } = this.state;\n    const {\n      data,\n      weights\n    } = dimensions;\n    const aggregationDataDirty = positionsChanged || gpuAggregationChanged || viewportChanged || this.isAggregationDirty(opts, {\n      compareAll: gpuAggregation,\n      dimension: data\n    });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {\n      dimension: weights\n    });\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n    const {\n      viewport\n    } = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {\n        width,\n        height\n      } = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        scaling: [width / 2, -height / 2, 1],\n        gridOffset: {\n          xOffset: cellSize,\n          yOffset: cellSize\n        },\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n\n  _updateAccessors(opts) {\n    const {\n      getWeight,\n      aggregation,\n      data\n    } = opts.props;\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n\n    this.setState({\n      getValue: getValueFunc(aggregation, getWeight, {\n        data\n      })\n    });\n  }\n\n  _resetResults() {\n    const {\n      count\n    } = this.state.weights;\n\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n\n}\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["log","GPUGridAggregator","AGGREGATION_OPERATION","getValueFunc","ScreenGridCellLayer","GridAggregationLayer","getFloatTexture","defaultProps","getPosition","type","value","d","position","getWeight","gpuAggregation","aggregation","POSITION_ATTRIBUTE_NAME","DIMENSIONS","data","props","weights","accessors","ScreenGridLayer","initializeState","gl","context","isSupported","setState","supported","error","id","dimensions","getCellSize","cellSizePixels","count","size","operation","SUM","needMax","maxTexture","projectPoints","subLayerData","attributes","positionAttributeName","posOffset","translation","attributeManager","getAttributeManager","add","accessor","fp64","use64bitPositions","shouldUpdateState","changeFlags","state","somethingChanged","updateState","opts","renderLayers","numRow","numCol","updateTriggers","aggregationBuffer","CellLayerClass","getSubLayerClass","getSubLayerProps","instanceCounts","numInstances","finalizeState","maxBuffer","delete","getPickingInfo","info","mode","index","gpuGridAggregator","aggregationResults","getData","object","getAggregationData","pixelIndex","updateResults","aggregationData","maxData","setData","setImageData","updateAggregationState","cellSize","cellSizeChanged","oldProps","viewportChanged","warn","gpuAggregationChanged","positionsChanged","isAttributeChanged","aggregationDataDirty","isAggregationDirty","compareAll","dimension","aggregationWeightsDirty","viewport","width","height","Math","ceil","allocateResources","scaling","gridOffset","xOffset","yOffset","_updateAccessors","_resetResults","getValue","layerName"],"sources":["../../../src/screen-grid-layer/screen-grid-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport GPUGridAggregator from '../utils/gpu-grid-aggregation/gpu-grid-aggregator';\nimport {AGGREGATION_OPERATION, getValueFunc} from '../utils/aggregation-operation-utils';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport GridAggregationLayer from '../grid-aggregation-layer';\nimport {getFloatTexture} from '../utils/resource-utils.js';\n\nconst defaultProps = {\n  ...ScreenGridCellLayer.defaultProps,\n  getPosition: {type: 'accessor', value: d => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\nconst POSITION_ATTRIBUTE_NAME = 'positions';\nconst DIMENSIONS = {\n  data: {\n    props: ['cellSizePixels']\n  },\n  weights: {\n    props: ['aggregation'],\n    accessors: ['getWeight']\n  }\n};\n\nexport default class ScreenGridLayer extends GridAggregationLayer {\n  initializeState() {\n    const {gl} = this.context;\n    if (!ScreenGridCellLayer.isSupported(gl)) {\n      // max aggregated value is sampled from a float texture\n      this.setState({supported: false});\n      log.error(`ScreenGridLayer: ${this.id} is not supported on this browser`)();\n      return;\n    }\n    super.initializeState({\n      dimensions: DIMENSIONS,\n      getCellSize: props => props.cellSizePixels\n    });\n    const weights = {\n      count: {\n        size: 1,\n        operation: AGGREGATION_OPERATION.SUM,\n        needMax: true,\n        maxTexture: getFloatTexture(gl, {id: `${this.id}-max-texture`})\n      }\n    };\n    this.setState({\n      supported: true,\n      projectPoints: true, // aggregation in screen space\n      weights,\n      subLayerData: {attributes: {}},\n      maxTexture: weights.count.maxTexture,\n      positionAttributeName: 'positions',\n      posOffset: [0, 0],\n      translation: [1, -1]\n    });\n    const attributeManager = this.getAttributeManager();\n    attributeManager.add({\n      [POSITION_ATTRIBUTE_NAME]: {\n        size: 3,\n        accessor: 'getPosition',\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      count: {size: 3, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}) {\n    return this.state.supported && changeFlags.somethingChanged;\n  }\n\n  updateState(opts) {\n    super.updateState(opts);\n  }\n\n  renderLayers() {\n    if (!this.state.supported) {\n      return [];\n    }\n    const {maxTexture, numRow, numCol, weights} = this.state;\n    const {updateTriggers} = this.props;\n    const {aggregationBuffer} = weights.count;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer',\n        updateTriggers\n      }),\n      {\n        data: {attributes: {instanceCounts: aggregationBuffer}},\n        maxTexture,\n        numInstances: numRow * numCol\n      }\n    );\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    const {aggregationBuffer, maxBuffer, maxTexture} = this.state;\n\n    aggregationBuffer?.delete();\n    maxBuffer?.delete();\n    maxTexture?.delete();\n  }\n\n  getPickingInfo({info, mode}) {\n    const {index} = info;\n    if (index >= 0) {\n      const {gpuGridAggregator, gpuAggregation, weights} = this.state;\n      // Get count aggregation results\n      const aggregationResults = gpuAggregation\n        ? gpuGridAggregator.getData('count')\n        : weights.count;\n\n      // Each instance (one cell) is aggregated into single pixel,\n      // Get current instance's aggregation details.\n      info.object = GPUGridAggregator.getAggregationData({\n        pixelIndex: index,\n        ...aggregationResults\n      });\n    }\n\n    return info;\n  }\n\n  // Aggregation Overrides\n\n  updateResults({aggregationData, maxData}) {\n    const {count} = this.state.weights;\n    count.aggregationData = aggregationData;\n    count.aggregationBuffer.setData({data: aggregationData});\n    count.maxData = maxData;\n    count.maxTexture.setImageData({data: maxData});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAggregationState(opts) {\n    const cellSize = opts.props.cellSizePixels;\n    const cellSizeChanged = opts.oldProps.cellSizePixels !== cellSize;\n    const {viewportChanged} = opts.changeFlags;\n    let gpuAggregation = opts.props.gpuAggregation;\n    if (this.state.gpuAggregation !== opts.props.gpuAggregation) {\n      if (gpuAggregation && !GPUGridAggregator.isSupported(this.context.gl)) {\n        log.warn('GPU Grid Aggregation not supported, falling back to CPU')();\n        gpuAggregation = false;\n      }\n    }\n    const gpuAggregationChanged = gpuAggregation !== this.state.gpuAggregation;\n    this.setState({\n      gpuAggregation\n    });\n\n    const positionsChanged = this.isAttributeChanged(POSITION_ATTRIBUTE_NAME);\n\n    const {dimensions} = this.state;\n    const {data, weights} = dimensions;\n    const aggregationDataDirty =\n      positionsChanged ||\n      gpuAggregationChanged ||\n      viewportChanged ||\n      this.isAggregationDirty(opts, {\n        compareAll: gpuAggregation, // check for all (including extentions props) when using gpu aggregation\n        dimension: data\n      });\n    const aggregationWeightsDirty = this.isAggregationDirty(opts, {dimension: weights});\n\n    this.setState({\n      aggregationDataDirty,\n      aggregationWeightsDirty\n    });\n\n    const {viewport} = this.context;\n\n    if (viewportChanged || cellSizeChanged) {\n      const {width, height} = viewport;\n      const numCol = Math.ceil(width / cellSize);\n      const numRow = Math.ceil(height / cellSize);\n      this.allocateResources(numRow, numCol);\n      this.setState({\n        // transformation from clipspace to screen(pixel) space\n        scaling: [width / 2, -height / 2, 1],\n\n        gridOffset: {xOffset: cellSize, yOffset: cellSize},\n        width,\n        height,\n        numCol,\n        numRow\n      });\n    }\n\n    if (aggregationWeightsDirty) {\n      this._updateAccessors(opts);\n    }\n    if (aggregationDataDirty || aggregationWeightsDirty) {\n      this._resetResults();\n    }\n  }\n  /* eslint-enable complexity, max-statements */\n\n  // Private\n\n  _updateAccessors(opts) {\n    const {getWeight, aggregation, data} = opts.props;\n    const {count} = this.state.weights;\n    if (count) {\n      count.getWeight = getWeight;\n      count.operation = AGGREGATION_OPERATION[aggregation];\n    }\n    this.setState({getValue: getValueFunc(aggregation, getWeight, {data})});\n  }\n\n  _resetResults() {\n    const {count} = this.state.weights;\n    if (count) {\n      count.aggregationData = null;\n    }\n  }\n}\n\nScreenGridLayer.layerName = 'ScreenGridLayer';\nScreenGridLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}