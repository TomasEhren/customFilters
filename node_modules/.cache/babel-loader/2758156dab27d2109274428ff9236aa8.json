{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _core = require(\"@luma.gl/core\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar Arrow2DGeometry = /*#__PURE__*/function (_Geometry) {\n  _inherits(Arrow2DGeometry, _Geometry);\n\n  var _super = _createSuper(Arrow2DGeometry);\n\n  function Arrow2DGeometry() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Arrow2DGeometry);\n\n    return _super.call(this, Object.assign({}, opts, {\n      attributes: getArrowAttributes(opts)\n    }));\n  }\n\n  return Arrow2DGeometry;\n}(_core.Geometry);\n\nexports[\"default\"] = Arrow2DGeometry;\n\nfunction getArrowAttributes(_ref) {\n  var _ref$length = _ref.length,\n      length = _ref$length === void 0 ? 1 : _ref$length,\n      _ref$headSize = _ref.headSize,\n      headSize = _ref$headSize === void 0 ? 0.2 : _ref$headSize,\n      _ref$tailWidth = _ref.tailWidth,\n      tailWidth = _ref$tailWidth === void 0 ? 0.05 : _ref$tailWidth,\n      _ref$tailStart = _ref.tailStart,\n      tailStart = _ref$tailStart === void 0 ? 0.05 : _ref$tailStart;\n  var texCoords = [// HEAD\n  0.5, 1.0, 0, 0.5 - headSize / 2, 1.0 - headSize, 0, 0.5 + headSize / 2, 1.0 - headSize, 0, 0.5 - tailWidth / 2, tailStart, 0, 0.5 + tailWidth / 2, 1.0 - headSize, 0, 0.5 + tailWidth / 2, tailStart, 0, 0.5 - tailWidth / 2, tailStart, 0, 0.5 - tailWidth / 2, 1.0 - headSize, 0, 0.5 + tailWidth / 2, 1.0 - headSize, 0];\n  var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]; // Center and scale\n\n  var positions = new Array(texCoords.length);\n\n  for (var i = 0; i < texCoords.length / 3; i++) {\n    var i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords)\n  };\n}","map":{"version":3,"mappings":"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","names":["Arrow2DGeometry","opts","_classCallCheck","Object","assign","attributes","getArrowAttributes","Geometry","length","headSize","tailWidth","tailStart","texCoords","normals","positions","Array","i","i3","Float32Array"],"sources":["../../../src/layers/path-marker-layer/arrow-2d-geometry.ts"],"sourcesContent":["import { Geometry } from '@luma.gl/core';\n\nexport default class Arrow2DGeometry extends Geometry {\n  constructor(opts = {}) {\n    super(\n      Object.assign({}, opts, {\n        attributes: getArrowAttributes(opts),\n      })\n    );\n  }\n}\n\nfunction getArrowAttributes({ length = 1, headSize = 0.2, tailWidth = 0.05, tailStart = 0.05 }) {\n  const texCoords = [\n    // HEAD\n    0.5,\n    1.0,\n    0,\n    0.5 - headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 + headSize / 2,\n    1.0 - headSize,\n    0,\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    tailStart,\n    0,\n    0.5 - tailWidth / 2,\n    1.0 - headSize,\n    0,\n    0.5 + tailWidth / 2,\n    1.0 - headSize,\n    0,\n  ];\n\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\n\n  // Center and scale\n  const positions = new Array(texCoords.length);\n  for (let i = 0; i < texCoords.length / 3; i++) {\n    const i3 = i * 3;\n    positions[i3 + 0] = (texCoords[i3 + 0] - 0.5) * length;\n    positions[i3 + 1] = (texCoords[i3 + 1] - 0.5) * length;\n    positions[i3 + 2] = 0;\n  }\n  return {\n    positions: new Float32Array(positions),\n    normals: new Float32Array(normals),\n    texCoords: new Float32Array(texCoords),\n  };\n}\n"]},"metadata":{},"sourceType":"script"}