{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _core = require(\"@deck.gl/core\");\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _meshLayers = require(\"@deck.gl/mesh-layers\");\n\nvar _pathOutlineLayer = _interopRequireDefault(require(\"../path-outline-layer/path-outline-layer\"));\n\nvar _arrow2dGeometry = _interopRequireDefault(require(\"./arrow-2d-geometry\"));\n\nvar _createPathMarkers = _interopRequireDefault(require(\"./create-path-markers\"));\n\nvar _polyline = require(\"./polyline\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DISTANCE_FOR_MULTI_ARROWS = 0.1;\nvar ARROW_HEAD_SIZE = 0.2;\nvar ARROW_TAIL_WIDTH = 0.05; // const ARROW_CENTER_ADJUST = -0.8;\n\nvar DEFAULT_MARKER_LAYER = _meshLayers.SimpleMeshLayer;\nvar DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new _arrow2dGeometry[\"default\"]({\n    headSize: ARROW_HEAD_SIZE,\n    tailWidth: ARROW_TAIL_WIDTH\n  })\n};\nvar defaultProps = Object.assign({}, _pathOutlineLayer[\"default\"].defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n  sizeScale: 100,\n  fp64: false,\n  highlightIndex: -1,\n  highlightPoint: null,\n  getPath: function getPath(x) {\n    return x.path;\n  },\n  getColor: function getColor(x) {\n    return x.color;\n  },\n  getMarkerColor: function getMarkerColor(x) {\n    return [0, 0, 0, 255];\n  },\n  getDirection: function getDirection(x) {\n    return x.direction;\n  },\n  getMarkerPercentages: function getMarkerPercentages(object, _ref) {\n    var lineLength = _ref.lineLength;\n    return lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5];\n  }\n});\n\nvar PathMarkerLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(PathMarkerLayer, _CompositeLayer);\n\n  var _super = _createSuper(PathMarkerLayer);\n\n  function PathMarkerLayer() {\n    _classCallCheck(this, PathMarkerLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PathMarkerLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        markers: [],\n        mesh: new _arrow2dGeometry[\"default\"]({\n          headSize: ARROW_HEAD_SIZE,\n          tailWidth: ARROW_TAIL_WIDTH\n        }),\n        closestPoint: null\n      };\n    } // @ts-ignore\n\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n      if (coordinateSystem === _core.COORDINATE_SYSTEM.METER_OFFSETS) {\n        var _viewport$metersToLng = viewport.metersToLngLatDelta(xyz),\n            _viewport$metersToLng2 = _slicedToArray(_viewport$metersToLng, 2),\n            dx = _viewport$metersToLng2[0],\n            dy = _viewport$metersToLng2[1];\n\n        var _coordinateOrigin = _slicedToArray(coordinateOrigin, 2),\n            _x = _coordinateOrigin[0],\n            y = _coordinateOrigin[1];\n\n        return viewport.projectFlat([_x + dx, dy + y]);\n      } else if (coordinateSystem === _core.COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n        var _xyz = _slicedToArray(xyz, 2),\n            _dx = _xyz[0],\n            _dy = _xyz[1];\n\n        var _coordinateOrigin2 = _slicedToArray(coordinateOrigin, 2),\n            _x2 = _coordinateOrigin2[0],\n            _y = _coordinateOrigin2[1];\n\n        return viewport.projectFlat([_x2 + _dx, _dy + _y]);\n      }\n\n      return viewport.projectFlat(xyz);\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var _this = this;\n\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n        var _this$props = this.props,\n            data = _this$props.data,\n            getPath = _this$props.getPath,\n            getDirection = _this$props.getDirection,\n            getMarkerColor = _this$props.getMarkerColor,\n            getMarkerPercentages = _this$props.getMarkerPercentages,\n            coordinateSystem = _this$props.coordinateSystem,\n            coordinateOrigin = _this$props.coordinateOrigin; // @ts-ignore\n\n        var viewport = this.context.viewport;\n\n        var projectFlat = function projectFlat(o) {\n          return _this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n        };\n\n        this.state.markers = (0, _createPathMarkers[\"default\"])({\n          data: data,\n          getPath: getPath,\n          getDirection: getDirection,\n          getColor: getMarkerColor,\n          getMarkerPercentages: getMarkerPercentages,\n          projectFlat: projectFlat\n        });\n\n        this._recalculateClosestPoint();\n      }\n\n      if (changeFlags.propsChanged) {\n        if (props.point !== oldProps.point) {\n          this._recalculateClosestPoint();\n        }\n      }\n    }\n  }, {\n    key: \"_recalculateClosestPoint\",\n    value: function _recalculateClosestPoint() {\n      var _this$props2 = this.props,\n          highlightPoint = _this$props2.highlightPoint,\n          highlightIndex = _this$props2.highlightIndex;\n\n      if (highlightPoint && highlightIndex >= 0) {\n        var object = this.props.data[highlightIndex];\n        var points = this.props.getPath(object);\n\n        var _getClosestPointOnPol = (0, _polyline.getClosestPointOnPolyline)({\n          points: points,\n          p: highlightPoint\n        }),\n            point = _getClosestPointOnPol.point;\n\n        this.state.closestPoints = [{\n          position: point\n        }];\n      } else {\n        this.state.closestPoints = [];\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref3) {\n      var info = _ref3.info;\n      return Object.assign(info, {\n        // override object with picked feature\n        object: info.object && info.object.path || info.object\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      return [new _pathOutlineLayer[\"default\"](this.props, // @ts-ignore\n      this.getSubLayerProps({\n        id: 'paths',\n        // Note: data has to be passed explicitly like this to avoid being empty\n        data: this.props.data\n      })), new this.props.MarkerLayer(this.getSubLayerProps(Object.assign({}, this.props.markerLayerProps, {\n        id: 'markers',\n        data: this.state.markers,\n        getOrientation: function getOrientation(x) {\n          return [0, -x.angle, 0];\n        },\n        getColor: function getColor(x) {\n          return x.color;\n        },\n        sizeScale: this.props.sizeScale,\n        fp64: this.props.fp64,\n        pickable: false,\n        parameters: {\n          blend: false,\n          depthTest: false\n        }\n      }))), this.state.closestPoints && new _layers.ScatterplotLayer({\n        id: \"\".concat(this.props.id, \"-highlight\"),\n        data: this.state.closestPoints,\n        // @ts-ignore\n        fp64: this.props.fp64\n      })];\n    }\n  }]);\n\n  return PathMarkerLayer;\n}(_core.CompositeLayer);\n\nexports[\"default\"] = PathMarkerLayer;\n\n_defineProperty(PathMarkerLayer, \"layerName\", 'PathMarkerLayer');\n\n_defineProperty(PathMarkerLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["DISTANCE_FOR_MULTI_ARROWS","ARROW_HEAD_SIZE","ARROW_TAIL_WIDTH","DEFAULT_MARKER_LAYER","SimpleMeshLayer","DEFAULT_MARKER_LAYER_PROPS","mesh","Arrow2DGeometry","headSize","tailWidth","defaultProps","Object","assign","PathOutlineLayer","MarkerLayer","markerLayerProps","sizeScale","fp64","highlightIndex","highlightPoint","getPath","x","path","getColor","color","getMarkerColor","getDirection","direction","getMarkerPercentages","object","lineLength","PathMarkerLayer","state","markers","closestPoint","xyz","viewport","coordinateSystem","coordinateOrigin","COORDINATE_SYSTEM","METER_OFFSETS","metersToLngLatDelta","dx","dy","y","projectFlat","LNGLAT_OFFSETS","props","oldProps","changeFlags","dataChanged","updateTriggersChanged","data","context","o","_this","_recalculateClosestPoint","propsChanged","point","points","p","closestPoints","position","info","getSubLayerProps","id","getOrientation","angle","pickable","parameters","blend","depthTest","ScatterplotLayer","CompositeLayer"],"sources":["../../../src/layers/path-marker-layer/path-marker-layer.ts"],"sourcesContent":["import { CompositeLayer, COORDINATE_SYSTEM } from '@deck.gl/core';\nimport { ScatterplotLayer } from '@deck.gl/layers';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport PathOutlineLayer, { PathOutlineLayerProps } from '../path-outline-layer/path-outline-layer';\nimport Arrow2DGeometry from './arrow-2d-geometry';\n\nimport createPathMarkers from './create-path-markers';\nimport { getClosestPointOnPolyline } from './polyline';\n\nconst DISTANCE_FOR_MULTI_ARROWS = 0.1;\nconst ARROW_HEAD_SIZE = 0.2;\nconst ARROW_TAIL_WIDTH = 0.05;\n// const ARROW_CENTER_ADJUST = -0.8;\n\nconst DEFAULT_MARKER_LAYER = SimpleMeshLayer;\n\nexport interface PathMarkerLayerProps<D> extends PathOutlineLayerProps<D> {\n  getDirection?: (x) => any;\n  getMarkerColor?: (x) => number[];\n  getMarkerPercentages?: (x: any, info: any) => number[];\n  highlightPoint?: any;\n  highlightIndex?: number;\n  MarkerLayer?: any;\n  markerLayerProps?: any;\n  sizeScale?: number;\n  fp64?: boolean;\n  nebulaLayer?: any;\n}\n\nconst DEFAULT_MARKER_LAYER_PROPS = {\n  mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n};\n\nconst defaultProps: PathMarkerLayerProps<any> = Object.assign({}, PathOutlineLayer.defaultProps, {\n  MarkerLayer: DEFAULT_MARKER_LAYER,\n  markerLayerProps: DEFAULT_MARKER_LAYER_PROPS,\n\n  sizeScale: 100,\n  fp64: false,\n\n  highlightIndex: -1,\n  highlightPoint: null,\n\n  getPath: (x) => x.path,\n  getColor: (x) => x.color,\n  getMarkerColor: (x) => [0, 0, 0, 255],\n  getDirection: (x) => x.direction,\n  getMarkerPercentages: (object, { lineLength }) =>\n    lineLength > DISTANCE_FOR_MULTI_ARROWS ? [0.25, 0.5, 0.75] : [0.5],\n});\n\nexport default class PathMarkerLayer extends CompositeLayer<any, PathMarkerLayerProps<any>> {\n  static layerName = 'PathMarkerLayer';\n  static defaultProps = defaultProps;\n\n  initializeState() {\n    this.state = {\n      markers: [],\n      mesh: new Arrow2DGeometry({ headSize: ARROW_HEAD_SIZE, tailWidth: ARROW_TAIL_WIDTH }),\n      closestPoint: null,\n    };\n  }\n  // @ts-ignore\n  projectFlat(xyz, viewport, coordinateSystem, coordinateOrigin) {\n    if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n      const [dx, dy] = viewport.metersToLngLatDelta(xyz);\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    } else if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n      const [dx, dy] = xyz;\n      const [x, y] = coordinateOrigin;\n      return viewport.projectFlat([x + dx, dy + y]);\n    }\n\n    return viewport.projectFlat(xyz);\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged) {\n      const {\n        data,\n        getPath,\n        getDirection,\n        getMarkerColor,\n        getMarkerPercentages,\n        coordinateSystem,\n        coordinateOrigin,\n      } = this.props;\n      // @ts-ignore\n      const { viewport } = this.context;\n      const projectFlat = (o) => this.projectFlat(o, viewport, coordinateSystem, coordinateOrigin);\n      this.state.markers = createPathMarkers({\n        data,\n        getPath,\n        getDirection,\n        getColor: getMarkerColor,\n        getMarkerPercentages,\n        projectFlat,\n      });\n      this._recalculateClosestPoint();\n    }\n    if (changeFlags.propsChanged) {\n      if (props.point !== oldProps.point) {\n        this._recalculateClosestPoint();\n      }\n    }\n  }\n\n  _recalculateClosestPoint() {\n    const { highlightPoint, highlightIndex } = this.props;\n    if (highlightPoint && highlightIndex >= 0) {\n      const object = this.props.data[highlightIndex];\n      const points = this.props.getPath(object);\n      const { point } = getClosestPointOnPolyline({ points, p: highlightPoint });\n      this.state.closestPoints = [\n        {\n          position: point,\n        },\n      ];\n    } else {\n      this.state.closestPoints = [];\n    }\n  }\n\n  getPickingInfo({ info }) {\n    return Object.assign(info, {\n      // override object with picked feature\n      object: (info.object && info.object.path) || info.object,\n    });\n  }\n\n  renderLayers() {\n    return [\n      new PathOutlineLayer(\n        this.props,\n        // @ts-ignore\n        this.getSubLayerProps({\n          id: 'paths',\n          // Note: data has to be passed explicitly like this to avoid being empty\n          data: this.props.data,\n        })\n      ),\n      new this.props.MarkerLayer(\n        this.getSubLayerProps(\n          Object.assign({}, this.props.markerLayerProps, {\n            id: 'markers',\n            data: this.state.markers,\n            getOrientation: (x) => [0, -x.angle, 0],\n            getColor: (x) => x.color,\n            sizeScale: this.props.sizeScale,\n            fp64: this.props.fp64,\n            pickable: false,\n            parameters: {\n              blend: false,\n              depthTest: false,\n            },\n          })\n        )\n      ),\n      this.state.closestPoints &&\n        new ScatterplotLayer({\n          id: `${this.props.id}-highlight`,\n          data: this.state.closestPoints,\n          // @ts-ignore\n          fp64: this.props.fp64,\n        }),\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}