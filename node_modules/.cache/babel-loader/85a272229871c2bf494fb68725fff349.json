{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { getPolygonSignedArea } from '@math.gl/polygon';\nexport function geojsonToFlatGeojson(features) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    coordLength: 2,\n    fixRingWinding: true\n  };\n  return features.map(function (feature) {\n    return flattenFeature(feature, options);\n  });\n}\n\nfunction flattenPoint(coordinates, data, indices, options) {\n  indices.push(data.length);\n  data.push.apply(data, _toConsumableArray(coordinates));\n\n  for (var i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n\nfunction flattenLineString(coordinates, data, indices, options) {\n  indices.push(data.length);\n\n  var _iterator = _createForOfIteratorHelper(coordinates),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n      data.push.apply(data, _toConsumableArray(c));\n\n      for (var i = c.length; i < options.coordLength; i++) {\n        data.push(0);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction flattenPolygon(coordinates, data, indices, areas, options) {\n  var count = 0;\n  var ringAreas = [];\n  var polygons = [];\n\n  var _iterator2 = _createForOfIteratorHelper(coordinates),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var lineString = _step2.value;\n      var lineString2d = lineString.map(function (p) {\n        return p.slice(0, 2);\n      });\n      var area = getPolygonSignedArea(lineString2d.flat());\n      var ccw = area < 0;\n\n      if (options.fixRingWinding && (count === 0 && !ccw || count > 0 && ccw)) {\n        lineString.reverse();\n        area = -area;\n      }\n\n      ringAreas.push(area);\n      flattenLineString(lineString, data, polygons, options);\n      count++;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n\nfunction flattenFeature(feature, options) {\n  var geometry = feature.geometry;\n\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n\n  var data = [];\n  var indices = [];\n  var areas;\n  var type;\n\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map(function (c) {\n        return flattenPoint(c, data, indices, options);\n      });\n      break;\n\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map(function (c) {\n        return flattenLineString(c, data, indices, options);\n      });\n      break;\n\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map(function (c) {\n        return flattenPolygon(c, data, indices, areas, options);\n      });\n      break;\n\n    default:\n      throw new Error(\"Unknown type: \".concat(type));\n  }\n\n  return _objectSpread(_objectSpread({}, feature), {}, {\n    geometry: {\n      type: type,\n      indices: indices,\n      data: data,\n      areas: areas\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["getPolygonSignedArea","geojsonToFlatGeojson","features","options","coordLength","fixRingWinding","map","feature","flattenFeature","flattenPoint","coordinates","data","indices","push","length","i","flattenLineString","c","flattenPolygon","areas","count","ringAreas","polygons","lineString","lineString2d","p","slice","area","flat","ccw","reverse","geometry","type","Error"],"sources":["../../../src/lib/geojson-to-flat-geojson.ts"],"sourcesContent":["import {getPolygonSignedArea} from '@math.gl/polygon';\n\nimport {Feature, Position, FlatFeature} from '@loaders.gl/schema';\n\n/**\n * Options for `geojsonToFlatGeojson`\n */\nexport type GeojsonToFlatGeojsonOptions = {\n  coordLength: number;\n  fixRingWinding: boolean;\n};\n\n// Coordinates defining a Point\ntype PointCoordinates = Position;\n// Coordinates defining a LineString\ntype LineStringCoordinates = Position[];\n// Coordinates defining a Polygon\ntype PolygonCoordinates = Position[][];\n\n/**\n * Convert GeoJSON features to Flat GeoJSON features\n *\n * @param features\n * @param options\n * @returns an Array of Flat GeoJSON features\n */\nexport function geojsonToFlatGeojson(\n  features: Feature[],\n  options: GeojsonToFlatGeojsonOptions = {coordLength: 2, fixRingWinding: true}\n): FlatFeature[] {\n  return features.map((feature) => flattenFeature(feature, options));\n}\n\n/**\n * Helper function to copy Point values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenPoint(\n  coordinates: PointCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  data.push(...coordinates);\n\n  // Pad up to coordLength\n  for (let i = coordinates.length; i < options.coordLength; i++) {\n    data.push(0);\n  }\n}\n\n/**\n * Helper function to copy LineString values from `coordinates` into `data` & `indices`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param options\n */\nfunction flattenLineString(\n  coordinates: LineStringCoordinates,\n  data: number[],\n  indices: number[],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  indices.push(data.length);\n  for (const c of coordinates) {\n    data.push(...c);\n\n    // Pad up to coordLength\n    for (let i = c.length; i < options.coordLength; i++) {\n      data.push(0);\n    }\n  }\n}\n\n/**\n * Helper function to copy Polygon values from `coordinates` into `data` & `indices` & `areas`\n *\n * @param coordinates\n * @param data\n * @param indices\n * @param areas\n * @param options\n */\nfunction flattenPolygon(\n  coordinates: PolygonCoordinates,\n  data: number[],\n  indices: number[][],\n  areas: number[][],\n  options: GeojsonToFlatGeojsonOptions\n) {\n  let count = 0;\n  const ringAreas: number[] = [];\n  const polygons: number[] = [];\n  for (const lineString of coordinates) {\n    const lineString2d = lineString.map((p) => p.slice(0, 2));\n    let area = getPolygonSignedArea(lineString2d.flat());\n    const ccw = area < 0;\n\n    // Exterior ring must be CCW and interior rings CW\n    if (options.fixRingWinding && ((count === 0 && !ccw) || (count > 0 && ccw))) {\n      lineString.reverse();\n      area = -area;\n    }\n    ringAreas.push(area);\n    flattenLineString(lineString, data, polygons, options);\n    count++;\n  }\n\n  if (count > 0) {\n    areas.push(ringAreas);\n    indices.push(polygons);\n  }\n}\n\n/**\n * Flatten single GeoJSON feature into Flat GeoJSON\n *\n * @param feature\n * @param options\n * @returns A Flat GeoJSON feature\n */\nfunction flattenFeature(feature: Feature, options: GeojsonToFlatGeojsonOptions): FlatFeature {\n  const {geometry} = feature;\n  if (geometry.type === 'GeometryCollection') {\n    throw new Error('GeometryCollection type not supported');\n  }\n  const data = [];\n  const indices = [];\n  let areas;\n  let type;\n\n  switch (geometry.type) {\n    case 'Point':\n      type = 'Point';\n      flattenPoint(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiPoint':\n      type = 'Point';\n      geometry.coordinates.map((c) => flattenPoint(c, data, indices, options));\n      break;\n    case 'LineString':\n      type = 'LineString';\n      flattenLineString(geometry.coordinates, data, indices, options);\n      break;\n    case 'MultiLineString':\n      type = 'LineString';\n      geometry.coordinates.map((c) => flattenLineString(c, data, indices, options));\n      break;\n    case 'Polygon':\n      type = 'Polygon';\n      areas = [];\n      flattenPolygon(geometry.coordinates, data, indices, areas, options);\n      break;\n    case 'MultiPolygon':\n      type = 'Polygon';\n      areas = [];\n      geometry.coordinates.map((c) => flattenPolygon(c, data, indices, areas, options));\n      break;\n    default:\n      throw new Error(`Unknown type: ${type}`);\n  }\n\n  return {...feature, geometry: {type, indices, data, areas}};\n}\n"]},"metadata":{},"sourceType":"module"}