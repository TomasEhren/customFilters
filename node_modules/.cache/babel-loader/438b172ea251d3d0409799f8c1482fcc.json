{"ast":null,"code":"import { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: x => x.position\n  },\n  getIcon: {\n    type: 'accessor',\n    value: x => x.icon\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  }\n};\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, picking]\n    });\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 5130,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIcon',\n        transform: this.getInstanceOffset\n      },\n      instanceIconFrames: {\n        size: 4,\n        accessor: 'getIcon',\n        transform: this.getInstanceIconFrame\n      },\n      instanceColorModes: {\n        size: 1,\n        type: 5121,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: 5121,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n  }\n\n  updateState(_ref) {\n    let {\n      oldProps,\n      props,\n      changeFlags\n    } = _ref;\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n    const attributeManager = this.getAttributeManager();\n    const {\n      iconAtlas,\n      iconMapping,\n      data,\n      getIcon\n    } = props;\n    const {\n      iconManager\n    } = this.state;\n    iconManager.setProps({\n      loadOptions: props.loadOptions\n    });\n    let iconMappingChanged = false;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({\n          iconAtlas,\n          autoPacking: false\n        });\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({\n          iconMapping\n        });\n        iconMappingChanged = true;\n      }\n    } else {\n      iconManager.setProps({\n        autoPacking: true\n      });\n    }\n\n    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n      iconManager.setProps({\n        data,\n        getIcon\n      });\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets');\n      attributeManager.invalidate('instanceIconFrames');\n      attributeManager.invalidate('instanceColorModes');\n    }\n\n    if (changeFlags.extensionsChanged) {\n      var _this$state$model;\n\n      const {\n        gl\n      } = this.context;\n      (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    this.state.iconManager.finalize();\n  }\n\n  draw(_ref2) {\n    let {\n      uniforms\n    } = _ref2;\n    const {\n      sizeScale,\n      sizeMinPixels,\n      sizeMaxPixels,\n      sizeUnits,\n      billboard,\n      alphaCutoff\n    } = this.props;\n    const {\n      iconManager\n    } = this.state;\n    const iconsTexture = iconManager.getTexture();\n\n    if (iconsTexture) {\n      this.state.model.setUniforms(uniforms).setUniforms({\n        iconsTexture,\n        iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n        sizeUnits: UNIT[sizeUnits],\n        sizeScale,\n        sizeMinPixels,\n        sizeMaxPixels,\n        billboard,\n        alphaCutoff\n      }).draw();\n    }\n  }\n\n  _getModel(gl) {\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n    return new Model(gl, { ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: 6,\n        attributes: {\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    const {\n      onIconError\n    } = this.getCurrentLayer().props;\n\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n  }\n\n}\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Layer","project32","picking","log","UNIT","Model","Geometry","vs","fs","IconManager","DEFAULT_COLOR","defaultProps","iconAtlas","type","value","async","iconMapping","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","max","getPosition","x","position","getIcon","icon","getColor","getSize","getAngle","getPixelOffset","onIconError","compare","optional","IconLayer","getShaders","modules","initializeState","state","iconManager","context","gl","onUpdate","_onUpdate","bind","onError","_onError","attributeManager","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","transition","accessor","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","props","colorFormat","length","normalized","instanceAngles","instancePixelOffset","updateState","oldProps","changeFlags","data","setProps","loadOptions","iconMappingChanged","prePacked","internalState","isAsyncPropLoading","autoPacking","dataChanged","updateTriggersChanged","all","invalidate","extensionsChanged","model","delete","_getModel","invalidateAll","isLoaded","finalizeState","finalize","draw","uniforms","iconsTexture","getTexture","setUniforms","iconsTextureDim","width","height","positions","id","geometry","drawMode","attributes","Float32Array","isInstanced","setNeedsRedraw","evt","getCurrentLayer","error","rect","getIconMapping","anchorX","anchorY","mapping","mask","y","layerName"],"sources":["../../../src/icon-layer/icon-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking, log, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n * @param {func} props.getAngle - returns rotating angle (in degree) of the icon.\n */\nconst defaultProps = {\n  iconAtlas: {type: 'image', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  onIconError: {type: 'function', value: null, compare: false, optional: true}\n};\n\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {size: 2, accessor: 'getIcon', transform: this.getInstanceOffset},\n      instanceIconFrames: {size: 4, accessor: 'getIcon', transform: this.getInstanceIconFrame},\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon} = props;\n    const {iconManager} = this.state;\n\n    iconManager.setProps({loadOptions: props.loadOptions});\n\n    let iconMappingChanged = false;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({iconAtlas, autoPacking: false});\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({iconMapping});\n        iconMappingChanged = true;\n      }\n    } else {\n      // otherwise, use autoPacking\n      iconManager.setProps({autoPacking: true});\n    }\n\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      iconManager.setProps({data, getIcon});\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets');\n      attributeManager.invalidate('instanceIconFrames');\n      attributeManager.invalidate('instanceColorModes');\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}) {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture) {\n      this.state.model\n        .setUniforms(uniforms)\n        .setUniforms({\n          iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeUnits: UNIT[sizeUnits],\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          billboard,\n          alphaCutoff\n        })\n        .draw();\n    }\n  }\n\n  _getModel(gl) {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    const {onIconError} = this.getCurrentLayer().props;\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n  }\n}\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}