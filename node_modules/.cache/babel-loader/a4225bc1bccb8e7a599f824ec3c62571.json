{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModifyMode = void 0;\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _utils = require(\"../utils\");\n\nvar _geojsonEditMode = require(\"./geojson-edit-mode\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar ModifyMode = /*#__PURE__*/function (_GeoJsonEditMode) {\n  _inherits(ModifyMode, _GeoJsonEditMode);\n\n  var _super = _createSuper(ModifyMode);\n\n  function ModifyMode() {\n    _classCallCheck(this, ModifyMode);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ModifyMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      var _this = this;\n\n      var handles = [];\n      var data = props.data,\n          lastPointerMoveEvent = props.lastPointerMoveEvent;\n      var features = data.features;\n      var picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n      var mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n      var _iterator = _createForOfIteratorHelper(props.selectedIndexes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _index = _step.value;\n\n          if (_index < features.length) {\n            var geometry = features[_index].geometry;\n            handles.push.apply(handles, _toConsumableArray((0, _utils.getEditHandlesForGeometry)(geometry, _index)));\n          } else {\n            console.warn(\"selectedFeatureIndexes out of range \".concat(_index)); // eslint-disable-line no-console,no-undef\n          }\n        } // intermediate edit handle\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (picks && picks.length && mapCoords) {\n        var _props$modeConfig;\n\n        var existingEditHandle = (0, _utils.getPickedExistingEditHandle)(picks); // don't show intermediate point when too close to an existing edit handle\n\n        var featureAsPick = !existingEditHandle && picks.find(function (pick) {\n          return !pick.isGuide;\n        }); // is the feature in the pick selected\n\n        if (featureAsPick && !featureAsPick.object.geometry.type.includes('Point') && !(((_props$modeConfig = props.modeConfig) === null || _props$modeConfig === void 0 ? void 0 : _props$modeConfig.lockRectangles) && featureAsPick.object.properties.shape === 'Rectangle') && props.selectedIndexes.includes(featureAsPick.index)) {\n          var intermediatePoint = null;\n          var positionIndexPrefix = [];\n          var referencePoint = (0, _helpers.point)(mapCoords); // process all lines of the (single) feature\n\n          (0, _utils.recursivelyTraverseNestedArrays)(featureAsPick.object.geometry.coordinates, [], function (lineString, prefix) {\n            var lineStringFeature = (0, _helpers.lineString)(lineString);\n\n            var candidateIntermediatePoint = _this.getNearestPoint( // @ts-ignore\n            lineStringFeature, referencePoint, props.modeConfig && props.modeConfig.viewport);\n\n            if (!intermediatePoint || candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }); // tack on the lone intermediate point to the set of handles\n\n          if (intermediatePoint) {\n            var _intermediatePoint = intermediatePoint,\n                position = _intermediatePoint.geometry.coordinates,\n                index = _intermediatePoint.properties.index;\n            handles.push({\n              type: 'Feature',\n              properties: {\n                guideType: 'editHandle',\n                editHandleType: 'intermediate',\n                featureIndex: featureAsPick.index,\n                positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [index + 1])\n              },\n              geometry: {\n                type: 'Point',\n                coordinates: position\n              }\n            });\n          }\n        }\n      }\n\n      return {\n        type: 'FeatureCollection',\n        features: handles\n      };\n    } // turf.js does not support elevation for nearestPointOnLine\n\n  }, {\n    key: \"getNearestPoint\",\n    value: function getNearestPoint(line, inPoint, viewport) {\n      var coordinates = line.geometry.coordinates;\n\n      if (coordinates.some(function (coord) {\n        return coord.length > 2;\n      })) {\n        if (viewport) {\n          // This line has elevation, we need to use alternative algorithm\n          return (0, _utils.nearestPointOnProjectedLine)(line, inPoint, viewport);\n        } // eslint-disable-next-line no-console,no-undef\n\n\n        console.log('Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.');\n      }\n\n      return (0, _utils.nearestPointOnLine)(line, inPoint, viewport);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {\n      var pickedExistingHandle = (0, _utils.getPickedExistingEditHandle)(event.picks);\n      var pickedIntermediateHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (pickedExistingHandle) {\n        var _pickedExistingHandle = pickedExistingHandle.properties,\n            featureIndex = _pickedExistingHandle.featureIndex,\n            positionIndexes = _pickedExistingHandle.positionIndexes;\n        var updatedData;\n\n        try {\n          updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).removePosition(featureIndex, positionIndexes).getObject();\n        } catch (ignored) {// This happens if user attempts to remove the last point\n        }\n\n        if (updatedData) {\n          props.onEdit({\n            updatedData: updatedData,\n            editType: 'removePosition',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes: positionIndexes,\n              position: pickedExistingHandle.geometry.coordinates\n            }\n          });\n        }\n      } else if (pickedIntermediateHandle) {\n        var _props$modeConfig2;\n\n        var _pickedIntermediateHa = pickedIntermediateHandle.properties,\n            _featureIndex = _pickedIntermediateHa.featureIndex,\n            _positionIndexes = _pickedIntermediateHa.positionIndexes;\n        var feature = props.data.features[_featureIndex];\n        var canAddPosition = !(((_props$modeConfig2 = props.modeConfig) === null || _props$modeConfig2 === void 0 ? void 0 : _props$modeConfig2.lockRectangles) && (feature === null || feature === void 0 ? void 0 : feature.properties.shape) === 'Rectangle');\n\n        if (canAddPosition) {\n          var _updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(_featureIndex, _positionIndexes, pickedIntermediateHandle.geometry.coordinates).getObject();\n\n          if (_updatedData) {\n            props.onEdit({\n              updatedData: _updatedData,\n              editType: 'addPosition',\n              editContext: {\n                featureIndexes: [_featureIndex],\n                positionIndexes: _positionIndexes,\n                position: pickedIntermediateHandle.geometry.coordinates\n              }\n            });\n          }\n        }\n      }\n    }\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {\n      var editHandle = (0, _utils.getPickedEditHandle)(event.pointerDownPicks);\n\n      if (editHandle) {\n        // Cancel map panning if pointer went down on an edit handle\n        event.cancelPan();\n\n        this._dragEditHandle('movePosition', props, editHandle, event);\n      }\n    }\n  }, {\n    key: \"_dragEditHandle\",\n    value: function _dragEditHandle(editType, props, editHandle, event) {\n      var _props$modeConfig3;\n\n      var editHandleProperties = editHandle.properties;\n      var editedFeature = props.data.features[editHandleProperties.featureIndex];\n      var updatedData;\n\n      if (((_props$modeConfig3 = props.modeConfig) === null || _props$modeConfig3 === void 0 ? void 0 : _props$modeConfig3.lockRectangles) && editedFeature.properties.shape === 'Rectangle') {\n        var coordinates = (0, _utils.updateRectanglePosition)(editedFeature, editHandleProperties.positionIndexes[1], event.mapCoords);\n        updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(editHandleProperties.featureIndex, {\n          coordinates: coordinates,\n          type: 'Polygon'\n        }).getObject();\n      } else {\n        updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replacePosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();\n      }\n\n      props.onEdit({\n        updatedData: updatedData,\n        editType: editType,\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n          positionIndexes: editHandleProperties.positionIndexes,\n          position: event.mapCoords\n        }\n      });\n    }\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var cursor = this.getCursor(event);\n      props.onUpdateCursor(cursor);\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedIntermediateEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        var editHandleProperties = editHandle.properties;\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).addPosition(editHandleProperties.featureIndex, editHandleProperties.positionIndexes, event.mapCoords).getObject();\n        props.onEdit({\n          updatedData: updatedData,\n          editType: 'addPosition',\n          editContext: {\n            featureIndexes: [editHandleProperties.featureIndex],\n            positionIndexes: editHandleProperties.positionIndexes,\n            position: event.mapCoords\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {\n      var selectedFeatureIndexes = props.selectedIndexes;\n      var editHandle = (0, _utils.getPickedEditHandle)(event.picks);\n\n      if (selectedFeatureIndexes.length && editHandle) {\n        this._dragEditHandle('finishMovePosition', props, editHandle, event);\n      }\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(event) {\n      var picks = event && event.picks || [];\n      var handlesPicked = (0, _utils.getPickedEditHandles)(picks);\n\n      if (handlesPicked.length) {\n        return 'cell';\n      }\n\n      return null;\n    }\n  }]);\n\n  return ModifyMode;\n}(_geojsonEditMode.GeoJsonEditMode);\n\nexports.ModifyMode = ModifyMode;","map":{"version":3,"mappings":"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","names":["ModifyMode","props","handles","data","lastPointerMoveEvent","features","picks","mapCoords","selectedIndexes","index","length","geometry","push","_toConsumableArray","console","warn","_iterator","existingEditHandle","featureAsPick","find","pick","isGuide","object","type","includes","modeConfig","lockRectangles","properties","shape","intermediatePoint","positionIndexPrefix","referencePoint","coordinates","lineString","prefix","lineStringFeature","candidateIntermediatePoint","_this","getNearestPoint","viewport","dist","position","guideType","editHandleType","featureIndex","positionIndexes","line","inPoint","some","coord","log","event","pickedExistingHandle","pickedIntermediateHandle","updatedData","ImmutableFeatureCollection","removePosition","getObject","ignored","onEdit","editType","editContext","featureIndexes","feature","canAddPosition","addPosition","editHandle","pointerDownPicks","cancelPan","_dragEditHandle","editHandleProperties","editedFeature","replaceGeometry","replacePosition","cursor","getCursor","onUpdateCursor","selectedFeatureIndexes","handlesPicked","GeoJsonEditMode"],"sources":["../../src/lib/modify-mode.ts"],"sourcesContent":["import { point, lineString as toLineString } from '@turf/helpers';\nimport {\n  recursivelyTraverseNestedArrays,\n  nearestPointOnProjectedLine,\n  nearestPointOnLine,\n  getEditHandlesForGeometry,\n  getPickedEditHandles,\n  getPickedEditHandle,\n  getPickedExistingEditHandle,\n  getPickedIntermediateEditHandle,\n  updateRectanglePosition,\n  NearestPointType,\n} from '../utils';\nimport { LineString, Point, Polygon, FeatureCollection, FeatureOf } from '../geojson-types';\nimport {\n  ModeProps,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Viewport,\n  GuideFeatureCollection,\n  EditHandleFeature,\n} from '../types';\nimport { GeoJsonEditMode } from './geojson-edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport class ModifyMode extends GeoJsonEditMode {\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    const handles = [];\n\n    const { data, lastPointerMoveEvent } = props;\n    const { features } = data;\n    const picks = lastPointerMoveEvent && lastPointerMoveEvent.picks;\n    const mapCoords = lastPointerMoveEvent && lastPointerMoveEvent.mapCoords;\n\n    for (const index of props.selectedIndexes) {\n      if (index < features.length) {\n        const { geometry } = features[index];\n        handles.push(...getEditHandlesForGeometry(geometry, index));\n      } else {\n        console.warn(`selectedFeatureIndexes out of range ${index}`); // eslint-disable-line no-console,no-undef\n      }\n    }\n\n    // intermediate edit handle\n    if (picks && picks.length && mapCoords) {\n      const existingEditHandle = getPickedExistingEditHandle(picks);\n      // don't show intermediate point when too close to an existing edit handle\n      const featureAsPick = !existingEditHandle && picks.find((pick) => !pick.isGuide);\n\n      // is the feature in the pick selected\n      if (\n        featureAsPick &&\n        !featureAsPick.object.geometry.type.includes('Point') &&\n        !(\n          props.modeConfig?.lockRectangles && featureAsPick.object.properties.shape === 'Rectangle'\n        ) &&\n        props.selectedIndexes.includes(featureAsPick.index)\n      ) {\n        let intermediatePoint: NearestPointType | null | undefined = null;\n        let positionIndexPrefix = [];\n        const referencePoint = point(mapCoords);\n        // process all lines of the (single) feature\n        recursivelyTraverseNestedArrays(\n          featureAsPick.object.geometry.coordinates,\n          [],\n          (lineString, prefix) => {\n            const lineStringFeature = toLineString(lineString);\n            const candidateIntermediatePoint = this.getNearestPoint(\n              // @ts-ignore\n              lineStringFeature,\n              referencePoint,\n              props.modeConfig && props.modeConfig.viewport\n            );\n            if (\n              !intermediatePoint ||\n              candidateIntermediatePoint.properties.dist < intermediatePoint.properties.dist\n            ) {\n              intermediatePoint = candidateIntermediatePoint;\n              positionIndexPrefix = prefix;\n            }\n          }\n        );\n        // tack on the lone intermediate point to the set of handles\n        if (intermediatePoint) {\n          const {\n            geometry: { coordinates: position },\n            properties: { index },\n          } = intermediatePoint;\n          handles.push({\n            type: 'Feature',\n            properties: {\n              guideType: 'editHandle',\n              editHandleType: 'intermediate',\n              featureIndex: featureAsPick.index,\n              positionIndexes: [...positionIndexPrefix, index + 1],\n            },\n            geometry: {\n              type: 'Point',\n              coordinates: position,\n            },\n          });\n        }\n      }\n    }\n\n    return {\n      type: 'FeatureCollection',\n      features: handles,\n    };\n  }\n\n  // turf.js does not support elevation for nearestPointOnLine\n  getNearestPoint(\n    line: FeatureOf<LineString>,\n    inPoint: FeatureOf<Point>,\n    viewport: Viewport | null | undefined\n  ): NearestPointType {\n    const { coordinates } = line.geometry;\n    if (coordinates.some((coord) => coord.length > 2)) {\n      if (viewport) {\n        // This line has elevation, we need to use alternative algorithm\n        return nearestPointOnProjectedLine(line, inPoint, viewport);\n      }\n      // eslint-disable-next-line no-console,no-undef\n      console.log(\n        'Editing 3D point but modeConfig.viewport not provided. Falling back to 2D logic.'\n      );\n    }\n    return nearestPointOnLine(line, inPoint, viewport);\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>) {\n    const pickedExistingHandle = getPickedExistingEditHandle(event.picks);\n    const pickedIntermediateHandle = getPickedIntermediateEditHandle(event.picks);\n\n    if (pickedExistingHandle) {\n      const { featureIndex, positionIndexes } = pickedExistingHandle.properties;\n\n      let updatedData;\n      try {\n        updatedData = new ImmutableFeatureCollection(props.data)\n          .removePosition(featureIndex, positionIndexes)\n          .getObject();\n      } catch (ignored) {\n        // This happens if user attempts to remove the last point\n      }\n\n      if (updatedData) {\n        props.onEdit({\n          updatedData,\n          editType: 'removePosition',\n          editContext: {\n            featureIndexes: [featureIndex],\n            positionIndexes,\n            position: pickedExistingHandle.geometry.coordinates,\n          },\n        });\n      }\n    } else if (pickedIntermediateHandle) {\n      const { featureIndex, positionIndexes } = pickedIntermediateHandle.properties;\n\n      const feature = props.data.features[featureIndex];\n      const canAddPosition = !(\n        props.modeConfig?.lockRectangles && feature?.properties.shape === 'Rectangle'\n      );\n\n      if (canAddPosition) {\n        const updatedData = new ImmutableFeatureCollection(props.data)\n          .addPosition(featureIndex, positionIndexes, pickedIntermediateHandle.geometry.coordinates)\n          .getObject();\n\n        if (updatedData) {\n          props.onEdit({\n            updatedData,\n            editType: 'addPosition',\n            editContext: {\n              featureIndexes: [featureIndex],\n              positionIndexes,\n              position: pickedIntermediateHandle.geometry.coordinates,\n            },\n          });\n        }\n      }\n    }\n  }\n\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {\n    const editHandle = getPickedEditHandle(event.pointerDownPicks);\n\n    if (editHandle) {\n      // Cancel map panning if pointer went down on an edit handle\n      event.cancelPan();\n\n      this._dragEditHandle('movePosition', props, editHandle, event);\n    }\n  }\n\n  _dragEditHandle(\n    editType: string,\n    props: ModeProps<FeatureCollection>,\n    editHandle: EditHandleFeature,\n    event: StopDraggingEvent | DraggingEvent\n  ) {\n    const editHandleProperties = editHandle.properties;\n    const editedFeature = props.data.features[editHandleProperties.featureIndex];\n\n    let updatedData;\n    if (props.modeConfig?.lockRectangles && editedFeature.properties.shape === 'Rectangle') {\n      const coordinates = updateRectanglePosition(\n        editedFeature as FeatureOf<Polygon>,\n        editHandleProperties.positionIndexes[1],\n        event.mapCoords\n      );\n\n      updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(editHandleProperties.featureIndex, { coordinates, type: 'Polygon' })\n        .getObject();\n    } else {\n      updatedData = new ImmutableFeatureCollection(props.data)\n        .replacePosition(\n          editHandleProperties.featureIndex,\n          editHandleProperties.positionIndexes,\n          event.mapCoords\n        )\n        .getObject();\n    }\n\n    props.onEdit({\n      updatedData,\n      editType,\n      editContext: {\n        featureIndexes: [editHandleProperties.featureIndex],\n        positionIndexes: editHandleProperties.positionIndexes,\n        position: event.mapCoords,\n      },\n    });\n  }\n\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    const cursor = this.getCursor(event);\n    props.onUpdateCursor(cursor);\n  }\n\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n\n    const editHandle = getPickedIntermediateEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      const editHandleProperties = editHandle.properties;\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .addPosition(\n          editHandleProperties.featureIndex,\n          editHandleProperties.positionIndexes,\n          event.mapCoords\n        )\n        .getObject();\n\n      props.onEdit({\n        updatedData,\n        editType: 'addPosition',\n        editContext: {\n          featureIndexes: [editHandleProperties.featureIndex],\n          positionIndexes: editHandleProperties.positionIndexes,\n          position: event.mapCoords,\n        },\n      });\n    }\n  }\n\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>) {\n    const selectedFeatureIndexes = props.selectedIndexes;\n    const editHandle = getPickedEditHandle(event.picks);\n    if (selectedFeatureIndexes.length && editHandle) {\n      this._dragEditHandle('finishMovePosition', props, editHandle, event);\n    }\n  }\n\n  getCursor(event: PointerMoveEvent): string | null | undefined {\n    const picks = (event && event.picks) || [];\n\n    const handlesPicked = getPickedEditHandles(picks);\n    if (handlesPicked.length) {\n      return 'cell';\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}