{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isBuffer, bufferToArrayBuffer } from './buffer-utils';\nexport function toArrayBuffer(data) {\n  if (isBuffer(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    var text = data;\n    var uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n\n  var array1 = new Uint8Array(arrayBuffer1);\n  var array2 = new Uint8Array(arrayBuffer2);\n\n  for (var i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function concatenateArrayBuffers() {\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  var sourceArrays = sources.map(function (source2) {\n    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;\n  });\n  var byteLength = sourceArrays.reduce(function (length, typedArray) {\n    return length + typedArray.byteLength;\n  }, 0);\n  var result = new Uint8Array(byteLength);\n  var offset = 0;\n\n  var _iterator = _createForOfIteratorHelper(sourceArrays),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sourceArray = _step.value;\n      result.set(sourceArray, offset);\n      offset += sourceArray.byteLength;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return result.buffer;\n}\nexport function concatenateTypedArrays() {\n  for (var _len2 = arguments.length, typedArrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    typedArrays[_key2] = arguments[_key2];\n  }\n\n  var arrays = typedArrays;\n  var TypedArrayConstructor = arrays && arrays.length > 1 && arrays[0].constructor || null;\n\n  if (!TypedArrayConstructor) {\n    throw new Error('\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types');\n  }\n\n  var sumLength = arrays.reduce(function (acc, value) {\n    return acc + value.length;\n  }, 0);\n  var result = new TypedArrayConstructor(sumLength);\n  var offset = 0;\n\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var array = _arrays[_i];\n    result.set(array, offset);\n    offset += array.length;\n  }\n\n  return result;\n}\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  var subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  var arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}","map":{"version":3,"mappings":"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","names":["isBuffer","bufferToArrayBuffer","toArrayBuffer","data","ArrayBuffer","isView","byteOffset","byteLength","buffer","slice","text","uint8Array","TextEncoder","encode","_toArrayBuffer","Error","compareArrayBuffers","arrayBuffer1","arrayBuffer2","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","concatenateTypedArrays","typedArrays","arrays","TypedArrayConstructor","constructor","sumLength","acc","value","array","sliceArrayBuffer","arrayBuffer","subArray","undefined","subarray","arrayCopy"],"sources":["../../../../src/lib/binary-utils/array-buffer-utils.ts"],"sourcesContent":["import {TypedArray} from '../../types';\nimport {isBuffer, bufferToArrayBuffer} from './buffer-utils';\n\n/**\n * Convert an object to an array buffer\n */\nexport function toArrayBuffer(data: any): ArrayBuffer {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (isBuffer(data)) {\n    return bufferToArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers look like Uint8Arrays (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  throw new Error('toArrayBuffer');\n}\n\n/**\n * compare two binary arrays for equality\n * @param {ArrayBuffer} a\n * @param {ArrayBuffer} b\n * @param {number} byteLength\n */\nexport function compareArrayBuffers(\n  arrayBuffer1: ArrayBuffer,\n  arrayBuffer2: ArrayBuffer,\n  byteLength?: number\n): boolean {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Concatenate a sequence of ArrayBuffers\n * @return A concatenated ArrayBuffer\n */\nexport function concatenateArrayBuffers(...sources: (ArrayBuffer | Uint8Array)[]): ArrayBuffer {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map((source2) =>\n    source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n/**\n * Concatenate arbitrary count of typed arrays\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays\n * @param {...*} arrays - list of arrays. All arrays should be the same type\n * @return A concatenated TypedArray\n */\nexport function concatenateTypedArrays<T>(...typedArrays: T[]): T {\n  // @ts-ignore\n  const arrays = typedArrays as TypedArray[];\n  // @ts-ignore\n  const TypedArrayConstructor = (arrays && arrays.length > 1 && arrays[0].constructor) || null;\n  if (!TypedArrayConstructor) {\n    throw new Error(\n      '\"concatenateTypedArrays\" - incorrect quantity of arguments or arguments have incompatible data types'\n    );\n  }\n\n  const sumLength = arrays.reduce((acc, value) => acc + value.length, 0);\n  // @ts-ignore typescript does not like dynamic constructors\n  const result = new TypedArrayConstructor(sumLength);\n  let offset = 0;\n  for (const array of arrays) {\n    result.set(array, offset);\n    offset += array.length;\n  }\n  return result;\n}\n\n/**\n * Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\n * @param arrayBuffer\n * @param byteOffset\n * @param byteLength\n */\nexport function sliceArrayBuffer(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number,\n  byteLength?: number\n): ArrayBuffer {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"]},"metadata":{},"sourceType":"module"}