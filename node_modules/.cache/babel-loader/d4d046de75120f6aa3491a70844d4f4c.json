{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\n\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  var position = 0;\n  var header = {};\n\n  var _iterator = _createForOfIteratorHelper(QUANTIZED_MESH_HEADER),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          key = _step$value[0],\n          bytesCount = _step$value[1];\n\n      var getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n      header[key] = getter.call(dataView, position, true);\n      position += bytesCount;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    header: header,\n    headerEndPosition: position\n  };\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  var position = headerEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = dataView.getUint32(position, true);\n  var vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  var elementArrayLength = vertexCount * bytesPerArrayElement;\n  var uArrayStartPosition = position;\n  var vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  var heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  var u = 0;\n  var v = 0;\n  var height = 0;\n\n  for (var i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n  return {\n    vertexData: vertexData,\n    vertexDataEndPosition: position\n  };\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  var encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  var indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  var highest = 0;\n\n  for (var i = 0; i < indices.length; ++i) {\n    var code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  var position = vertexDataEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n\n  var triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var triangleIndicesCount = triangleCount * 3;\n  var triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices: triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  var position = triangleIndicesEndPosition;\n  var elementsPerVertex = 3;\n  var vertexCount = vertexData.length / elementsPerVertex;\n  var bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  var westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  var southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  var eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  var northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  var northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices: westIndices,\n    southIndices: southIndices,\n    eastIndices: eastIndices,\n    northIndices: northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  var extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions: extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n\n  var position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    var extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    var extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    var extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    position += extensionLength;\n  }\n\n  return {\n    extensions: extensions,\n    extensionsEndPosition: position\n  };\n}\n\nexport var DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nvar DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  var view = new DataView(data);\n\n  var _decodeHeader = decodeHeader(view),\n      header = _decodeHeader.header,\n      headerEndPosition = _decodeHeader.headerEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header: header\n    };\n  }\n\n  var _decodeVertexData = decodeVertexData(view, headerEndPosition),\n      vertexData = _decodeVertexData.vertexData,\n      vertexDataEndPosition = _decodeVertexData.vertexDataEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header: header,\n      vertexData: vertexData\n    };\n  }\n\n  var _decodeTriangleIndice = decodeTriangleIndices(view, vertexData, vertexDataEndPosition),\n      triangleIndices = _decodeTriangleIndice.triangleIndices,\n      triangleIndicesEndPosition = _decodeTriangleIndice.triangleIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices\n    };\n  }\n\n  var _decodeEdgeIndices = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition),\n      westIndices = _decodeEdgeIndices.westIndices,\n      southIndices = _decodeEdgeIndices.southIndices,\n      eastIndices = _decodeEdgeIndices.eastIndices,\n      northIndices = _decodeEdgeIndices.northIndices,\n      edgeIndicesEndPosition = _decodeEdgeIndices.edgeIndicesEndPosition;\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header: header,\n      vertexData: vertexData,\n      triangleIndices: triangleIndices,\n      westIndices: westIndices,\n      northIndices: northIndices,\n      eastIndices: eastIndices,\n      southIndices: southIndices\n    };\n  }\n\n  var _decodeExtensions = decodeExtensions(view, edgeIndicesEndPosition),\n      extensions = _decodeExtensions.extensions;\n\n  return {\n    header: header,\n    vertexData: vertexData,\n    triangleIndices: triangleIndices,\n    westIndices: westIndices,\n    northIndices: northIndices,\n    eastIndices: eastIndices,\n    southIndices: southIndices,\n    extensions: extensions\n  };\n}","map":{"version":3,"mappings":"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","names":["QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","value","decodeHeader","dataView","position","header","key","bytesCount","getter","getFloat64","getFloat32","call","headerEndPosition","decodeVertexData","elementsPerVertex","vertexCount","getUint32","vertexData","Uint16Array","Uint32Array","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","getUint16","vertexDataEndPosition","decodeIndex","buffer","indicesCount","bytesPerIndex","encoded","indices","highest","length","code","decodeTriangleIndices","triangleCount","triangleIndicesCount","triangleIndices","triangleIndicesEndPosition","decodeEdgeIndices","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","decodeVertexNormalsExtension","extensionDataView","Uint8Array","byteOffset","byteLength","decodeWaterMaskExtension","slice","decodeExtensions","indicesEndPosition","extensions","extensionsEndPosition","extensionId","getUint8","extensionLength","extensionView","DataView","vertexNormals","waterMask","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","Object","assign","view"],"sources":["../../../src/lib/decode-quantized-mesh.ts"],"sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\ntype Extensions = {\n  vertexNormals?: any;\n  waterMask?: any;\n};\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions: Extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}