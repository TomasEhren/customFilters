{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nexport var TypedArrayManager = /*#__PURE__*/function () {\n  function TypedArrayManager(props) {\n    _classCallCheck(this, TypedArrayManager);\n\n    this._pool = [];\n    this.props = {\n      overAlloc: 2,\n      poolSize: 100\n    };\n    this.setProps(props);\n  }\n\n  _createClass(TypedArrayManager, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      Object.assign(this.props, props);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(typedArray, count, _ref) {\n      var _ref$size = _ref.size,\n          size = _ref$size === void 0 ? 1 : _ref$size,\n          type = _ref.type,\n          _ref$padding = _ref.padding,\n          padding = _ref$padding === void 0 ? 0 : _ref$padding,\n          _ref$copy = _ref.copy,\n          copy = _ref$copy === void 0 ? false : _ref$copy,\n          _ref$initialize = _ref.initialize,\n          initialize = _ref$initialize === void 0 ? false : _ref$initialize,\n          maxCount = _ref.maxCount;\n      var Type = type || typedArray && typedArray.constructor || Float32Array;\n      var newSize = count * size + padding;\n\n      if (ArrayBuffer.isView(typedArray)) {\n        if (newSize <= typedArray.length) {\n          return typedArray;\n        }\n\n        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n          return new Type(typedArray.buffer, 0, newSize);\n        }\n      }\n\n      var maxSize;\n\n      if (maxCount) {\n        maxSize = maxCount * size + padding;\n      }\n\n      var newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n      if (typedArray && copy) {\n        newArray.set(typedArray);\n      } else if (!initialize) {\n        newArray.fill(0, 0, 4);\n      }\n\n      this._release(typedArray);\n\n      return newArray;\n    }\n  }, {\n    key: \"release\",\n    value: function release(typedArray) {\n      this._release(typedArray);\n    }\n  }, {\n    key: \"_allocate\",\n    value: function _allocate(Type, size, initialize, maxSize) {\n      var sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n\n      if (sizeToAllocate > maxSize) {\n        sizeToAllocate = maxSize;\n      }\n\n      var pool = this._pool;\n      var byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i >= 0) {\n        var array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n\n        if (initialize) {\n          array.fill(0);\n        }\n\n        return array;\n      }\n\n      return new Type(sizeToAllocate);\n    }\n  }, {\n    key: \"_release\",\n    value: function _release(typedArray) {\n      if (!ArrayBuffer.isView(typedArray)) {\n        return;\n      }\n\n      var pool = this._pool;\n      var buffer = typedArray.buffer;\n      var byteLength = buffer.byteLength;\n      var i = pool.findIndex(function (b) {\n        return b.byteLength >= byteLength;\n      });\n\n      if (i < 0) {\n        pool.push(buffer);\n      } else if (i > 0 || pool.length < this.props.poolSize) {\n        pool.splice(i, 0, buffer);\n      }\n\n      if (pool.length > this.props.poolSize) {\n        pool.shift();\n      }\n    }\n  }]);\n\n  return TypedArrayManager;\n}();\nexport default new TypedArrayManager();","map":{"version":3,"mappings":"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","names":["TypedArrayManager","constructor","props","_pool","overAlloc","poolSize","setProps","Object","assign","allocate","typedArray","count","size","type","padding","copy","initialize","maxCount","Type","Float32Array","newSize","ArrayBuffer","isView","length","BYTES_PER_ELEMENT","buffer","byteLength","maxSize","newArray","_allocate","set","fill","_release","release","sizeToAllocate","Math","max","ceil","pool","i","findIndex","b","array","splice","push","shift"],"sources":["../../../src/utils/typed-array-manager.js"],"sourcesContent":["export class TypedArrayManager {\n  constructor(props) {\n    this._pool = [];\n    this.props = {overAlloc: 2, poolSize: 100};\n    this.setProps(props);\n  }\n\n  setProps(props) {\n    Object.assign(this.props, props);\n  }\n\n  allocate(\n    typedArray,\n    count,\n    {size = 1, type, padding = 0, copy = false, initialize = false, maxCount}\n  ) {\n    const Type = type || (typedArray && typedArray.constructor) || Float32Array;\n\n    const newSize = count * size + padding;\n    if (ArrayBuffer.isView(typedArray)) {\n      if (newSize <= typedArray.length) {\n        return typedArray;\n      }\n      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {\n        return new Type(typedArray.buffer, 0, newSize);\n      }\n    }\n\n    let maxSize;\n    if (maxCount) {\n      maxSize = maxCount * size + padding;\n    }\n\n    const newArray = this._allocate(Type, newSize, initialize, maxSize);\n\n    if (typedArray && copy) {\n      newArray.set(typedArray);\n    } else if (!initialize) {\n      // Hack - always initialize the first 4 elements. NaNs crash the Attribute validation\n      newArray.fill(0, 0, 4);\n    }\n\n    this._release(typedArray);\n    return newArray;\n  }\n\n  release(typedArray) {\n    this._release(typedArray);\n  }\n\n  _allocate(Type, size, initialize, maxSize) {\n    // Allocate at least one element to ensure a valid buffer\n    let sizeToAllocate = Math.max(Math.ceil(size * this.props.overAlloc), 1);\n    // Don't over allocate after certain specified number of elements\n    if (sizeToAllocate > maxSize) {\n      sizeToAllocate = maxSize;\n    }\n\n    // Check if available in pool\n    const pool = this._pool;\n    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i >= 0) {\n      // Create a new array using an existing buffer\n      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);\n      if (initialize) {\n        // Viewing a buffer with a different type may create NaNs\n        array.fill(0);\n      }\n      return array;\n    }\n    return new Type(sizeToAllocate);\n  }\n\n  _release(typedArray) {\n    if (!ArrayBuffer.isView(typedArray)) {\n      return;\n    }\n    const pool = this._pool;\n    const {buffer} = typedArray;\n    // Save the buffer of the released array into the pool\n    // Sort buffers by size\n    // TODO - implement binary search?\n    const {byteLength} = buffer;\n    const i = pool.findIndex(b => b.byteLength >= byteLength);\n    if (i < 0) {\n      pool.push(buffer);\n    } else if (i > 0 || pool.length < this.props.poolSize) {\n      pool.splice(i, 0, buffer);\n    }\n    if (pool.length > this.props.poolSize) {\n      // Drop the smallest one\n      pool.shift();\n    }\n  }\n}\n\nexport default new TypedArrayManager();\n"]},"metadata":{},"sourceType":"module"}