{"ast":null,"code":"import { GLTFMaterialParser } from '@luma.gl/experimental';\nimport { Model, pbr } from '@luma.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n\n  if (!hasColorAttribute) {\n    attributes.colors = {\n      constant: true,\n      value: new Float32Array([1, 1, 1])\n    };\n  }\n}\n\nconst defaultProps = {\n  pbrMaterial: {\n    type: 'object',\n    value: null\n  },\n  featureIds: {\n    type: 'array',\n    value: null,\n    optional: true\n  }\n};\nexport default class _MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return { ...shaders,\n      vs,\n      fs\n    };\n  }\n\n  initializeState() {\n    const {\n      featureIds\n    } = this.props;\n    super.initializeState();\n\n    if (featureIds) {\n      this.state.attributeManager.add({\n        featureIdsPickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState(_ref) {\n    let {\n      props,\n      oldProps,\n      changeFlags\n    } = _ref;\n    super.updateState({\n      props,\n      oldProps,\n      changeFlags\n    });\n\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {\n      featureIds\n    } = this.props;\n\n    if (!this.state.model) {\n      return;\n    }\n\n    this.state.model.setUniforms({\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      u_pickFeatureIds: Boolean(featureIds)\n    });\n    super.draw(opts);\n  }\n\n  getModel(mesh) {\n    const {\n      id,\n      pbrMaterial\n    } = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, { ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: { ...shaders.defines,\n        ...(materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines),\n        HAS_UV_REGIONS: mesh.attributes.uvRegions\n      },\n      parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,\n      isInstanced: true\n    });\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {\n      model\n    } = this.state;\n\n    if (model) {\n      const {\n        mesh\n      } = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);\n    const materialParser = new GLTFMaterialParser(this.context.gl, {\n      attributes: {\n        NORMAL: mesh.attributes.normals,\n        TEXCOORD_0: mesh.attributes.texCoords\n      },\n      material: {\n        unlit,\n        ...pbrMaterial\n      },\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n    return materialParser;\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    const {\n      featureIds\n    } = this.props;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n    const pickingColor = [];\n\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n\n}\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"AAAA,SAAQA,kBAAR,QAAiC,uBAAjC;AACA,SAAQC,KAAR,EAAeC,GAAf,QAAyB,eAAzB;AAEA,SAAQC,eAAR,QAA8B,sBAA9B;AAEA,OAAOC,EAAP,MAAe,0BAAf;AACA,OAAOC,EAAP,MAAe,4BAAf;;AAEA,SAASC,0BAAT,CAAoCC,UAApC,EAAgD;EAC9C,MAAMC,iBAAiB,GAAGD,UAAU,CAACE,OAAXF,IAAsBA,UAAU,CAACG,MAA3D;;EACA,IAAI,CAACF,iBAAL,EAAwB;IACtBD,UAAU,CAACG,MAAXH,GAAoB;MAACI,QAAQ,EAAE,IAAX;MAAiBC,KAAK,EAAE,IAAIC,YAAJ,CAAiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAjB;IAAxB,CAApBN;EACD;AACF;;AAED,MAAMO,YAAY,GAAG;EAEnBC,WAAW,EAAE;IAACC,IAAI,EAAE,QAAP;IAAiBJ,KAAK,EAAE;EAAxB,CAFM;EAGnBK,UAAU,EAAE;IAACD,IAAI,EAAE,OAAP;IAAgBJ,KAAK,EAAE,IAAvB;IAA6BM,QAAQ,EAAE;EAAvC;AAHO,CAArB;AAMA,eAAe,MAAMC,UAAN,SAAyBhB,eAAzB,CAAyC;EACtDiB,UAAU,GAAG;IACX,MAAMC,OAAO,GAAG,MAAMD,UAAN,EAAhB;IACA,MAAME,OAAO,GAAGD,OAAO,CAACC,OAAxB;IACAA,OAAO,CAACC,IAARD,CAAapB,GAAboB;IACA,OAAO,EAAC,GAAGD,OAAJ;MAAajB,EAAb;MAAiBC;IAAjB,CAAP;EACD;;EAEDmB,eAAe,GAAG;IAChB,MAAM;MAACP;IAAD,IAAe,KAAKQ,KAA1B;IACA,MAAMD,eAAN;;IAEA,IAAIP,UAAJ,EAAgB;MACd,KAAKS,KAAL,CAAWC,gBAAX,CAA4BC,GAA5B,CAAgC;QAC9BC,uBAAuB,EAAE;UACvBb,IAAI,MADmB;UAEvBc,IAAI,EAAE,CAFiB;UAGvBC,OAAO,EAAE,IAHc;UAIvBC,MAAM,EAAE,KAAKC;QAJU;MADK,CAAhC;IAQD;EACF;;EAEDC,WAAW,OAAiC;IAAA,IAAhC;MAACT,KAAD;MAAQU,QAAR;MAAkBC;IAAlB,CAAgC;IAC1C,MAAMF,WAAN,CAAkB;MAACT,KAAD;MAAQU,QAAR;MAAkBC;IAAlB,CAAlB;;IACA,IAAIX,KAAK,CAACV,WAANU,KAAsBU,QAAQ,CAACpB,WAAnC,EAAgD;MAC9C,KAAKsB,yBAAL,CAA+BZ,KAAK,CAACV,WAArC;IACD;EACF;;EAEDuB,IAAI,CAACC,IAAD,EAAO;IACT,MAAM;MAACtB;IAAD,IAAe,KAAKQ,KAA1B;;IACA,IAAI,CAAC,KAAKC,KAAL,CAAWc,KAAhB,EAAuB;MACrB;IACD;;IACD,KAAKd,KAAL,CAAWc,KAAX,CAAiBC,WAAjB,CAA6B;MAE3BC,QAAQ,EAAE,KAAKhB,KAAL,CAAWc,KAAX,CAAiBG,WAAjB,GAA+BC,uBAFd;MAG3BC,gBAAgB,EAAEC,OAAO,CAAC7B,UAAD;IAHE,CAA7B;IAMA,MAAMqB,IAAN,CAAWC,IAAX;EACD;;EAEDQ,QAAQ,CAACC,IAAD,EAAO;IACb,MAAM;MAACC,EAAD;MAAKlC;IAAL,IAAoB,KAAKU,KAA/B;IACA,MAAMyB,cAAc,GAAG,KAAKC,aAAL,CAAmBpC,WAAnB,EAAgCiC,IAAhC,CAAvB;IACA,MAAM3B,OAAO,GAAG,KAAKD,UAAL,EAAhB;IACAd,0BAA0B,CAAC0C,IAAI,CAACzC,UAAN,CAA1BD;IACA,MAAMkC,KAAK,GAAG,IAAIvC,KAAJ,CAAU,KAAKmD,OAAL,CAAaC,EAAvB,EAA2B,EACvC,GAAG,KAAKjC,UAAL,EADoC;MAEvC6B,EAFuC;MAGvCK,QAAQ,EAAEN,IAH6B;MAIvCO,OAAO,EAAE,EACP,GAAGlC,OAAO,CAACkC,OADJ;QAEP,IAAGL,cAAH,SAAGA,kBAAH,WAAGA,GAAH,MAAGA,iBAAc,CAAEK,OAAnB,CAFO;QAGPC,cAAc,EAAER,IAAI,CAACzC,UAALyC,CAAgBS;MAHzB,CAJ8B;MASvCC,UAAU,EAAER,cAAF,SAAEA,kBAAF,WAAEA,GAAF,MAAEA,iBAAc,CAAEQ,UATW;MAUvCC,WAAW,EAAE;IAV0B,CAA3B,CAAd;IAaA,OAAOnB,KAAP;EACD;;EAEDH,yBAAyB,CAACtB,WAAD,EAAc;IACrC,MAAM;MAACyB;IAAD,IAAU,KAAKd,KAArB;;IACA,IAAIc,KAAJ,EAAW;MACT,MAAM;QAACQ;MAAD,IAAS,KAAKvB,KAApB;MACA,MAAMyB,cAAc,GAAG,KAAKC,aAAL,CAAmBpC,WAAnB,EAAgCiC,IAAhC,CAAvB;MACAR,KAAK,CAACC,WAAND,CAAkBU,cAAc,CAACU,QAAjCpB;IACD;EACF;;EAEDW,aAAa,CAACpC,WAAD,EAAciC,IAAd,EAAoB;IAC/B,MAAMa,KAAK,GAAGf,OAAO,CACnB/B,WAAW,CAAC+C,oBAAZ/C,IAAoCA,WAAW,CAAC+C,oBAAZ/C,CAAiCgD,gBADlD,CAArB;IAGA,MAAMb,cAAc,GAAG,IAAIlD,kBAAJ,CAAuB,KAAKoD,OAAL,CAAaC,EAApC,EAAwC;MAC7D9C,UAAU,EAAE;QAACyD,MAAM,EAAEhB,IAAI,CAACzC,UAALyC,CAAgBiB,OAAzB;QAAkCC,UAAU,EAAElB,IAAI,CAACzC,UAALyC,CAAgBmB;MAA9D,CADiD;MAE7DC,QAAQ,EAAE;QAACP,KAAD;QAAQ,GAAG9C;MAAX,CAFmD;MAG7DsD,QAAQ,EAAE,KAHmD;MAI7DC,6BAA6B,EAAE,IAJ8B;MAK7DC,MAAM,EAAE,IALqD;MAM7DC,WAAW,EAAE;IANgD,CAAxC,CAAvB;IAQA,OAAOtB,cAAP;EACD;;EAEDjB,gCAAgC,CAACwC,SAAD,EAAY;IAC1C,MAAM;MAACxD;IAAD,IAAe,KAAKQ,KAA1B;IACA,MAAMb,KAAK,GAAG,IAAI8D,iBAAJ,CAAsBzD,UAAU,CAAC0D,MAAX1D,GAAoBwD,SAAS,CAAC3C,IAApD,CAAd;IAEA,MAAM8C,YAAY,GAAG,EAArB;;IACA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAG5D,UAAU,CAAC0D,MAAvC,EAA+CE,KAAK,EAApD,EAAwD;MACtD,KAAKC,kBAAL,CAAwB7D,UAAU,CAAC4D,KAAD,CAAlC,EAA2CD,YAA3C;MAEAhE,KAAK,CAACiE,KAAK,GAAG,CAAT,CAALjE,GAAmBgE,YAAY,CAAC,CAAD,CAA/BhE;MACAA,KAAK,CAACiE,KAAK,GAAG,CAARA,GAAY,CAAb,CAALjE,GAAuBgE,YAAY,CAAC,CAAD,CAAnChE;MACAA,KAAK,CAACiE,KAAK,GAAG,CAARA,GAAY,CAAb,CAALjE,GAAuBgE,YAAY,CAAC,CAAD,CAAnChE;IACD;;IAED6D,SAAS,CAAC7D,KAAV6D,GAAkB7D,KAAlB6D;EACD;;AAxGqD;AA2GxDtD,UAAU,CAAC4D,SAAX5D,GAAuB,YAAvBA;AACAA,UAAU,CAACL,YAAXK,GAA0BL,YAA1BK","names":["GLTFMaterialParser","Model","pbr","SimpleMeshLayer","vs","fs","validateGeometryAttributes","attributes","hasColorAttribute","COLOR_0","colors","constant","value","Float32Array","defaultProps","pbrMaterial","type","featureIds","optional","_MeshLayer","getShaders","shaders","modules","push","initializeState","props","state","attributeManager","add","featureIdsPickingColors","size","noAlloc","update","calculateFeatureIdsPickingColors","updateState","oldProps","changeFlags","updatePbrMaterialUniforms","draw","opts","model","setUniforms","u_Camera","getUniforms","project_uCameraPosition","u_pickFeatureIds","Boolean","getModel","mesh","id","materialParser","parseMaterial","context","gl","geometry","defines","HAS_UV_REGIONS","uvRegions","parameters","isInstanced","uniforms","unlit","pbrMetallicRoughness","baseColorTexture","NORMAL","normals","TEXCOORD_0","texCoords","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","attribute","Uint8ClampedArray","length","pickingColor","index","encodePickingColor","layerName"],"sources":["../../../src/mesh-layer/mesh-layer.js"],"sourcesContent":["import {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {Model, pbr} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n}\n\nconst defaultProps = {\n  // PBR material object. _lighting must be pbr for this to work\n  pbrMaterial: {type: 'object', value: null},\n  featureIds: {type: 'array', value: null, optional: true}\n};\n\nexport default class _MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return {...shaders, vs, fs};\n  }\n\n  initializeState() {\n    const {featureIds} = this.props;\n    super.initializeState();\n\n    if (featureIds) {\n      this.state.attributeManager.add({\n        featureIdsPickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {featureIds} = this.props;\n    if (!this.state.model) {\n      return;\n    }\n    this.state.model.setUniforms({\n      // Needed for PBR (TODO: find better way to get it)\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      u_pickFeatureIds: Boolean(featureIds)\n    });\n\n    super.draw(opts);\n  }\n\n  getModel(mesh) {\n    const {id, pbrMaterial} = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: {\n        ...shaders.defines,\n        ...materialParser?.defines,\n        HAS_UV_REGIONS: mesh.attributes.uvRegions\n      },\n      parameters: materialParser?.parameters,\n      isInstanced: true\n    });\n\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {model} = this.state;\n    if (model) {\n      const {mesh} = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(\n      pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture\n    );\n    const materialParser = new GLTFMaterialParser(this.context.gl, {\n      attributes: {NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords},\n      material: {unlit, ...pbrMaterial},\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n    return materialParser;\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    const {featureIds} = this.props;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n}\n\n_MeshLayer.layerName = '_MeshLayer';\n_MeshLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}