{"ast":null,"code":"import { compareArrayBuffers, path } from '@loaders.gl/loader-utils';\nimport { normalizeLoader } from '../loader-utils/normalize-loader';\nimport { log } from '../utils/log';\nimport { getResourceUrlAndType } from '../utils/resource-utils';\nimport { getRegisteredLoaders } from './register-loaders';\nimport { isBlob } from '../../javascript-utils/is-type';\nconst EXT_PATTERN = /\\.([^.]+)$/;\nexport async function selectLoader(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  let loader = selectLoaderSync(data, loaders, { ...options,\n    nothrow: true\n  }, context);\n\n  if (loader) {\n    return loader;\n  }\n\n  if (isBlob(data)) {\n    data = await data.slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\nexport function selectLoaderSync(data) {\n  let loaders = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let context = arguments.length > 3 ? arguments[3] : undefined;\n\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  if (loaders && !Array.isArray(loaders)) {\n    return normalizeLoader(loaders);\n  }\n\n  let candidateLoaders = [];\n\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n\n  if (!(options !== null && options !== void 0 && options.ignoreRegisteredLoaders)) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  normalizeLoaders(candidateLoaders);\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  if (!loader && !(options !== null && options !== void 0 && options.nothrow)) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\nfunction selectLoaderInternal(data, loaders, options, context) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  const testUrl = url || (context === null || context === void 0 ? void 0 : context.url);\n  let loader = null;\n  let reason = '';\n\n  if (options !== null && options !== void 0 && options.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.mimeType);\n    reason = \"match forced by supplied MIME type \".concat(options === null || options === void 0 ? void 0 : options.mimeType);\n  }\n\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? \"matched url \".concat(testUrl) : '');\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? \"matched MIME type \".concat(type) : '');\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? \"matched initial data \".concat(getFirstCharacters(data)) : '');\n  loader = loader || findLoaderByMIMEType(loaders, options === null || options === void 0 ? void 0 : options.fallbackMimeType);\n  reason = reason || (loader ? \"matched fallback MIME type \".concat(type) : '');\n\n  if (reason) {\n    var _loader;\n\n    log.log(1, \"selectLoader selected \".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, \": \").concat(reason, \".\"));\n  }\n\n  return loader;\n}\n\nfunction validHTTPResponse(data) {\n  if (data instanceof Response) {\n    if (data.status === 204) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction getNoValidLoaderMessage(data) {\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(data);\n  let message = 'No valid loader found (';\n  message += url ? \"\".concat(path.filename(url), \", \") : 'no url provided, ';\n  message += \"MIME type: \".concat(type ? \"\\\"\".concat(type, \"\\\"\") : 'not provided', \", \");\n  const firstCharacters = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? \" first bytes: \\\"\".concat(firstCharacters, \"\\\"\") : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\nfunction findLoaderByUrl(loaders, url) {\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    if (mimeType === \"application/x.\".concat(loader.id)) {\n      return loader;\n    }\n  }\n\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => data.startsWith(test));\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some(test => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data) {\n  let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n\n  return magic;\n}","map":{"version":3,"mappings":"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","names":["compareArrayBuffers","path","normalizeLoader","log","getResourceUrlAndType","getRegisteredLoaders","isBlob","EXT_PATTERN","selectLoader","data","loaders","options","context","validHTTPResponse","loader","selectLoaderSync","nothrow","slice","arrayBuffer","Error","getNoValidLoaderMessage","Array","isArray","candidateLoaders","concat","ignoreRegisteredLoaders","push","normalizeLoaders","selectLoaderInternal","url","type","testUrl","reason","mimeType","findLoaderByMIMEType","findLoaderByUrl","findLoaderByInitialBytes","getFirstCharacters","fallbackMimeType","_loader","name","Response","status","message","filename","firstCharacters","match","exec","extension","findLoaderByExtension","toLowerCase","loaderExtension","extensions","mimeTypes","includes","id","testDataAgainstText","ArrayBuffer","isView","testDataAgainstBinary","buffer","byteOffset","testText","tests","some","test","startsWith","testBinary","byteLength","magic","getMagicString","length","dataView","DataView","i","String","fromCharCode","getUint8"],"sources":["../../../../src/lib/api/select-loader.ts"],"sourcesContent":["import type {LoaderContext, LoaderOptions, Loader} from '@loaders.gl/loader-utils';\nimport {compareArrayBuffers, path} from '@loaders.gl/loader-utils';\nimport {normalizeLoader} from '../loader-utils/normalize-loader';\nimport {log} from '../utils/log';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {getRegisteredLoaders} from './register-loaders';\nimport {isBlob} from '../../javascript-utils/is-type';\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport async function selectLoader(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Promise<Loader | null> {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // First make a sync attempt, disabling exceptions\n  let loader = selectLoaderSync(data, loaders, {...options, nothrow: true}, context);\n  if (loader) {\n    return loader;\n  }\n\n  // For Blobs and Files, try to asynchronously read a small initial slice and test again with that\n  // to see if we can detect by initial content\n  if (isBlob(data)) {\n    data = await (data as Blob).slice(0, 10).arrayBuffer();\n    loader = selectLoaderSync(data, loaders, options, context);\n  }\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/**\n * Find a loader that matches file extension and/or initial file content\n * Search the loaders array argument for a loader that matches url extension or initial data\n * Returns: a normalized loader\n * @param data data to assist\n * @param loaders\n * @param options\n * @param context used internally, applications should not provide this parameter\n */\nexport function selectLoaderSync(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[] | Loader = [],\n  options?: LoaderOptions,\n  context?: LoaderContext\n): Loader | null {\n  if (!validHTTPResponse(data)) {\n    return null;\n  }\n\n  // eslint-disable-next-line complexity\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behavior be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    // TODO - remove support for legacy loaders\n    return normalizeLoader(loaders);\n  }\n\n  // Build list of candidate loaders that will be searched in order for a match\n  let candidateLoaders: Loader[] = [];\n  // First search supplied loaders\n  if (loaders) {\n    candidateLoaders = candidateLoaders.concat(loaders);\n  }\n  // Then fall back to registered loaders\n  if (!options?.ignoreRegisteredLoaders) {\n    candidateLoaders.push(...getRegisteredLoaders());\n  }\n\n  // TODO - remove support for legacy loaders\n  normalizeLoaders(candidateLoaders);\n\n  const loader = selectLoaderInternal(data, candidateLoaders, options, context);\n\n  // no loader available\n  if (!loader && !options?.nothrow) {\n    throw new Error(getNoValidLoaderMessage(data));\n  }\n\n  return loader;\n}\n\n/** Implements loaders selection logic */\nfunction selectLoaderInternal(\n  data: Response | Blob | ArrayBuffer | string,\n  loaders: Loader[],\n  options?: LoaderOptions,\n  context?: LoaderContext\n) {\n  const {url, type} = getResourceUrlAndType(data);\n\n  const testUrl = url || context?.url;\n\n  let loader: Loader | null = null;\n  let reason: string = '';\n\n  // if options.mimeType is supplied, it takes precedence\n  if (options?.mimeType) {\n    loader = findLoaderByMIMEType(loaders, options?.mimeType);\n    reason = `match forced by supplied MIME type ${options?.mimeType}`;\n  }\n\n  // Look up loader by url\n  loader = loader || findLoaderByUrl(loaders, testUrl);\n  reason = reason || (loader ? `matched url ${testUrl}` : '');\n\n  // Look up loader by mime type\n  loader = loader || findLoaderByMIMEType(loaders, type);\n  reason = reason || (loader ? `matched MIME type ${type}` : '');\n\n  // Look for loader via initial bytes (Note: not always accessible (e.g. Response, stream, async iterator)\n  loader = loader || findLoaderByInitialBytes(loaders, data);\n  reason = reason || (loader ? `matched initial data ${getFirstCharacters(data)}` : '');\n\n  // Look up loader by fallback mime type\n  loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);\n  reason = reason || (loader ? `matched fallback MIME type ${type}` : '');\n\n  if (reason) {\n    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);\n  }\n\n  return loader;\n}\n\n/** Check HTTP Response */\nfunction validHTTPResponse(data: any): boolean {\n  // HANDLE HTTP status\n  if (data instanceof Response) {\n    // 204 - NO CONTENT. This handles cases where e.g. a tile server responds with 204 for a missing tile\n    if (data.status === 204) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/** Generate a helpful message to help explain why loader selection failed. */\nfunction getNoValidLoaderMessage(data): string {\n  const {url, type} = getResourceUrlAndType(data);\n\n  let message = 'No valid loader found (';\n  message += url ? `${path.filename(url)}, ` : 'no url provided, ';\n  message += `MIME type: ${type ? `\"${type}\"` : 'not provided'}, `;\n  // First characters are only accessible when called on data (string or arrayBuffer).\n  const firstCharacters: string = data ? getFirstCharacters(data) : '';\n  message += firstCharacters ? ` first bytes: \"${firstCharacters}\"` : 'first bytes: not available';\n  message += ')';\n  return message;\n}\n\nfunction normalizeLoaders(loaders: Loader[]): void {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders: Loader[], url?: string): Loader | null {\n  // Get extension\n  const match = url && EXT_PATTERN.exec(url);\n  const extension = match && match[1];\n  return extension ? findLoaderByExtension(loaders, extension) : null;\n}\n\nfunction findLoaderByExtension(loaders: Loader[], extension: string): Loader | null {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByMIMEType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n\n    // Support referring to loaders using the \"unregistered tree\"\n    // https://en.wikipedia.org/wiki/Media_type#Unregistered_tree\n    if (mimeType === `application/x.${loader.id}`) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByInitialBytes(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testDataAgainstText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testDataAgainstBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testDataAgainstText(data, loader) {\n  if (loader.testText) {\n    return loader.testText(data);\n  }\n\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => data.startsWith(test));\n}\n\nfunction testDataAgainstBinary(data, byteOffset, loader) {\n  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];\n  return tests.some((test) => testBinary(data, byteOffset, loader, test));\n}\n\nfunction testBinary(data, byteOffset, loader, test) {\n  if (test instanceof ArrayBuffer) {\n    return compareArrayBuffers(test, data, test.byteLength);\n  }\n  switch (typeof test) {\n    case 'function':\n      return test(data, loader);\n\n    case 'string':\n      // Magic bytes check: If `test` is a string, check if binary data starts with that strings\n      const magic = getMagicString(data, byteOffset, test.length);\n      return test === magic;\n\n    default:\n      return false;\n  }\n}\n\nfunction getFirstCharacters(data, length: number = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength < byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"]},"metadata":{},"sourceType":"module"}