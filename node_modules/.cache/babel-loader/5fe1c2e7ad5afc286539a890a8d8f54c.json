{"ast":null,"code":"import { bitCode, intersect } from './lineclip';\nimport { getPointAtIndex, copy, push } from './utils';\nexport function cutPolylineByGrid(positions) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n\n      push(part, scratchPoint);\n      copy(a, scratchPoint);\n      moveToNeighborCell(cell, gridResolution, codeB);\n\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!positions.length) {\n    return [];\n  }\n\n  const {\n    size = 2,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    edgeTypes = false\n  } = options;\n  const result = [];\n  const queue = [{\n    pos: positions,\n    types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n    holes: holeIndices || []\n  }];\n  const bbox = [[], []];\n  let cell = [];\n\n  while (queue.length) {\n    const {\n      pos,\n      types,\n      holes\n    } = queue.shift();\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {\n        pos: parts[0].pos,\n        types: parts[0].types,\n        holes: []\n      };\n      const polygonHigh = {\n        pos: parts[1].pos,\n        types: parts[1].types,\n        holes: []\n      };\n      queue.push(polygonLow, polygonHigh);\n\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      const polygon = {\n        positions: pos\n      };\n\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n\n  return result;\n}\n\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [lowPointCount ? {\n    pos: resultLow,\n    types: edgeTypes && typesLow\n  } : null, highPointCount ? {\n    pos: resultHigh,\n    types: edgeTypes && typesHigh\n  } : null];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}","map":{"version":3,"mappings":"AACA,SAAQA,OAAR,EAAiBC,SAAjB,QAAiC,YAAjC;AACA,SAAQC,eAAR,EAAyBC,IAAzB,EAA+BC,IAA/B,QAA0C,SAA1C;AAEA,OAAO,SAASC,iBAAT,CAA2BC,SAA3B,EAAoD;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EACzD,MAAM;IACJC,IAAI,GAAG,CADH;IAEJC,MAAM,GAAG,KAFL;IAGJC,cAAc,GAAG,EAHb;IAIJC,UAAU,GAAG,CAAC,CAAD,EAAI,CAAJ,CAJT;IAKJC,UAAU,GAAG,CALT;IAMJC,QAAQ,GAAGP,SAAS,CAACQ;EANjB,IAOFP,OAPJ;EAQA,MAAMQ,SAAS,GAAG,CAACF,QAAQ,GAAGD,UAAZ,IAA0BJ,IAA5C;EACA,IAAIQ,IAAI,GAAG,EAAX;EACA,MAAMC,MAAM,GAAG,CAACD,IAAD,CAAf;EACA,MAAME,CAAC,GAAGhB,eAAe,CAACI,SAAD,EAAY,CAAZ,EAAeE,IAAf,EAAqBI,UAArB,CAAzB;EACA,IAAIO,CAAJ;EACA,IAAIC,KAAJ;EACA,MAAMC,IAAI,GAAGC,WAAW,CAACJ,CAAD,EAAIR,cAAJ,EAAoBC,UAApB,EAAgC,EAAhC,CAAxB;EACA,MAAMY,YAAY,GAAG,EAArB;EACAnB,IAAI,CAACY,IAAD,EAAOE,CAAP,CAAJd;;EAEA,KAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAApB,EAA+BS,CAAC,EAAhC,EAAoC;IAClCL,CAAC,GAAGjB,eAAe,CAACI,SAAD,EAAYkB,CAAZ,EAAehB,IAAf,EAAqBI,UAArB,EAAiCO,CAAjC,CAAnBA;IACAC,KAAK,GAAGpB,OAAO,CAACmB,CAAD,EAAIE,IAAJ,CAAfD;;IAEA,OAAOA,KAAP,EAAc;MAEZnB,SAAS,CAACiB,CAAD,EAAIC,CAAJ,EAAOC,KAAP,EAAcC,IAAd,EAAoBE,YAApB,CAATtB;MACA,MAAMwB,OAAO,GAAGzB,OAAO,CAACuB,YAAD,EAAeF,IAAf,CAAvB;;MACA,IAAII,OAAJ,EAAa;QACXxB,SAAS,CAACiB,CAAD,EAAIK,YAAJ,EAAkBE,OAAlB,EAA2BJ,IAA3B,EAAiCE,YAAjC,CAATtB;QACAmB,KAAK,GAAGK,OAARL;MACD;;MACDhB,IAAI,CAACY,IAAD,EAAOO,YAAP,CAAJnB;MAEAD,IAAI,CAACe,CAAD,EAAIK,YAAJ,CAAJpB;MAEAuB,kBAAkB,CAACL,IAAD,EAAOX,cAAP,EAAuBU,KAAvB,CAAlBM;;MACA,IAAIjB,MAAM,IAAIO,IAAI,CAACF,MAALE,GAAcR,IAA5B,EAAkC;QAChCQ,IAAI,GAAG,EAAPA;QACAC,MAAM,CAACb,IAAPa,CAAYD,IAAZC;QACAb,IAAI,CAACY,IAAD,EAAOE,CAAP,CAAJd;MACD;;MAEDgB,KAAK,GAAGpB,OAAO,CAACmB,CAAD,EAAIE,IAAJ,CAAfD;IACD;;IAEDhB,IAAI,CAACY,IAAD,EAAOG,CAAP,CAAJf;IACAD,IAAI,CAACe,CAAD,EAAIC,CAAJ,CAAJhB;EACD;;EAED,OAAOM,MAAM,GAAGQ,MAAH,GAAYA,MAAM,CAAC,CAAD,CAA/B;AACD;AAED,MAAMU,WAAW,GAAG,CAApB;AACA,MAAMC,WAAW,GAAG,CAApB;;AAEA,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,IAA7B,EAAmC;EACjC,KAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,IAAI,CAACjB,MAAzB,EAAiCU,CAAC,EAAlC,EAAsC;IACpCM,IAAI,CAAC1B,IAAL0B,CAAUC,IAAI,CAACP,CAAD,CAAdM;EACD;;EACD,OAAOA,IAAP;AACD;;AAED,OAAO,SAASE,gBAAT,CAA0B1B,SAA1B,EAAqC2B,WAArC,EAAgE;EAAA,IAAd1B,OAAc,uEAAJ,EAAI;;EACrE,IAAI,CAACD,SAAS,CAACQ,MAAf,EAAuB;IAErB,OAAO,EAAP;EACD;;EACD,MAAM;IAACN,IAAI,GAAG,CAAR;IAAWE,cAAc,GAAG,EAA5B;IAAgCC,UAAU,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA7C;IAAqDuB,SAAS,GAAG;EAAjE,IAA0E3B,OAAhF;EACA,MAAMU,MAAM,GAAG,EAAf;EACA,MAAMkB,KAAK,GAAG,CACZ;IACEC,GAAG,EAAE9B,SADP;IAEE+B,KAAK,EAAEH,SAAS,IAAI,IAAII,KAAJ,CAAUhC,SAAS,CAACQ,MAAVR,GAAmBE,IAA7B,EAAmC+B,IAAnC,CAAwCX,WAAxC,CAFtB;IAGEY,KAAK,EAAEP,WAAW,IAAI;EAHxB,CADY,CAAd;EAOA,MAAMQ,IAAI,GAAG,CAAC,EAAD,EAAK,EAAL,CAAb;EACA,IAAIpB,IAAI,GAAG,EAAX;;EAGA,OAAOc,KAAK,CAACrB,MAAb,EAAqB;IACnB,MAAM;MAACsB,GAAD;MAAMC,KAAN;MAAaG;IAAb,IAAsBL,KAAK,CAACO,KAANP,EAA5B;IAGAQ,cAAc,CAACP,GAAD,EAAM5B,IAAN,EAAYgC,KAAK,CAAC,CAAD,CAALA,IAAYJ,GAAG,CAACtB,MAA5B,EAAoC2B,IAApC,CAAdE;IACAtB,IAAI,GAAGC,WAAW,CAACmB,IAAI,CAAC,CAAD,CAAL,EAAU/B,cAAV,EAA0BC,UAA1B,EAAsCU,IAAtC,CAAlBA;IACA,MAAMuB,IAAI,GAAG5C,OAAO,CAACyC,IAAI,CAAC,CAAD,CAAL,EAAUpB,IAAV,CAApB;;IAEA,IAAIuB,IAAJ,EAAU;MAER,IAAIC,KAAK,GAAGC,aAAa,CAACV,GAAD,EAAMC,KAAN,EAAa7B,IAAb,EAAmB,CAAnB,EAAsBgC,KAAK,CAAC,CAAD,CAALA,IAAYJ,GAAG,CAACtB,MAAtC,EAA8CO,IAA9C,EAAoDuB,IAApD,CAAzB;MACA,MAAMG,UAAU,GAAG;QAACX,GAAG,EAAES,KAAK,CAAC,CAAD,CAALA,CAAST,GAAf;QAAoBC,KAAK,EAAEQ,KAAK,CAAC,CAAD,CAALA,CAASR,KAApC;QAA2CG,KAAK,EAAE;MAAlD,CAAnB;MACA,MAAMQ,WAAW,GAAG;QAACZ,GAAG,EAAES,KAAK,CAAC,CAAD,CAALA,CAAST,GAAf;QAAoBC,KAAK,EAAEQ,KAAK,CAAC,CAAD,CAALA,CAASR,KAApC;QAA2CG,KAAK,EAAE;MAAlD,CAApB;MACAL,KAAK,CAAC/B,IAAN+B,CAAWY,UAAXZ,EAAuBa,WAAvBb;;MAGA,KAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,KAAK,CAAC1B,MAA1B,EAAkCU,CAAC,EAAnC,EAAuC;QACrCqB,KAAK,GAAGC,aAAa,CAACV,GAAD,EAAMC,KAAN,EAAa7B,IAAb,EAAmBgC,KAAK,CAAChB,CAAD,CAAxB,EAA6BgB,KAAK,CAAChB,CAAC,GAAG,CAAL,CAALgB,IAAgBJ,GAAG,CAACtB,MAAjD,EAAyDO,IAAzD,EAA+DuB,IAA/D,CAArBC;;QAEA,IAAIA,KAAK,CAAC,CAAD,CAAT,EAAc;UACZE,UAAU,CAACP,KAAXO,CAAiB3C,IAAjB2C,CAAsBA,UAAU,CAACX,GAAXW,CAAejC,MAArCiC;UACAA,UAAU,CAACX,GAAXW,GAAiBlB,aAAa,CAACkB,UAAU,CAACX,GAAZ,EAAiBS,KAAK,CAAC,CAAD,CAALA,CAAST,GAA1B,CAA9BW;;UACA,IAAIb,SAAJ,EAAe;YACba,UAAU,CAACV,KAAXU,GAAmBlB,aAAa,CAACkB,UAAU,CAACV,KAAZ,EAAmBQ,KAAK,CAAC,CAAD,CAALA,CAASR,KAA5B,CAAhCU;UACD;QACF;;QACD,IAAIF,KAAK,CAAC,CAAD,CAAT,EAAc;UACZG,WAAW,CAACR,KAAZQ,CAAkB5C,IAAlB4C,CAAuBA,WAAW,CAACZ,GAAZY,CAAgBlC,MAAvCkC;UACAA,WAAW,CAACZ,GAAZY,GAAkBnB,aAAa,CAACmB,WAAW,CAACZ,GAAb,EAAkBS,KAAK,CAAC,CAAD,CAALA,CAAST,GAA3B,CAA/BY;;UACA,IAAId,SAAJ,EAAe;YACbc,WAAW,CAACX,KAAZW,GAAoBnB,aAAa,CAACmB,WAAW,CAACX,KAAb,EAAoBQ,KAAK,CAAC,CAAD,CAALA,CAASR,KAA7B,CAAjCW;UACD;QACF;MACF;IAzBH,OA0BO;MAEL,MAAMC,OAAO,GAAG;QAAC3C,SAAS,EAAE8B;MAAZ,CAAhB;;MACA,IAAIF,SAAJ,EAAe;QACbe,OAAO,CAACf,SAARe,GAAoBZ,KAApBY;MACD;;MACD,IAAIT,KAAK,CAAC1B,MAAV,EAAkB;QAChBmC,OAAO,CAAChB,WAARgB,GAAsBT,KAAtBS;MACD;;MAEDhC,MAAM,CAACb,IAAPa,CAAYgC,OAAZhC;IACD;EACF;;EACD,OAAOA,MAAP;AACD;;AAMD,SAAS6B,aAAT,CAAuBxC,SAAvB,EAAkC4B,SAAlC,EAA6C1B,IAA7C,EAAmDI,UAAnD,EAA+DC,QAA/D,EAAyE4B,IAAzE,EAA+ES,IAA/E,EAAqF;EACnF,MAAMnC,SAAS,GAAG,CAACF,QAAQ,GAAGD,UAAZ,IAA0BJ,IAA5C;EACA,MAAM2C,SAAS,GAAG,EAAlB;EACA,MAAMC,UAAU,GAAG,EAAnB;EACA,MAAMC,QAAQ,GAAG,EAAjB;EACA,MAAMC,SAAS,GAAG,EAAlB;EACA,MAAM/B,YAAY,GAAG,EAArB;EAEA,IAAIgC,CAAJ;EACA,IAAIC,IAAJ;EACA,IAAIC,IAAJ;EACA,MAAMC,IAAI,GAAGxD,eAAe,CAACI,SAAD,EAAYS,SAAS,GAAG,CAAxB,EAA2BP,IAA3B,EAAiCI,UAAjC,CAA5B;EACA,IAAI+C,QAAQ,GAAGC,IAAI,CAACC,IAALD,CAAUV,IAAI,GAAG,CAAPA,GAAWQ,IAAI,CAAC,CAAD,CAAJA,GAAUjB,IAAI,CAAC,CAAD,CAAzBS,GAA+BQ,IAAI,CAAC,CAAD,CAAJA,GAAUjB,IAAI,CAAC,CAAD,CAAvDmB,CAAf;EACA,IAAIE,QAAQ,GAAG5B,SAAS,IAAIA,SAAS,CAACnB,SAAS,GAAG,CAAb,CAArC;EACA,IAAIgD,aAAa,GAAG,CAApB;EACA,IAAIC,cAAc,GAAG,CAArB;;EAEA,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,SAApB,EAA+BS,CAAC,EAAhC,EAAoC;IAClC+B,CAAC,GAAGrD,eAAe,CAACI,SAAD,EAAYkB,CAAZ,EAAehB,IAAf,EAAqBI,UAArB,EAAiC2C,CAAjC,CAAnBA;IACAC,IAAI,GAAGI,IAAI,CAACC,IAALD,CAAUV,IAAI,GAAG,CAAPA,GAAWK,CAAC,CAAC,CAAD,CAADA,GAAOd,IAAI,CAAC,CAAD,CAAtBS,GAA4BK,CAAC,CAAC,CAAD,CAADA,GAAOd,IAAI,CAAC,CAAD,CAAjDmB,CAAPJ;IACAC,IAAI,GAAGvB,SAAS,IAAIA,SAAS,CAACtB,UAAU,GAAGJ,IAAbI,GAAoBY,CAArB,CAA7BiC;;IAGA,IAAID,IAAI,IAAIG,QAARH,IAAoBG,QAAQ,KAAKH,IAArC,EAA2C;MACzCvD,SAAS,CAACyD,IAAD,EAAOH,CAAP,EAAUL,IAAV,EAAgBT,IAAhB,EAAsBlB,YAAtB,CAATtB;MACAG,IAAI,CAAC+C,SAAD,EAAY5B,YAAZ,CAAJnB,IAAiCiD,QAAQ,CAACjD,IAATiD,CAAcS,QAAdT,CAAjCjD;MACAA,IAAI,CAACgD,UAAD,EAAa7B,YAAb,CAAJnB,IAAkCkD,SAAS,CAAClD,IAAVkD,CAAeQ,QAAfR,CAAlClD;IACD;;IAED,IAAIoD,IAAI,IAAI,CAAZ,EAAe;MACbpD,IAAI,CAAC+C,SAAD,EAAYI,CAAZ,CAAJnD,IAAsBiD,QAAQ,CAACjD,IAATiD,CAAcI,IAAdJ,CAAtBjD;MACA2D,aAAa,IAAIP,IAAjBO;IAFF,OAGO,IAAIV,QAAQ,CAACvC,MAAb,EAAqB;MAC1BuC,QAAQ,CAACA,QAAQ,CAACvC,MAATuC,GAAkB,CAAnB,CAARA,GAAgC1B,WAAhC0B;IACD;;IACD,IAAIG,IAAI,IAAI,CAAZ,EAAe;MACbpD,IAAI,CAACgD,UAAD,EAAaG,CAAb,CAAJnD,IAAuBkD,SAAS,CAAClD,IAAVkD,CAAeG,IAAfH,CAAvBlD;MACA4D,cAAc,IAAIR,IAAlBQ;IAFF,OAGO,IAAIV,SAAS,CAACxC,MAAd,EAAsB;MAC3BwC,SAAS,CAACA,SAAS,CAACxC,MAAVwC,GAAmB,CAApB,CAATA,GAAkC3B,WAAlC2B;IACD;;IAEDnD,IAAI,CAACuD,IAAD,EAAOH,CAAP,CAAJpD;IACAwD,QAAQ,GAAGH,IAAXG;IACAG,QAAQ,GAAGL,IAAXK;EACD;;EAED,OAAO,CACLC,aAAa,GAAG;IAAC3B,GAAG,EAAEe,SAAN;IAAiBd,KAAK,EAAEH,SAAS,IAAImB;EAArC,CAAH,GAAoD,IAD5D,EAELW,cAAc,GAAG;IAAC5B,GAAG,EAAEgB,UAAN;IAAkBf,KAAK,EAAEH,SAAS,IAAIoB;EAAtC,CAAH,GAAsD,IAF/D,CAAP;AAID;;AAED,SAAShC,WAAT,CAAqBiC,CAArB,EAAwB7C,cAAxB,EAAwCC,UAAxC,EAAoDsD,GAApD,EAAyD;EACvD,MAAMC,IAAI,GAAGN,IAAI,CAACO,KAALP,CAAW,CAACL,CAAC,CAAC,CAAD,CAADA,GAAO5C,UAAU,CAAC,CAAD,CAAlB,IAAyBD,cAApCkD,IAAsDlD,cAAtDkD,GAAuEjD,UAAU,CAAC,CAAD,CAA9F;EACA,MAAMyD,MAAM,GACVR,IAAI,CAACO,KAALP,CAAW,CAACL,CAAC,CAAC,CAAD,CAADA,GAAO5C,UAAU,CAAC,CAAD,CAAlB,IAAyBD,cAApCkD,IAAsDlD,cAAtDkD,GAAuEjD,UAAU,CAAC,CAAD,CADnF;EAEAsD,GAAG,CAAC,CAAD,CAAHA,GAASC,IAATD;EACAA,GAAG,CAAC,CAAD,CAAHA,GAASG,MAATH;EACAA,GAAG,CAAC,CAAD,CAAHA,GAASC,IAAI,GAAGxD,cAAhBuD;EACAA,GAAG,CAAC,CAAD,CAAHA,GAASG,MAAM,GAAG1D,cAAlBuD;EACA,OAAOA,GAAP;AACD;;AAED,SAASvC,kBAAT,CAA4BL,IAA5B,EAAkCX,cAAlC,EAAkDwC,IAAlD,EAAwD;EACtD,IAAIA,IAAI,GAAG,CAAX,EAAc;IAEZ7B,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;IACAA,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;EAHF,OAIO,IAAI6B,IAAI,GAAG,CAAX,EAAc;IAEnB7B,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;IACAA,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;EAHK,OAIA,IAAI6B,IAAI,GAAG,CAAX,EAAc;IAEnB7B,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;IACAA,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;EAHK,OAIA,IAAI6B,IAAI,GAAG,CAAX,EAAc;IAEnB7B,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;IACAA,IAAI,CAAC,CAAD,CAAJA,IAAWX,cAAXW;EACD;AACF;;AAED,SAASsB,cAAT,CAAwBrC,SAAxB,EAAmCE,IAAnC,EAAyCK,QAAzC,EAAmDoD,GAAnD,EAAwD;EACtD,IAAII,IAAI,GAAGC,QAAX;EACA,IAAIC,IAAI,GAAG,CAACD,QAAZ;EACA,IAAIE,IAAI,GAAGF,QAAX;EACA,IAAIG,IAAI,GAAG,CAACH,QAAZ;;EAEA,KAAK,IAAI9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,QAApB,EAA8BW,CAAC,IAAIhB,IAAnC,EAAyC;IACvC,MAAMkE,CAAC,GAAGpE,SAAS,CAACkB,CAAD,CAAnB;IACA,MAAMmD,CAAC,GAAGrE,SAAS,CAACkB,CAAC,GAAG,CAAL,CAAnB;IACA6C,IAAI,GAAGK,CAAC,GAAGL,IAAJK,GAAWA,CAAXA,GAAeL,IAAtBA;IACAE,IAAI,GAAGG,CAAC,GAAGH,IAAJG,GAAWA,CAAXA,GAAeH,IAAtBA;IACAC,IAAI,GAAGG,CAAC,GAAGH,IAAJG,GAAWA,CAAXA,GAAeH,IAAtBA;IACAC,IAAI,GAAGE,CAAC,GAAGF,IAAJE,GAAWA,CAAXA,GAAeF,IAAtBA;EACD;;EAEDR,GAAG,CAAC,CAAD,CAAHA,CAAO,CAAPA,IAAYI,IAAZJ;EACAA,GAAG,CAAC,CAAD,CAAHA,CAAO,CAAPA,IAAYO,IAAZP;EACAA,GAAG,CAAC,CAAD,CAAHA,CAAO,CAAPA,IAAYM,IAAZN;EACAA,GAAG,CAAC,CAAD,CAAHA,CAAO,CAAPA,IAAYQ,IAAZR;EACA,OAAOA,GAAP;AACD","names":["bitCode","intersect","getPointAtIndex","copy","push","cutPolylineByGrid","positions","options","size","broken","gridResolution","gridOffset","startIndex","endIndex","length","numPoints","part","result","a","b","codeB","cell","getGridCell","scratchPoint","i","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","concatInPlace","arr1","arr2","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","bbox","shift","getBoundingBox","code","parts","bisectPolygon","polygonLow","polygonHigh","polygon","edge","resultLow","resultHigh","typesLow","typesHigh","p","side","type","prev","prevSide","Math","sign","prevType","lowPointCount","highPointCount","out","left","floor","bottom","minX","Infinity","maxX","minY","maxY","x","y"],"sources":["../../src/cut-by-grid.js"],"sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nexport function cutPolylineByGrid(positions, options = {}) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1, arr2) {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n\nexport function cutPolygonByGrid(positions, holeIndices, options = {}) {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options;\n  const result = [];\n  const queue = [\n    {\n      pos: positions,\n      types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n      holes: holeIndices || []\n    }\n  ];\n  const bbox = [[], []];\n  let cell = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n"]},"metadata":{},"sourceType":"module"}