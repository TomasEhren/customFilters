{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIntermediatePosition = getIntermediatePosition;\nexports.GeoJsonEditMode = void 0;\n\nvar _union = _interopRequireDefault(require(\"@turf/union\"));\n\nvar _difference = _interopRequireDefault(require(\"@turf/difference\"));\n\nvar _intersect = _interopRequireDefault(require(\"@turf/intersect\"));\n\nvar _rewind = _interopRequireDefault(require(\"@turf/rewind\"));\n\nvar _utils = require(\"../utils\");\n\nvar _immutableFeatureCollection = require(\"./immutable-feature-collection\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_GUIDES = {\n  type: 'FeatureCollection',\n  features: []\n};\nvar DEFAULT_TOOLTIPS = []; // Main interface for `EditMode`s that edit GeoJSON\n\nvar GeoJsonEditMode = /*#__PURE__*/function () {\n  function GeoJsonEditMode() {\n    _classCallCheck(this, GeoJsonEditMode);\n\n    _defineProperty(this, \"_clickSequence\", []);\n  }\n\n  _createClass(GeoJsonEditMode, [{\n    key: \"getGuides\",\n    value: function getGuides(props) {\n      return DEFAULT_GUIDES;\n    }\n  }, {\n    key: \"getTooltips\",\n    value: function getTooltips(props) {\n      return DEFAULT_TOOLTIPS;\n    }\n  }, {\n    key: \"getSelectedFeature\",\n    value: function getSelectedFeature(props) {\n      if (props.selectedIndexes.length === 1) {\n        return props.data.features[props.selectedIndexes[0]];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedGeometry\",\n    value: function getSelectedGeometry(props) {\n      var feature = this.getSelectedFeature(props);\n\n      if (feature) {\n        return feature.geometry;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSelectedFeaturesAsFeatureCollection\",\n    value: function getSelectedFeaturesAsFeatureCollection(props) {\n      var features = props.data.features;\n      var selectedFeatures = props.selectedIndexes.map(function (selectedIndex) {\n        return features[selectedIndex];\n      });\n      return {\n        type: 'FeatureCollection',\n        features: selectedFeatures\n      };\n    }\n  }, {\n    key: \"getClickSequence\",\n    value: function getClickSequence() {\n      return this._clickSequence;\n    }\n  }, {\n    key: \"addClickSequence\",\n    value: function addClickSequence(_ref) {\n      var mapCoords = _ref.mapCoords;\n\n      this._clickSequence.push(mapCoords);\n    }\n  }, {\n    key: \"resetClickSequence\",\n    value: function resetClickSequence() {\n      this._clickSequence = [];\n    }\n  }, {\n    key: \"getTentativeGuide\",\n    value: function getTentativeGuide(props) {\n      var guides = this.getGuides(props); // @ts-ignore\n\n      return guides.features.find(function (f) {\n        return f.properties && f.properties.guideType === 'tentative';\n      });\n    }\n  }, {\n    key: \"isSelectionPicked\",\n    value: function isSelectionPicked(picks, props) {\n      if (!picks.length) return false;\n      var pickedFeatures = (0, _utils.getNonGuidePicks)(picks).map(function (_ref2) {\n        var index = _ref2.index;\n        return index;\n      });\n      var pickedHandles = (0, _utils.getPickedEditHandles)(picks).map(function (_ref3) {\n        var properties = _ref3.properties;\n        return properties.featureIndex;\n      });\n      var pickedIndexes = new Set([].concat(_toConsumableArray(pickedFeatures), _toConsumableArray(pickedHandles)));\n      return props.selectedIndexes.some(function (index) {\n        return pickedIndexes.has(index);\n      });\n    }\n  }, {\n    key: \"rewindPolygon\",\n    value: function rewindPolygon(feature) {\n      var geometry = feature.geometry;\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      if (isPolygonal) {\n        // @ts-ignore\n        return (0, _rewind[\"default\"])(feature);\n      }\n\n      return feature;\n    }\n  }, {\n    key: \"getAddFeatureAction\",\n    value: function getAddFeatureAction(featureOrGeometry, features) {\n      // Unsure why flow can't deal with Geometry type, but there I fixed it\n      var featureOrGeometryAsAny = featureOrGeometry;\n      var feature = featureOrGeometryAsAny.type === 'Feature' ? featureOrGeometryAsAny : {\n        type: 'Feature',\n        properties: {},\n        geometry: featureOrGeometryAsAny\n      };\n      var rewindFeature = this.rewindPolygon(feature);\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features).addFeature(rewindFeature).getObject();\n      return {\n        updatedData: updatedData,\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: [updatedData.features.length - 1]\n        }\n      };\n    }\n  }, {\n    key: \"getAddManyFeaturesAction\",\n    value: function getAddManyFeaturesAction(_ref4, features) {\n      var featuresToAdd = _ref4.features;\n      var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(features);\n      var initialIndex = updatedData.getObject().features.length;\n      var updatedIndexes = [];\n\n      var _iterator = _createForOfIteratorHelper(featuresToAdd),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var feature = _step.value;\n          var properties = feature.properties,\n              geometry = feature.geometry;\n          var geometryAsAny = geometry;\n          updatedData = updatedData.addFeature({\n            type: 'Feature',\n            properties: properties,\n            geometry: geometryAsAny\n          });\n          updatedIndexes.push(initialIndex + updatedIndexes.length);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        updatedData: updatedData.getObject(),\n        editType: 'addFeature',\n        editContext: {\n          featureIndexes: updatedIndexes\n        }\n      };\n    }\n  }, {\n    key: \"getAddFeatureOrBooleanPolygonAction\",\n    value: function getAddFeatureOrBooleanPolygonAction(featureOrGeometry, props) {\n      var featureOrGeometryAsAny = featureOrGeometry;\n      var selectedFeature = this.getSelectedFeature(props);\n      var modeConfig = props.modeConfig;\n\n      if (modeConfig && modeConfig.booleanOperation) {\n        if (!selectedFeature || selectedFeature.geometry.type !== 'Polygon' && selectedFeature.geometry.type !== 'MultiPolygon') {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('booleanOperation only supported for single Polygon or MultiPolygon selection');\n          return null;\n        }\n\n        var feature = featureOrGeometryAsAny.type === 'Feature' ? featureOrGeometryAsAny : {\n          type: 'Feature',\n          geometry: featureOrGeometryAsAny\n        };\n        var updatedGeometry;\n\n        if (modeConfig.booleanOperation === 'union') {\n          updatedGeometry = (0, _union[\"default\"])(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'difference') {\n          // @ts-ignore\n          updatedGeometry = (0, _difference[\"default\"])(selectedFeature, feature);\n        } else if (modeConfig.booleanOperation === 'intersection') {\n          // @ts-ignore\n          updatedGeometry = (0, _intersect[\"default\"])(selectedFeature, feature);\n        } else {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn(\"Invalid booleanOperation \".concat(modeConfig.booleanOperation));\n          return null;\n        }\n\n        if (!updatedGeometry) {\n          // eslint-disable-next-line no-console,no-undef\n          console.warn('Canceling edit. Boolean operation erased entire polygon.');\n          return null;\n        }\n\n        var featureIndex = props.selectedIndexes[0];\n        var updatedData = new _immutableFeatureCollection.ImmutableFeatureCollection(props.data).replaceGeometry(featureIndex, updatedGeometry.geometry).getObject();\n        var editAction = {\n          updatedData: updatedData,\n          editType: 'unionGeometry',\n          editContext: {\n            featureIndexes: [featureIndex]\n          }\n        };\n        return editAction;\n      }\n\n      return this.getAddFeatureAction(featureOrGeometry, props.data);\n    }\n  }, {\n    key: \"createTentativeFeature\",\n    value: function createTentativeFeature(props) {\n      return null;\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(event, props) {}\n  }, {\n    key: \"handlePointerMove\",\n    value: function handlePointerMove(event, props) {\n      var tentativeFeature = this.createTentativeFeature(props);\n\n      if (tentativeFeature) {\n        props.onEdit({\n          updatedData: props.data,\n          editType: 'updateTentativeFeature',\n          editContext: {\n            feature: tentativeFeature\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleStartDragging\",\n    value: function handleStartDragging(event, props) {}\n  }, {\n    key: \"handleStopDragging\",\n    value: function handleStopDragging(event, props) {}\n  }, {\n    key: \"handleDragging\",\n    value: function handleDragging(event, props) {}\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(event, props) {\n      if (event.key === 'Escape') {\n        this.resetClickSequence();\n        props.onEdit({\n          // Because the new drawing feature is dropped, so the data will keep as the same.\n          updatedData: props.data,\n          editType: 'cancelFeature',\n          editContext: {}\n        });\n      }\n    }\n  }]);\n\n  return GeoJsonEditMode;\n}();\n\nexports.GeoJsonEditMode = GeoJsonEditMode;\n\nfunction getIntermediatePosition(position1, position2) {\n  var intermediatePosition = [(position1[0] + position2[0]) / 2.0, (position1[1] + position2[1]) / 2.0]; // @ts-ignore\n\n  return intermediatePosition;\n}","map":{"version":3,"mappings":"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","names":["DEFAULT_GUIDES","type","features","DEFAULT_TOOLTIPS","GeoJsonEditMode","props","selectedIndexes","length","data","feature","getSelectedFeature","geometry","selectedFeatures","map","selectedIndex","_clickSequence","mapCoords","push","guides","getGuides","find","f","properties","guideType","picks","pickedFeatures","index","pickedHandles","featureIndex","pickedIndexes","Set","some","has","isPolygonal","featureOrGeometry","featureOrGeometryAsAny","rewindFeature","rewindPolygon","updatedData","ImmutableFeatureCollection","addFeature","getObject","editType","editContext","featureIndexes","featuresToAdd","initialIndex","updatedIndexes","geometryAsAny","_iterator","selectedFeature","modeConfig","booleanOperation","console","warn","updatedGeometry","replaceGeometry","editAction","getAddFeatureAction","event","tentativeFeature","createTentativeFeature","onEdit","key","resetClickSequence","getIntermediatePosition","position1","position2","intermediatePosition"],"sources":["../../src/lib/geojson-edit-mode.ts"],"sourcesContent":["import turfUnion from '@turf/union';\nimport turfDifference from '@turf/difference';\nimport turfIntersect from '@turf/intersect';\nimport rewind from '@turf/rewind';\n\nimport {\n  EditAction,\n  ClickEvent,\n  PointerMoveEvent,\n  StartDraggingEvent,\n  StopDraggingEvent,\n  DraggingEvent,\n  Pick,\n  Tooltip,\n  ModeProps,\n  GuideFeatureCollection,\n  TentativeFeature,\n} from '../types';\nimport { FeatureCollection, Feature, Polygon, Geometry, Position } from '../geojson-types';\nimport { getPickedEditHandles, getNonGuidePicks } from '../utils';\nimport { EditMode } from './edit-mode';\nimport { ImmutableFeatureCollection } from './immutable-feature-collection';\n\nexport type GeoJsonEditAction = EditAction<FeatureCollection>;\n\nconst DEFAULT_GUIDES: GuideFeatureCollection = {\n  type: 'FeatureCollection',\n  features: [],\n};\nconst DEFAULT_TOOLTIPS: Tooltip[] = [];\n\n// Main interface for `EditMode`s that edit GeoJSON\nexport type GeoJsonEditModeType = EditMode<FeatureCollection, FeatureCollection>;\n\nexport interface GeoJsonEditModeConstructor {\n  new (): GeoJsonEditModeType;\n}\n\nexport class GeoJsonEditMode implements EditMode<FeatureCollection, GuideFeatureCollection> {\n  _clickSequence: Position[] = [];\n\n  getGuides(props: ModeProps<FeatureCollection>): GuideFeatureCollection {\n    return DEFAULT_GUIDES;\n  }\n\n  getTooltips(props: ModeProps<FeatureCollection>): Tooltip[] {\n    return DEFAULT_TOOLTIPS;\n  }\n\n  getSelectedFeature(props: ModeProps<FeatureCollection>): Feature | null | undefined {\n    if (props.selectedIndexes.length === 1) {\n      return props.data.features[props.selectedIndexes[0]];\n    }\n    return null;\n  }\n\n  getSelectedGeometry(props: ModeProps<FeatureCollection>): Geometry | null | undefined {\n    const feature = this.getSelectedFeature(props);\n    if (feature) {\n      return feature.geometry;\n    }\n    return null;\n  }\n\n  getSelectedFeaturesAsFeatureCollection(props: ModeProps<FeatureCollection>): FeatureCollection {\n    const { features } = props.data;\n    const selectedFeatures = props.selectedIndexes.map((selectedIndex) => features[selectedIndex]);\n    return {\n      type: 'FeatureCollection',\n      features: selectedFeatures,\n    };\n  }\n\n  getClickSequence(): Position[] {\n    return this._clickSequence;\n  }\n\n  addClickSequence({ mapCoords }: ClickEvent): void {\n    this._clickSequence.push(mapCoords);\n  }\n\n  resetClickSequence(): void {\n    this._clickSequence = [];\n  }\n\n  getTentativeGuide(props: ModeProps<FeatureCollection>): TentativeFeature | null | undefined {\n    const guides = this.getGuides(props);\n\n    // @ts-ignore\n    return guides.features.find((f) => f.properties && f.properties.guideType === 'tentative');\n  }\n\n  isSelectionPicked(picks: Pick[], props: ModeProps<FeatureCollection>): boolean {\n    if (!picks.length) return false;\n    const pickedFeatures = getNonGuidePicks(picks).map(({ index }) => index);\n    const pickedHandles = getPickedEditHandles(picks).map(\n      ({ properties }) => properties.featureIndex\n    );\n    const pickedIndexes = new Set([...pickedFeatures, ...pickedHandles]);\n    return props.selectedIndexes.some((index) => pickedIndexes.has(index));\n  }\n\n  rewindPolygon(feature: Feature): Feature {\n    const { geometry } = feature;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    if (isPolygonal) {\n      // @ts-ignore\n      return rewind(feature);\n    }\n\n    return feature;\n  }\n\n  getAddFeatureAction(\n    featureOrGeometry: Geometry | Feature,\n    features: FeatureCollection\n  ): GeoJsonEditAction {\n    // Unsure why flow can't deal with Geometry type, but there I fixed it\n    const featureOrGeometryAsAny: any = featureOrGeometry;\n\n    const feature: any =\n      featureOrGeometryAsAny.type === 'Feature'\n        ? featureOrGeometryAsAny\n        : {\n            type: 'Feature',\n            properties: {},\n            geometry: featureOrGeometryAsAny,\n          };\n\n    const rewindFeature = this.rewindPolygon(feature);\n    const updatedData = new ImmutableFeatureCollection(features)\n      .addFeature(rewindFeature)\n      .getObject();\n\n    return {\n      updatedData,\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: [updatedData.features.length - 1],\n      },\n    };\n  }\n\n  getAddManyFeaturesAction(\n    { features: featuresToAdd }: FeatureCollection,\n    features: FeatureCollection\n  ): GeoJsonEditAction {\n    let updatedData = new ImmutableFeatureCollection(features);\n    const initialIndex = updatedData.getObject().features.length;\n    const updatedIndexes = [];\n    for (const feature of featuresToAdd) {\n      const { properties, geometry } = feature;\n      const geometryAsAny: any = geometry;\n      updatedData = updatedData.addFeature({\n        type: 'Feature',\n        properties,\n        geometry: geometryAsAny,\n      });\n      updatedIndexes.push(initialIndex + updatedIndexes.length);\n    }\n\n    return {\n      updatedData: updatedData.getObject(),\n      editType: 'addFeature',\n      editContext: {\n        featureIndexes: updatedIndexes,\n      },\n    };\n  }\n\n  getAddFeatureOrBooleanPolygonAction(\n    featureOrGeometry: Polygon | Feature,\n    props: ModeProps<FeatureCollection>\n  ): GeoJsonEditAction | null | undefined {\n    const featureOrGeometryAsAny: any = featureOrGeometry;\n\n    const selectedFeature = this.getSelectedFeature(props);\n    const { modeConfig } = props;\n    if (modeConfig && modeConfig.booleanOperation) {\n      if (\n        !selectedFeature ||\n        (selectedFeature.geometry.type !== 'Polygon' &&\n          selectedFeature.geometry.type !== 'MultiPolygon')\n      ) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(\n          'booleanOperation only supported for single Polygon or MultiPolygon selection'\n        );\n        return null;\n      }\n\n      const feature =\n        featureOrGeometryAsAny.type === 'Feature'\n          ? featureOrGeometryAsAny\n          : {\n              type: 'Feature',\n              geometry: featureOrGeometryAsAny,\n            };\n\n      let updatedGeometry;\n      if (modeConfig.booleanOperation === 'union') {\n        updatedGeometry = turfUnion(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'difference') {\n        // @ts-ignore\n        updatedGeometry = turfDifference(selectedFeature, feature);\n      } else if (modeConfig.booleanOperation === 'intersection') {\n        // @ts-ignore\n        updatedGeometry = turfIntersect(selectedFeature, feature);\n      } else {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn(`Invalid booleanOperation ${modeConfig.booleanOperation}`);\n        return null;\n      }\n\n      if (!updatedGeometry) {\n        // eslint-disable-next-line no-console,no-undef\n        console.warn('Canceling edit. Boolean operation erased entire polygon.');\n        return null;\n      }\n\n      const featureIndex = props.selectedIndexes[0];\n\n      const updatedData = new ImmutableFeatureCollection(props.data)\n        .replaceGeometry(featureIndex, updatedGeometry.geometry)\n        .getObject();\n\n      const editAction: GeoJsonEditAction = {\n        updatedData,\n        editType: 'unionGeometry',\n        editContext: {\n          featureIndexes: [featureIndex],\n        },\n      };\n\n      return editAction;\n    }\n    return this.getAddFeatureAction(featureOrGeometry, props.data);\n  }\n\n  createTentativeFeature(props: ModeProps<FeatureCollection>): TentativeFeature {\n    return null;\n  }\n\n  handleClick(event: ClickEvent, props: ModeProps<FeatureCollection>): void {}\n  handlePointerMove(event: PointerMoveEvent, props: ModeProps<FeatureCollection>): void {\n    const tentativeFeature = this.createTentativeFeature(props);\n    if (tentativeFeature) {\n      props.onEdit({\n        updatedData: props.data,\n        editType: 'updateTentativeFeature',\n        editContext: {\n          feature: tentativeFeature,\n        },\n      });\n    }\n  }\n  handleStartDragging(event: StartDraggingEvent, props: ModeProps<FeatureCollection>): void {}\n  handleStopDragging(event: StopDraggingEvent, props: ModeProps<FeatureCollection>): void {}\n  handleDragging(event: DraggingEvent, props: ModeProps<FeatureCollection>): void {}\n\n  handleKeyUp(event: KeyboardEvent, props: ModeProps<FeatureCollection>): void {\n    if (event.key === 'Escape') {\n      this.resetClickSequence();\n      props.onEdit({\n        // Because the new drawing feature is dropped, so the data will keep as the same.\n        updatedData: props.data,\n        editType: 'cancelFeature',\n        editContext: {},\n      });\n    }\n  }\n}\n\nexport function getIntermediatePosition(position1: Position, position2: Position): Position {\n  const intermediatePosition = [\n    (position1[0] + position2[0]) / 2.0,\n    (position1[1] + position2[1]) / 2.0,\n  ];\n  // @ts-ignore\n  return intermediatePosition;\n}\n"]},"metadata":{},"sourceType":"script"}