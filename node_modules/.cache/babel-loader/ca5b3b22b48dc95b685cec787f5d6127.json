{"ast":null,"code":"import { assert, log } from '@luma.gl/webgl';\nimport { Matrix4, Quaternion } from '@math.gl/core';\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {\n      buffer,\n      byteOffset\n    } = accessor.bufferView.data;\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      const slicedArray = [];\n\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\nconst helperMatrix = new Matrix4();\n\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\n\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    quaternion.slerp({\n      start,\n      target: stop,\n      ratio\n    });\n\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, _ref) {\n  let {\n    p0,\n    outTangent0,\n    inTangent1,\n    p1,\n    tDiff,\n    ratio: t\n  } = _ref;\n\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, _ref2, target, path) {\n  let {\n    input,\n    interpolation,\n    output\n  } = _ref2;\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n        cubicsplineInterpolate(target, path, {\n          p0,\n          outTangent0,\n          inTangent1,\n          p1,\n          tDiff,\n          ratio\n        });\n      }\n\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n    this.channels.forEach(_ref3 => {\n      let {\n        sampler,\n        target,\n        path\n      } = _ref3;\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(_ref4 => {\n        let {\n          input,\n          interpolation = 'LINEAR',\n          output\n        } = _ref4;\n        return {\n          input: accessorToJsArray(gltf.accessors[input]),\n          interpolation,\n          output: accessorToJsArray(gltf.accessors[output])\n        };\n      });\n      const channels = animation.channels.map(_ref5 => {\n        let {\n          sampler,\n          target\n        } = _ref5;\n        return {\n          sampler: samplers[sampler],\n          target: gltf.nodes[target.node],\n          path: target.path\n        };\n      });\n      return new GLTFAnimation({\n        name,\n        channels\n      });\n    });\n  }\n\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["assert","log","Matrix4","Quaternion","ATTRIBUTE_TYPE_TO_COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","accessorToJsArray","accessor","_animation","ArrayType","componentType","components","type","length","count","buffer","byteOffset","bufferView","data","array","Array","from","slicedArray","i","push","slice","helperMatrix","applyTranslationRotationScale","gltfNode","node","matrix","identity","translation","translate","rotation","rotationMatrix","fromQuaternion","multiplyRight","scale","quaternion","linearInterpolate","target","path","start","stop","ratio","slerp","cubicsplineInterpolate","p0","outTangent0","inTangent1","p1","tDiff","t","m0","m1","Math","pow","stepInterpolate","value","interpolate","time","input","interpolation","output","maxTime","animationTime","nextIndex","findIndex","previousIndex","max","isArray","warn","previousTime","nextTime","GLTFAnimation","constructor","props","startTime","playing","speed","channels","Object","assign","animate","timeMs","absTime","forEach","sampler","_node","GLTFAnimator","gltf","animations","map","animation","index","name","samplers","accessors","nodes","setTime","getAnimations"],"sources":["../../../src/gltf/gltf-animator.js"],"sourcesContent":["import {assert, log} from '@luma.gl/webgl';\nimport {Matrix4, Quaternion} from '@math.gl/core';\n\n// TODO: import from loaders.gl?\nexport const ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n//\n\nfunction accessorToJsArray(accessor) {\n  if (!accessor._animation) {\n    const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n    const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n    const length = components * accessor.count;\n    const {buffer, byteOffset} = accessor.bufferView.data;\n\n    const array = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length);\n\n    if (components === 1) {\n      accessor._animation = Array.from(array);\n    } else {\n      // Slice array\n      const slicedArray = [];\n      for (let i = 0; i < array.length; i += components) {\n        slicedArray.push(Array.from(array.slice(i, i + components)));\n      }\n      accessor._animation = slicedArray;\n    }\n  }\n\n  return accessor._animation;\n}\n\n// TODO: share with GLTFInstantiator\nconst helperMatrix = new Matrix4();\nfunction applyTranslationRotationScale(gltfNode, node) {\n  node.matrix.identity();\n\n  if (gltfNode.translation) {\n    node.matrix.translate(gltfNode.translation);\n  }\n\n  if (gltfNode.rotation) {\n    const rotationMatrix = helperMatrix.fromQuaternion(gltfNode.rotation);\n    node.matrix.multiplyRight(rotationMatrix);\n  }\n\n  if (gltfNode.scale) {\n    node.matrix.scale(gltfNode.scale);\n  }\n}\n\nconst quaternion = new Quaternion();\nfunction linearInterpolate(target, path, start, stop, ratio) {\n  if (path === 'rotation') {\n    // SLERP when path is rotation\n    quaternion.slerp({start, target: stop, ratio});\n    for (let i = 0; i < quaternion.length; i++) {\n      target[path][i] = quaternion[i];\n    }\n  } else {\n    // regular interpolation\n    for (let i = 0; i < start.length; i++) {\n      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];\n    }\n  }\n}\n\nfunction cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio: t}) {\n  // TODO: Quaternion might need normalization\n  for (let i = 0; i < target[path].length; i++) {\n    const m0 = outTangent0[i] * tDiff;\n    const m1 = inTangent1[i] * tDiff;\n    target[path][i] =\n      (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] +\n      (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 +\n      (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] +\n      (Math.pow(t, 3) - Math.pow(t, 2)) * m1;\n  }\n}\n\nfunction stepInterpolate(target, path, value) {\n  for (let i = 0; i < value.length; i++) {\n    target[path][i] = value[i];\n  }\n}\n\nfunction interpolate(time, {input, interpolation, output}, target, path) {\n  const maxTime = input[input.length - 1];\n  const animationTime = time % maxTime;\n\n  const nextIndex = input.findIndex(t => t >= animationTime);\n  const previousIndex = Math.max(0, nextIndex - 1);\n\n  if (!Array.isArray(target[path])) {\n    switch (path) {\n      case 'translation':\n        target[path] = [0, 0, 0];\n        break;\n\n      case 'rotation':\n        target[path] = [0, 0, 0, 1];\n        break;\n\n      case 'scale':\n        target[path] = [1, 1, 1];\n        break;\n\n      default:\n        log.warn(`Bad animation path ${path}`)();\n    }\n  }\n\n  assert(target[path].length === output[previousIndex].length);\n  const previousTime = input[previousIndex];\n  const nextTime = input[nextIndex];\n\n  switch (interpolation) {\n    case 'STEP':\n      stepInterpolate(target, path, output[previousIndex]);\n      break;\n\n    case 'LINEAR':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);\n      }\n      break;\n\n    case 'CUBICSPLINE':\n      if (nextTime > previousTime) {\n        const ratio = (animationTime - previousTime) / (nextTime - previousTime);\n        const tDiff = nextTime - previousTime;\n\n        const p0 = output[3 * previousIndex + 1];\n        const outTangent0 = output[3 * previousIndex + 2];\n        const inTangent1 = output[3 * nextIndex + 0];\n        const p1 = output[3 * nextIndex + 1];\n\n        cubicsplineInterpolate(target, path, {p0, outTangent0, inTangent1, p1, tDiff, ratio});\n      }\n      break;\n\n    default:\n      log.warn(`Interpolation ${interpolation} not supported`)();\n      break;\n  }\n}\n\nclass GLTFAnimation {\n  constructor(props) {\n    this.startTime = 0;\n    this.playing = true;\n    this.speed = 1;\n    this.channels = [];\n\n    Object.assign(this, props);\n  }\n\n  animate(timeMs) {\n    if (!this.playing) {\n      return;\n    }\n\n    const absTime = timeMs / 1000;\n    const time = (absTime - this.startTime) * this.speed;\n\n    this.channels.forEach(({sampler, target, path}) => {\n      interpolate(time, sampler, target, path);\n      applyTranslationRotationScale(target, target._node);\n    });\n  }\n}\n\nexport default class GLTFAnimator {\n  constructor(gltf) {\n    this.animations = gltf.animations.map((animation, index) => {\n      const name = animation.name || `Animation-${index}`;\n      const samplers = animation.samplers.map(({input, interpolation = 'LINEAR', output}) => ({\n        input: accessorToJsArray(gltf.accessors[input]),\n        interpolation,\n        output: accessorToJsArray(gltf.accessors[output])\n      }));\n      const channels = animation.channels.map(({sampler, target}) => ({\n        sampler: samplers[sampler],\n        target: gltf.nodes[target.node],\n        path: target.path\n      }));\n      return new GLTFAnimation({name, channels});\n    });\n  }\n\n  // TODO(Tarek): This should be removed? (deck.gl is using this)\n  animate(time) {\n    this.setTime(time);\n  }\n\n  setTime(time) {\n    this.animations.forEach(animation => animation.animate(time));\n  }\n\n  getAnimations() {\n    return this.animations;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}