{"ast":null,"code":"import _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { deviation, extent, groupSort, median, variance } from 'd3-array';\nimport { rgb } from 'd3-color';\nimport { scaleLinear, scaleOrdinal, scaleLog, scalePoint, scaleQuantile, scaleQuantize, scaleSqrt } from 'd3-scale';\nimport { format as d3Format } from 'd3-format';\nimport moment from 'moment-timezone';\nimport { CPUGridLayer, HeatmapLayer, HexagonLayer } from '@deck.gl/aggregation-layers';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { H3HexagonLayer, MVTLayer } from '@deck.gl/geo-layers';\nimport CartoTileLayer from '../layers/carto-tile-layer';\nimport { TILE_FORMATS } from './maps-api-common';\nimport { assert } from '../utils';\nvar SCALE_FUNCS = {\n  linear: scaleLinear,\n  ordinal: scaleOrdinal,\n  log: scaleLog,\n  point: scalePoint,\n  quantile: scaleQuantile,\n  quantize: scaleQuantize,\n  sqrt: scaleSqrt\n};\nexport var AGGREGATION = {\n  average: 'MEAN',\n  maximum: 'MAX',\n  minimum: 'MIN',\n  sum: 'SUM'\n};\nvar AGGREGATION_FUNC = {\n  'count unique': function countUnique(values, accessor) {\n    return groupSort(values, function (v) {\n      return v.length;\n    }, accessor).length;\n  },\n  median: median,\n  mode: function mode(values, accessor) {\n    return groupSort(values, function (v) {\n      return v.length;\n    }, accessor).pop();\n  },\n  stddev: deviation,\n  variance: variance\n};\n\nvar hexToRGBA = function hexToRGBA(c) {\n  var _rgb = rgb(c),\n      r = _rgb.r,\n      g = _rgb.g,\n      b = _rgb.b,\n      opacity = _rgb.opacity;\n\n  return [r, g, b, 255 * opacity];\n};\n\nvar sharedPropMap = {\n  color: 'getFillColor',\n  isVisible: 'visible',\n  label: 'cartoLabel',\n  textLabel: {\n    alignment: 'getTextAlignmentBaseline',\n    anchor: 'getTextAnchor',\n    color: 'getTextColor',\n    size: 'getTextSize'\n  },\n  visConfig: {\n    enable3d: 'extruded',\n    elevationScale: 'elevationScale',\n    filled: 'filled',\n    opacity: 'opacity',\n    strokeColor: 'getLineColor',\n    stroked: 'stroked',\n    thickness: 'getLineWidth',\n    radius: 'getPointRadius',\n    wireframe: 'wireframe'\n  }\n};\nvar aggregationVisConfig = {\n  colorAggregation: function colorAggregation(x) {\n    return {\n      colorAggregation: AGGREGATION[x] || AGGREGATION.sum\n    };\n  },\n  colorRange: function colorRange(x) {\n    return {\n      colorRange: x.colors.map(hexToRGBA)\n    };\n  },\n  coverage: 'coverage',\n  elevationPercentile: ['elevationLowerPercentile', 'elevationUpperPercentile'],\n  percentile: ['lowerPercentile', 'upperPercentile']\n};\nvar defaultProps = {\n  lineMiterLimit: 2,\n  lineWidthUnits: 'pixels',\n  pointRadiusUnits: 'pixels',\n  rounded: true,\n  wrapLongitude: false\n};\n\nfunction mergePropMaps() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return _objectSpread(_objectSpread(_objectSpread({}, a), b), {}, {\n    visConfig: _objectSpread(_objectSpread({}, a.visConfig), b.visConfig)\n  });\n}\n\nexport function getLayer(type, config, dataset) {\n  var _config$columns;\n\n  if (type === 'mvt' || type === 'tileset') {\n    return getTileLayer(dataset);\n  }\n\n  var geoColumn = dataset === null || dataset === void 0 ? void 0 : dataset.geoColumn;\n\n  var getPosition = function getPosition(d) {\n    return d[geoColumn].coordinates;\n  };\n\n  var hexagonId = (_config$columns = config.columns) === null || _config$columns === void 0 ? void 0 : _config$columns.hex_id;\n  var layer = {\n    point: {\n      Layer: GeoJsonLayer,\n      propMap: {\n        visConfig: {\n          outline: 'stroked'\n        }\n      }\n    },\n    geojson: {\n      Layer: GeoJsonLayer\n    },\n    grid: {\n      Layer: CPUGridLayer,\n      propMap: {\n        visConfig: _objectSpread(_objectSpread({}, aggregationVisConfig), {}, {\n          worldUnitSize: function worldUnitSize(x) {\n            return {\n              cellSize: 1000 * x\n            };\n          }\n        })\n      },\n      defaultProps: {\n        getPosition: getPosition\n      }\n    },\n    heatmap: {\n      Layer: HeatmapLayer,\n      propMap: {\n        visConfig: _objectSpread(_objectSpread({}, aggregationVisConfig), {}, {\n          radius: 'radiusPixels'\n        })\n      },\n      defaultProps: {\n        getPosition: getPosition\n      }\n    },\n    hexagon: {\n      Layer: HexagonLayer,\n      propMap: {\n        visConfig: _objectSpread(_objectSpread({}, aggregationVisConfig), {}, {\n          worldUnitSize: function worldUnitSize(x) {\n            return {\n              radius: 1000 * x\n            };\n          }\n        })\n      },\n      defaultProps: {\n        getPosition: getPosition\n      }\n    },\n    hexagonId: {\n      Layer: H3HexagonLayer,\n      propMap: {\n        visConfig: {\n          coverage: 'coverage'\n        }\n      },\n      defaultProps: {\n        getHexagon: function getHexagon(d) {\n          return d[hexagonId];\n        },\n        stroked: false\n      }\n    }\n  }[type];\n  assert(layer, \"Unsupported layer type: \".concat(type));\n  layer.propMap = mergePropMaps(sharedPropMap, layer.propMap);\n  layer.defaultProps = _objectSpread(_objectSpread({}, defaultProps), layer.defaultProps);\n  return layer;\n}\n\nfunction getTileLayer(dataset) {\n  var _dataset$data$tiles = _slicedToArray(dataset.data.tiles, 1),\n      tileUrl = _dataset$data$tiles[0];\n\n  var formatTiles = new URL(tileUrl).searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n  return {\n    Layer: formatTiles === TILE_FORMATS.MVT ? MVTLayer : CartoTileLayer,\n    propMap: sharedPropMap,\n    defaultProps: _objectSpread(_objectSpread({}, defaultProps), {}, {\n      uniqueIdProperty: 'geoid',\n      formatTiles: formatTiles\n    })\n  };\n}\n\nfunction domainFromAttribute(attribute, scaleType) {\n  if (scaleType === 'ordinal' || scaleType === 'point') {\n    return attribute.categories.map(function (c) {\n      return c.category;\n    }).filter(function (c) {\n      return c !== undefined && c !== null;\n    });\n  }\n\n  var min = attribute.min;\n\n  if (scaleType === 'log' && min === 0) {\n    min = 1e-5;\n  }\n\n  return [min, attribute.max];\n}\n\nfunction domainFromValues(values, scaleType) {\n  if (scaleType === 'ordinal') {\n    return _toConsumableArray(new Set(values)).sort();\n  } else if (scaleType === 'quantile') {\n    return values.sort(function (a, b) {\n      return a - b;\n    });\n  } else if (scaleType === 'log') {\n    var _extent = extent(values),\n        _extent2 = _slicedToArray(_extent, 2),\n        d0 = _extent2[0],\n        d1 = _extent2[1];\n\n    return [d0 === 0 ? 1e-5 : d0, d1];\n  }\n\n  return extent(values);\n}\n\nfunction calculateDomain(data, name, scaleType) {\n  if (data.tilestats) {\n    var attributes = data.tilestats.layers[0].attributes;\n    var attribute = attributes.find(function (a) {\n      return a.attribute === name;\n    });\n    return domainFromAttribute(attribute, scaleType);\n  } else if (data.features) {\n    var values = data.features.map(function (_ref) {\n      var properties = _ref.properties;\n      return properties[name];\n    });\n    return domainFromValues(values, scaleType);\n  } else if (Array.isArray(data) && data[0][name] !== undefined) {\n    var _values = data.map(function (properties) {\n      return properties[name];\n    });\n\n    return domainFromValues(_values, scaleType);\n  }\n\n  return [0, 1];\n}\n\nfunction normalizeAccessor(accessor, data) {\n  if (data.features || data.tilestats) {\n    return function (_ref2) {\n      var properties = _ref2.properties;\n      return accessor(properties);\n    };\n  }\n\n  return accessor;\n}\n\nexport function getColorValueAccessor(_ref3, colorAggregation, data) {\n  var name = _ref3.name;\n  var aggregator = AGGREGATION_FUNC[colorAggregation];\n\n  var accessor = function accessor(values) {\n    return aggregator(values, function (p) {\n      return p[name];\n    });\n  };\n\n  return normalizeAccessor(accessor, data);\n}\nexport function getColorAccessor(_ref4, scaleType, _ref5, opacity, data) {\n  var name = _ref4.name;\n  var colors = _ref5.colors;\n  var scale = SCALE_FUNCS[scaleType]();\n  scale.domain(calculateDomain(data, name, scaleType));\n  scale.range(colors);\n  var alpha = opacity !== undefined ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;\n\n  var accessor = function accessor(properties) {\n    var _rgb2 = rgb(scale(properties[name])),\n        r = _rgb2.r,\n        g = _rgb2.g,\n        b = _rgb2.b;\n\n    return [r, g, b, alpha];\n  };\n\n  return normalizeAccessor(accessor, data);\n}\nexport function getSizeAccessor(_ref6, scaleType, range, data) {\n  var name = _ref6.name;\n  var scale = SCALE_FUNCS[scaleType]();\n  scale.domain(calculateDomain(data, name, scaleType));\n  scale.range(range);\n\n  var accessor = function accessor(properties) {\n    return scale(properties[name]);\n  };\n\n  return normalizeAccessor(accessor, data);\n}\nvar FORMATS = {\n  date: function date(s) {\n    return moment.utc(s).format('MM/DD/YY HH:mm:ssa');\n  },\n  integer: d3Format('i'),\n  float: d3Format('.5f'),\n  timestamp: function timestamp(s) {\n    return moment.utc(s).format('X');\n  },\n  default: String\n};\nexport function getTextAccessor(_ref7, data) {\n  var name = _ref7.name,\n      type = _ref7.type;\n  var format = FORMATS[type] || FORMATS.default;\n\n  var accessor = function accessor(properties) {\n    return format(properties[name]);\n  };\n\n  return normalizeAccessor(accessor, data);\n}\nexport function getTextPixelOffsetAccessor(_ref8, radius) {\n  var alignment = _ref8.alignment,\n      anchor = _ref8.anchor,\n      size = _ref8.size;\n  var padding = 20;\n  var signX = anchor === 'middle' ? 0 : anchor === 'start' ? 1 : -1;\n  var signY = alignment === 'center' ? 0 : alignment === 'bottom' ? 1 : -1;\n  var sizeOffset = alignment === 'center' ? 0 : size;\n\n  var calculateOffset = function calculateOffset(r) {\n    return [signX * (r + padding), signY * (r + padding + sizeOffset)];\n  };\n\n  return typeof radius === 'function' ? function (d) {\n    return calculateOffset(radius(d));\n  } : calculateOffset(radius);\n}\nexport { domainFromValues as _domainFromValues };","map":{"version":3,"mappings":"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","names":["deviation","extent","groupSort","median","variance","rgb","scaleLinear","scaleOrdinal","scaleLog","scalePoint","scaleQuantile","scaleQuantize","scaleSqrt","format","d3Format","moment","CPUGridLayer","HeatmapLayer","HexagonLayer","GeoJsonLayer","H3HexagonLayer","MVTLayer","CartoTileLayer","TILE_FORMATS","assert","SCALE_FUNCS","linear","ordinal","log","point","quantile","quantize","sqrt","AGGREGATION","average","maximum","minimum","sum","AGGREGATION_FUNC","values","accessor","v","length","mode","pop","stddev","hexToRGBA","c","r","g","b","opacity","sharedPropMap","color","isVisible","label","textLabel","alignment","anchor","size","visConfig","enable3d","elevationScale","filled","strokeColor","stroked","thickness","radius","wireframe","aggregationVisConfig","colorAggregation","x","colorRange","colors","map","coverage","elevationPercentile","percentile","defaultProps","lineMiterLimit","lineWidthUnits","pointRadiusUnits","rounded","wrapLongitude","mergePropMaps","a","getLayer","type","config","dataset","getTileLayer","geoColumn","getPosition","d","coordinates","hexagonId","columns","_config$columns","hex_id","layer","Layer","propMap","outline","geojson","grid","worldUnitSize","cellSize","heatmap","hexagon","getHexagon","data","tiles","tileUrl","formatTiles","URL","searchParams","get","MVT","uniqueIdProperty","domainFromAttribute","attribute","scaleType","categories","category","filter","undefined","min","max","domainFromValues","Set","sort","d0","d1","calculateDomain","name","tilestats","attributes","layers","find","features","properties","Array","isArray","normalizeAccessor","getColorValueAccessor","aggregator","p","getColorAccessor","scale","domain","range","alpha","Math","round","pow","getSizeAccessor","FORMATS","date","s","utc","integer","float","timestamp","default","String","getTextAccessor","getTextPixelOffsetAccessor","padding","signX","signY","sizeOffset","calculateOffset","_domainFromValues"],"sources":["../../../src/api/layer-map.ts"],"sourcesContent":["import {deviation, extent, groupSort, median, variance} from 'd3-array';\nimport {rgb} from 'd3-color';\nimport {\n  scaleLinear,\n  scaleOrdinal,\n  scaleLog,\n  scalePoint,\n  scaleQuantile,\n  scaleQuantize,\n  scaleSqrt\n} from 'd3-scale';\nimport {format as d3Format} from 'd3-format';\nimport moment from 'moment-timezone';\n\nimport {CPUGridLayer, HeatmapLayer, HexagonLayer} from '@deck.gl/aggregation-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {H3HexagonLayer, MVTLayer} from '@deck.gl/geo-layers';\n\nimport CartoTileLayer from '../layers/carto-tile-layer';\nimport {TILE_FORMATS} from './maps-api-common';\nimport {assert} from '../utils';\n\nconst SCALE_FUNCS = {\n  linear: scaleLinear,\n  ordinal: scaleOrdinal,\n  log: scaleLog,\n  point: scalePoint,\n  quantile: scaleQuantile,\n  quantize: scaleQuantize,\n  sqrt: scaleSqrt\n};\nexport type SCALE_TYPE = keyof typeof SCALE_FUNCS;\n\nexport const AGGREGATION = {\n  average: 'MEAN',\n  maximum: 'MAX',\n  minimum: 'MIN',\n  sum: 'SUM'\n};\n\nconst AGGREGATION_FUNC = {\n  'count unique': (values, accessor) => groupSort(values, v => v.length, accessor).length,\n  median,\n  // Unfortunately mode() is only available in d3-array@3+ which is ESM only\n  mode: (values, accessor) => groupSort(values, v => v.length, accessor).pop(),\n  stddev: deviation,\n  variance\n};\n\nconst hexToRGBA = c => {\n  const {r, g, b, opacity} = rgb(c);\n  return [r, g, b, 255 * opacity];\n};\n\n// Kepler -> Deck.gl\nconst sharedPropMap = {\n  color: 'getFillColor',\n  isVisible: 'visible',\n  label: 'cartoLabel',\n  textLabel: {\n    alignment: 'getTextAlignmentBaseline',\n    anchor: 'getTextAnchor',\n    color: 'getTextColor',\n    size: 'getTextSize'\n  },\n  visConfig: {\n    enable3d: 'extruded',\n    elevationScale: 'elevationScale',\n    filled: 'filled',\n    opacity: 'opacity',\n    strokeColor: 'getLineColor',\n    stroked: 'stroked',\n    thickness: 'getLineWidth',\n    radius: 'getPointRadius',\n    wireframe: 'wireframe'\n  }\n};\n\nconst aggregationVisConfig = {\n  colorAggregation: x => ({colorAggregation: AGGREGATION[x] || AGGREGATION.sum}),\n  colorRange: x => ({colorRange: x.colors.map(hexToRGBA)}),\n  coverage: 'coverage',\n  elevationPercentile: ['elevationLowerPercentile', 'elevationUpperPercentile'],\n  percentile: ['lowerPercentile', 'upperPercentile']\n};\n\nconst defaultProps = {\n  lineMiterLimit: 2,\n  lineWidthUnits: 'pixels',\n  pointRadiusUnits: 'pixels',\n  rounded: true,\n  wrapLongitude: false\n};\n\nfunction mergePropMaps(a = {}, b = {}) {\n  return {...a, ...b, visConfig: {...a.visConfig, ...b.visConfig}};\n}\n\nexport function getLayer(\n  type: string,\n  config,\n  dataset\n): {Layer: any; propMap: any; defaultProps: any} {\n  if (type === 'mvt' || type === 'tileset') {\n    return getTileLayer(dataset);\n  }\n\n  const geoColumn = dataset?.geoColumn;\n  const getPosition = d => d[geoColumn].coordinates;\n\n  const hexagonId = config.columns?.hex_id;\n  const layer = {\n    point: {\n      Layer: GeoJsonLayer,\n      propMap: {visConfig: {outline: 'stroked'}}\n    },\n    geojson: {\n      Layer: GeoJsonLayer\n    },\n    grid: {\n      Layer: CPUGridLayer,\n      propMap: {visConfig: {...aggregationVisConfig, worldUnitSize: x => ({cellSize: 1000 * x})}},\n      defaultProps: {getPosition}\n    },\n    heatmap: {\n      Layer: HeatmapLayer,\n      propMap: {visConfig: {...aggregationVisConfig, radius: 'radiusPixels'}},\n      defaultProps: {getPosition}\n    },\n    hexagon: {\n      Layer: HexagonLayer,\n      propMap: {visConfig: {...aggregationVisConfig, worldUnitSize: x => ({radius: 1000 * x})}},\n      defaultProps: {getPosition}\n    },\n    hexagonId: {\n      Layer: H3HexagonLayer,\n      propMap: {visConfig: {coverage: 'coverage'}},\n      defaultProps: {getHexagon: d => d[hexagonId], stroked: false}\n    }\n  }[type];\n\n  assert(layer, `Unsupported layer type: ${type}`);\n  layer.propMap = mergePropMaps(sharedPropMap, layer.propMap);\n  layer.defaultProps = {...defaultProps, ...layer.defaultProps};\n  return layer;\n}\n\nfunction getTileLayer(dataset) {\n  const {\n    data: {\n      tiles: [tileUrl]\n    }\n  } = dataset;\n  /* global URL */\n  const formatTiles = new URL(tileUrl).searchParams.get('formatTiles') || TILE_FORMATS.MVT;\n\n  return {\n    Layer: formatTiles === TILE_FORMATS.MVT ? MVTLayer : CartoTileLayer,\n    propMap: sharedPropMap,\n    defaultProps: {\n      ...defaultProps,\n      uniqueIdProperty: 'geoid',\n      formatTiles\n    }\n  };\n}\n\nfunction domainFromAttribute(attribute, scaleType: SCALE_TYPE) {\n  if (scaleType === 'ordinal' || scaleType === 'point') {\n    return attribute.categories.map(c => c.category).filter(c => c !== undefined && c !== null);\n  }\n\n  let {min} = attribute;\n  if (scaleType === 'log' && min === 0) {\n    min = 1e-5;\n  }\n  return [min, attribute.max];\n}\n\nfunction domainFromValues(values, scaleType: SCALE_TYPE) {\n  if (scaleType === 'ordinal') {\n    return [...new Set(values)].sort();\n  } else if (scaleType === 'quantile') {\n    return values.sort((a, b) => a - b);\n  } else if (scaleType === 'log') {\n    const [d0, d1] = extent(values as number[]);\n    return [d0 === 0 ? 1e-5 : d0, d1];\n  }\n  return extent(values);\n}\n\nfunction calculateDomain(data, name, scaleType) {\n  if (data.tilestats) {\n    // Tileset data type\n    const {attributes} = data.tilestats.layers[0];\n    const attribute = attributes.find(a => a.attribute === name);\n    return domainFromAttribute(attribute, scaleType);\n  } else if (data.features) {\n    // GeoJSON data type\n    const values = data.features.map(({properties}) => properties[name]);\n    return domainFromValues(values, scaleType);\n  } else if (Array.isArray(data) && data[0][name] !== undefined) {\n    // JSON data type\n    const values = data.map(properties => properties[name]);\n    return domainFromValues(values, scaleType);\n  }\n\n  return [0, 1];\n}\n\nfunction normalizeAccessor(accessor, data) {\n  if (data.features || data.tilestats) {\n    return ({properties}) => {\n      return accessor(properties);\n    };\n  }\n  return accessor;\n}\n\nexport function getColorValueAccessor({name}, colorAggregation, data: any) {\n  const aggregator = AGGREGATION_FUNC[colorAggregation];\n  const accessor = values => aggregator(values, p => p[name]);\n  return normalizeAccessor(accessor, data);\n}\n\nexport function getColorAccessor(\n  {name},\n  scaleType: SCALE_TYPE,\n  {colors},\n  opacity: number | undefined,\n  data: any\n) {\n  const scale = SCALE_FUNCS[scaleType as any]();\n  scale.domain(calculateDomain(data, name, scaleType));\n  scale.range(colors);\n  const alpha = opacity !== undefined ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;\n\n  const accessor = properties => {\n    const {r, g, b} = rgb(scale(properties[name]));\n    return [r, g, b, alpha];\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nexport function getSizeAccessor({name}, scaleType: SCALE_TYPE, range: Iterable<Range>, data: any) {\n  const scale = SCALE_FUNCS[scaleType as any]();\n  scale.domain(calculateDomain(data, name, scaleType));\n  scale.range(range);\n\n  const accessor = properties => {\n    return scale(properties[name]);\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nconst FORMATS: Record<string, (value: any) => string> = {\n  date: s => moment.utc(s).format('MM/DD/YY HH:mm:ssa'),\n  integer: d3Format('i'),\n  float: d3Format('.5f'),\n  timestamp: s => moment.utc(s).format('X'),\n  default: String\n};\n\nexport function getTextAccessor({name, type}, data) {\n  const format = FORMATS[type] || FORMATS.default;\n  const accessor = properties => {\n    return format(properties[name]);\n  };\n  return normalizeAccessor(accessor, data);\n}\n\nexport function getTextPixelOffsetAccessor({alignment, anchor, size}, radius) {\n  const padding = 20;\n  const signX = anchor === 'middle' ? 0 : anchor === 'start' ? 1 : -1;\n  const signY = alignment === 'center' ? 0 : alignment === 'bottom' ? 1 : -1;\n  const sizeOffset = alignment === 'center' ? 0 : size;\n\n  const calculateOffset = r => [signX * (r + padding), signY * (r + padding + sizeOffset)];\n\n  return typeof radius === 'function'\n    ? d => {\n        return calculateOffset(radius(d));\n      }\n    : calculateOffset(radius);\n}\n\nexport {domainFromValues as _domainFromValues};\n"]},"metadata":{},"sourceType":"module"}