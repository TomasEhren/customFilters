{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Buffer, assert } from '@luma.gl/webgl';\nvar GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  var buffers = {};\n  var indices = geometry.indices;\n\n  for (var name in geometry.attributes) {\n    var attribute = geometry.attributes[name];\n    var remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      var typedArray = attribute.value;\n\n      var accessor = _objectSpread({}, attribute);\n\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    var data = indices.value || indices;\n    assert(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for \"indices\" must be of integer type');\n    var _accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [new Buffer(gl, {\n      data: data,\n      target: 34963\n    }), _accessor];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  var _ref = options || {},\n      _ref$attributeMap = _ref.attributeMap,\n      attributeMap = _ref$attributeMap === void 0 ? GLTF_TO_LUMA_ATTRIBUTE_MAP : _ref$attributeMap;\n\n  return attributeMap && attributeMap[name] || name;\n}\n\nexport function inferAttributeAccessor(attributeName, attribute) {\n  var category;\n\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n\n    default:\n  }\n\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), \"attribute \".concat(attributeName, \" needs size\"));\n}","map":{"version":3,"mappings":"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","names":["Buffer","assert","GLTF_TO_LUMA_ATTRIBUTE_MAP","POSITION","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","getBuffersFromGeometry","gl","geometry","options","buffers","indices","name","attributes","attribute","remappedName","mapAttributeName","constant","value","typedArray","accessor","inferAttributeAccessor","data","Uint16Array","Uint32Array","size","isIndexed","undefined","target","attributeMap","attributeName","category","Number","isFinite"],"sources":["../../../src/lib/model-utils.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, assert} from '@luma.gl/webgl';\n\n// Support for mapping new geometries with glTF attribute names to \"classic\" luma.gl shader names\nconst GLTF_TO_LUMA_ATTRIBUTE_MAP = {\n  POSITION: 'positions',\n  NORMAL: 'normals',\n  COLOR_0: 'colors',\n  TEXCOORD_0: 'texCoords',\n  TEXCOORD_1: 'texCoords1',\n  TEXCOORD_2: 'texCoords2'\n};\n\nexport function getBuffersFromGeometry(gl, geometry, options) {\n  const buffers = {};\n  let indices = geometry.indices;\n\n  for (const name in geometry.attributes) {\n    const attribute = geometry.attributes[name];\n    const remappedName = mapAttributeName(name, options);\n\n    if (name === 'indices') {\n      indices = attribute;\n    } else if (attribute.constant) {\n      buffers[remappedName] = attribute.value;\n    } else {\n      const typedArray = attribute.value;\n      // Create accessor by copying the attribute and removing `value``\n      const accessor = {...attribute};\n      delete accessor.value;\n      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];\n\n      inferAttributeAccessor(name, accessor);\n    }\n  }\n\n  if (indices) {\n    const data = indices.value || indices;\n    assert(\n      data instanceof Uint16Array || data instanceof Uint32Array,\n      'attribute array for \"indices\" must be of integer type'\n    );\n    const accessor = {\n      size: 1,\n      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed\n    };\n    buffers.indices = [\n      new Buffer(gl, {\n        data,\n        target: GL.ELEMENT_ARRAY_BUFFER\n      }),\n      accessor\n    ];\n  }\n\n  return buffers;\n}\n\nfunction mapAttributeName(name, options) {\n  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};\n  return (attributeMap && attributeMap[name]) || name;\n}\n\n// Check for well known attribute names\n// eslint-disable-next-line complexity\nexport function inferAttributeAccessor(attributeName, attribute) {\n  let category;\n  switch (attributeName) {\n    case 'texCoords':\n    case 'texCoord1':\n    case 'texCoord2':\n    case 'texCoord3':\n      category = 'uvs';\n      break;\n    case 'vertices':\n    case 'positions':\n    case 'normals':\n    case 'pickingColors':\n      category = 'vectors';\n      break;\n    default:\n  }\n\n  // Check for categorys\n  switch (category) {\n    case 'vectors':\n      attribute.size = attribute.size || 3;\n      break;\n    case 'uvs':\n      attribute.size = attribute.size || 2;\n      break;\n    default:\n  }\n\n  assert(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);\n}\n"]},"metadata":{},"sourceType":"module"}