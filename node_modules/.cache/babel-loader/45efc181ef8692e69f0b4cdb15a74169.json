{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { isResponse } from '../../javascript-utils/is-type';\nimport { getResourceContentLength, getResourceUrlAndType } from './resource-utils';\nexport function makeResponse(_x) {\n  return _makeResponse.apply(this, arguments);\n}\n\nfunction _makeResponse() {\n  _makeResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resource) {\n    var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!isResponse(resource)) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", resource);\n\n          case 2:\n            headers = {};\n            contentLength = getResourceContentLength(resource);\n\n            if (contentLength >= 0) {\n              headers['content-length'] = String(contentLength);\n            }\n\n            _getResourceUrlAndTyp = getResourceUrlAndType(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;\n\n            if (type) {\n              headers['content-type'] = type;\n            }\n\n            _context.next = 9;\n            return getInitialDataUrl(resource);\n\n          case 9:\n            initialDataUrl = _context.sent;\n\n            if (initialDataUrl) {\n              headers['x-first-bytes'] = initialDataUrl;\n            }\n\n            if (typeof resource === 'string') {\n              resource = new TextEncoder().encode(resource);\n            }\n\n            response = new Response(resource, {\n              headers: headers\n            });\n            Object.defineProperty(response, 'url', {\n              value: url\n            });\n            return _context.abrupt(\"return\", response);\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _makeResponse.apply(this, arguments);\n}\n\nexport function checkResponse(_x2) {\n  return _checkResponse.apply(this, arguments);\n}\n\nfunction _checkResponse() {\n  _checkResponse = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(response) {\n    var message;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (response.ok) {\n              _context2.next = 5;\n              break;\n            }\n\n            _context2.next = 3;\n            return getResponseError(response);\n\n          case 3:\n            message = _context2.sent;\n            throw new Error(message);\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _checkResponse.apply(this, arguments);\n}\n\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    var message = \"\".concat(response.status, \" \").concat(response.statusText);\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n    throw new Error(message);\n  }\n}\n\nfunction getResponseError(_x3) {\n  return _getResponseError.apply(this, arguments);\n}\n\nfunction _getResponseError() {\n  _getResponseError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(response) {\n    var message, contentType, text;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            message = \"Failed to fetch resource \".concat(response.url, \" (\").concat(response.status, \"): \");\n            _context3.prev = 1;\n            contentType = response.headers.get('Content-Type');\n            text = response.statusText;\n\n            if (!contentType.includes('application/json')) {\n              _context3.next = 11;\n              break;\n            }\n\n            _context3.t0 = text;\n            _context3.t1 = \" \";\n            _context3.next = 9;\n            return response.text();\n\n          case 9:\n            _context3.t2 = _context3.sent;\n            text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);\n\n          case 11:\n            message += text;\n            message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n            _context3.next = 17;\n            break;\n\n          case 15:\n            _context3.prev = 15;\n            _context3.t3 = _context3[\"catch\"](1);\n\n          case 17:\n            return _context3.abrupt(\"return\", message);\n\n          case 18:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[1, 15]]);\n  }));\n  return _getResponseError.apply(this, arguments);\n}\n\nfunction getInitialDataUrl(_x4) {\n  return _getInitialDataUrl.apply(this, arguments);\n}\n\nfunction _getInitialDataUrl() {\n  _getInitialDataUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(resource) {\n    var INITIAL_DATA_LENGTH, blobSlice, slice, base64;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            INITIAL_DATA_LENGTH = 5;\n\n            if (!(typeof resource === 'string')) {\n              _context4.next = 3;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", \"data:,\".concat(resource.slice(0, INITIAL_DATA_LENGTH)));\n\n          case 3:\n            if (!(resource instanceof Blob)) {\n              _context4.next = 8;\n              break;\n            }\n\n            blobSlice = resource.slice(0, 5);\n            _context4.next = 7;\n            return new Promise(function (resolve) {\n              var reader = new FileReader();\n\n              reader.onload = function (event) {\n                var _event$target;\n\n                return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n              };\n\n              reader.readAsDataURL(blobSlice);\n            });\n\n          case 7:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 8:\n            if (!(resource instanceof ArrayBuffer)) {\n              _context4.next = 12;\n              break;\n            }\n\n            slice = resource.slice(0, INITIAL_DATA_LENGTH);\n            base64 = arrayBufferToBase64(slice);\n            return _context4.abrupt(\"return\", \"data:base64,\".concat(base64));\n\n          case 12:\n            return _context4.abrupt(\"return\", null);\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getInitialDataUrl.apply(this, arguments);\n}\n\nfunction arrayBufferToBase64(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n\n  for (var i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return btoa(binary);\n}","map":{"version":3,"mappings":"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","names":["isResponse","getResourceContentLength","getResourceUrlAndType","makeResponse","resource","headers","contentLength","String","url","type","getInitialDataUrl","initialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","getResponseError","message","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","concat","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","_event$target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"sources":["../../../../src/lib/utils/response-utils.ts"],"sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"]},"metadata":{},"sourceType":"module"}