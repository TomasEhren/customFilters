{"ast":null,"code":"import VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\nimport { flatGeojsonToBinary } from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nexport default function parseMVT(arrayBuffer, options) {\n  options = normalizeOptions(options);\n  const features = [];\n\n  if (options) {\n    const binary = options.gis.format === 'binary';\n    const geometryInfo = {\n      coordLength: 2,\n      pointPositionsCount: 0,\n      pointFeaturesCount: 0,\n      linePositionsCount: 0,\n      linePathsCount: 0,\n      lineFeaturesCount: 0,\n      polygonPositionsCount: 0,\n      polygonObjectsCount: 0,\n      polygonRingsCount: 0,\n      polygonFeaturesCount: 0\n    };\n\n    if (arrayBuffer.byteLength > 0) {\n      const tile = binary ? new BinaryVectorTile(new Protobuf(arrayBuffer)) : new VectorTile(new Protobuf(arrayBuffer));\n      const loaderOptions = options.mvt;\n      const selectedLayers = Array.isArray(loaderOptions.layers) ? loaderOptions.layers : Object.keys(tile.layers);\n      selectedLayers.forEach(layerName => {\n        const vectorTileLayer = tile.layers[layerName];\n        const featureOptions = { ...loaderOptions,\n          layerName\n        };\n\n        if (!vectorTileLayer) {\n          return;\n        }\n\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n          const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n          const decodedFeature = binary ? getDecodedFeatureBinary(vectorTileFeature, featureOptions) : getDecodedFeature(vectorTileFeature, featureOptions);\n          features.push(decodedFeature);\n        }\n      });\n    }\n\n    if (binary) {\n      const data = flatGeojsonToBinary(features, geometryInfo);\n      data.byteLength = arrayBuffer.byteLength;\n      return data;\n    }\n  }\n\n  return features;\n}\n\nfunction normalizeOptions(options) {\n  if (options) {\n    options = { ...options,\n      mvt: options.mvt || {},\n      gis: options.gis || {}\n    };\n    const wgs84Coordinates = options.coordinates === 'wgs84';\n    const {\n      tileIndex\n    } = options;\n    const hasTileIndex = tileIndex && Number.isFinite(tileIndex.x) && Number.isFinite(tileIndex.y) && Number.isFinite(tileIndex.z);\n\n    if (wgs84Coordinates && !hasTileIndex) {\n      throw new Error('MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.');\n    }\n  }\n\n  return options;\n}\n\nfunction getDecodedFeature(feature, options) {\n  const decodedFeature = feature.toGeoJSON(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates);\n\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction getDecodedFeatureBinary(feature, options) {\n  const decodedFeature = feature.toBinaryCoordinates(options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary);\n\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\nfunction transformToLocalCoordinates(line, feature) {\n  const {\n    extent\n  } = feature;\n\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data, feature) {\n  const {\n    extent\n  } = feature;\n\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}","map":{"version":3,"mappings":"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","names":["VectorTile","BinaryVectorTile","flatGeojsonToBinary","Protobuf","parseMVT","arrayBuffer","options","normalizeOptions","features","binary","gis","format","geometryInfo","coordLength","pointPositionsCount","pointFeaturesCount","linePositionsCount","linePathsCount","lineFeaturesCount","polygonPositionsCount","polygonObjectsCount","polygonRingsCount","polygonFeaturesCount","byteLength","tile","loaderOptions","mvt","selectedLayers","Array","isArray","layers","Object","keys","forEach","layerName","vectorTileLayer","featureOptions","i","length","vectorTileFeature","feature","decodedFeature","getDecodedFeatureBinary","getDecodedFeature","push","data","wgs84Coordinates","coordinates","tileIndex","hasTileIndex","Number","isFinite","x","y","z","Error","toGeoJSON","transformToLocalCoordinates","layerProperty","properties","toBinaryCoordinates","transformToLocalCoordinatesBinary","line","extent","p","il"],"sources":["../../../src/lib/parse-mvt.ts"],"sourcesContent":["// import {VectorTile} from '@mapbox/vector-tile';\nimport VectorTile from './mapbox-vector-tile/vector-tile';\nimport BinaryVectorTile from './binary-vector-tile/vector-tile';\n\nimport {flatGeojsonToBinary} from '@loaders.gl/gis';\nimport Protobuf from 'pbf';\nimport type {FlatFeature} from '@loaders.gl/schema';\nimport type {MvtMapboxCoordinates, MvtOptions} from '../lib/types';\nimport VectorTileFeatureBinary from './binary-vector-tile/vector-tile-feature';\nimport VectorTileFeatureMapBox from './mapbox-vector-tile/vector-tile-feature';\nimport {LoaderOptions} from '@loaders.gl/loader-utils';\n\n/**\n * Parse MVT arrayBuffer and return GeoJSON.\n *\n * @param arrayBuffer A MVT arrayBuffer\n * @param options\n * @returns A GeoJSON geometry object or a binary representation\n */\nexport default function parseMVT(arrayBuffer: ArrayBuffer, options?: LoaderOptions) {\n  options = normalizeOptions(options);\n  const features: (FlatFeature | MvtMapboxCoordinates)[] = [];\n\n  if (options) {\n    const binary = options.gis.format === 'binary';\n    const geometryInfo = {\n      coordLength: 2,\n      pointPositionsCount: 0,\n      pointFeaturesCount: 0,\n      linePositionsCount: 0,\n      linePathsCount: 0,\n      lineFeaturesCount: 0,\n      polygonPositionsCount: 0,\n      polygonObjectsCount: 0,\n      polygonRingsCount: 0,\n      polygonFeaturesCount: 0\n    };\n\n    if (arrayBuffer.byteLength > 0) {\n      const tile = binary\n        ? new BinaryVectorTile(new Protobuf(arrayBuffer))\n        : new VectorTile(new Protobuf(arrayBuffer));\n      const loaderOptions = options.mvt;\n\n      const selectedLayers = Array.isArray(loaderOptions.layers)\n        ? loaderOptions.layers\n        : Object.keys(tile.layers);\n\n      selectedLayers.forEach((layerName: string) => {\n        const vectorTileLayer = tile.layers[layerName];\n        const featureOptions = {...loaderOptions, layerName};\n\n        if (!vectorTileLayer) {\n          return;\n        }\n\n        for (let i = 0; i < vectorTileLayer.length; i++) {\n          const vectorTileFeature = vectorTileLayer.feature(i, geometryInfo);\n\n          const decodedFeature = binary\n            ? getDecodedFeatureBinary(vectorTileFeature as VectorTileFeatureBinary, featureOptions)\n            : getDecodedFeature(vectorTileFeature as VectorTileFeatureMapBox, featureOptions);\n          features.push(decodedFeature);\n        }\n      });\n    }\n\n    if (binary) {\n      const data = flatGeojsonToBinary(features as FlatFeature[], geometryInfo);\n      // Add the original byteLength (as a reasonable approximation of the size of the binary data)\n      // TODO decide where to store extra fields like byteLength (header etc) and document\n      // @ts-ignore\n      data.byteLength = arrayBuffer.byteLength;\n      return data;\n    }\n  }\n  return features;\n}\n\n/**\n * @param options\n * @returns options\n */\nfunction normalizeOptions(options: LoaderOptions | undefined) {\n  if (options) {\n    options = {\n      ...options,\n      mvt: options.mvt || {},\n      gis: options.gis || {}\n    };\n\n    // Validate\n    const wgs84Coordinates = options.coordinates === 'wgs84';\n    const {tileIndex} = options;\n    const hasTileIndex =\n      tileIndex &&\n      Number.isFinite(tileIndex.x) &&\n      Number.isFinite(tileIndex.y) &&\n      Number.isFinite(tileIndex.z);\n\n    if (wgs84Coordinates && !hasTileIndex) {\n      throw new Error(\n        'MVT Loader: WGS84 coordinates need tileIndex property. Check documentation.'\n      );\n    }\n  }\n  return options;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded feature\n */\nfunction getDecodedFeature(\n  feature: VectorTileFeatureMapBox,\n  options: MvtOptions\n): MvtMapboxCoordinates {\n  const decodedFeature = feature.toGeoJSON(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinates\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param feature\n * @param options\n * @returns decoded binary feature\n */\nfunction getDecodedFeatureBinary(\n  feature: VectorTileFeatureBinary,\n  options: MvtOptions\n): FlatFeature {\n  const decodedFeature = feature.toBinaryCoordinates(\n    options.coordinates === 'wgs84' ? options.tileIndex : transformToLocalCoordinatesBinary\n  );\n\n  // Add layer name to GeoJSON properties\n  if (options.layerProperty && decodedFeature.properties) {\n    decodedFeature.properties[options.layerProperty] = options.layerName;\n  }\n\n  return decodedFeature;\n}\n\n/**\n * @param line\n * @param feature\n */\nfunction transformToLocalCoordinates(line: number[], feature: {extent: any}): void {\n  // This function transforms local coordinates in a\n  // [0 - bufferSize, this.extent + bufferSize] range to a\n  // [0 - (bufferSize / this.extent), 1 + (bufferSize / this.extent)] range.\n  // The resulting extent would be 1.\n  const {extent} = feature;\n  for (let i = 0; i < line.length; i++) {\n    const p = line[i];\n    p[0] /= extent;\n    p[1] /= extent;\n  }\n}\n\nfunction transformToLocalCoordinatesBinary(data: number[], feature: {extent: any}) {\n  // For the binary code path, the feature data is just\n  // one big flat array, so we just divide each value\n  const {extent} = feature;\n  for (let i = 0, il = data.length; i < il; ++i) {\n    data[i] /= extent;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}