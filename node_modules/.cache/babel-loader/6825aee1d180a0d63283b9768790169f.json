{"ast":null,"code":"import { clamp } from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport { mod } from '../utils/math-utils';\nconst DEFAULT_STATE = {\n  rotationX: 0,\n  rotationOrbit: 0,\n  zoom: 0,\n  target: [0, 0, 0],\n  minRotationX: -90,\n  maxRotationX: 90,\n  minZoom: -Infinity,\n  maxZoom: Infinity\n};\nexport class OrbitState extends ViewState {\n  constructor(_ref) {\n    let {\n      makeViewport,\n      width,\n      height,\n      rotationX = DEFAULT_STATE.rotationX,\n      rotationOrbit = DEFAULT_STATE.rotationOrbit,\n      target = DEFAULT_STATE.target,\n      zoom = DEFAULT_STATE.zoom,\n      minRotationX = DEFAULT_STATE.minRotationX,\n      maxRotationX = DEFAULT_STATE.maxRotationX,\n      minZoom = DEFAULT_STATE.minZoom,\n      maxZoom = DEFAULT_STATE.maxZoom,\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    } = _ref;\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    });\n    this._state = {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    };\n    this.makeViewport = makeViewport;\n  }\n\n  panStart(_ref2) {\n    let {\n      pos\n    } = _ref2;\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  pan(_ref3) {\n    let {\n      pos,\n      startPosition\n    } = _ref3;\n    const startPanPosition = this._state.startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this._viewportProps);\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n    return this._getUpdatedState(newProps);\n  }\n\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  rotateStart(_ref4) {\n    let {\n      pos\n    } = _ref4;\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this._viewportProps.rotationX,\n      startRotationOrbit: this._viewportProps.rotationOrbit\n    });\n  }\n\n  rotate(_ref5) {\n    let {\n      pos,\n      deltaAngleX = 0,\n      deltaAngleY = 0\n    } = _ref5;\n    const {\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit\n    } = this._state;\n    const {\n      width,\n      height\n    } = this._viewportProps;\n\n    if (!startRotatePos || !Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {\n      return this;\n    }\n\n    let newRotation;\n\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        deltaScaleX *= -1;\n      }\n\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = { ...this._viewportProps\n    };\n    const {\n      rotationOrbit\n    } = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  zoomStart(_ref6) {\n    let {\n      pos\n    } = _ref6;\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this._viewportProps.zoom\n    });\n  }\n\n  zoom(_ref7) {\n    let {\n      pos,\n      startPos,\n      scale\n    } = _ref7;\n    const {\n      zoom\n    } = this._viewportProps;\n    let {\n      startZoom,\n      startZoomPosition\n    } = this._state;\n\n    if (!Number.isFinite(startZoom)) {\n      startZoom = zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    const newZoom = this._calculateNewZoom({\n      scale,\n      startZoom\n    });\n\n    const zoomedViewport = this.makeViewport({ ...this._viewportProps,\n      zoom: newZoom\n    });\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: speed\n      })\n    });\n  }\n\n  zoomOut() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({\n        scale: 1 / speed\n      })\n    });\n  }\n\n  moveLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit - speed\n    });\n  }\n\n  rotateRight() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit + speed\n    });\n  }\n\n  rotateUp() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX - speed\n    });\n  }\n\n  rotateDown() {\n    let speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX + speed\n    });\n  }\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this._viewportProps);\n    return pos && viewport.unproject(pos);\n  }\n\n  _calculateNewZoom(_ref8) {\n    let {\n      scale,\n      startZoom\n    } = _ref8;\n    const {\n      maxZoom,\n      minZoom\n    } = this._viewportProps;\n\n    if (!Number.isFinite(startZoom)) {\n      startZoom = this._viewportProps.zoom;\n    }\n\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {\n      width,\n      height,\n      target\n    } = this._viewportProps;\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    return new this.constructor({ ...this._viewportProps,\n      ...this._state,\n      ...newProps\n    });\n  }\n\n  _applyConstraints(props) {\n    const {\n      maxZoom,\n      minZoom,\n      zoom,\n      maxRotationX,\n      minRotationX,\n      rotationOrbit\n    } = props;\n    props.zoom = clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n\n}\nexport default class OrbitController extends Controller {\n  constructor(props) {\n    super(OrbitState, props);\n  }\n\n  get linearTransitionProps() {\n    return ['target', 'zoom', 'rotationX', 'rotationOrbit'];\n  }\n\n}","map":{"version":3,"mappings":"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","names":["clamp","Controller","ViewState","mod","DEFAULT_STATE","rotationX","rotationOrbit","zoom","target","minRotationX","maxRotationX","minZoom","Infinity","maxZoom","OrbitState","constructor","makeViewport","width","height","startPanPosition","startRotatePos","startRotationX","startRotationOrbit","startZoomPosition","startZoom","_state","panStart","pos","_getUpdatedState","_unproject","pan","startPosition","viewport","_viewportProps","newProps","panByPosition","panEnd","rotateStart","rotate","deltaAngleX","deltaAngleY","Number","isFinite","newRotation","deltaScaleX","deltaScaleY","rotateEnd","shortestPathFrom","viewState","fromProps","getViewportProps","props","Math","abs","zoomStart","startPos","scale","newZoom","_calculateNewZoom","zoomedViewport","zoomEnd","zoomIn","speed","zoomOut","moveLeft","_panFromCenter","moveRight","moveUp","moveDown","rotateLeft","rotateRight","rotateUp","rotateDown","unproject","log2","offset","_applyConstraints","OrbitController","linearTransitionProps"],"sources":["../../../src/controllers/orbit-controller.ts"],"sourcesContent":["import {clamp} from '@math.gl/core';\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport {mod} from '../utils/math-utils';\n\nconst DEFAULT_STATE = {\n  rotationX: 0,\n  rotationOrbit: 0,\n  zoom: 0,\n  target: [0, 0, 0],\n  minRotationX: -90,\n  maxRotationX: 90,\n  minZoom: -Infinity,\n  maxZoom: Infinity\n};\n\n/* Helpers */\n\nexport class OrbitState extends ViewState {\n  constructor({\n    makeViewport,\n\n    /* Viewport arguments */\n    width, // Width of viewport\n    height, // Height of viewport\n    rotationX = DEFAULT_STATE.rotationX, // Rotation around x axis\n    rotationOrbit = DEFAULT_STATE.rotationOrbit, // Rotation around orbit axis\n    target = DEFAULT_STATE.target,\n    zoom = DEFAULT_STATE.zoom,\n\n    /* Viewport constraints */\n    minRotationX = DEFAULT_STATE.minRotationX,\n    maxRotationX = DEFAULT_STATE.maxRotationX,\n    minZoom = DEFAULT_STATE.minZoom,\n    maxZoom = DEFAULT_STATE.maxZoom,\n\n    /** Interaction states, required to calculate change during transform */\n    // Model state when the pan operation first started\n    startPanPosition,\n    // Model state when the rotate operation first started\n    startRotatePos,\n    startRotationX,\n    startRotationOrbit,\n    // Model state when the zoom operation first started\n    startZoomPosition,\n    startZoom\n  }) {\n    super({\n      width,\n      height,\n      rotationX,\n      rotationOrbit,\n      target,\n      zoom,\n      minRotationX,\n      maxRotationX,\n      minZoom,\n      maxZoom\n    });\n\n    this._state = {\n      startPanPosition,\n      startRotatePos,\n      startRotationX,\n      startRotationOrbit,\n      startZoomPosition,\n      startZoom\n    };\n\n    this.makeViewport = makeViewport;\n  }\n\n  /**\n   * Start panning\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  panStart({pos}) {\n    return this._getUpdatedState({\n      startPanPosition: this._unproject(pos)\n    });\n  }\n\n  /**\n   * Pan\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  pan({pos, startPosition}) {\n    const startPanPosition = this._state.startPanPosition || startPosition;\n\n    if (!startPanPosition) {\n      return this;\n    }\n\n    const viewport = this.makeViewport(this._viewportProps);\n    const newProps = viewport.panByPosition(startPanPosition, pos);\n\n    return this._getUpdatedState(newProps);\n  }\n\n  /**\n   * End panning\n   * Must call if `panStart()` was called\n   */\n  panEnd() {\n    return this._getUpdatedState({\n      startPanPosition: null\n    });\n  }\n\n  /**\n   * Start rotating\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  rotateStart({pos}) {\n    return this._getUpdatedState({\n      startRotatePos: pos,\n      startRotationX: this._viewportProps.rotationX,\n      startRotationOrbit: this._viewportProps.rotationOrbit\n    });\n  }\n\n  /**\n   * Rotate\n   * @param {[Number, Number]} pos - position on screen where the pointer is\n   */\n  rotate({pos, deltaAngleX = 0, deltaAngleY = 0}) {\n    const {startRotatePos, startRotationX, startRotationOrbit} = this._state;\n    const {width, height} = this._viewportProps;\n\n    if (\n      !startRotatePos ||\n      !Number.isFinite(startRotationX) ||\n      !Number.isFinite(startRotationOrbit)\n    ) {\n      return this;\n    }\n\n    let newRotation;\n    if (pos) {\n      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;\n      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;\n\n      if (startRotationX < -90 || startRotationX > 90) {\n        // When looking at the \"back\" side of the scene, invert horizontal drag\n        // so that the camera movement follows user input\n        deltaScaleX *= -1;\n      }\n      newRotation = {\n        rotationX: startRotationX + deltaScaleY * 180,\n        rotationOrbit: startRotationOrbit + deltaScaleX * 180\n      };\n    } else {\n      newRotation = {\n        rotationX: startRotationX + deltaAngleY,\n        rotationOrbit: startRotationOrbit + deltaAngleX\n      };\n    }\n\n    return this._getUpdatedState(newRotation);\n  }\n\n  /**\n   * End rotating\n   * Must call if `rotateStart()` was called\n   */\n  rotateEnd() {\n    return this._getUpdatedState({\n      startRotationX: null,\n      startRotationOrbit: null\n    });\n  }\n\n  // shortest path between two view states\n  shortestPathFrom(viewState) {\n    const fromProps = viewState.getViewportProps();\n    const props = {...this._viewportProps};\n    const {rotationOrbit} = props;\n\n    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {\n      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;\n    }\n\n    return props;\n  }\n\n  /**\n   * Start zooming\n   * @param {[Number, Number]} pos - position on screen where the pointer grabs\n   */\n  zoomStart({pos}) {\n    return this._getUpdatedState({\n      startZoomPosition: this._unproject(pos),\n      startZoom: this._viewportProps.zoom\n    });\n  }\n\n  /**\n   * Zoom\n   * @param {[Number, Number]} pos - position on screen where the current target is\n   * @param {[Number, Number]} startPos - the target position at\n   *   the start of the operation. Must be supplied of `zoomStart()` was not called\n   * @param {Number} scale - a number between [0, 1] specifying the accumulated\n   *   relative scale.\n   */\n  zoom({pos, startPos, scale}) {\n    const {zoom} = this._viewportProps;\n    let {startZoom, startZoomPosition} = this._state;\n    if (!Number.isFinite(startZoom)) {\n      // We have two modes of zoom:\n      // scroll zoom that are discrete events (transform from the current zoom level),\n      // and pinch zoom that are continuous events (transform from the zoom level when\n      // pinch started).\n      // If startZoom state is defined, then use the startZoom state;\n      // otherwise assume discrete zooming\n      startZoom = zoom;\n      startZoomPosition = this._unproject(startPos) || this._unproject(pos);\n    }\n\n    const newZoom = this._calculateNewZoom({scale, startZoom});\n    const zoomedViewport = this.makeViewport({...this._viewportProps, zoom: newZoom});\n\n    return this._getUpdatedState({\n      zoom: newZoom,\n      ...zoomedViewport.panByPosition(startZoomPosition, pos)\n    });\n  }\n\n  /**\n   * End zooming\n   * Must call if `zoomStart()` was called\n   */\n  zoomEnd() {\n    return this._getUpdatedState({\n      startZoomPosition: null,\n      startZoom: null\n    });\n  }\n\n  zoomIn(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: speed})\n    });\n  }\n\n  zoomOut(speed = 2) {\n    return this._getUpdatedState({\n      zoom: this._calculateNewZoom({scale: 1 / speed})\n    });\n  }\n\n  moveLeft(speed = 50) {\n    return this._panFromCenter([-speed, 0]);\n  }\n\n  moveRight(speed = 50) {\n    return this._panFromCenter([speed, 0]);\n  }\n\n  moveUp(speed = 50) {\n    return this._panFromCenter([0, -speed]);\n  }\n\n  moveDown(speed = 50) {\n    return this._panFromCenter([0, speed]);\n  }\n\n  rotateLeft(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit - speed\n    });\n  }\n\n  rotateRight(speed = 15) {\n    return this._getUpdatedState({\n      rotationOrbit: this._viewportProps.rotationOrbit + speed\n    });\n  }\n\n  rotateUp(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX - speed\n    });\n  }\n\n  rotateDown(speed = 10) {\n    return this._getUpdatedState({\n      rotationX: this._viewportProps.rotationX + speed\n    });\n  }\n\n  /* Private methods */\n\n  _unproject(pos) {\n    const viewport = this.makeViewport(this._viewportProps);\n    return pos && viewport.unproject(pos);\n  }\n\n  // Calculates new zoom\n  _calculateNewZoom({scale, startZoom}) {\n    const {maxZoom, minZoom} = this._viewportProps;\n    if (!Number.isFinite(startZoom)) {\n      startZoom = this._viewportProps.zoom;\n    }\n    const zoom = startZoom + Math.log2(scale);\n    return clamp(zoom, minZoom, maxZoom);\n  }\n\n  _panFromCenter(offset) {\n    const {width, height, target} = this._viewportProps;\n    return this.pan({\n      startPosition: target,\n      pos: [width / 2 + offset[0], height / 2 + offset[1]]\n    });\n  }\n\n  _getUpdatedState(newProps) {\n    // Update _viewportProps\n    return new this.constructor({...this._viewportProps, ...this._state, ...newProps});\n  }\n\n  // Apply any constraints (mathematical or defined by _viewportProps) to map state\n  _applyConstraints(props) {\n    // Ensure zoom is within specified range\n    const {maxZoom, minZoom, zoom, maxRotationX, minRotationX, rotationOrbit} = props;\n\n    props.zoom = clamp(zoom, minZoom, maxZoom);\n    props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);\n    if (rotationOrbit < -180 || rotationOrbit > 180) {\n      props.rotationOrbit = mod(rotationOrbit + 180, 360) - 180;\n    }\n\n    return props;\n  }\n}\n\nexport default class OrbitController extends Controller {\n  constructor(props) {\n    super(OrbitState, props);\n  }\n\n  get linearTransitionProps() {\n    return ['target', 'zoom', 'rotationX', 'rotationOrbit'];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}