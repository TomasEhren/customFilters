{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty2 from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _DEFAULT_SAMPLER;\n\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength } from '../gltf-utils/gltf-utils';\nvar COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nvar BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nvar GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nvar SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nvar DEFAULT_SAMPLER = (_DEFAULT_SAMPLER = {}, _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MAG_FILTER, GL_SAMPLER.LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_MIN_FILTER, GL_SAMPLER.NEAREST_MIPMAP_LINEAR), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_S, GL_SAMPLER.REPEAT), _defineProperty2(_DEFAULT_SAMPLER, GL_SAMPLER.TEXTURE_WRAP_T, GL_SAMPLER.REPEAT), _DEFAULT_SAMPLER);\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nvar GLTFPostProcessor = /*#__PURE__*/function () {\n  function GLTFPostProcessor() {\n    _classCallCheck(this, GLTFPostProcessor);\n\n    _defineProperty(this, \"baseUri\", '');\n\n    _defineProperty(this, \"json\", {});\n\n    _defineProperty(this, \"buffers\", []);\n\n    _defineProperty(this, \"images\", []);\n  }\n\n  _createClass(GLTFPostProcessor, [{\n    key: \"postProcess\",\n    value: function postProcess(gltf) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var json = gltf.json,\n          _gltf$buffers = gltf.buffers,\n          buffers = _gltf$buffers === void 0 ? [] : _gltf$buffers,\n          _gltf$images = gltf.images,\n          images = _gltf$images === void 0 ? [] : _gltf$images,\n          _gltf$baseUri = gltf.baseUri,\n          baseUri = _gltf$baseUri === void 0 ? '' : _gltf$baseUri;\n      assert(json);\n      this.baseUri = baseUri;\n      this.json = json;\n      this.buffers = buffers;\n      this.images = images;\n\n      this._resolveTree(this.json, options);\n\n      return this.json;\n    }\n  }, {\n    key: \"_resolveTree\",\n    value: function _resolveTree(json) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (json.bufferViews) {\n        json.bufferViews = json.bufferViews.map(function (bufView, i) {\n          return _this._resolveBufferView(bufView, i);\n        });\n      }\n\n      if (json.images) {\n        json.images = json.images.map(function (image, i) {\n          return _this._resolveImage(image, i);\n        });\n      }\n\n      if (json.samplers) {\n        json.samplers = json.samplers.map(function (sampler, i) {\n          return _this._resolveSampler(sampler, i);\n        });\n      }\n\n      if (json.textures) {\n        json.textures = json.textures.map(function (texture, i) {\n          return _this._resolveTexture(texture, i);\n        });\n      }\n\n      if (json.accessors) {\n        json.accessors = json.accessors.map(function (accessor, i) {\n          return _this._resolveAccessor(accessor, i);\n        });\n      }\n\n      if (json.materials) {\n        json.materials = json.materials.map(function (material, i) {\n          return _this._resolveMaterial(material, i);\n        });\n      }\n\n      if (json.meshes) {\n        json.meshes = json.meshes.map(function (mesh, i) {\n          return _this._resolveMesh(mesh, i);\n        });\n      }\n\n      if (json.nodes) {\n        json.nodes = json.nodes.map(function (node, i) {\n          return _this._resolveNode(node, i);\n        });\n      }\n\n      if (json.skins) {\n        json.skins = json.skins.map(function (skin, i) {\n          return _this._resolveSkin(skin, i);\n        });\n      }\n\n      if (json.scenes) {\n        json.scenes = json.scenes.map(function (scene, i) {\n          return _this._resolveScene(scene, i);\n        });\n      }\n\n      if (json.scene !== undefined) {\n        json.scene = json.scenes[this.json.scene];\n      }\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this._get('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this._get('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this._get('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this._get('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this._get('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this._get('accessors', index);\n    }\n  }, {\n    key: \"getCamera\",\n    value: function getCamera(index) {\n      return null;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this._get('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this._get('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this._get('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this._get('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this._get('buffers', index);\n    }\n  }, {\n    key: \"_get\",\n    value: function _get(array, index) {\n      if (typeof index === 'object') {\n        return index;\n      }\n\n      var object = this.json[array] && this.json[array][index];\n\n      if (!object) {\n        console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n\n      return object;\n    }\n  }, {\n    key: \"_resolveScene\",\n    value: function _resolveScene(scene, index) {\n      var _this2 = this;\n\n      scene.id = scene.id || \"scene-\".concat(index);\n      scene.nodes = (scene.nodes || []).map(function (node) {\n        return _this2.getNode(node);\n      });\n      return scene;\n    }\n  }, {\n    key: \"_resolveNode\",\n    value: function _resolveNode(node, index) {\n      var _this3 = this;\n\n      node.id = node.id || \"node-\".concat(index);\n\n      if (node.children) {\n        node.children = node.children.map(function (child) {\n          return _this3.getNode(child);\n        });\n      }\n\n      if (node.mesh !== undefined) {\n        node.mesh = this.getMesh(node.mesh);\n      } else if (node.meshes !== undefined && node.meshes.length) {\n        node.mesh = node.meshes.reduce(function (accum, meshIndex) {\n          var mesh = _this3.getMesh(meshIndex);\n\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        }, {\n          primitives: []\n        });\n      }\n\n      if (node.camera !== undefined) {\n        node.camera = this.getCamera(node.camera);\n      }\n\n      if (node.skin !== undefined) {\n        node.skin = this.getSkin(node.skin);\n      }\n\n      return node;\n    }\n  }, {\n    key: \"_resolveSkin\",\n    value: function _resolveSkin(skin, index) {\n      skin.id = skin.id || \"skin-\".concat(index);\n      skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n      return skin;\n    }\n  }, {\n    key: \"_resolveMesh\",\n    value: function _resolveMesh(mesh, index) {\n      var _this4 = this;\n\n      mesh.id = mesh.id || \"mesh-\".concat(index);\n\n      if (mesh.primitives) {\n        mesh.primitives = mesh.primitives.map(function (primitive) {\n          primitive = _objectSpread({}, primitive);\n          var attributes = primitive.attributes;\n          primitive.attributes = {};\n\n          for (var attribute in attributes) {\n            primitive.attributes[attribute] = _this4.getAccessor(attributes[attribute]);\n          }\n\n          if (primitive.indices !== undefined) {\n            primitive.indices = _this4.getAccessor(primitive.indices);\n          }\n\n          if (primitive.material !== undefined) {\n            primitive.material = _this4.getMaterial(primitive.material);\n          }\n\n          return primitive;\n        });\n      }\n\n      return mesh;\n    }\n  }, {\n    key: \"_resolveMaterial\",\n    value: function _resolveMaterial(material, index) {\n      material.id = material.id || \"material-\".concat(index);\n\n      if (material.normalTexture) {\n        material.normalTexture = _objectSpread({}, material.normalTexture);\n        material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n      }\n\n      if (material.occlusionTexture) {\n        material.occlustionTexture = _objectSpread({}, material.occlustionTexture);\n        material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n      }\n\n      if (material.emissiveTexture) {\n        material.emmisiveTexture = _objectSpread({}, material.emmisiveTexture);\n        material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n      }\n\n      if (!material.emissiveFactor) {\n        material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n      }\n\n      if (material.pbrMetallicRoughness) {\n        material.pbrMetallicRoughness = _objectSpread({}, material.pbrMetallicRoughness);\n        var mr = material.pbrMetallicRoughness;\n\n        if (mr.baseColorTexture) {\n          mr.baseColorTexture = _objectSpread({}, mr.baseColorTexture);\n          mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n        }\n\n        if (mr.metallicRoughnessTexture) {\n          mr.metallicRoughnessTexture = _objectSpread({}, mr.metallicRoughnessTexture);\n          mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n        }\n      }\n\n      return material;\n    }\n  }, {\n    key: \"_resolveAccessor\",\n    value: function _resolveAccessor(accessor, index) {\n      accessor.id = accessor.id || \"accessor-\".concat(index);\n\n      if (accessor.bufferView !== undefined) {\n        accessor.bufferView = this.getBufferView(accessor.bufferView);\n      }\n\n      accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n      accessor.components = getSizeFromAccessorType(accessor.type);\n      accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n      if (accessor.bufferView) {\n        var buffer = accessor.bufferView.buffer;\n\n        var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, accessor.bufferView),\n            ArrayType = _getAccessorArrayType.ArrayType,\n            byteLength = _getAccessorArrayType.byteLength;\n\n        var byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n        var cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n\n        if (accessor.bufferView.byteStride) {\n          cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n        }\n\n        accessor.value = new ArrayType(cutBuffer);\n      }\n\n      return accessor;\n    }\n  }, {\n    key: \"_getValueFromInterleavedBuffer\",\n    value: function _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n      var result = new Uint8Array(count * bytesPerElement);\n\n      for (var i = 0; i < count; i++) {\n        var elementOffset = byteOffset + i * byteStride;\n        result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n      }\n\n      return result.buffer;\n    }\n  }, {\n    key: \"_resolveTexture\",\n    value: function _resolveTexture(texture, index) {\n      texture.id = texture.id || \"texture-\".concat(index);\n      texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n      texture.source = this.getImage(texture.source);\n      return texture;\n    }\n  }, {\n    key: \"_resolveSampler\",\n    value: function _resolveSampler(sampler, index) {\n      sampler.id = sampler.id || \"sampler-\".concat(index);\n      sampler.parameters = {};\n\n      for (var key in sampler) {\n        var glEnum = this._enumSamplerParameter(key);\n\n        if (glEnum !== undefined) {\n          sampler.parameters[glEnum] = sampler[key];\n        }\n      }\n\n      return sampler;\n    }\n  }, {\n    key: \"_enumSamplerParameter\",\n    value: function _enumSamplerParameter(key) {\n      return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n    }\n  }, {\n    key: \"_resolveImage\",\n    value: function _resolveImage(image, index) {\n      image.id = image.id || \"image-\".concat(index);\n\n      if (image.bufferView !== undefined) {\n        image.bufferView = this.getBufferView(image.bufferView);\n      }\n\n      var preloadedImage = this.images[index];\n\n      if (preloadedImage) {\n        image.image = preloadedImage;\n      }\n\n      return image;\n    }\n  }, {\n    key: \"_resolveBufferView\",\n    value: function _resolveBufferView(bufferView, index) {\n      var bufferIndex = bufferView.buffer;\n\n      var result = _objectSpread(_objectSpread({\n        id: \"bufferView-\".concat(index)\n      }, bufferView), {}, {\n        buffer: this.buffers[bufferIndex]\n      });\n\n      var arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n      var byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n      if ('byteOffset' in bufferView) {\n        byteOffset += bufferView.byteOffset;\n      }\n\n      result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n      return result;\n    }\n  }, {\n    key: \"_resolveCamera\",\n    value: function _resolveCamera(camera, index) {\n      camera.id = camera.id || \"camera-\".concat(index);\n\n      if (camera.perspective) {}\n\n      if (camera.orthographic) {}\n\n      return camera;\n    }\n  }]);\n\n  return GLTFPostProcessor;\n}();\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"mappings":"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","names":["assert","getAccessorArrayTypeAndLength","COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","getBytesFromComponentType","componentType","getSizeFromAccessorType","type","GLTFPostProcessor","_defineProperty","postProcess","gltf","options","json","buffers","images","baseUri","_resolveTree","bufferViews","map","bufView","i","_resolveBufferView","image","_resolveImage","samplers","sampler","_resolveSampler","textures","texture","_resolveTexture","accessors","accessor","_resolveAccessor","materials","material","_resolveMaterial","meshes","mesh","_resolveMesh","nodes","node","_resolveNode","skins","skin","_resolveSkin","scenes","scene","_resolveScene","undefined","getScene","index","_get","getNode","getSkin","getMesh","getMaterial","getAccessor","getCamera","getTexture","getSampler","getImage","getBufferView","getBuffer","array","object","console","warn","id","children","child","length","reduce","accum","meshIndex","primitives","concat","camera","inverseBindMatrices","primitive","attributes","attribute","indices","normalTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bufferView","bytesPerComponent","components","bytesPerElement","buffer","ArrayType","byteLength","byteOffset","cutBuffer","arrayBuffer","slice","byteStride","_getValueFromInterleavedBuffer","count","value","result","Uint8Array","elementOffset","set","source","parameters","key","glEnum","_enumSamplerParameter","preloadedImage","bufferIndex","data","_resolveCamera","perspective","orthographic","postProcessGLTF"],"sources":["../../../../src/lib/api/post-process-gltf.ts"],"sourcesContent":["import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}