{"ast":null,"code":"import { Buffer, Transform } from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport { padBuffer, getAttributeTypeFromSize, getSourceBufferAttribute, getAttributeBufferLength, cycleBuffers } from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\nexport default class GPUInterpolationTransition {\n  constructor(_ref) {\n    let {\n      gl,\n      attribute,\n      timeline\n    } = _ref;\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: 35050\n    };\n    this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  start(transitionSettings, numInstances) {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    const {\n      gl,\n      buffers,\n      attribute\n    } = this;\n    cycleBuffers(buffers);\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({\n        buffer,\n        ...padBufferOpts\n      });\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      value: attribute.value\n    });\n    this.transition.start(transitionSettings);\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update() {\n    const updated = this.transition.update();\n\n    if (updated) {\n      const {\n        time,\n        settings: {\n          duration,\n          easing\n        }\n      } = this.transition;\n      const t = easing(time / duration);\n      this.transform.run({\n        uniforms: {\n          time: t\n        }\n      });\n    }\n\n    return updated;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n  }\n\n}\nconst vs = \"\\n#define SHADER_NAME interpolation-transition-vertex-shader\\n\\nuniform float time;\\nattribute ATTRIBUTE_TYPE aFrom;\\nattribute ATTRIBUTE_TYPE aTo;\\nvarying ATTRIBUTE_TYPE vCurrent;\\n\\nvoid main(void) {\\n  vCurrent = mix(aFrom, aTo, time);\\n  gl_Position = vec4(0.0);\\n}\\n\";\n\nfunction getTransform(gl, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}","map":{"version":3,"mappings":"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","names":["Buffer","Transform","Attribute","padBuffer","getAttributeTypeFromSize","getSourceBufferAttribute","getAttributeBufferLength","cycleBuffers","Transition","GPUInterpolationTransition","constructor","gl","attribute","timeline","type","transition","attributeInTransition","settings","currentStartIndices","startIndices","currentLength","transform","getTransform","bufferOpts","byteLength","usage","buffers","inProgress","start","transitionSettings","numInstances","duration","cancel","padBufferOpts","fromLength","fromStartIndices","getData","enter","buffer","update","value","elementCount","Math","floor","size","sourceBuffers","aFrom","aTo","feedbackBuffers","vCurrent","updated","time","easing","t","run","uniforms","delete","length","pop","vs","attributeType","defines","ATTRIBUTE_TYPE","varyings"],"sources":["../../../src/transitions/gpu-interpolation-transition.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {Buffer, Transform} from '@luma.gl/core';\nimport Attribute from '../lib/attribute/attribute';\nimport {\n  padBuffer,\n  getAttributeTypeFromSize,\n  getSourceBufferAttribute,\n  getAttributeBufferLength,\n  cycleBuffers\n} from '../lib/attribute/attribute-transition-utils';\nimport Transition from './transition';\n\nexport default class GPUInterpolationTransition {\n  constructor({gl, attribute, timeline}) {\n    this.gl = gl;\n    this.type = 'interpolation';\n    this.transition = new Transition(timeline);\n    this.attribute = attribute;\n    // this is the attribute we return during the transition - note: if it is a constant\n    // attribute, it will be converted and returned as a regular attribute\n    // `attribute.userData` is the original options passed when constructing the attribute.\n    // This ensures that we set the proper `doublePrecision` flag and shader attributes.\n    this.attributeInTransition = new Attribute(gl, attribute.settings);\n    this.currentStartIndices = attribute.startIndices;\n    // storing currentLength because this.buffer may be larger than the actual length we want to use\n    // this is because we only reallocate buffers when they grow, not when they shrink,\n    // due to performance costs\n    this.currentLength = 0;\n    this.transform = getTransform(gl, attribute);\n    const bufferOpts = {\n      byteLength: 0,\n      usage: GL.DYNAMIC_COPY\n    };\n    this.buffers = [\n      new Buffer(gl, bufferOpts), // from\n      new Buffer(gl, bufferOpts) // current\n    ];\n  }\n\n  get inProgress() {\n    return this.transition.inProgress;\n  }\n\n  // this is called when an attribute's values have changed and\n  // we need to start animating towards the new values\n  // this also correctly resizes / pads the transform's buffers\n  // in case the attribute's buffer has changed in length or in\n  // startIndices\n  start(transitionSettings, numInstances) {\n    if (transitionSettings.duration <= 0) {\n      this.transition.cancel();\n      return;\n    }\n\n    const {gl, buffers, attribute} = this;\n    // Alternate between two buffers when new transitions start.\n    // Last destination buffer is used as an attribute (from state),\n    // And the other buffer is now the current buffer.\n    cycleBuffers(buffers);\n\n    const padBufferOpts = {\n      numInstances,\n      attribute,\n      fromLength: this.currentLength,\n      fromStartIndices: this.currentStartIndices,\n      getData: transitionSettings.enter\n    };\n\n    for (const buffer of buffers) {\n      padBuffer({buffer, ...padBufferOpts});\n    }\n\n    this.currentStartIndices = attribute.startIndices;\n    this.currentLength = getAttributeBufferLength(attribute, numInstances);\n    this.attributeInTransition.update({\n      buffer: buffers[1],\n      // Hack: Float64Array is required for double-precision attributes\n      // to generate correct shader attributes\n      value: attribute.value\n    });\n\n    this.transition.start(transitionSettings);\n\n    this.transform.update({\n      elementCount: Math.floor(this.currentLength / attribute.size),\n      sourceBuffers: {\n        aFrom: buffers[0],\n        aTo: getSourceBufferAttribute(gl, attribute)\n      },\n      feedbackBuffers: {\n        vCurrent: buffers[1]\n      }\n    });\n  }\n\n  update() {\n    const updated = this.transition.update();\n    if (updated) {\n      const {\n        time,\n        settings: {duration, easing}\n      } = this.transition;\n      const t = easing(time / duration);\n      this.transform.run({\n        uniforms: {time: t}\n      });\n    }\n    return updated;\n  }\n\n  cancel() {\n    this.transition.cancel();\n    this.transform.delete();\n    while (this.buffers.length) {\n      this.buffers.pop().delete();\n    }\n  }\n}\n\nconst vs = `\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n`;\n\nfunction getTransform(gl, attribute) {\n  const attributeType = getAttributeTypeFromSize(attribute.size);\n  return new Transform(gl, {\n    vs,\n    defines: {\n      ATTRIBUTE_TYPE: attributeType\n    },\n    varyings: ['vCurrent']\n  });\n}\n"]},"metadata":{},"sourceType":"module"}