{"ast":null,"code":"const logState = {\n  attributeUpdateMessages: []\n};\nconst LOG_LEVEL_MAJOR_UPDATE = 1;\nconst LOG_LEVEL_MINOR_UPDATE = 2;\nconst LOG_LEVEL_UPDATE_DETAIL = 3;\nconst LOG_LEVEL_INFO = 4;\nconst LOG_LEVEL_DRAW = 2;\nexport const getLoggers = log => ({\n  'layer.changeFlag': (layer, key, flags) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, \"\".concat(layer.id, \" \").concat(key, \": \"), flags[key])();\n  },\n  'layer.initialize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, \"Initializing \".concat(layer))();\n  },\n  'layer.update': (layer, needsUpdate) => {\n    if (needsUpdate) {\n      const flags = layer.getChangeFlags();\n      log.log(LOG_LEVEL_MINOR_UPDATE, \"Updating \".concat(layer, \" because: \").concat(Object.keys(flags).filter(key => flags[key]).join(', ')))();\n    } else {\n      log.log(LOG_LEVEL_INFO, \"\".concat(layer, \" does not need update\"))();\n    }\n  },\n  'layer.matched': (layer, changed) => {\n    if (changed) {\n      log.log(LOG_LEVEL_INFO, \"Matched \".concat(layer, \", state transfered\"))();\n    }\n  },\n  'layer.finalize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, \"Finalizing \".concat(layer))();\n  },\n  'compositeLayer.renderLayers': (layer, updated, subLayers) => {\n    if (updated) {\n      log.log(LOG_LEVEL_MINOR_UPDATE, \"Composite layer rendered new subLayers \".concat(layer), subLayers)();\n    } else {\n      log.log(LOG_LEVEL_INFO, \"Composite layer reused subLayers \".concat(layer), subLayers)();\n    }\n  },\n  'layerManager.setLayers': (layerManager, updated, layers) => {\n    if (updated) {\n      log.log(LOG_LEVEL_MINOR_UPDATE, \"Updating \".concat(layers.length, \" deck layers\"))();\n    }\n  },\n  'layerManager.activateViewport': (layerManager, viewport) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();\n  },\n  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? \"invalidated attributes \".concat(attributeNames, \" (\").concat(trigger, \") for \").concat(attributeManager.id) : \"invalidated all attributes for \".concat(attributeManager.id))();\n  },\n  'attributeManager.updateStart': attributeManager => {\n    logState.attributeUpdateMessages.length = 0;\n    logState.attributeManagerUpdateStart = Date.now();\n  },\n  'attributeManager.updateEnd': (attributeManager, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);\n    log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(attributeManager.id, \" in \").concat(timeMs, \"ms\"))();\n\n    for (const updateMessage of logState.attributeUpdateMessages) {\n      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();\n    }\n\n    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();\n  },\n  'attribute.updateStart': attribute => {\n    logState.attributeUpdateStart = Date.now();\n  },\n  'attribute.allocate': (attribute, numInstances) => {\n    const message = \"\".concat(attribute.id, \" allocated \").concat(numInstances);\n    logState.attributeUpdateMessages.push(message);\n  },\n  'attribute.updateEnd': (attribute, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);\n    const message = \"\".concat(attribute.id, \" updated \").concat(numInstances, \" in \").concat(timeMs, \"ms\");\n    logState.attributeUpdateMessages.push(message);\n  },\n  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {\n    const {\n      pass,\n      redrawReason,\n      stats\n    } = opts;\n\n    for (const status of renderStats) {\n      const {\n        totalCount,\n        visibleCount,\n        compositeCount,\n        pickableCount\n      } = status;\n      const primitiveCount = totalCount - compositeCount;\n      const hiddenCount = primitiveCount - visibleCount;\n      log.log(LOG_LEVEL_DRAW, \"RENDER #\".concat(deckRenderer.renderCount, \"   \").concat(visibleCount, \" (of \").concat(totalCount, \" layers) to \").concat(pass, \" because \").concat(redrawReason, \"   (\").concat(hiddenCount, \" hidden, \").concat(compositeCount, \" composite \").concat(pickableCount, \" pickable)\"))();\n\n      if (stats) {\n        stats.get('Redraw Layers').add(visibleCount);\n      }\n    }\n  }\n});","map":{"version":3,"mappings":"AAAA,MAAMA,QAAQ,GAAG;EACfC,uBAAuB,EAAE;AADV,CAAjB;AAIA,MAAMC,sBAAsB,GAAG,CAA/B;AACA,MAAMC,sBAAsB,GAAG,CAA/B;AACA,MAAMC,uBAAuB,GAAG,CAAhC;AACA,MAAMC,cAAc,GAAG,CAAvB;AACA,MAAMC,cAAc,GAAG,CAAvB;AAEA,OAAO,MAAMC,UAAU,GAAGC,GAAG,KAAK;EAGhC,oBAAoB,CAACC,KAAD,EAAQC,GAAR,EAAaC,KAAb,KAAuB;IACzCH,GAAG,CAACA,GAAJA,CAAQJ,uBAARI,YAAoCC,KAAK,CAACG,EAA1C,cAAgDF,GAAhD,SAAyDC,KAAK,CAACD,GAAD,CAA9DF;EAJ8B;EAOhC,oBAAoBC,KAAK,IAAI;IAC3BD,GAAG,CAACA,GAAJA,CAAQN,sBAARM,yBAAgDC,KAAhD;EAR8B;EAUhC,gBAAgB,CAACA,KAAD,EAAQI,WAAR,KAAwB;IACtC,IAAIA,WAAJ,EAAiB;MACf,MAAMF,KAAK,GAAGF,KAAK,CAACK,cAANL,EAAd;MACAD,GAAG,CAACA,GAAJA,CACEL,sBADFK,qBAEcC,KAFd,uBAEgCM,MAAM,CAACC,IAAPD,CAAYJ,KAAZI,EAC3BE,MAD2BF,CACpBL,GAAG,IAAIC,KAAK,CAACD,GAAD,CADQK,EAE3BG,IAF2BH,CAEtB,IAFsBA,CAFhC;IAFF,OAQO;MACLP,GAAG,CAACA,GAAJA,CAAQH,cAARG,YAA2BC,KAA3B;IACD;EArB6B;EAuBhC,iBAAiB,CAACA,KAAD,EAAQU,OAAR,KAAoB;IACnC,IAAIA,OAAJ,EAAa;MACXX,GAAG,CAACA,GAAJA,CAAQH,cAARG,oBAAmCC,KAAnC;IACD;EA1B6B;EA4BhC,kBAAkBA,KAAK,IAAI;IACzBD,GAAG,CAACA,GAAJA,CAAQN,sBAARM,uBAA8CC,KAA9C;EA7B8B;EAkChC,+BAA+B,CAACA,KAAD,EAAQW,OAAR,EAAiBC,SAAjB,KAA+B;IAC5D,IAAID,OAAJ,EAAa;MACXZ,GAAG,CAACA,GAAJA,CACEL,sBADFK,mDAE4CC,KAF5C,GAGEY,SAHFb;IADF,OAMO;MACLA,GAAG,CAACA,GAAJA,CAAQH,cAARG,6CAA4DC,KAA5D,GAAqEY,SAArEb;IACD;EA3C6B;EAgDhC,0BAA0B,CAACc,YAAD,EAAeF,OAAf,EAAwBG,MAAxB,KAAmC;IAC3D,IAAIH,OAAJ,EAAa;MACXZ,GAAG,CAACA,GAAJA,CAAQL,sBAARK,qBAA4Ce,MAAM,CAACC,MAAnD;IACD;EAnD6B;EAsDhC,iCAAiC,CAACF,YAAD,EAAeG,QAAf,KAA4B;IAC3DjB,GAAG,CAACA,GAAJA,CAAQJ,uBAARI,EAAiC,kBAAjCA,EAAqDiB,QAArDjB;EAvD8B;EA4DhC,+BAA+B,CAACkB,gBAAD,EAAmBC,OAAnB,EAA4BC,cAA5B,KAA+C;IAC5EpB,GAAG,CAACA,GAAJA,CACEN,sBADFM,EAEEoB,cAAc,oCACgBA,cADhB,eACmCD,OADnC,mBACmDD,gBAAgB,CAACd,EADpE,6CAEwBc,gBAAgB,CAACd,EAFzC,CAFhBJ;EA7D8B;EAqEhC,gCAAgCkB,gBAAgB,IAAI;IAClD1B,QAAQ,CAACC,uBAATD,CAAiCwB,MAAjCxB,GAA0C,CAA1CA;IACAA,QAAQ,CAAC6B,2BAAT7B,GAAuC8B,IAAI,CAACC,GAALD,EAAvC9B;EAvE8B;EAyEhC,8BAA8B,CAAC0B,gBAAD,EAAmBM,YAAnB,KAAoC;IAChE,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAALD,CAAWJ,IAAI,CAACC,GAALD,KAAa9B,QAAQ,CAAC6B,2BAAjCK,CAAf;IACA1B,GAAG,CAAC4B,cAAJ5B,CACEL,sBADFK,mCAE4BwB,YAF5B,2BAEyDN,gBAAgB,CAACd,EAF1E,iBAEmFqB,MAFnF;;IAIA,KAAK,MAAMI,aAAX,IAA4BrC,QAAQ,CAACC,uBAArC,EAA8D;MAC5DO,GAAG,CAACA,GAAJA,CAAQJ,uBAARI,EAAiC6B,aAAjC7B;IACD;;IACDA,GAAG,CAAC8B,QAAJ9B,CAAaL,sBAAbK;EAlF8B;EAuFhC,yBAAyB+B,SAAS,IAAI;IACpCvC,QAAQ,CAACwC,oBAATxC,GAAgC8B,IAAI,CAACC,GAALD,EAAhC9B;EAxF8B;EA0FhC,sBAAsB,CAACuC,SAAD,EAAYP,YAAZ,KAA6B;IACjD,MAAMS,OAAO,aAAMF,SAAS,CAAC3B,EAAhB,wBAAgCoB,YAAhC,CAAb;IACAhC,QAAQ,CAACC,uBAATD,CAAiC0C,IAAjC1C,CAAsCyC,OAAtCzC;EA5F8B;EA8FhC,uBAAuB,CAACuC,SAAD,EAAYP,YAAZ,KAA6B;IAClD,MAAMC,MAAM,GAAGC,IAAI,CAACC,KAALD,CAAWJ,IAAI,CAACC,GAALD,KAAa9B,QAAQ,CAACwC,oBAAjCN,CAAf;IACA,MAAMO,OAAO,aAAMF,SAAS,CAAC3B,EAAhB,sBAA8BoB,YAA9B,iBAAiDC,MAAjD,OAAb;IACAjC,QAAQ,CAACC,uBAATD,CAAiC0C,IAAjC1C,CAAsCyC,OAAtCzC;EAjG8B;EAsGhC,6BAA6B,CAAC2C,YAAD,EAAeC,WAAf,EAA4BC,IAA5B,KAAqC;IAChE,MAAM;MAACC,IAAD;MAAOC,YAAP;MAAqBC;IAArB,IAA8BH,IAApC;;IACA,KAAK,MAAMI,MAAX,IAAqBL,WAArB,EAAkC;MAChC,MAAM;QAACM,UAAD;QAAaC,YAAb;QAA2BC,cAA3B;QAA2CC;MAA3C,IAA4DJ,MAAlE;MACA,MAAMK,cAAc,GAAGJ,UAAU,GAAGE,cAApC;MACA,MAAMG,WAAW,GAAGD,cAAc,GAAGH,YAArC;MAEA3C,GAAG,CAACA,GAAJA,CACEF,cADFE,oBAEamC,YAAY,CAACa,WAF1B,gBAGFL,YAHE,kBAGkBD,UAHlB,yBAG2CJ,IAH3C,sBAG2DC,YAH3D,iBAIDQ,WAJC,sBAIsBH,cAJtB,wBAIkDC,aAJlD;;MAOA,IAAIL,KAAJ,EAAW;QACTA,KAAK,CAACS,GAANT,CAAU,eAAVA,EAA2BU,GAA3BV,CAA+BG,YAA/BH;MACD;IACF;EACF;AAxH+B,CAAL,CAAtB","names":["logState","attributeUpdateMessages","LOG_LEVEL_MAJOR_UPDATE","LOG_LEVEL_MINOR_UPDATE","LOG_LEVEL_UPDATE_DETAIL","LOG_LEVEL_INFO","LOG_LEVEL_DRAW","getLoggers","log","layer","key","flags","id","needsUpdate","getChangeFlags","Object","keys","filter","join","changed","updated","subLayers","layerManager","layers","length","viewport","attributeManager","trigger","attributeNames","attributeManagerUpdateStart","Date","now","numInstances","timeMs","Math","round","groupCollapsed","updateMessage","groupEnd","attribute","attributeUpdateStart","message","push","deckRenderer","renderStats","opts","pass","redrawReason","stats","status","totalCount","visibleCount","compositeCount","pickableCount","primitiveCount","hiddenCount","renderCount","get","add"],"sources":["../../../src/debug/loggers.js"],"sourcesContent":["const logState = {\n  attributeUpdateMessages: []\n};\n\nconst LOG_LEVEL_MAJOR_UPDATE = 1; // Events with direct perf impact\nconst LOG_LEVEL_MINOR_UPDATE = 2; // Events that may affect perf\nconst LOG_LEVEL_UPDATE_DETAIL = 3;\nconst LOG_LEVEL_INFO = 4;\nconst LOG_LEVEL_DRAW = 2;\n\nexport const getLoggers = log => ({\n  /* Layer events */\n\n  'layer.changeFlag': (layer, key, flags) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, `${layer.id} ${key}: `, flags[key])();\n  },\n\n  'layer.initialize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, `Initializing ${layer}`)();\n  },\n  'layer.update': (layer, needsUpdate) => {\n    if (needsUpdate) {\n      const flags = layer.getChangeFlags();\n      log.log(\n        LOG_LEVEL_MINOR_UPDATE,\n        `Updating ${layer} because: ${Object.keys(flags)\n          .filter(key => flags[key])\n          .join(', ')}`\n      )();\n    } else {\n      log.log(LOG_LEVEL_INFO, `${layer} does not need update`)();\n    }\n  },\n  'layer.matched': (layer, changed) => {\n    if (changed) {\n      log.log(LOG_LEVEL_INFO, `Matched ${layer}, state transfered`)();\n    }\n  },\n  'layer.finalize': layer => {\n    log.log(LOG_LEVEL_MAJOR_UPDATE, `Finalizing ${layer}`)();\n  },\n\n  /* CompositeLayer events */\n\n  'compositeLayer.renderLayers': (layer, updated, subLayers) => {\n    if (updated) {\n      log.log(\n        LOG_LEVEL_MINOR_UPDATE,\n        `Composite layer rendered new subLayers ${layer}`,\n        subLayers\n      )();\n    } else {\n      log.log(LOG_LEVEL_INFO, `Composite layer reused subLayers ${layer}`, subLayers)();\n    }\n  },\n\n  /* LayerManager events */\n\n  'layerManager.setLayers': (layerManager, updated, layers) => {\n    if (updated) {\n      log.log(LOG_LEVEL_MINOR_UPDATE, `Updating ${layers.length} deck layers`)();\n    }\n  },\n\n  'layerManager.activateViewport': (layerManager, viewport) => {\n    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();\n  },\n\n  /* AttributeManager events */\n\n  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {\n    log.log(\n      LOG_LEVEL_MAJOR_UPDATE,\n      attributeNames\n        ? `invalidated attributes ${attributeNames} (${trigger}) for ${attributeManager.id}`\n        : `invalidated all attributes for ${attributeManager.id}`\n    )();\n  },\n\n  'attributeManager.updateStart': attributeManager => {\n    logState.attributeUpdateMessages.length = 0;\n    logState.attributeManagerUpdateStart = Date.now();\n  },\n  'attributeManager.updateEnd': (attributeManager, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);\n    log.groupCollapsed(\n      LOG_LEVEL_MINOR_UPDATE,\n      `Updated attributes for ${numInstances} instances in ${attributeManager.id} in ${timeMs}ms`\n    )();\n    for (const updateMessage of logState.attributeUpdateMessages) {\n      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();\n    }\n    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();\n  },\n\n  /* Attribute events */\n\n  'attribute.updateStart': attribute => {\n    logState.attributeUpdateStart = Date.now();\n  },\n  'attribute.allocate': (attribute, numInstances) => {\n    const message = `${attribute.id} allocated ${numInstances}`;\n    logState.attributeUpdateMessages.push(message);\n  },\n  'attribute.updateEnd': (attribute, numInstances) => {\n    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);\n    const message = `${attribute.id} updated ${numInstances} in ${timeMs}ms`;\n    logState.attributeUpdateMessages.push(message);\n  },\n\n  /* Render events */\n\n  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {\n    const {pass, redrawReason, stats} = opts;\n    for (const status of renderStats) {\n      const {totalCount, visibleCount, compositeCount, pickableCount} = status;\n      const primitiveCount = totalCount - compositeCount;\n      const hiddenCount = primitiveCount - visibleCount;\n\n      log.log(\n        LOG_LEVEL_DRAW,\n        `RENDER #${deckRenderer.renderCount} \\\n  ${visibleCount} (of ${totalCount} layers) to ${pass} because ${redrawReason} \\\n  (${hiddenCount} hidden, ${compositeCount} composite ${pickableCount} pickable)`\n      )();\n\n      if (stats) {\n        stats.get('Redraw Layers').add(visibleCount);\n      }\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"module"}