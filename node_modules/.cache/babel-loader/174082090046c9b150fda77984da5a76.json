{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { getBlobOrSVGDataUrl } from './svg-utils';\nexport default function parseToImage(_x, _x2, _x3) {\n  return _parseToImage.apply(this, arguments);\n}\n\nfunction _parseToImage() {\n  _parseToImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(arrayBuffer, options, url) {\n    var blobOrDataUrl, URL, objectUrl;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n            URL = self.URL || self.webkitURL;\n            objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n            _context.prev = 3;\n            _context.next = 6;\n            return loadToImage(objectUrl || blobOrDataUrl, options);\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n            _context.prev = 7;\n\n            if (objectUrl) {\n              URL.revokeObjectURL(objectUrl);\n            }\n\n            return _context.finish(7);\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[3,, 7, 10]]);\n  }));\n  return _parseToImage.apply(this, arguments);\n}\n\nexport function loadToImage(_x4, _x5) {\n  return _loadToImage.apply(this, arguments);\n}\n\nfunction _loadToImage() {\n  _loadToImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(url, options) {\n    var image;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            image = new Image();\n            image.src = url;\n\n            if (!(options.image && options.image.decode && image.decode)) {\n              _context2.next = 6;\n              break;\n            }\n\n            _context2.next = 5;\n            return image.decode();\n\n          case 5:\n            return _context2.abrupt(\"return\", image);\n\n          case 6:\n            _context2.next = 8;\n            return new Promise(function (resolve, reject) {\n              try {\n                image.onload = function () {\n                  return resolve(image);\n                };\n\n                image.onerror = function (err) {\n                  return reject(new Error(\"Could not load image \".concat(url, \": \").concat(err)));\n                };\n              } catch (error) {\n                reject(error);\n              }\n            });\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _loadToImage.apply(this, arguments);\n}","map":{"version":3,"mappings":";;AACA,SAAQA,mBAAR,QAAkC,aAAlC;AAGA,wBAA8BC,YAA9B;EAAA;AAAA;;;2EAAe,iBACbC,WADa,EAEbC,OAFa,EAGbC,GAHa;IAAA;IAAA;MAAA;QAAA;UAAA;YASPC,aATO,GASSL,mBAAmB,CAACE,WAAD,EAAcE,GAAd,CAT5B;YAUPE,GAVO,GAUDC,IAAI,CAACD,GAALC,IAAYA,IAAI,CAACC,SAVhB;YAWPC,SAXO,GAWK,OAAOJ,aAAP,KAAyB,QAAzB,IAAqCC,GAAG,CAACI,eAAJJ,CAAoBD,aAApBC,CAX1C;YAAA;YAAA;YAAA,OAaEK,WAAW,CAACF,SAAS,IAAIJ,aAAd,EAA6BF,OAA7B,CAbb;;UAAA;YAAA;;UAAA;YAAA;;YAeX,IAAIM,SAAJ,EAAe;cACbH,GAAG,CAACM,eAAJN,CAAoBG,SAApBH;YACD;;YAjBU;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;AAqBf,gBAAsBK,WAAtB;EAAA;AAAA;;;0EAAO,kBAA2BP,GAA3B,EAAgCD,OAAhC;IAAA;IAAA;MAAA;QAAA;UAAA;YACCU,KADD,GACS,IAAIC,KAAJ,EADT;YAELD,KAAK,CAACE,GAANF,GAAYT,GAAZS;;YAFK,MAWDV,OAAO,CAACU,KAARV,IAAiBA,OAAO,CAACU,KAARV,CAAca,MAA/Bb,IAAyCU,KAAK,CAACG,MAX9C;cAAA;cAAA;YAAA;;YAAA;YAAA,OAYGH,KAAK,CAACG,MAANH,EAZH;;UAAA;YAAA,kCAaIA,KAbJ;;UAAA;YAAA;YAAA,OAiBQ,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;cAC5C,IAAI;gBACFN,KAAK,CAACO,MAANP,GAAe;kBAAA,OAAMK,OAAO,CAACL,KAAD,CAAb;gBAAA,CAAfA;;gBACAA,KAAK,CAACQ,OAANR,GAAiBS,aAAD;kBAAA,OAASH,MAAM,CAAC,IAAII,KAAJ,gCAAkCnB,GAAlC,eAA0CkB,GAA1C,EAAD,CAAf;gBAAA,CAAhBT;cAFF,EAGE,OAAOW,KAAP,EAAc;gBACdL,MAAM,CAACK,KAAD,CAANL;cACD;YANU,EAjBR;;UAAA;YAAA;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C","names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"sources":["../../../../src/lib/parsers/parse-to-image.ts"],"sourcesContent":["import type {ImageLoaderOptions} from '../../image-loader';\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(\n  arrayBuffer: ArrayBuffer,\n  options: ImageLoaderOptions,\n  url?: string\n): Promise<HTMLImageElement> {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options): Promise<HTMLImageElement> {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = (err) => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"module"}