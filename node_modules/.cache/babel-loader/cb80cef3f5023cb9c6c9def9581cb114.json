{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { getMeshBoundingBox } from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport { addSkirt } from './helpers/skirt';\n\nfunction getTerrain(imageData, width, height, elevationDecoder, tesselator) {\n  var rScaler = elevationDecoder.rScaler,\n      bScaler = elevationDecoder.bScaler,\n      gScaler = elevationDecoder.gScaler,\n      offset = elevationDecoder.offset;\n  var terrain = new Float32Array((width + 1) * (height + 1));\n\n  for (var i = 0, y = 0; y < height; y++) {\n    for (var x = 0; x < width; x++, i++) {\n      var k = i * 4;\n      var r = imageData[k + 0];\n      var g = imageData[k + 1];\n      var b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    for (var _i = (width + 1) * width, _x = 0; _x < width; _x++, _i++) {\n      terrain[_i] = terrain[_i - width - 1];\n    }\n\n    for (var _i2 = height, _y = 0; _y < height + 1; _y++, _i2 += height + 1) {\n      terrain[_i2] = terrain[_i2 - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, width, height, bounds) {\n  var gridSize = width + 1;\n  var numOfVerticies = vertices.length / 2;\n  var positions = new Float32Array(numOfVerticies * 3);\n  var texCoords = new Float32Array(numOfVerticies * 2);\n\n  var _ref = bounds || [0, 0, width, height],\n      _ref2 = _slicedToArray(_ref, 4),\n      minX = _ref2[0],\n      minY = _ref2[1],\n      maxX = _ref2[2],\n      maxY = _ref2[3];\n\n  var xScale = (maxX - minX) / width;\n  var yScale = (maxY - minY) / height;\n\n  for (var i = 0; i < numOfVerticies; i++) {\n    var x = vertices[i * 2];\n    var y = vertices[i * 2 + 1];\n    var pixelIdx = y * gridSize + x;\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {\n      value: positions,\n      size: 3\n    },\n    TEXCOORD_0: {\n      value: texCoords,\n      size: 2\n    }\n  };\n}\n\nfunction getMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n\n  var meshMaxError = terrainOptions.meshMaxError,\n      bounds = terrainOptions.bounds,\n      elevationDecoder = terrainOptions.elevationDecoder;\n  var data = terrainImage.data,\n      width = terrainImage.width,\n      height = terrainImage.height;\n  var terrain;\n  var mesh;\n\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n\n    default:\n      if (width === height && !(height & width - 1)) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n\n      break;\n  }\n\n  var _mesh = mesh,\n      vertices = _mesh.vertices;\n  var _mesh2 = mesh,\n      triangles = _mesh2.triangles;\n  var attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n  var boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    var _addSkirt = addSkirt(attributes, triangles, terrainOptions.skirtHeight),\n        newAttributes = _addSkirt.attributes,\n        newTriangles = _addSkirt.triangles;\n\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: boundingBox\n    },\n    mode: 4,\n    indices: {\n      value: Uint32Array.from(triangles),\n      size: 1\n    },\n    attributes: attributes\n  };\n}\n\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  var gridSize = width + 1;\n  var martini = new Martini(gridSize);\n  var tile = martini.createTile(terrain);\n\n  var _tile$getMesh = tile.getMesh(meshMaxError),\n      vertices = _tile$getMesh.vertices,\n      triangles = _tile$getMesh.triangles;\n\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\n\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  var tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  var coords = tin.coords,\n      triangles = tin.triangles;\n  var vertices = coords;\n  return {\n    vertices: vertices,\n    triangles: triangles\n  };\n}\n\nexport default function loadTerrain(_x2, _x3, _x4) {\n  return _loadTerrain.apply(this, arguments);\n}\n\nfunction _loadTerrain() {\n  _loadTerrain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(arrayBuffer, options, context) {\n    var loadImageOptions, image;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            loadImageOptions = _objectSpread(_objectSpread({}, options), {}, {\n              mimeType: 'application/x.image',\n              image: _objectSpread(_objectSpread({}, options.image), {}, {\n                type: 'data'\n              })\n            });\n            _context.next = 3;\n            return context.parse(arrayBuffer, loadImageOptions);\n\n          case 3:\n            image = _context.sent;\n            return _context.abrupt(\"return\", getMesh(image, options.terrain));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _loadTerrain.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["getMeshBoundingBox","Martini","Delatin","addSkirt","getTerrain","imageData","width","height","elevationDecoder","tesselator","rScaler","bScaler","gScaler","offset","terrain","Float32Array","i","y","x","k","r","g","b","getMeshAttributes","vertices","bounds","gridSize","numOfVerticies","length","positions","texCoords","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","getMesh","terrainImage","terrainOptions","meshMaxError","data","mesh","getMartiniTileMesh","getDelatinTileMesh","triangles","attributes","boundingBox","skirtHeight","newAttributes","newTriangles","loaderData","header","vertexCount","mode","indices","Uint32Array","from","martini","tile","createTile","tin","run","coords","loadTerrain","arrayBuffer","options","context","loadImageOptions","mimeType","image","type","parse"],"sources":["../../../src/lib/parse-terrain.ts"],"sourcesContent":["import {getMeshBoundingBox} from '@loaders.gl/schema';\nimport Martini from '@mapbox/martini';\nimport Delatin from './delatin';\nimport {addSkirt} from './helpers/skirt';\n\ntype TerrainOptions = {\n  meshMaxError: number;\n  bounds: number[];\n  elevationDecoder: ElevationDecoder;\n  tesselator: 'martini' | 'delatin';\n  skirtHeight?: number;\n};\n\ntype TerrainImage = {\n  data: Uint8Array;\n  width: number;\n  height: number;\n};\n\ntype ElevationDecoder = {\n  rScaler: any;\n  bScaler: any;\n  gScaler: any;\n  offset: number;\n};\n\nfunction getTerrain(\n  imageData: Uint8Array,\n  width: number,\n  height: number,\n  elevationDecoder: ElevationDecoder,\n  tesselator: 'martini' | 'delatin'\n) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array((width + 1) * (height + 1));\n  // decode terrain values\n  for (let i = 0, y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n\n  if (tesselator === 'martini') {\n    // backfill bottom border\n    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {\n      terrain[i] = terrain[i - width - 1];\n    }\n    // backfill right border\n    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {\n      terrain[i] = terrain[i - 1];\n    }\n  }\n\n  return terrain;\n}\n\nfunction getMeshAttributes(\n  vertices,\n  terrain: Uint8Array,\n  width: number,\n  height: number,\n  bounds: number[]\n) {\n  const gridSize = width + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];\n  const xScale = (maxX - minX) / width;\n  const yScale = (maxY - minY) / height;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / width;\n    texCoords[2 * i + 1] = y / height;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\n/**\n * Returns generated mesh object from image data\n *\n * @param {object} terrainImage terrain image data\n * @param {object} terrainOptions terrain options\n * @returns mesh object\n */\nfunction getMesh(terrainImage: TerrainImage, terrainOptions: TerrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const {data, width, height} = terrainImage;\n\n  let terrain;\n  let mesh;\n  switch (terrainOptions.tesselator) {\n    case 'martini':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      break;\n    case 'delatin':\n      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);\n      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      break;\n    // auto\n    default:\n      if (width === height && !(height & (width - 1))) {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'martini');\n        mesh = getMartiniTileMesh(meshMaxError, width, terrain);\n      } else {\n        terrain = getTerrain(data, width, height, elevationDecoder, 'delatin');\n        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);\n      }\n      break;\n  }\n\n  const {vertices} = mesh;\n  let {triangles} = mesh;\n  let attributes = getMeshAttributes(vertices, terrain, width, height, bounds);\n\n  // Compute bounding box before adding skirt so that z values are not skewed\n  const boundingBox = getMeshBoundingBox(attributes);\n\n  if (terrainOptions.skirtHeight) {\n    const {attributes: newAttributes, triangles: newTriangles} = addSkirt(\n      attributes,\n      triangles,\n      terrainOptions.skirtHeight\n    );\n    attributes = newAttributes;\n    triangles = newTriangles;\n  }\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: Uint32Array.from(triangles), size: 1},\n    attributes\n  };\n}\n\n/**\n * Get Martini generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: Uint16Array, triangles: Uint32Array}} vertices and triangles data\n */\nfunction getMartiniTileMesh(meshMaxError, width, terrain) {\n  const gridSize = width + 1;\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  return {vertices, triangles};\n}\n\n/**\n * Get Delatin generated vertices and triangles\n *\n * @param {number} meshMaxError threshold for simplifying mesh\n * @param {number} width width of the input data array\n * @param {number} height height of the input data array\n * @param {number[] | Float32Array} terrain elevation data\n * @returns {{vertices: number[], triangles: number[]}} vertices and triangles data\n */\nfunction getDelatinTileMesh(meshMaxError, width, height, terrain) {\n  const tin = new Delatin(terrain, width + 1, height + 1);\n  tin.run(meshMaxError);\n  // @ts-expect-error\n  const {coords, triangles} = tin;\n  const vertices = coords;\n  return {vertices, triangles};\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  const loadImageOptions = {\n    ...options,\n    mimeType: 'application/x.image',\n    image: {...options.image, type: 'data'}\n  };\n  const image = await context.parse(arrayBuffer, loadImageOptions);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMesh(image, options.terrain);\n}\n"]},"metadata":{},"sourceType":"module"}