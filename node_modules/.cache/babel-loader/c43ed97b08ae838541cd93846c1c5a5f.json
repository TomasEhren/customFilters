{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { default as LayersPass } from './layers-pass';\nimport { Framebuffer, Texture2D, Renderbuffer, withParameters, cssToDeviceRatio } from '@luma.gl/core';\nexport default class ShadowPass extends LayersPass {\n  constructor(gl, props) {\n    super(gl, props);\n\n    _defineProperty(this, \"shadowMap\", void 0);\n\n    _defineProperty(this, \"depthBuffer\", void 0);\n\n    _defineProperty(this, \"fbo\", void 0);\n\n    this.shadowMap = new Texture2D(gl, {\n      width: 1,\n      height: 1,\n      parameters: {\n        [10241]: 9729,\n        [10240]: 9729,\n        [10242]: 33071,\n        [10243]: 33071\n      }\n    });\n    this.depthBuffer = new Renderbuffer(gl, {\n      format: 33189,\n      width: 1,\n      height: 1\n    });\n    this.fbo = new Framebuffer(gl, {\n      id: 'shadowmap',\n      width: 1,\n      height: 1,\n      attachments: {\n        [36064]: this.shadowMap,\n        [36096]: this.depthBuffer\n      }\n    });\n  }\n\n  render(params) {\n    const target = this.fbo;\n    withParameters(this.gl, {\n      depthRange: [0, 1],\n      depthTest: true,\n      blend: false,\n      clearColor: [1, 1, 1, 1]\n    }, () => {\n      const viewport = params.viewports[0];\n      const pixelRatio = cssToDeviceRatio(this.gl);\n      const width = viewport.width * pixelRatio;\n      const height = viewport.height * pixelRatio;\n\n      if (width !== target.width || height !== target.height) {\n        target.resize({\n          width,\n          height\n        });\n      }\n\n      super.render({ ...params,\n        target,\n        pass: 'shadow'\n      });\n    });\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.shadowEnabled !== false;\n  }\n\n  getModuleParameters() {\n    return {\n      drawToShadowMap: true\n    };\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.delete();\n      this.fbo = null;\n    }\n\n    if (this.shadowMap) {\n      this.shadowMap.delete();\n      this.shadowMap = null;\n    }\n\n    if (this.depthBuffer) {\n      this.depthBuffer.delete();\n      this.depthBuffer = null;\n    }\n  }\n\n}","map":{"version":3,"mappings":";AAAA,SAAQA,OAAO,IAAIC,UAAnB,QAAoC,eAApC;AACA,SACEC,WADF,EAEEC,SAFF,EAGEC,YAHF,EAIEC,cAJF,EAKEC,gBALF,QAMO,eANP;AAQA,eAAe,MAAMC,UAAN,SAAyBN,UAAzB,CAAoC;EAKjDO,WAAW,CAACC,EAAD,EAAKC,KAAL,EAAY;IACrB,MAAMD,EAAN,EAAUC,KAAV;;IADqBC;;IAAAA;;IAAAA;;IAIrB,KAAKC,SAAL,GAAiB,IAAIT,SAAJ,CAAcM,EAAd,EAAkB;MACjCI,KAAK,EAAE,CAD0B;MAEjCC,MAAM,EAAE,CAFyB;MAGjCC,UAAU,EAAE;QACV,aADU;QAEV,aAFU;QAGV,cAHU;QAIV;MAJU;IAHqB,CAAlB,CAAjB;IAWA,KAAKC,WAAL,GAAmB,IAAIZ,YAAJ,CAAiBK,EAAjB,EAAqB;MACtCQ,MAAM,OADgC;MAEtCJ,KAAK,EAAE,CAF+B;MAGtCC,MAAM,EAAE;IAH8B,CAArB,CAAnB;IAMA,KAAKI,GAAL,GAAW,IAAIhB,WAAJ,CAAgBO,EAAhB,EAAoB;MAC7BU,EAAE,EAAE,WADyB;MAE7BN,KAAK,EAAE,CAFsB;MAG7BC,MAAM,EAAE,CAHqB;MAI7BM,WAAW,EAAE;QACX,SAAwB,KAAKR,SADlB;QAGX,SAAuB,KAAKI;MAHjB;IAJgB,CAApB,CAAX;EAUD;;EAEDK,MAAM,CAACC,MAAD,EAAS;IACb,MAAMC,MAAM,GAAG,KAAKL,GAApB;IAEAb,cAAc,CACZ,KAAKI,EADO,EAEZ;MACEe,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,CADd;MAEEC,SAAS,EAAE,IAFb;MAGEC,KAAK,EAAE,KAHT;MAIEC,UAAU,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;IAJd,CAFY,EAQZ,MAAM;MACJ,MAAMC,QAAQ,GAAGN,MAAM,CAACO,SAAPP,CAAiB,CAAjBA,CAAjB;MACA,MAAMQ,UAAU,GAAGxB,gBAAgB,CAAC,KAAKG,EAAN,CAAnC;MACA,MAAMI,KAAK,GAAGe,QAAQ,CAACf,KAATe,GAAiBE,UAA/B;MACA,MAAMhB,MAAM,GAAGc,QAAQ,CAACd,MAATc,GAAkBE,UAAjC;;MACA,IAAIjB,KAAK,KAAKU,MAAM,CAACV,KAAjBA,IAA0BC,MAAM,KAAKS,MAAM,CAACT,MAAhD,EAAwD;QACtDS,MAAM,CAACQ,MAAPR,CAAc;UAACV,KAAD;UAAQC;QAAR,CAAdS;MACD;;MAED,MAAMF,MAAN,CAAa,EAAC,GAAGC,MAAJ;QAAYC,MAAZ;QAAoBS,IAAI,EAAE;MAA1B,CAAb;IAjBU,EAAd3B;EAoBD;;EAED4B,eAAe,CAACC,KAAD,EAAQ;IACrB,OAAOA,KAAK,CAACxB,KAANwB,CAAYC,aAAZD,KAA8B,KAArC;EACD;;EAEDE,mBAAmB,GAAG;IACpB,OAAO;MACLC,eAAe,EAAE;IADZ,CAAP;EAGD;;EAEDC,MAAM,GAAG;IACP,IAAI,KAAKpB,GAAT,EAAc;MACZ,KAAKA,GAAL,CAASoB,MAAT;MACA,KAAKpB,GAAL,GAAW,IAAX;IACD;;IAED,IAAI,KAAKN,SAAT,EAAoB;MAClB,KAAKA,SAAL,CAAe0B,MAAf;MACA,KAAK1B,SAAL,GAAiB,IAAjB;IACD;;IAED,IAAI,KAAKI,WAAT,EAAsB;MACpB,KAAKA,WAAL,CAAiBsB,MAAjB;MACA,KAAKtB,WAAL,GAAmB,IAAnB;IACD;EACF;;AAxFgD","names":["default","LayersPass","Framebuffer","Texture2D","Renderbuffer","withParameters","cssToDeviceRatio","ShadowPass","constructor","gl","props","_defineProperty","shadowMap","width","height","parameters","depthBuffer","format","fbo","id","attachments","render","params","target","depthRange","depthTest","blend","clearColor","viewport","viewports","pixelRatio","resize","pass","shouldDrawLayer","layer","shadowEnabled","getModuleParameters","drawToShadowMap","delete"],"sources":["../../../src/passes/shadow-pass.ts"],"sourcesContent":["import {default as LayersPass} from './layers-pass';\nimport {\n  Framebuffer,\n  Texture2D,\n  Renderbuffer,\n  withParameters,\n  cssToDeviceRatio\n} from '@luma.gl/core';\n\nexport default class ShadowPass extends LayersPass {\n  shadowMap: Texture2D;\n  depthBuffer: Renderbuffer;\n  fbo: Framebuffer;\n\n  constructor(gl, props) {\n    super(gl, props);\n\n    // The shadowMap texture\n    this.shadowMap = new Texture2D(gl, {\n      width: 1,\n      height: 1,\n      parameters: {\n        [gl.TEXTURE_MIN_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_MAG_FILTER]: gl.LINEAR,\n        [gl.TEXTURE_WRAP_S]: gl.CLAMP_TO_EDGE,\n        [gl.TEXTURE_WRAP_T]: gl.CLAMP_TO_EDGE\n      }\n    });\n\n    this.depthBuffer = new Renderbuffer(gl, {\n      format: gl.DEPTH_COMPONENT16,\n      width: 1,\n      height: 1\n    });\n\n    this.fbo = new Framebuffer(gl, {\n      id: 'shadowmap',\n      width: 1,\n      height: 1,\n      attachments: {\n        [gl.COLOR_ATTACHMENT0]: this.shadowMap,\n        // Depth attachment has to be specified for depth test to work\n        [gl.DEPTH_ATTACHMENT]: this.depthBuffer\n      }\n    });\n  }\n\n  render(params) {\n    const target = this.fbo;\n\n    withParameters(\n      this.gl,\n      {\n        depthRange: [0, 1],\n        depthTest: true,\n        blend: false,\n        clearColor: [1, 1, 1, 1]\n      },\n      () => {\n        const viewport = params.viewports[0];\n        const pixelRatio = cssToDeviceRatio(this.gl);\n        const width = viewport.width * pixelRatio;\n        const height = viewport.height * pixelRatio;\n        if (width !== target.width || height !== target.height) {\n          target.resize({width, height});\n        }\n\n        super.render({...params, target, pass: 'shadow'});\n      }\n    );\n  }\n\n  shouldDrawLayer(layer) {\n    return layer.props.shadowEnabled !== false;\n  }\n\n  getModuleParameters() {\n    return {\n      drawToShadowMap: true\n    };\n  }\n\n  delete() {\n    if (this.fbo) {\n      this.fbo.delete();\n      this.fbo = null;\n    }\n\n    if (this.shadowMap) {\n      this.shadowMap.delete();\n      this.shadowMap = null;\n    }\n\n    if (this.depthBuffer) {\n      this.depthBuffer.delete();\n      this.depthBuffer = null;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}