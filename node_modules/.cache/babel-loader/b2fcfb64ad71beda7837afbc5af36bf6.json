{"ast":null,"code":"const QUANTIZED_MESH_HEADER = new Map([['centerX', Float64Array.BYTES_PER_ELEMENT], ['centerY', Float64Array.BYTES_PER_ELEMENT], ['centerZ', Float64Array.BYTES_PER_ELEMENT], ['minHeight', Float32Array.BYTES_PER_ELEMENT], ['maxHeight', Float32Array.BYTES_PER_ELEMENT], ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT], ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT], ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]]);\n\nfunction decodeZigZag(value) {\n  return value >> 1 ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {\n    header,\n    headerEndPosition: position\n  };\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n  return {\n    vertexData,\n    vertexDataEndPosition: position\n  };\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex) {\n  let encoded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - position % bytesPerIndex;\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);\n  position += triangleIndicesCount * bytesPerIndex;\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);\n  position += southVertexCount * bytesPerIndex;\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);\n  position += northVertexCount * bytesPerIndex;\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);\n}\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {\n      extensions,\n      extensionsEndPosition: indicesEndPosition\n    };\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1:\n        {\n          extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n          break;\n        }\n\n      case 2:\n        {\n          extensions.waterMask = decodeWaterMaskExtension(extensionView);\n          break;\n        }\n\n      default:\n        {}\n    }\n\n    position += extensionLength;\n  }\n\n  return {\n    extensions,\n    extensionsEndPosition: position\n  };\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {\n    header,\n    headerEndPosition\n  } = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {\n      header\n    };\n  }\n\n  const {\n    vertexData,\n    vertexDataEndPosition\n  } = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {\n      header,\n      vertexData\n    };\n  }\n\n  const {\n    triangleIndices,\n    triangleIndicesEndPosition\n  } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {\n      header,\n      vertexData,\n      triangleIndices\n    };\n  }\n\n  const {\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices,\n    edgeIndicesEndPosition\n  } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {\n    extensions\n  } = decodeExtensions(view, edgeIndicesEndPosition);\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}","map":{"version":3,"mappings":"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","names":["QUANTIZED_MESH_HEADER","Map","Float64Array","BYTES_PER_ELEMENT","Float32Array","decodeZigZag","value","decodeHeader","dataView","position","header","key","bytesCount","getter","getFloat64","getFloat32","call","headerEndPosition","decodeVertexData","elementsPerVertex","vertexCount","getUint32","vertexData","Uint16Array","Uint32Array","bytesPerArrayElement","elementArrayLength","uArrayStartPosition","vArrayStartPosition","heightArrayStartPosition","u","v","height","i","getUint16","vertexDataEndPosition","decodeIndex","buffer","indicesCount","bytesPerIndex","encoded","indices","highest","length","code","decodeTriangleIndices","triangleCount","triangleIndicesCount","triangleIndices","triangleIndicesEndPosition","decodeEdgeIndices","westVertexCount","westIndices","southVertexCount","southIndices","eastVertexCount","eastIndices","northVertexCount","northIndices","edgeIndicesEndPosition","decodeVertexNormalsExtension","extensionDataView","Uint8Array","byteOffset","byteLength","decodeWaterMaskExtension","slice","decodeExtensions","indicesEndPosition","extensions","extensionsEndPosition","extensionId","getUint8","extensionLength","extensionView","DataView","vertexNormals","waterMask","DECODING_STEPS","vertices","edgeIndices","DEFAULT_OPTIONS","maxDecodingStep","decode","data","userOptions","options","Object","assign","view"],"sources":["../../../src/lib/decode-quantized-mesh.ts"],"sourcesContent":["// Copyright (C) 2018-2019 HERE Europe B.V.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst QUANTIZED_MESH_HEADER = new Map([\n  ['centerX', Float64Array.BYTES_PER_ELEMENT],\n  ['centerY', Float64Array.BYTES_PER_ELEMENT],\n  ['centerZ', Float64Array.BYTES_PER_ELEMENT],\n\n  ['minHeight', Float32Array.BYTES_PER_ELEMENT],\n  ['maxHeight', Float32Array.BYTES_PER_ELEMENT],\n\n  ['boundingSphereCenterX', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterY', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereCenterZ', Float64Array.BYTES_PER_ELEMENT],\n  ['boundingSphereRadius', Float64Array.BYTES_PER_ELEMENT],\n\n  ['horizonOcclusionPointX', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointY', Float64Array.BYTES_PER_ELEMENT],\n  ['horizonOcclusionPointZ', Float64Array.BYTES_PER_ELEMENT]\n]);\n\nfunction decodeZigZag(value) {\n  return (value >> 1) ^ -(value & 1);\n}\n\nfunction decodeHeader(dataView) {\n  let position = 0;\n  const header = {};\n\n  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {\n    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;\n\n    header[key] = getter.call(dataView, position, true);\n    position += bytesCount;\n  }\n\n  return {header, headerEndPosition: position};\n}\n\nfunction decodeVertexData(dataView, headerEndPosition) {\n  let position = headerEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = dataView.getUint32(position, true);\n  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);\n\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;\n  const elementArrayLength = vertexCount * bytesPerArrayElement;\n  const uArrayStartPosition = position;\n  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;\n  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < vertexCount; i++) {\n    u += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));\n    v += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));\n    height += decodeZigZag(\n      dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true)\n    );\n\n    vertexData[i] = u;\n    vertexData[i + vertexCount] = v;\n    vertexData[i + vertexCount * 2] = height;\n  }\n\n  position += elementArrayLength * 3;\n\n  return {vertexData, vertexDataEndPosition: position};\n}\n\nfunction decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {\n  let indices;\n\n  if (bytesPerIndex === 2) {\n    indices = new Uint16Array(buffer, position, indicesCount);\n  } else {\n    indices = new Uint32Array(buffer, position, indicesCount);\n  }\n\n  if (!encoded) {\n    return indices;\n  }\n\n  let highest = 0;\n\n  for (let i = 0; i < indices.length; ++i) {\n    const code = indices[i];\n\n    indices[i] = highest - code;\n\n    if (code === 0) {\n      ++highest;\n    }\n  }\n\n  return indices;\n}\n\nfunction decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {\n  let position = vertexDataEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  if (position % bytesPerIndex !== 0) {\n    position += bytesPerIndex - (position % bytesPerIndex);\n  }\n\n  const triangleCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const triangleIndicesCount = triangleCount * 3;\n  const triangleIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    triangleIndicesCount,\n    bytesPerIndex\n  );\n  position += triangleIndicesCount * bytesPerIndex;\n\n  return {\n    triangleIndicesEndPosition: position,\n    triangleIndices\n  };\n}\n\nfunction decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {\n  let position = triangleIndicesEndPosition;\n  const elementsPerVertex = 3;\n  const vertexCount = vertexData.length / elementsPerVertex;\n  const bytesPerIndex =\n    vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;\n\n  const westVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);\n  position += westVertexCount * bytesPerIndex;\n\n  const southVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const southIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    southVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += southVertexCount * bytesPerIndex;\n\n  const eastVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);\n  position += eastVertexCount * bytesPerIndex;\n\n  const northVertexCount = dataView.getUint32(position, true);\n  position += Uint32Array.BYTES_PER_ELEMENT;\n\n  const northIndices = decodeIndex(\n    dataView.buffer,\n    position,\n    northVertexCount,\n    bytesPerIndex,\n    false\n  );\n  position += northVertexCount * bytesPerIndex;\n\n  return {\n    edgeIndicesEndPosition: position,\n    westIndices,\n    southIndices,\n    eastIndices,\n    northIndices\n  };\n}\n\nfunction decodeVertexNormalsExtension(extensionDataView) {\n  return new Uint8Array(\n    extensionDataView.buffer,\n    extensionDataView.byteOffset,\n    extensionDataView.byteLength\n  );\n}\n\nfunction decodeWaterMaskExtension(extensionDataView) {\n  return extensionDataView.buffer.slice(\n    extensionDataView.byteOffset,\n    extensionDataView.byteOffset + extensionDataView.byteLength\n  );\n}\n\ntype Extensions = {\n  vertexNormals?: any;\n  waterMask?: any;\n};\n\nfunction decodeExtensions(dataView, indicesEndPosition) {\n  const extensions: Extensions = {};\n\n  if (dataView.byteLength <= indicesEndPosition) {\n    return {extensions, extensionsEndPosition: indicesEndPosition};\n  }\n\n  let position = indicesEndPosition;\n\n  while (position < dataView.byteLength) {\n    const extensionId = dataView.getUint8(position, true);\n    position += Uint8Array.BYTES_PER_ELEMENT;\n\n    const extensionLength = dataView.getUint32(position, true);\n    position += Uint32Array.BYTES_PER_ELEMENT;\n\n    const extensionView = new DataView(dataView.buffer, position, extensionLength);\n\n    switch (extensionId) {\n      case 1: {\n        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);\n\n        break;\n      }\n      case 2: {\n        extensions.waterMask = decodeWaterMaskExtension(extensionView);\n\n        break;\n      }\n      default: {\n        // console.warn(`Unknown extension with id ${extensionId}`)\n      }\n    }\n\n    position += extensionLength;\n  }\n\n  return {extensions, extensionsEndPosition: position};\n}\n\nexport const DECODING_STEPS = {\n  header: 0,\n  vertices: 1,\n  triangleIndices: 2,\n  edgeIndices: 3,\n  extensions: 4\n};\n\nconst DEFAULT_OPTIONS = {\n  maxDecodingStep: DECODING_STEPS.extensions\n};\n\nexport default function decode(data, userOptions) {\n  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);\n  const view = new DataView(data);\n  const {header, headerEndPosition} = decodeHeader(view);\n\n  if (options.maxDecodingStep < DECODING_STEPS.vertices) {\n    return {header};\n  }\n\n  const {vertexData, vertexDataEndPosition} = decodeVertexData(view, headerEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {\n    return {header, vertexData};\n  }\n\n  const {triangleIndices, triangleIndicesEndPosition} = decodeTriangleIndices(\n    view,\n    vertexData,\n    vertexDataEndPosition\n  );\n\n  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {\n    return {header, vertexData, triangleIndices};\n  }\n\n  const {westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition} =\n    decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);\n\n  if (options.maxDecodingStep < DECODING_STEPS.extensions) {\n    return {\n      header,\n      vertexData,\n      triangleIndices,\n      westIndices,\n      northIndices,\n      eastIndices,\n      southIndices\n    };\n  }\n\n  const {extensions} = decodeExtensions(view, edgeIndicesEndPosition);\n\n  return {\n    header,\n    vertexData,\n    triangleIndices,\n    westIndices,\n    northIndices,\n    eastIndices,\n    southIndices,\n    extensions\n  };\n}\n"]},"metadata":{},"sourceType":"module"}