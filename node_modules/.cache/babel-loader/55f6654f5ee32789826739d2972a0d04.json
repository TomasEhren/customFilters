{"ast":null,"code":"import { fs } from '@loaders.gl/loader-utils';\nexport async function readArrayBuffer(file, start, length) {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\nexport async function readBlob(blob) {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n\n    fileReader.onload = event => {\n      var _event$target;\n\n      return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n    };\n\n    fileReader.onerror = error => reject(error);\n\n    fileReader.readAsArrayBuffer(blob);\n  });\n}","map":{"version":3,"mappings":"AACA,SAAQA,EAAR,QAAiB,0BAAjB;AASA,OAAO,eAAeC,eAAf,CACLC,IADK,EAELC,KAFK,EAGLC,MAHK,EAIiB;EACtB,IAAI,OAAOF,IAAP,KAAgB,QAApB,EAA8B;IAC5B,OAAO,MAAMF,EAAE,CAACK,kBAAHL,CAAsBE,IAAtBF,EAA4BG,KAA5BH,EAAmCI,MAAnCJ,CAAb;EACD;;EAED,IAAI,EAAEE,IAAI,YAAYI,IAAlB,CAAJ,EAA6B;IAC3BJ,IAAI,GAAG,IAAII,IAAJ,CAAS,CAACJ,IAAD,CAAT,CAAPA;EACD;;EACD,MAAMK,KAAK,GAAGL,IAAI,CAACK,KAALL,CAAWC,KAAXD,EAAkBC,KAAK,GAAGC,MAA1BF,CAAd;EACA,OAAO,MAAMM,QAAQ,CAACD,KAAD,CAArB;AACD;AASD,OAAO,eAAeC,QAAf,CAAwBC,IAAxB,EAA0D;EAC/D,OAAO,MAAM,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IAC5C,MAAMC,UAAU,GAAG,IAAIC,UAAJ,EAAnB;;IACAD,UAAU,CAACE,MAAXF,GAAqBG,KAAD;MAAA;;MAAA,OAClBL,OAAO,CAACK,KAAD,SAACA,SAAD,WAACA,GAAD,MAACA,GAAD,iBAACA,KAAK,CAAEC,MAAR,kDAACC,cAAeC,MAAhB,CADW;IAApB;;IAGAN,UAAU,CAACO,OAAXP,GAAsBQ,KAAD,IAAsCT,MAAM,CAACS,KAAD,CAAjER;;IACAA,UAAU,CAACS,iBAAXT,CAA6BJ,IAA7BI;EANW,EAAb;AAQD","names":["fs","readArrayBuffer","file","start","length","_readToArrayBuffer","Blob","slice","readBlob","blob","Promise","resolve","reject","fileReader","FileReader","onload","event","target","_event$target","result","onerror","error","readAsArrayBuffer"],"sources":["../../../../src/lib/fetch/read-array-buffer.ts"],"sourcesContent":["//\nimport {fs} from '@loaders.gl/loader-utils';\n\n/**\n * Reads a chunk from a random access file\n * @param file\n * @param start\n * @param length\n * @returns\n */\nexport async function readArrayBuffer(\n  file: Blob | ArrayBuffer | string | number,\n  start: number,\n  length: number\n): Promise<ArrayBuffer> {\n  if (typeof file === 'number') {\n    return await fs._readToArrayBuffer(file, start, length);\n  }\n  // TODO - we can do better for ArrayBuffer and string\n  if (!(file instanceof Blob)) {\n    file = new Blob([file]);\n  }\n  const slice = file.slice(start, start + length);\n  return await readBlob(slice);\n}\n\n/**\n * Read a slice of a Blob or File, without loading the entire file into memory\n * The trick when reading File objects is to read successive \"slices\" of the File\n * Per spec https://w3c.github.io/FileAPI/, slicing a File only updates the start and end fields\n * Actually reading from file happens in `readAsArrayBuffer`\n * @param blob to read\n */\nexport async function readBlob(blob: Blob): Promise<ArrayBuffer> {\n  return await new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = (event: ProgressEvent<FileReader>) =>\n      resolve(event?.target?.result as ArrayBuffer);\n    // TODO - reject with a proper Error\n    fileReader.onerror = (error: ProgressEvent<FileReader>) => reject(error);\n    fileReader.readAsArrayBuffer(blob);\n  });\n}\n"]},"metadata":{},"sourceType":"module"}