{"ast":null,"code":"import MathArray from './base/math-array';\nimport { checkNumber, checkVector } from '../lib/validators';\nimport assert from '../lib/assert';\nimport * as quat from 'gl-matrix/quat';\nimport * as vec4 from 'gl-matrix/vec4';\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\nexport default class Quaternion extends MathArray {\n  constructor() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    super(-0, -0, -0, -0);\n\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  fromMatrix3(m) {\n    quat.fromMat3(this, m);\n    return this.check();\n  }\n\n  identity() {\n    quat.identity(this);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat.setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = checkNumber(value);\n  }\n\n  len() {\n    return quat.length(this);\n  }\n\n  lengthSquared() {\n    return quat.squaredLength(this);\n  }\n\n  dot(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.dot only takes one argument');\n    }\n\n    return quat.dot(this, a);\n  }\n\n  rotationTo(vectorA, vectorB) {\n    quat.rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  add(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.add only takes one argument');\n    }\n\n    quat.add(this, this, a);\n    return this.check();\n  }\n\n  calculateW() {\n    quat.calculateW(this, this);\n    return this.check();\n  }\n\n  conjugate() {\n    quat.conjugate(this, this);\n    return this.check();\n  }\n\n  invert() {\n    quat.invert(this, this);\n    return this.check();\n  }\n\n  lerp(a, b, t) {\n    quat.lerp(this, a, b, t);\n    return this.check();\n  }\n\n  multiplyRight(a, b) {\n    assert(!b);\n    quat.multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a, b) {\n    assert(!b);\n    quat.multiply(this, a, this);\n    return this.check();\n  }\n\n  normalize() {\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n\n    if (length === 0) {\n      this[3] = 1;\n    }\n\n    return this.check();\n  }\n\n  rotateX(rad) {\n    quat.rotateX(this, this, rad);\n    return this.check();\n  }\n\n  rotateY(rad) {\n    quat.rotateY(this, this, rad);\n    return this.check();\n  }\n\n  rotateZ(rad) {\n    quat.rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  scale(b) {\n    quat.scale(this, this, b);\n    return this.check();\n  }\n\n  slerp(start, target, ratio) {\n    switch (arguments.length) {\n      case 1:\n        ({\n          start = IDENTITY_QUATERNION,\n          target,\n          ratio\n        } = arguments[0]);\n        break;\n\n      case 2:\n        [target, ratio] = arguments;\n        start = this;\n        break;\n\n      default:\n    }\n\n    quat.slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vector;\n    vec4.transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a, b) {\n    return this.multiplyLeft(a, b);\n  }\n\n  multiply(a, b) {\n    return this.multiplyRight(a, b);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["MathArray","checkNumber","checkVector","assert","quat","vec4","IDENTITY_QUATERNION","Quaternion","constructor","x","y","z","w","Array","isArray","arguments","length","copy","set","array","check","fromMatrix3","m","fromMat3","identity","fromAxisRotation","axis","rad","setAxisAngle","ELEMENTS","value","len","lengthSquared","squaredLength","dot","a","b","undefined","Error","rotationTo","vectorA","vectorB","add","calculateW","conjugate","invert","lerp","t","multiplyRight","multiply","multiplyLeft","normalize","l","rotateX","rotateY","rotateZ","scale","slerp","start","target","ratio","transformVector4","vector","result","transformQuat","lengthSq","setFromAxisAngle","premultiply"],"sources":["../../../src/classes/quaternion.js"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport MathArray from './base/math-array';\nimport {checkNumber, checkVector} from '../lib/validators';\nimport assert from '../lib/assert';\n\n// @ts-ignore: error TS2307: Cannot find module 'gl-matrix/...'.\nimport * as quat from 'gl-matrix/quat';\n// @ts-ignore: error TS2307: Cannot find module 'gl-matrix/...'.\nimport * as vec4 from 'gl-matrix/vec4';\n\nconst IDENTITY_QUATERNION = [0, 0, 0, 1];\n\nexport default class Quaternion extends MathArray {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    // PERF NOTE: initialize elements as double precision numbers\n    super(-0, -0, -0, -0);\n    // eslint-disable-next-line prefer-rest-params\n    if (Array.isArray(x) && arguments.length === 1) {\n      this.copy(x);\n    } else {\n      this.set(x, y, z, w);\n    }\n  }\n\n  copy(array) {\n    this[0] = array[0];\n    this[1] = array[1];\n    this[2] = array[2];\n    this[3] = array[3];\n    return this.check();\n  }\n\n  set(x, y, z, w) {\n    this[0] = x;\n    this[1] = y;\n    this[2] = z;\n    this[3] = w;\n    return this.check();\n  }\n\n  // Creates a quaternion from the given 3x3 rotation matrix.\n  // NOTE: The resultant quaternion is not normalized, so you should\n  // be sure to renormalize the quaternion yourself where necessary.\n  fromMatrix3(m) {\n    quat.fromMat3(this, m);\n    return this.check();\n  }\n\n  // Set a quat to the identity quaternion\n  identity() {\n    quat.identity(this);\n    return this.check();\n  }\n\n  fromAxisRotation(axis, rad) {\n    quat.setAxisAngle(this, axis, rad);\n    return this.check();\n  }\n\n  // Set the components of a quat to the given values\n  // set(i, j, k, l) {\n  //   quat.set(this, i, j, k, l);\n  //   return this.check();\n  // }\n\n  // Sets a quat from the given angle and rotation axis, then returns it.\n  setAxisAngle(axis, rad) {\n    return this.fromAxisRotation(axis, rad);\n  }\n\n  // Getters/setters\n  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */\n  get ELEMENTS() {\n    return 4;\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  set x(value) {\n    this[0] = checkNumber(value);\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set y(value) {\n    this[1] = checkNumber(value);\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set z(value) {\n    this[2] = checkNumber(value);\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set w(value) {\n    this[3] = checkNumber(value);\n  }\n\n  /* eslint-enable no-multi-spaces, brace-style, no-return-assign */\n\n  // Calculates the length of a quat\n  len() {\n    return quat.length(this);\n  }\n\n  // Calculates the squared length of a quat\n  lengthSquared() {\n    return quat.squaredLength(this);\n  }\n\n  // Calculates the dot product of two quat's\n  // @return {Number}\n  dot(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.dot only takes one argument');\n    }\n    return quat.dot(this, a);\n  }\n\n  // Gets the rotation axis and angle for a given quaternion.\n  // If a quaternion is created with setAxisAngle, this method will\n  // return the same values as providied in the original parameter\n  // list OR functionally equivalent values.\n  // Example: The quaternion formed by axis [0, 0, 1] and angle -90\n  // is the same as the quaternion formed by [0, 0, 1] and 270.\n  // This method favors the latter.\n  // @return {{[x,y,z], Number}}\n  // getAxisAngle() {\n  //   const axis = [];\n  //   const angle = quat.getAxisAngle(axis, this);\n  //   return {axis, angle};\n  // }\n\n  // MODIFIERS\n\n  // Sets a quaternion to represent the shortest rotation from one vector\n  // to another. Both vectors are assumed to be unit length.\n  rotationTo(vectorA, vectorB) {\n    quat.rotationTo(this, vectorA, vectorB);\n    return this.check();\n  }\n\n  // Sets the specified quaternion with values corresponding to the given axes.\n  // Each axis is a vec3 and is expected to be unit length and perpendicular\n  // to all other specified axes.\n  // setAxes() {\n  //   Number\n  // }\n\n  // Performs a spherical linear interpolation with two control points\n  // sqlerp() {\n  //   Number;\n  // }\n\n  // Adds two quat's\n  add(a, b) {\n    if (b !== undefined) {\n      throw new Error('Quaternion.add only takes one argument');\n    }\n    quat.add(this, this, a);\n    return this.check();\n  }\n\n  // Calculates the W component of a quat from the X, Y, and Z components.\n  // Any existing W component will be ignored.\n  calculateW() {\n    quat.calculateW(this, this);\n    return this.check();\n  }\n\n  // Calculates the conjugate of a quat If the quaternion is normalized,\n  // this function is faster than quat.inverse and produces the same result.\n  conjugate() {\n    quat.conjugate(this, this);\n    return this.check();\n  }\n\n  // Calculates the inverse of a quat\n  invert() {\n    quat.invert(this, this);\n    return this.check();\n  }\n\n  // Performs a linear interpolation between two quat's\n  lerp(a, b, t) {\n    quat.lerp(this, a, b, t);\n    return this.check();\n  }\n\n  // Multiplies two quat's\n  multiplyRight(a, b) {\n    assert(!b); // Quaternion.multiply only takes one argument\n    quat.multiply(this, this, a);\n    return this.check();\n  }\n\n  multiplyLeft(a, b) {\n    assert(!b); // Quaternion.multiply only takes one argument\n    quat.multiply(this, a, this);\n    return this.check();\n  }\n\n  // Normalize a quat\n  normalize() {\n    // Handle 0 case\n    const length = this.len();\n    const l = length > 0 ? 1 / length : 0;\n    this[0] = this[0] * l;\n    this[1] = this[1] * l;\n    this[2] = this[2] * l;\n    this[3] = this[3] * l;\n    // Set to [0, 0, 0, 1] if length is 0\n    if (length === 0) {\n      this[3] = 1;\n    }\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the X axis\n  rotateX(rad) {\n    quat.rotateX(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Y axis\n  rotateY(rad) {\n    quat.rotateY(this, this, rad);\n    return this.check();\n  }\n\n  // Rotates a quaternion by the given angle about the Z axis\n  rotateZ(rad) {\n    quat.rotateZ(this, this, rad);\n    return this.check();\n  }\n\n  // Scales a quat by a scalar number\n  scale(b) {\n    quat.scale(this, this, b);\n    return this.check();\n  }\n\n  // Performs a spherical linear interpolation between two quat\n  slerp(start, target, ratio) {\n    // eslint-disable-next-line prefer-rest-params\n    switch (arguments.length) {\n      case 1: // Deprecated signature ({start, target, ratio})\n        // eslint-disable-next-line prefer-rest-params\n        ({start = IDENTITY_QUATERNION, target, ratio} = arguments[0]);\n        break;\n      case 2: // THREE.js compatibility signature (target, ration)\n        // eslint-disable-next-line prefer-rest-params\n        [target, ratio] = arguments;\n        start = this; // eslint-disable-line\n        break;\n      default: // Default signature: (start, target, ratio)\n    }\n    quat.slerp(this, start, target, ratio);\n    return this.check();\n  }\n\n  transformVector4(vector, result = vector) {\n    vec4.transformQuat(result, vector, this);\n    return checkVector(result, 4);\n  }\n\n  // THREE.js Math API compatibility\n  lengthSq() {\n    return this.lengthSquared();\n  }\n\n  setFromAxisAngle(axis, rad) {\n    return this.setAxisAngle(axis, rad);\n  }\n\n  premultiply(a, b) {\n    return this.multiplyLeft(a, b);\n  }\n\n  multiply(a, b) {\n    return this.multiplyRight(a, b);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}