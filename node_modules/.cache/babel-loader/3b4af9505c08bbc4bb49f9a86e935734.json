{"ast":null,"code":"import _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { isWebGL } from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport { Program, VertexArray, clear as _clear, TransformFeedback, Buffer, log, isObjectEmpty, uid, assert } from '@luma.gl/webgl';\nimport { getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration } from '@luma.gl/webgl';\nimport { getBuffersFromGeometry } from './model-utils';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000;\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nvar NOOP = function NOOP() {};\n\nvar DRAW_PARAMS = {};\n\nvar Model = /*#__PURE__*/function () {\n  function Model(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? uid('model') : _props$id;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0;\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize(props) {\n      this.props = {};\n      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n      this._programManagerState = -1;\n      this._managedProgram = false;\n      var _props$program = props.program,\n          program = _props$program === void 0 ? null : _props$program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this.program = null;\n      this.vertexArray = null;\n      this._programDirty = true;\n      this.userData = {};\n      this.needsRedraw = true;\n      this._attributes = {};\n      this.attributes = {};\n      this.uniforms = {};\n      this.pickable = true;\n\n      this._checkProgram();\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));\n      this.drawMode = props.drawMode !== undefined ? props.drawMode : 4;\n      this.vertexCount = props.vertexCount || 0;\n      this.geometryBuffers = {};\n      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n      this._setModelProps(props);\n\n      this.geometry = {};\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this._setModelProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key].delete();\n        }\n      }\n\n      if (this._managedProgram) {\n        this.programManager.release(this.program);\n        this._managedProgram = false;\n      }\n\n      this.vertexArray.delete();\n\n      this._deleteGeometryBuffers();\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(props) {\n      var program = props.program,\n          vs = props.vs,\n          fs = props.fs,\n          modules = props.modules,\n          defines = props.defines,\n          inject = props.inject,\n          varyings = props.varyings,\n          bufferMode = props.bufferMode,\n          transpileToGLSL100 = props.transpileToGLSL100;\n      this.programProps = {\n        program: program,\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        inject: inject,\n        varyings: varyings,\n        bufferMode: bufferMode,\n        transpileToGLSL100: transpileToGLSL100\n      };\n      this._programDirty = true;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.uniforms;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = drawMode;\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.drawMode = geometry.drawMode;\n      this.vertexCount = geometry.getVertexCount();\n\n      this._deleteGeometryBuffers();\n\n      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n      this.vertexArray.setAttributes(this.geometryBuffers);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      var normalizedAttributes = {};\n\n      for (var name in attributes) {\n        var attribute = attributes[name];\n        normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n      }\n\n      this.vertexArray.setAttributes(normalizedAttributes);\n      return this;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.uniforms, uniforms);\n      return this;\n    }\n  }, {\n    key: \"getModuleUniforms\",\n    value: function getModuleUniforms(opts) {\n      this._checkProgram();\n\n      var getUniforms = this.programManager.getUniforms(this.program);\n\n      if (getUniforms) {\n        return getUniforms(opts);\n      }\n\n      return {};\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n\n      return this;\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._checkProgram();\n\n      var _opts$moduleSettings = opts.moduleSettings,\n          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n          framebuffer = opts.framebuffer,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n          _opts$attributes = opts.attributes,\n          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n          _opts$transformFeedba = opts.transformFeedback,\n          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n          _opts$vertexArray = opts.vertexArray,\n          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray;\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms);\n      var logPriority;\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n      }\n\n      var drawParams = this.vertexArray.getDrawParams();\n      var _this$props = this.props,\n          _this$props$isIndexed = _this$props.isIndexed,\n          isIndexed = _this$props$isIndexed === void 0 ? drawParams.isIndexed : _this$props$isIndexed,\n          _this$props$indexType = _this$props.indexType,\n          indexType = _this$props$indexType === void 0 ? drawParams.indexType : _this$props$indexType,\n          _this$props$indexOffs = _this$props.indexOffset,\n          indexOffset = _this$props$indexOffs === void 0 ? drawParams.indexOffset : _this$props$indexOffs,\n          _this$props$vertexArr = _this$props.vertexArrayInstanced,\n          vertexArrayInstanced = _this$props$vertexArr === void 0 ? drawParams.isInstanced : _this$props$vertexArr;\n\n      if (vertexArrayInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n      var _this$props2 = this.props,\n          _this$props2$onBefore = _this$props2.onBeforeRender,\n          onBeforeRender = _this$props2$onBefore === void 0 ? NOOP : _this$props2$onBefore,\n          _this$props2$onAfterR = _this$props2.onAfterRender,\n          onAfterRender = _this$props2$onAfterR === void 0 ? NOOP : _this$props2$onAfterR;\n      onBeforeRender();\n      this.program.setUniforms(this.uniforms);\n      var didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      }));\n      onAfterRender();\n\n      if (log.priority >= LOG_DRAW_PRIORITY) {\n        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n      }\n\n      return didDraw;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n          discard = _opts$discard === void 0 ? true : _opts$discard,\n          feedbackBuffers = opts.feedbackBuffers,\n          _opts$unbindModels = opts.unbindModels,\n          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n      return this.setUniforms(uniforms).draw();\n    }\n  }, {\n    key: \"_setModelProps\",\n    value: function _setModelProps(props) {\n      Object.assign(this.props, props);\n\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms);\n      }\n\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      }\n\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      }\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n    }\n  }, {\n    key: \"_checkProgram\",\n    value: function _checkProgram() {\n      var needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n      if (!needsUpdate) {\n        return;\n      }\n\n      var program = this.programProps.program;\n\n      if (program) {\n        this._managedProgram = false;\n      } else {\n        var _this$programProps = this.programProps,\n            vs = _this$programProps.vs,\n            fs = _this$programProps.fs,\n            modules = _this$programProps.modules,\n            inject = _this$programProps.inject,\n            defines = _this$programProps.defines,\n            varyings = _this$programProps.varyings,\n            bufferMode = _this$programProps.bufferMode,\n            transpileToGLSL100 = _this$programProps.transpileToGLSL100;\n        program = this.programManager.get({\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          varyings: varyings,\n          bufferMode: bufferMode,\n          transpileToGLSL100: transpileToGLSL100\n        });\n\n        if (this.program && this._managedProgram) {\n          this.programManager.release(this.program);\n        }\n\n        this._programManagerState = this.programManager.stateHash;\n        this._managedProgram = true;\n      }\n\n      assert(program instanceof Program, 'Model needs a program');\n      this._programDirty = false;\n\n      if (program === this.program) {\n        return;\n      }\n\n      this.program = program;\n\n      if (this.vertexArray) {\n        this.vertexArray.setProps({\n          program: this.program,\n          attributes: this.vertexArray.attributes\n        });\n      } else {\n        this.vertexArray = new VertexArray(this.gl, {\n          program: this.program\n        });\n      }\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms()));\n    }\n  }, {\n    key: \"_deleteGeometryBuffers\",\n    value: function _deleteGeometryBuffers() {\n      for (var name in this.geometryBuffers) {\n        var buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n\n        if (buffer instanceof Buffer) {\n          buffer.delete();\n        }\n      }\n    }\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      }\n    }\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      return this;\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(logLevel) {\n      var logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n      if (Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.level <= 2\n      })();\n      return logLevel;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n      if (logLevel === undefined) {\n        return;\n      }\n\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms)\n      }),\n          uniformTable = _getDebugTableForUnif.table,\n          unusedTable = _getDebugTableForUnif.unusedTable,\n          unusedCount = _getDebugTableForUnif.unusedCount;\n\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms),\n        undefinedOnly: true\n      }),\n          missingTable = _getDebugTableForUnif2.table,\n          missingCount = _getDebugTableForUnif2.count;\n\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      }\n\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      }\n\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(logLevel, attributeTable)();\n      log.table(logLevel, uniformTable)();\n      log.table(logLevel + 1, configTable)();\n\n      if (framebuffer) {\n        framebuffer.log({\n          logLevel: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id))();\n    }\n  }]);\n\n  return Model;\n}();\n\nexport { Model as default };","map":{"version":3,"mappings":"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","names":["isWebGL","ProgramManager","Program","VertexArray","clear","TransformFeedback","Buffer","log","isObjectEmpty","uid","assert","getDebugTableForUniforms","getDebugTableForVertexArray","getDebugTableForProgramConfiguration","getBuffersFromGeometry","LOG_DRAW_PRIORITY","LOG_DRAW_TIMEOUT","ERR_MODEL_PARAMS","NOOP","DRAW_PARAMS","Model","constructor","gl","props","id","lastLogTime","animated","initialize","programManager","getDefaultProgramManager","_programManagerState","_managedProgram","program","vs","fs","modules","defines","inject","varyings","bufferMode","transpileToGLSL100","programProps","vertexArray","_programDirty","userData","needsRedraw","_attributes","attributes","uniforms","pickable","_checkProgram","setUniforms","Object","assign","getModuleUniforms","moduleSettings","drawMode","undefined","vertexCount","geometryBuffers","isInstanced","instanced","instanceCount","_setModelProps","geometry","Number","isFinite","setProps","delete","key","release","_deleteGeometryBuffers","getDrawMode","getVertexCount","getInstanceCount","getAttributes","getProgram","setProgram","getUniforms","setDrawMode","setVertexCount","setInstanceCount","setGeometry","setAttributes","normalizedAttributes","name","attribute","getValue","opts","updateModuleSettings","draw","framebuffer","transformFeedback","parameters","logPriority","priority","_logDrawCallStart","drawParams","getDrawParams","isIndexed","indexType","indexOffset","vertexArrayInstanced","warn","onBeforeRender","onAfterRender","didDraw","offset","_logDrawCallEnd","transform","discard","feedbackBuffers","unbindModels","_setFeedbackBuffers","forEach","model","unbindBuffers","bindBuffers","render","_feedbackBuffers","needsUpdate","stateHash","get","buffer","_setAnimationProps","animationProps","setBuffers","logLevel","logDrawTimeout","Date","now","group","collapsed","level","attributeTable","header","uniformTable","table","unusedTable","unusedCount","undefinedOnly","missingTable","missingCount","count","keys","configTable","configuration","message","groupEnd"],"sources":["../../../src/lib/model.js"],"sourcesContent":["/* eslint-disable complexity */\n\nimport GL from '@luma.gl/constants';\nimport {isWebGL} from '@luma.gl/gltools';\nimport ProgramManager from './program-manager';\nimport {\n  Program,\n  VertexArray,\n  clear,\n  TransformFeedback,\n  Buffer,\n  log,\n  isObjectEmpty,\n  uid,\n  assert\n} from '@luma.gl/webgl';\nimport {\n  getDebugTableForUniforms,\n  getDebugTableForVertexArray,\n  getDebugTableForProgramConfiguration\n} from '@luma.gl/webgl';\nimport {getBuffersFromGeometry} from './model-utils';\n\nconst LOG_DRAW_PRIORITY = 2;\nconst LOG_DRAW_TIMEOUT = 10000;\n\nconst ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\n\nconst NOOP = () => {};\nconst DRAW_PARAMS = {};\n\nexport default class Model {\n  constructor(gl, props = {}) {\n    // Deduce a helpful id\n    const {id = uid('model')} = props;\n    assert(isWebGL(gl));\n    this.id = id;\n    this.gl = gl;\n    this.id = props.id || uid('Model');\n    this.lastLogTime = 0; // TODO - move to probe.gl\n    this.animated = false;\n    this.initialize(props);\n  }\n\n  initialize(props) {\n    this.props = {};\n\n    this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);\n    this._programManagerState = -1;\n    this._managedProgram = false;\n\n    const {\n      program = null,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this.program = null;\n    this.vertexArray = null;\n    this._programDirty = true;\n\n    // Initialize state\n    this.userData = {};\n    this.needsRedraw = true;\n\n    // Attributes and buffers\n    // Model manages auto Buffer creation from typed arrays\n    this._attributes = {}; // All attributes\n    this.attributes = {}; // User defined attributes\n\n    // Model manages uniform animation\n    this.uniforms = {};\n\n    // picking options\n    this.pickable = true;\n\n    this._checkProgram();\n\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )\n    );\n\n    this.drawMode = props.drawMode !== undefined ? props.drawMode : GL.TRIANGLES;\n    this.vertexCount = props.vertexCount || 0;\n\n    // Track buffers created by setGeometry\n    this.geometryBuffers = {};\n\n    // geometry might have set drawMode and vertexCount\n    this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;\n\n    this._setModelProps(props);\n\n    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated\n    this.geometry = {};\n\n    // assert(program || program instanceof Program);\n    assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n  }\n\n  setProps(props) {\n    this._setModelProps(props);\n  }\n\n  delete() {\n    // delete all attributes created by this model\n    // TODO - should buffer deletes be handled by vertex array?\n    for (const key in this._attributes) {\n      if (this._attributes[key] !== this.attributes[key]) {\n        this._attributes[key].delete();\n      }\n    }\n\n    if (this._managedProgram) {\n      this.programManager.release(this.program);\n      this._managedProgram = false;\n    }\n\n    this.vertexArray.delete();\n\n    this._deleteGeometryBuffers();\n  }\n\n  // GETTERS\n\n  getDrawMode() {\n    return this.drawMode;\n  }\n\n  getVertexCount() {\n    return this.vertexCount;\n  }\n\n  getInstanceCount() {\n    return this.instanceCount;\n  }\n\n  getAttributes() {\n    return this.attributes;\n  }\n\n  getProgram() {\n    return this.program;\n  }\n\n  setProgram(props) {\n    const {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    } = props;\n    this.programProps = {\n      program,\n      vs,\n      fs,\n      modules,\n      defines,\n      inject,\n      varyings,\n      bufferMode,\n      transpileToGLSL100\n    };\n    this._programDirty = true;\n  }\n\n  getUniforms() {\n    return this.uniforms;\n  }\n\n  // SETTERS\n\n  setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n    return this;\n  }\n\n  setVertexCount(vertexCount) {\n    assert(Number.isFinite(vertexCount));\n    this.vertexCount = vertexCount;\n    return this;\n  }\n\n  setInstanceCount(instanceCount) {\n    assert(Number.isFinite(instanceCount));\n    this.instanceCount = instanceCount;\n    return this;\n  }\n\n  setGeometry(geometry) {\n    this.drawMode = geometry.drawMode;\n    this.vertexCount = geometry.getVertexCount();\n\n    this._deleteGeometryBuffers();\n\n    this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);\n    this.vertexArray.setAttributes(this.geometryBuffers);\n    return this;\n  }\n\n  setAttributes(attributes = {}) {\n    // Avoid setting needsRedraw if no attributes\n    if (isObjectEmpty(attributes)) {\n      return this;\n    }\n\n    const normalizedAttributes = {};\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      // The `getValue` call provides support for deck.gl `Attribute` class\n      // TODO - remove once deck refactoring completes\n      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;\n    }\n\n    this.vertexArray.setAttributes(normalizedAttributes);\n    return this;\n  }\n\n  // TODO - should actually set the uniforms\n  setUniforms(uniforms = {}) {\n    Object.assign(this.uniforms, uniforms);\n\n    return this;\n  }\n\n  getModuleUniforms(opts) {\n    this._checkProgram();\n\n    const getUniforms = this.programManager.getUniforms(this.program);\n\n    if (getUniforms) {\n      return getUniforms(opts);\n    }\n\n    return {};\n  }\n\n  updateModuleSettings(opts) {\n    const uniforms = this.getModuleUniforms(opts || {});\n    return this.setUniforms(uniforms);\n  }\n\n  // DRAW CALLS\n\n  clear(opts) {\n    clear(this.program.gl, opts);\n    return this;\n  }\n\n  draw(opts = {}) {\n    // Lazy update program and vertex array\n    this._checkProgram();\n\n    const {\n      moduleSettings = null,\n      framebuffer,\n      uniforms = {},\n      attributes = {},\n      transformFeedback = this.transformFeedback,\n      parameters = {},\n      vertexArray = this.vertexArray\n    } = opts;\n\n    // Update model with any just provided attributes, settings or uniforms\n    this.setAttributes(attributes);\n    this.updateModuleSettings(moduleSettings);\n    this.setUniforms(uniforms);\n\n    let logPriority;\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);\n    }\n\n    const drawParams = this.vertexArray.getDrawParams();\n    const {\n      isIndexed = drawParams.isIndexed,\n      indexType = drawParams.indexType,\n      indexOffset = drawParams.indexOffset,\n      vertexArrayInstanced = drawParams.isInstanced\n    } = this.props;\n\n    if (vertexArrayInstanced && !this.isInstanced) {\n      log.warn('Found instanced attributes on non-instanced model', this.id)();\n    }\n\n    const {isInstanced, instanceCount} = this;\n\n    const {onBeforeRender = NOOP, onAfterRender = NOOP} = this.props;\n\n    onBeforeRender();\n\n    this.program.setUniforms(this.uniforms);\n\n    const didDraw = this.program.draw(\n      Object.assign(DRAW_PARAMS, opts, {\n        logPriority,\n        uniforms: null, // Already set (may contain \"function values\" not understood by Program)\n        framebuffer,\n        parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray,\n        transformFeedback,\n        isIndexed,\n        indexType,\n        isInstanced,\n        instanceCount,\n        offset: isIndexed ? indexOffset : 0\n      })\n    );\n\n    onAfterRender();\n\n    if (log.priority >= LOG_DRAW_PRIORITY) {\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n    }\n\n    return didDraw;\n  }\n\n  // Draw call for transform feedback\n  transform(opts = {}) {\n    const {discard = true, feedbackBuffers, unbindModels = []} = opts;\n\n    let {parameters} = opts;\n\n    if (feedbackBuffers) {\n      this._setFeedbackBuffers(feedbackBuffers);\n    }\n\n    if (discard) {\n      parameters = Object.assign({}, parameters, {[GL.RASTERIZER_DISCARD]: discard});\n    }\n\n    unbindModels.forEach(model => model.vertexArray.unbindBuffers());\n    try {\n      this.draw(Object.assign({}, opts, {parameters}));\n    } finally {\n      unbindModels.forEach(model => model.vertexArray.bindBuffers());\n    }\n\n    return this;\n  }\n\n  // DEPRECATED METHODS\n\n  render(uniforms = {}) {\n    log.warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();\n    return this.setUniforms(uniforms).draw();\n  }\n\n  // PRIVATE METHODS\n\n  _setModelProps(props) {\n    Object.assign(this.props, props);\n\n    if ('uniforms' in props) {\n      this.setUniforms(props.uniforms);\n    }\n\n    if ('pickable' in props) {\n      this.pickable = props.pickable;\n    }\n\n    if ('instanceCount' in props) {\n      this.instanceCount = props.instanceCount;\n    }\n    if ('geometry' in props) {\n      this.setGeometry(props.geometry);\n    }\n\n    // webgl settings\n    if ('attributes' in props) {\n      this.setAttributes(props.attributes);\n    }\n    if ('_feedbackBuffers' in props) {\n      this._setFeedbackBuffers(props._feedbackBuffers);\n    }\n  }\n\n  _checkProgram() {\n    const needsUpdate =\n      this._programDirty || this.programManager.stateHash !== this._programManagerState;\n\n    if (!needsUpdate) {\n      return;\n    }\n\n    let {program} = this.programProps;\n\n    if (program) {\n      this._managedProgram = false;\n    } else {\n      const {\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      } = this.programProps;\n      program = this.programManager.get({\n        vs,\n        fs,\n        modules,\n        inject,\n        defines,\n        varyings,\n        bufferMode,\n        transpileToGLSL100\n      });\n      if (this.program && this._managedProgram) {\n        this.programManager.release(this.program);\n      }\n      this._programManagerState = this.programManager.stateHash;\n      this._managedProgram = true;\n    }\n\n    assert(program instanceof Program, 'Model needs a program');\n\n    this._programDirty = false;\n\n    if (program === this.program) {\n      return;\n    }\n\n    this.program = program;\n\n    if (this.vertexArray) {\n      // @ts-ignore TODO\n      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});\n    } else {\n      this.vertexArray = new VertexArray(this.gl, {program: this.program});\n    }\n\n    // Make sure we have some reasonable default uniforms in place\n    this.setUniforms(\n      Object.assign(\n        {},\n        this.getModuleUniforms() // Get all default uniforms,\n      )\n    );\n  }\n\n  _deleteGeometryBuffers() {\n    for (const name in this.geometryBuffers) {\n      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair\n      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];\n      if (buffer instanceof Buffer) {\n        buffer.delete();\n      }\n    }\n  }\n\n  // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n  // experimental\n  _setAnimationProps(animationProps) {\n    if (this.animated) {\n      assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n      // const animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n      // Object.assign(this.uniforms, animatedUniforms);\n    }\n  }\n\n  // Transform Feedback\n\n  _setFeedbackBuffers(feedbackBuffers = {}) {\n    // Avoid setting needsRedraw if no feedbackBuffers\n    if (isObjectEmpty(feedbackBuffers)) {\n      return this;\n    }\n\n    const {gl} = this.program;\n    this.transformFeedback =\n      this.transformFeedback ||\n      new TransformFeedback(gl, {\n        program: this.program\n      });\n\n    this.transformFeedback.setBuffers(feedbackBuffers);\n    return this;\n  }\n\n  _logDrawCallStart(logLevel) {\n    const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;\n    if (Date.now() - this.lastLogTime < logDrawTimeout) {\n      return undefined;\n    }\n\n    this.lastLogTime = Date.now();\n\n    log.group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: log.level <= 2})();\n\n    return logLevel;\n  }\n\n  _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {\n    // HACK: logLevel === undefined means logDrawCallStart didn't run\n    if (logLevel === undefined) {\n      return;\n    }\n\n    const attributeTable = getDebugTableForVertexArray({\n      vertexArray,\n      header: `${this.id} attributes`,\n      // @ts-ignore\n      attributes: this._attributes\n    });\n\n    const {table: uniformTable, unusedTable, unusedCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms)\n    });\n\n    // log missing uniforms\n    const {table: missingTable, count: missingCount} = getDebugTableForUniforms({\n      header: `${this.id} uniforms`,\n      program: this.program,\n      uniforms: Object.assign({}, this.program.uniforms, uniforms),\n      undefinedOnly: true\n    });\n\n    if (missingCount > 0) {\n      log.log('MISSING UNIFORMS', Object.keys(missingTable))();\n      // log.table(logLevel, missingTable)();\n    }\n    if (unusedCount > 0) {\n      log.log('UNUSED UNIFORMS', Object.keys(unusedTable))();\n      // log.log(logLevel, 'Unused uniforms ', unusedTable)();\n    }\n\n    const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n\n    log.table(logLevel, attributeTable)();\n\n    log.table(logLevel, uniformTable)();\n\n    log.table(logLevel + 1, configTable)();\n\n    if (framebuffer) {\n      framebuffer.log({logLevel: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});\n    }\n\n    log.groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}