{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toDeckColor = toDeckColor;\nexports.recursivelyTraverseNestedArrays = recursivelyTraverseNestedArrays;\nexports.generatePointsParallelToLinePoints = generatePointsParallelToLinePoints;\nexports.distance2d = distance2d;\nexports.mix = mix;\nexports.nearestPointOnProjectedLine = nearestPointOnProjectedLine;\nexports.nearestPointOnLine = nearestPointOnLine;\nexports.getPickedEditHandle = getPickedEditHandle;\nexports.getPickedSnapSourceEditHandle = getPickedSnapSourceEditHandle;\nexports.getNonGuidePicks = getNonGuidePicks;\nexports.getPickedExistingEditHandle = getPickedExistingEditHandle;\nexports.getPickedIntermediateEditHandle = getPickedIntermediateEditHandle;\nexports.getPickedEditHandles = getPickedEditHandles;\nexports.getEditHandlesForGeometry = getEditHandlesForGeometry;\nexports.updateRectanglePosition = updateRectanglePosition;\nexports.mapCoords = mapCoords;\n\nvar _destination = _interopRequireDefault(require(\"@turf/destination\"));\n\nvar _bearing = _interopRequireDefault(require(\"@turf/bearing\"));\n\nvar _pointToLineDistance = _interopRequireDefault(require(\"@turf/point-to-line-distance\"));\n\nvar _meta = require(\"@turf/meta\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _invariant = require(\"@turf/invariant\");\n\nvar _viewportMercatorProject = _interopRequireDefault(require(\"viewport-mercator-project\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction toDeckColor(color) {\n  var defaultColor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [255, 0, 0, 255];\n\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n} //\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\n\n\nfunction recursivelyTraverseNestedArrays(array, prefix, fn) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n\n  for (var i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [].concat(_toConsumableArray(prefix), [i]), fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n\n  return false;\n}\n\nfunction generatePointsParallelToLinePoints(p1, p2, mapCoords) {\n  var lineString = {\n    type: 'LineString',\n    coordinates: [p1, p2]\n  };\n  var pt = (0, _helpers.point)(mapCoords);\n  var ddistance = (0, _pointToLineDistance[\"default\"])(pt, lineString);\n  var lineBearing = (0, _bearing[\"default\"])(p1, p2); // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n\n  var isPointToLeftOfLine = (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]); // Bearing to draw perpendicular to the line string\n\n  var orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270; // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n\n  var p3 = (0, _destination[\"default\"])(p2, ddistance, orthogonalBearing);\n  var p4 = (0, _destination[\"default\"])(p1, ddistance, orthogonalBearing);\n  return [p3.geometry.coordinates, p4.geometry.coordinates];\n}\n\nfunction distance2d(x1, y1, x2, y2) {\n  var dx = x1 - x2;\n  var dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction mix(a, b, ratio) {\n  return b * ratio + a * (1 - ratio);\n}\n\nfunction nearestPointOnProjectedLine(line, inPoint, viewport) {\n  var wmViewport = new _viewportMercatorProject[\"default\"](viewport); // Project the line to viewport, then find the nearest point\n\n  var coordinates = line.geometry.coordinates;\n  var projectedCoords = coordinates.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        x = _ref2[0],\n        y = _ref2[1],\n        _ref2$ = _ref2[2],\n        z = _ref2$ === void 0 ? 0 : _ref2$;\n\n    return wmViewport.project([x, y, z]);\n  }); // @ts-ignore\n\n  var _wmViewport$project = wmViewport.project(inPoint.geometry.coordinates),\n      _wmViewport$project2 = _slicedToArray(_wmViewport$project, 2),\n      x = _wmViewport$project2[0],\n      y = _wmViewport$project2[1]; // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n\n  var minDistance = Infinity;\n  var minPointInfo = {};\n  projectedCoords.forEach(function (_ref3, index) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        x2 = _ref4[0],\n        y2 = _ref4[1];\n\n    if (index === 0) {\n      return;\n    }\n\n    var _projectedCoords = _slicedToArray(projectedCoords[index - 1], 2),\n        x1 = _projectedCoords[0],\n        y1 = _projectedCoords[1]; // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n\n\n    var A = y1 - y2;\n    var B = x2 - x1;\n    var C = x1 * y2 - x2 * y1; // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n\n    var div = A * A + B * B;\n    var distance = Math.abs(A * x + B * y + C) / Math.sqrt(div); // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index: index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div\n      };\n    }\n  }); // @ts-ignore\n\n  var _minPointInfo = minPointInfo,\n      index = _minPointInfo.index,\n      x0 = _minPointInfo.x0,\n      y0 = _minPointInfo.y0;\n\n  var _projectedCoords2 = _slicedToArray(projectedCoords[index - 1], 3),\n      x1 = _projectedCoords2[0],\n      y1 = _projectedCoords2[1],\n      _projectedCoords2$ = _projectedCoords2[2],\n      z1 = _projectedCoords2$ === void 0 ? 0 : _projectedCoords2$;\n\n  var _projectedCoords$inde = _slicedToArray(projectedCoords[index], 3),\n      x2 = _projectedCoords$inde[0],\n      y2 = _projectedCoords$inde[1],\n      _projectedCoords$inde2 = _projectedCoords$inde[2],\n      z2 = _projectedCoords$inde2 === void 0 ? 0 : _projectedCoords$inde2; // calculate what ratio of the line we are on to find the proper z\n\n\n  var lineLength = distance2d(x1, y1, x2, y2);\n  var startToPointLength = distance2d(x1, y1, x0, y0);\n  var ratio = startToPointLength / lineLength;\n  var z0 = mix(z1, z2, ratio);\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0])\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1\n    }\n  };\n}\n\nfunction nearestPointOnLine(lines, inPoint, viewport) {\n  var _lines$geometry, _lines$geometry2;\n\n  var mercator;\n\n  if (viewport) {\n    mercator = new _viewportMercatorProject[\"default\"](viewport);\n  }\n\n  var closestPoint = (0, _helpers.point)([Infinity, Infinity], {\n    dist: Infinity\n  });\n\n  if (!((_lines$geometry = lines.geometry) === null || _lines$geometry === void 0 ? void 0 : _lines$geometry.coordinates.length) || ((_lines$geometry2 = lines.geometry) === null || _lines$geometry2 === void 0 ? void 0 : _lines$geometry2.coordinates.length) < 2) {\n    return closestPoint;\n  } // @ts-ignore\n\n\n  (0, _meta.flattenEach)(lines, function (line) {\n    var coords = (0, _invariant.getCoords)(line); // @ts-ignore\n\n    var pointCoords = (0, _invariant.getCoords)(inPoint);\n    var minDist;\n    var to;\n    var from;\n    var x;\n    var y;\n    var segmentIdx;\n    var dist;\n\n    if (coords.length > 1 && pointCoords.length) {\n      var lineCoordinates;\n      var pointCoordinate; // If viewport is given, then translate these coordinates to pixels to increase precision\n\n      if (mercator) {\n        lineCoordinates = coords.map(function (lineCoordinate) {\n          return mercator.project(lineCoordinate);\n        });\n        pointCoordinate = mercator.project(pointCoords);\n      } else {\n        lineCoordinates = coords;\n        pointCoordinate = pointCoords;\n      }\n\n      for (var n = 1; n < lineCoordinates.length; n++) {\n        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {\n          var slope = (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) / (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);\n          var inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];\n          dist = Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) / Math.sqrt(slope * slope + 1);\n        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]); // length^2 of line segment\n\n\n        var rl2 = Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) + Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2); // distance^2 of pt to end line segment\n\n        var ln2 = Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2); // distance^2 of pt to begin line segment\n\n        var lnm12 = Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) + Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2); // minimum distance^2 of pt to infinite line\n\n        var dist2 = Math.pow(dist, 2); // calculated length^2 of line segment\n\n        var calcrl2 = ln2 - dist2 + lnm12 - dist2; // redefine minimum distance to line segment (not infinite line) if necessary\n\n        if (calcrl2 > rl2) {\n          dist = Math.sqrt(Math.min(ln2, lnm12));\n        }\n\n        if (minDist === null || minDist === undefined || minDist > dist) {\n          // eslint-disable-next-line max-depth\n          if (calcrl2 > rl2) {\n            // eslint-disable-next-line max-depth\n            if (lnm12 < ln2) {\n              to = 0; // nearer to previous point\n\n              from = 1;\n            } else {\n              from = 0; // nearer to current point\n\n              to = 1;\n            }\n          } else {\n            // perpendicular from point intersects line segment\n            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);\n            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);\n          }\n\n          minDist = dist;\n          segmentIdx = n;\n        }\n      }\n\n      var dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];\n      var dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];\n      x = lineCoordinates[segmentIdx - 1][0] - dx * to;\n      y = lineCoordinates[segmentIdx - 1][1] - dy * to;\n    } // index needs to be -1 because we have to account for the shift from initial backscan\n\n\n    var snapPoint = {\n      x: x,\n      y: y,\n      idx: segmentIdx - 1,\n      to: to,\n      from: from\n    };\n\n    if (mercator) {\n      var pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);\n      snapPoint = {\n        x: pixelToLatLong[0],\n        y: pixelToLatLong[1],\n        idx: segmentIdx - 1,\n        to: to,\n        from: from\n      };\n    }\n\n    closestPoint = (0, _helpers.point)([snapPoint.x, snapPoint.y], {\n      dist: Math.abs(snapPoint.from - snapPoint.to),\n      index: snapPoint.idx\n    });\n  });\n  return closestPoint;\n}\n\nfunction getPickedEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nfunction getPickedSnapSourceEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (handle) {\n    return handle.properties.editHandleType === 'snap-source';\n  });\n}\n\nfunction getNonGuidePicks(picks) {\n  return picks && picks.filter(function (pick) {\n    return !pick.isGuide;\n  });\n}\n\nfunction getPickedExistingEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref5) {\n    var properties = _ref5.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'existing';\n  });\n}\n\nfunction getPickedIntermediateEditHandle(picks) {\n  var handles = getPickedEditHandles(picks);\n  return handles.find(function (_ref6) {\n    var properties = _ref6.properties;\n    return properties.featureIndex >= 0 && properties.editHandleType === 'intermediate';\n  });\n}\n\nfunction getPickedEditHandles(picks) {\n  var handles = picks && picks.filter(function (pick) {\n    return pick.isGuide && pick.object.properties.guideType === 'editHandle';\n  }).map(function (pick) {\n    return pick.object;\n  }) || [];\n  return handles;\n}\n\nfunction getEditHandlesForGeometry(geometry, featureIndex) {\n  var editHandleType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'existing';\n  var handles = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [{\n        type: 'Feature',\n        properties: {\n          guideType: 'editHandle',\n          editHandleType: editHandleType,\n          positionIndexes: [],\n          featureIndex: featureIndex\n        },\n        geometry: {\n          type: 'Point',\n          coordinates: geometry.coordinates\n        }\n      }];\n      break;\n\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType));\n      break;\n\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (var a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType));\n\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (var _a = 0; _a < geometry.coordinates.length; _a++) {\n        for (var b = 0; b < geometry.coordinates[_a].length; b++) {\n          handles = handles.concat(getEditHandlesForCoordinates(geometry.coordinates[_a][b], [_a, b], featureIndex, editHandleType)); // Don't repeat the first/last handle for Polygons\n\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n\n    default:\n      // @ts-ignore\n      throw Error(\"Unhandled geometry type: \".concat(geometry.type));\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(coordinates, positionIndexPrefix, featureIndex) {\n  var editHandleType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'existing';\n  var editHandles = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var position = coordinates[i];\n    editHandles.push({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        positionIndexes: [].concat(_toConsumableArray(positionIndexPrefix), [i]),\n        featureIndex: featureIndex,\n        editHandleType: editHandleType\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: position\n      }\n    });\n  }\n\n  return editHandles;\n}\n/**\n * Calculates coordinates for a feature preserving rectangular shape.\n * @param feature Feature before modification.\n * @param editHandleIndex Index of the point to modify.\n * @param mapCoords New position for the point.\n * @returns Updated coordinates.\n */\n\n\nfunction updateRectanglePosition(feature, editHandleIndex, mapCoords) {\n  var coordinates = feature.geometry.coordinates;\n\n  if (!coordinates) {\n    return null;\n  }\n\n  var points = coordinates[0].slice(0, 4);\n  points[editHandleIndex % 4] = mapCoords;\n  var p0 = points[(editHandleIndex + 2) % 4];\n  var p2 = points[editHandleIndex % 4];\n  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];\n  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];\n  return [[].concat(_toConsumableArray(points), [points[0]])];\n}\n/** Creates a copy of feature's coordinates.\n * Each position in coordinates is transformed by calling the provided function.\n * @param coords Coordinates of a feature.\n * @param callback A function to transform each coordinate.\n * @retuns Transformed coordinates.\n */\n\n\nfunction mapCoords(coords, callback) {\n  if (typeof coords[0] === 'number') {\n    if (!isNaN(coords[0]) && isFinite(coords[0])) {\n      return callback(coords);\n    }\n\n    return coords;\n  }\n\n  return coords.map(function (coord) {\n    return mapCoords(coord, callback);\n  }).filter(Boolean);\n}","map":{"version":3,"mappings":"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","names":["toDeckColor","color","defaultColor","Array","isArray","recursivelyTraverseNestedArrays","array","prefix","fn","i","length","generatePointsParallelToLinePoints","p1","p2","mapCoords","lineString","type","coordinates","pt","ddistance","lineBearing","isPointToLeftOfLine","orthogonalBearing","p3","p4","geometry","distance2d","x1","y1","x2","y2","dx","dy","Math","sqrt","mix","a","b","ratio","nearestPointOnProjectedLine","line","inPoint","viewport","wmViewport","WebMercatorViewport","projectedCoords","map","x","y","z","project","minDistance","Infinity","minPointInfo","forEach","index","A","B","C","div","distance","abs","x0","y0","z1","z2","lineLength","startToPointLength","z0","unproject","properties","dist","nearestPointOnLine","lines","mercator","closestPoint","_lines$geometry","coords","pointCoords","minDist","to","from","segmentIdx","lineCoordinates","pointCoordinate","lineCoordinate","n","slope","inverseSlope","rl2","pow","ln2","lnm12","dist2","calcrl2","min","undefined","snapPoint","idx","pixelToLatLong","getPickedEditHandle","picks","handles","getPickedEditHandles","getPickedSnapSourceEditHandle","find","handle","editHandleType","getNonGuidePicks","filter","pick","isGuide","getPickedExistingEditHandle","featureIndex","getPickedIntermediateEditHandle","object","guideType","getEditHandlesForGeometry","positionIndexes","concat","getEditHandlesForCoordinates","slice","Error","positionIndexPrefix","editHandles","position","push","updateRectanglePosition","feature","editHandleIndex","points","p0","callback","isNaN","isFinite","coord","Boolean"],"sources":["../src/utils.ts"],"sourcesContent":["import destination from '@turf/destination';\nimport bearing from '@turf/bearing';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport { flattenEach } from '@turf/meta';\nimport { point, MultiLineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport WebMercatorViewport from 'viewport-mercator-project';\nimport { Viewport, Pick, EditHandleFeature, EditHandleType } from './types';\nimport {\n  Geometry,\n  Position,\n  Point,\n  LineString,\n  Polygon,\n  FeatureOf,\n  FeatureWithProps,\n  AnyCoordinates,\n} from './geojson-types';\n\nexport type NearestPointType = FeatureWithProps<Point, { dist: number; index: number }>;\n\nexport function toDeckColor(\n  color?: [number, number, number, number] | number,\n  defaultColor: [number, number, number, number] = [255, 0, 0, 255]\n): [number, number, number, number] {\n  if (!Array.isArray(color)) {\n    return defaultColor;\n  }\n  return [color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255];\n}\n\n//\n// a GeoJSON helper function that calls the provided function with\n// an argument that is the most deeply-nested array having elements\n// that are arrays of primitives as an argument, e.g.\n//\n// {\n//   \"type\": \"MultiPolygon\",\n//   \"coordinates\": [\n//       [\n//           [[30, 20], [45, 40], [10, 40], [30, 20]]\n//       ],\n//       [\n//           [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//       ]\n//   ]\n// }\n//\n// the function would be called on:\n//\n// [[30, 20], [45, 40], [10, 40], [30, 20]]\n//\n// and\n//\n// [[15, 5], [40, 10], [10, 20], [5, 10], [15, 5]]\n//\nexport function recursivelyTraverseNestedArrays(\n  array: Array<any>,\n  prefix: Array<number>,\n  fn: Function\n) {\n  if (!Array.isArray(array[0])) {\n    return true;\n  }\n  for (let i = 0; i < array.length; i++) {\n    if (recursivelyTraverseNestedArrays(array[i], [...prefix, i], fn)) {\n      fn(array, prefix);\n      break;\n    }\n  }\n  return false;\n}\n\nexport function generatePointsParallelToLinePoints(\n  p1: Position,\n  p2: Position,\n  mapCoords: Position\n): Position[] {\n  const lineString: LineString = {\n    type: 'LineString',\n    coordinates: [p1, p2],\n  };\n  const pt = point(mapCoords);\n  const ddistance = pointToLineDistance(pt, lineString);\n  const lineBearing = bearing(p1, p2);\n\n  // Check if current point is to the left or right of line\n  // Line from A=(x1,y1) to B=(x2,y2) a point P=(x,y)\n  // then (x−x1)(y2−y1)−(y−y1)(x2−x1)\n  const isPointToLeftOfLine =\n    (mapCoords[0] - p1[0]) * (p2[1] - p1[1]) - (mapCoords[1] - p1[1]) * (p2[0] - p1[0]);\n\n  // Bearing to draw perpendicular to the line string\n  const orthogonalBearing = isPointToLeftOfLine < 0 ? lineBearing - 90 : lineBearing - 270;\n\n  // Get coordinates for the point p3 and p4 which are perpendicular to the lineString\n  // Add the distance as the current position moves away from the lineString\n  const p3 = destination(p2, ddistance, orthogonalBearing);\n  const p4 = destination(p1, ddistance, orthogonalBearing);\n\n  return [p3.geometry.coordinates, p4.geometry.coordinates] as Position[];\n}\n\nexport function distance2d(x1: number, y1: number, x2: number, y2: number): number {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function mix(a: number, b: number, ratio: number): number {\n  return b * ratio + a * (1 - ratio);\n}\n\nexport function nearestPointOnProjectedLine(\n  line: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport: Viewport\n): NearestPointType {\n  const wmViewport = new WebMercatorViewport(viewport);\n  // Project the line to viewport, then find the nearest point\n  const coordinates: Array<Array<number>> = line.geometry.coordinates as any;\n  const projectedCoords = coordinates.map(([x, y, z = 0]) => wmViewport.project([x, y, z]));\n  // @ts-ignore\n  const [x, y] = wmViewport.project(inPoint.geometry.coordinates);\n  // console.log('projectedCoords', JSON.stringify(projectedCoords));\n\n  let minDistance = Infinity;\n  let minPointInfo = {};\n\n  projectedCoords.forEach(([x2, y2], index) => {\n    if (index === 0) {\n      return;\n    }\n\n    const [x1, y1] = projectedCoords[index - 1];\n\n    // line from projectedCoords[index - 1] to projectedCoords[index]\n    // convert to Ax + By + C = 0\n    const A = y1 - y2;\n    const B = x2 - x1;\n    const C = x1 * y2 - x2 * y1;\n\n    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    const div = A * A + B * B;\n    const distance = Math.abs(A * x + B * y + C) / Math.sqrt(div);\n\n    // TODO: Check if inside bounds\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPointInfo = {\n        index,\n        x0: (B * (B * x - A * y) - A * C) / div,\n        y0: (A * (-B * x + A * y) - B * C) / div,\n      };\n    }\n  });\n  // @ts-ignore\n  const { index, x0, y0 } = minPointInfo;\n  const [x1, y1, z1 = 0] = projectedCoords[index - 1];\n  const [x2, y2, z2 = 0] = projectedCoords[index];\n\n  // calculate what ratio of the line we are on to find the proper z\n  const lineLength = distance2d(x1, y1, x2, y2);\n  const startToPointLength = distance2d(x1, y1, x0, y0);\n  const ratio = startToPointLength / lineLength;\n  const z0 = mix(z1, z2, ratio);\n\n  return {\n    type: 'Feature',\n    geometry: {\n      type: 'Point',\n      coordinates: wmViewport.unproject([x0, y0, z0]),\n    },\n    properties: {\n      // TODO: calculate the distance in proper units\n      dist: minDistance,\n      index: index - 1,\n    },\n  };\n}\n\nexport function nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: FeatureOf<LineString>,\n  inPoint: FeatureOf<Point>,\n  viewport?: Viewport\n): NearestPointType {\n  let mercator;\n\n  if (viewport) {\n    mercator = new WebMercatorViewport(viewport);\n  }\n  let closestPoint: any = point([Infinity, Infinity], {\n    dist: Infinity,\n  });\n\n  if (!lines.geometry?.coordinates.length || lines.geometry?.coordinates.length < 2) {\n    return closestPoint;\n  }\n\n  // @ts-ignore\n  flattenEach(lines, (line: any) => {\n    const coords: any = getCoords(line);\n    // @ts-ignore\n    const pointCoords: any = getCoords(inPoint);\n\n    let minDist;\n    let to;\n    let from;\n    let x;\n    let y;\n    let segmentIdx;\n    let dist;\n\n    if (coords.length > 1 && pointCoords.length) {\n      let lineCoordinates;\n      let pointCoordinate;\n\n      // If viewport is given, then translate these coordinates to pixels to increase precision\n      if (mercator) {\n        lineCoordinates = coords.map((lineCoordinate) => mercator.project(lineCoordinate));\n        pointCoordinate = mercator.project(pointCoords);\n      } else {\n        lineCoordinates = coords;\n        pointCoordinate = pointCoords;\n      }\n\n      for (let n = 1; n < lineCoordinates.length; n++) {\n        if (lineCoordinates[n][0] !== lineCoordinates[n - 1][0]) {\n          const slope =\n            (lineCoordinates[n][1] - lineCoordinates[n - 1][1]) /\n            (lineCoordinates[n][0] - lineCoordinates[n - 1][0]);\n          const inverseSlope = lineCoordinates[n][1] - slope * lineCoordinates[n][0];\n\n          dist =\n            Math.abs(slope * pointCoordinate[0] + inverseSlope - pointCoordinate[1]) /\n            Math.sqrt(slope * slope + 1);\n        } else dist = Math.abs(pointCoordinate[0] - lineCoordinates[n][0]);\n\n        // length^2 of line segment\n        const rl2 =\n          Math.pow(lineCoordinates[n][1] - lineCoordinates[n - 1][1], 2) +\n          Math.pow(lineCoordinates[n][0] - lineCoordinates[n - 1][0], 2);\n\n        // distance^2 of pt to end line segment\n        const ln2 =\n          Math.pow(lineCoordinates[n][1] - pointCoordinate[1], 2) +\n          Math.pow(lineCoordinates[n][0] - pointCoordinate[0], 2);\n\n        // distance^2 of pt to begin line segment\n        const lnm12 =\n          Math.pow(lineCoordinates[n - 1][1] - pointCoordinate[1], 2) +\n          Math.pow(lineCoordinates[n - 1][0] - pointCoordinate[0], 2);\n\n        // minimum distance^2 of pt to infinite line\n        const dist2 = Math.pow(dist, 2);\n\n        // calculated length^2 of line segment\n        const calcrl2 = ln2 - dist2 + lnm12 - dist2;\n\n        // redefine minimum distance to line segment (not infinite line) if necessary\n        if (calcrl2 > rl2) {\n          dist = Math.sqrt(Math.min(ln2, lnm12));\n        }\n\n        if (minDist === null || minDist === undefined || minDist > dist) {\n          // eslint-disable-next-line max-depth\n          if (calcrl2 > rl2) {\n            // eslint-disable-next-line max-depth\n            if (lnm12 < ln2) {\n              to = 0; // nearer to previous point\n              from = 1;\n            } else {\n              from = 0; // nearer to current point\n              to = 1;\n            }\n          } else {\n            // perpendicular from point intersects line segment\n            to = Math.sqrt(lnm12 - dist2) / Math.sqrt(rl2);\n            from = Math.sqrt(ln2 - dist2) / Math.sqrt(rl2);\n          }\n          minDist = dist;\n          segmentIdx = n;\n        }\n      }\n\n      const dx = lineCoordinates[segmentIdx - 1][0] - lineCoordinates[segmentIdx][0];\n      const dy = lineCoordinates[segmentIdx - 1][1] - lineCoordinates[segmentIdx][1];\n\n      x = lineCoordinates[segmentIdx - 1][0] - dx * to;\n      y = lineCoordinates[segmentIdx - 1][1] - dy * to;\n    }\n\n    // index needs to be -1 because we have to account for the shift from initial backscan\n    let snapPoint = { x, y, idx: segmentIdx - 1, to, from };\n\n    if (mercator) {\n      const pixelToLatLong = mercator.unproject([snapPoint.x, snapPoint.y]);\n      snapPoint = {\n        x: pixelToLatLong[0],\n        y: pixelToLatLong[1],\n        idx: segmentIdx - 1,\n        to,\n        from,\n      };\n    }\n\n    closestPoint = point([snapPoint.x, snapPoint.y], {\n      dist: Math.abs(snapPoint.from - snapPoint.to),\n      index: snapPoint.idx,\n    });\n  });\n\n  return closestPoint;\n}\n\nexport function getPickedEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.length ? handles[0] : null;\n}\n\nexport function getPickedSnapSourceEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find((handle) => handle.properties.editHandleType === 'snap-source');\n}\n\nexport function getNonGuidePicks(picks: Pick[]): Pick[] {\n  return picks && picks.filter((pick) => !pick.isGuide);\n}\n\nexport function getPickedExistingEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(\n    ({ properties }) => properties.featureIndex >= 0 && properties.editHandleType === 'existing'\n  );\n}\n\nexport function getPickedIntermediateEditHandle(\n  picks: Pick[] | null | undefined\n): EditHandleFeature | null | undefined {\n  const handles = getPickedEditHandles(picks);\n  return handles.find(\n    ({ properties }) => properties.featureIndex >= 0 && properties.editHandleType === 'intermediate'\n  );\n}\n\nexport function getPickedEditHandles(picks: Pick[] | null | undefined): EditHandleFeature[] {\n  const handles =\n    (picks &&\n      picks\n        .filter((pick) => pick.isGuide && pick.object.properties.guideType === 'editHandle')\n        .map((pick) => pick.object)) ||\n    [];\n\n  return handles;\n}\n\nexport function getEditHandlesForGeometry(\n  geometry: Geometry,\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandleFeature[] {\n  let handles: EditHandleFeature[] = [];\n\n  switch (geometry.type) {\n    case 'Point':\n      // positions are not nested\n      handles = [\n        {\n          type: 'Feature',\n          properties: {\n            guideType: 'editHandle',\n            editHandleType,\n            positionIndexes: [],\n            featureIndex,\n          },\n          geometry: {\n            type: 'Point',\n            coordinates: geometry.coordinates,\n          },\n        },\n      ];\n      break;\n    case 'MultiPoint':\n    case 'LineString':\n      // positions are nested 1 level\n      handles = handles.concat(\n        getEditHandlesForCoordinates(geometry.coordinates, [], featureIndex, editHandleType)\n      );\n      break;\n    case 'Polygon':\n    case 'MultiLineString':\n      // positions are nested 2 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        handles = handles.concat(\n          getEditHandlesForCoordinates(geometry.coordinates[a], [a], featureIndex, editHandleType)\n        );\n        if (geometry.type === 'Polygon') {\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n    case 'MultiPolygon':\n      // positions are nested 3 levels\n      for (let a = 0; a < geometry.coordinates.length; a++) {\n        for (let b = 0; b < geometry.coordinates[a].length; b++) {\n          handles = handles.concat(\n            getEditHandlesForCoordinates(\n              geometry.coordinates[a][b],\n              [a, b],\n              featureIndex,\n              editHandleType\n            )\n          );\n          // Don't repeat the first/last handle for Polygons\n          handles = handles.slice(0, -1);\n        }\n      }\n\n      break;\n    default:\n      // @ts-ignore\n      throw Error(`Unhandled geometry type: ${geometry.type}`);\n  }\n\n  return handles;\n}\n\nfunction getEditHandlesForCoordinates(\n  coordinates: any[],\n  positionIndexPrefix: number[],\n  featureIndex: number,\n  editHandleType: EditHandleType = 'existing'\n): EditHandleFeature[] {\n  const editHandles = [];\n  for (let i = 0; i < coordinates.length; i++) {\n    const position = coordinates[i];\n    editHandles.push({\n      type: 'Feature',\n      properties: {\n        guideType: 'editHandle',\n        positionIndexes: [...positionIndexPrefix, i],\n        featureIndex,\n        editHandleType,\n      },\n      geometry: {\n        type: 'Point',\n        coordinates: position,\n      },\n    });\n  }\n  return editHandles;\n}\n\n/**\n * Calculates coordinates for a feature preserving rectangular shape.\n * @param feature Feature before modification.\n * @param editHandleIndex Index of the point to modify.\n * @param mapCoords New position for the point.\n * @returns Updated coordinates.\n */\nexport function updateRectanglePosition(\n  feature: FeatureOf<Polygon>,\n  editHandleIndex: number,\n  mapCoords: Position\n): Position[][] {\n  const coordinates = feature.geometry.coordinates;\n  if (!coordinates) {\n    return null;\n  }\n\n  const points = coordinates[0].slice(0, 4);\n  points[editHandleIndex % 4] = mapCoords;\n\n  const p0 = points[(editHandleIndex + 2) % 4];\n  const p2 = points[editHandleIndex % 4];\n  points[(editHandleIndex + 1) % 4] = [p2[0], p0[1]];\n  points[(editHandleIndex + 3) % 4] = [p0[0], p2[1]];\n\n  return [[...points, points[0]]];\n}\n\n/** Creates a copy of feature's coordinates.\n * Each position in coordinates is transformed by calling the provided function.\n * @param coords Coordinates of a feature.\n * @param callback A function to transform each coordinate.\n * @retuns Transformed coordinates.\n */\nexport function mapCoords(\n  coords: AnyCoordinates,\n  callback: (coords: Position) => Position\n): AnyCoordinates {\n  if (typeof coords[0] === 'number') {\n    if (!isNaN(coords[0]) && isFinite(coords[0])) {\n      return callback(coords as Position);\n    }\n    return coords;\n  }\n\n  return (coords as Position[])\n    .map((coord) => {\n      return mapCoords(coord, callback) as Position;\n    })\n    .filter(Boolean);\n}\n"]},"metadata":{},"sourceType":"script"}