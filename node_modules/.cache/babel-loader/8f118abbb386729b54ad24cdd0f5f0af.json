{"ast":null,"code":"import { LayerExtension } from '@deck.gl/core';\nimport { Texture2D } from '@luma.gl/core';\nimport { patternShaders } from './shaders.glsl';\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: null,\n  fillPatternMapping: null,\n  fillPatternMask: true,\n  getFillPattern: {\n    type: 'accessor',\n    value: d => d.pattern\n  },\n  getFillPatternScale: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillPatternOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [10241]: 9729,\n  [10240]: 9729,\n  [10242]: 33071,\n  [10243]: 33071\n};\nexport default class FillStyleExtension extends LayerExtension {\n  constructor() {\n    let {\n      pattern = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      pattern\n    });\n  }\n\n  isEnabled(layer) {\n    return layer.getAttributeManager() && !layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(_ref, extension) {\n    let {\n      props,\n      oldProps\n    } = _ref;\n\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {\n      extension.loadPatternAtlas.call(this, props);\n    }\n\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      extension.loadPatternMapping.call(this, props);\n    }\n  }\n\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {\n      patternTexture\n    } = this.state;\n    this.setModuleParameters({\n      fillPatternTexture: patternTexture || this.state.emptyTexture\n    });\n  }\n\n  finalizeState() {\n    const {\n      patternTexture,\n      emptyTexture\n    } = this.state;\n    patternTexture === null || patternTexture === void 0 ? void 0 : patternTexture.delete();\n    emptyTexture === null || emptyTexture === void 0 ? void 0 : emptyTexture.delete();\n  }\n\n  async loadPatternAtlas(_ref2) {\n    let {\n      fillPatternAtlas,\n      fetch\n    } = _ref2;\n\n    var _this$state$patternTe;\n\n    (_this$state$patternTe = this.state.patternTexture) === null || _this$state$patternTe === void 0 ? void 0 : _this$state$patternTe.delete();\n    this.setState({\n      patternTexture: null\n    });\n    let image = fillPatternAtlas;\n\n    if (typeof image === 'string') {\n      image = await fetch(image, {\n        propName: 'fillPatternAtlas',\n        layer: this\n      });\n    }\n\n    const patternTexture = image instanceof Texture2D ? image : new Texture2D(this.context.gl, {\n      data: image,\n      parameters: DEFAULT_TEXTURE_PARAMETERS\n    });\n    this.setState({\n      patternTexture\n    });\n  }\n\n  async loadPatternMapping(_ref3) {\n    let {\n      fillPatternMapping,\n      fetch\n    } = _ref3;\n    this.setState({\n      patternMapping: null\n    });\n    let patternMapping = fillPatternMapping;\n\n    if (typeof patternMapping === 'string') {\n      patternMapping = await fetch(patternMapping, {\n        propName: 'fillPatternMapping',\n        layer: this\n      });\n    }\n\n    this.setState({\n      patternMapping\n    });\n    this.getAttributeManager().invalidate('getFillPattern');\n    this.setNeedsUpdate();\n  }\n\n  getPatternFrame(name) {\n    const {\n      patternMapping\n    } = this.state;\n    const def = patternMapping && patternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n\n}\nFillStyleExtension.extensionName = 'FillStyleExtension';\nFillStyleExtension.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["LayerExtension","Texture2D","patternShaders","defaultProps","fillPatternEnabled","fillPatternAtlas","fillPatternMapping","fillPatternMask","getFillPattern","type","value","d","pattern","getFillPatternScale","getFillPatternOffset","DEFAULT_TEXTURE_PARAMETERS","FillStyleExtension","constructor","isEnabled","layer","getAttributeManager","state","pathTesselator","getShaders","extension","modules","opts","filter","Boolean","initializeState","context","attributeManager","add","fillPatternFrames","size","accessor","transform","getPatternFrame","bind","shaderAttributes","divisor","instanceFillPatternFrames","fillPatternScales","defaultValue","instanceFillPatternScales","fillPatternOffsets","instanceFillPatternOffsets","setState","emptyTexture","gl","data","Uint8Array","width","height","updateState","props","oldProps","loadPatternAtlas","call","loadPatternMapping","draw","params","patternTexture","setModuleParameters","fillPatternTexture","finalizeState","delete","fetch","image","propName","parameters","patternMapping","invalidate","setNeedsUpdate","name","def","x","y","extensionName"],"sources":["../../../src/fill-style/fill-style.js"],"sourcesContent":["import {LayerExtension} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {patternShaders} from './shaders.glsl';\n\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: null,\n  fillPatternMapping: null,\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nexport default class FillStyleExtension extends LayerExtension {\n  constructor({pattern = false} = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer) {\n    return layer.getAttributeManager() && !layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({props, oldProps}, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {\n      extension.loadPatternAtlas.call(this, props);\n    }\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      extension.loadPatternMapping.call(this, props);\n    }\n  }\n\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {patternTexture} = this.state;\n    this.setModuleParameters({\n      fillPatternTexture: patternTexture || this.state.emptyTexture\n    });\n  }\n\n  finalizeState() {\n    const {patternTexture, emptyTexture} = this.state;\n    patternTexture?.delete();\n    emptyTexture?.delete();\n  }\n\n  async loadPatternAtlas({fillPatternAtlas, fetch}) {\n    this.state.patternTexture?.delete();\n    this.setState({patternTexture: null});\n    let image = fillPatternAtlas;\n    if (typeof image === 'string') {\n      image = await fetch(image, {propName: 'fillPatternAtlas', layer: this});\n    }\n    const patternTexture =\n      image instanceof Texture2D\n        ? image\n        : new Texture2D(this.context.gl, {\n            data: image,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          });\n    this.setState({patternTexture});\n  }\n\n  async loadPatternMapping({fillPatternMapping, fetch}) {\n    this.setState({patternMapping: null});\n    let patternMapping = fillPatternMapping;\n    if (typeof patternMapping === 'string') {\n      patternMapping = await fetch(patternMapping, {\n        propName: 'fillPatternMapping',\n        layer: this\n      });\n    }\n    this.setState({patternMapping});\n    this.getAttributeManager().invalidate('getFillPattern');\n    this.setNeedsUpdate();\n  }\n\n  getPatternFrame(name) {\n    const {patternMapping} = this.state;\n    const def = patternMapping && patternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n\nFillStyleExtension.extensionName = 'FillStyleExtension';\nFillStyleExtension.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}