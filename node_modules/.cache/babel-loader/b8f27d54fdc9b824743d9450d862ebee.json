{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector3 } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { INTERSECTION } from '../../constants';\nvar scratchVector = new Vector3();\nvar scratchVector2 = new Vector3();\n\nvar BoundingSphere = /*#__PURE__*/function () {\n  function BoundingSphere() {\n    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];\n    var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;\n\n    _classCallCheck(this, BoundingSphere);\n\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  _createClass(BoundingSphere, [{\n    key: \"fromCenterRadius\",\n    value: function fromCenterRadius(center, radius) {\n      this.center.from(center);\n      this.radius = radius;\n      return this;\n    }\n  }, {\n    key: \"fromCornerPoints\",\n    value: function fromCornerPoints(corner, oppositeCorner) {\n      oppositeCorner = scratchVector.from(oppositeCorner);\n      this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n      this.radius = this.center.distance(oppositeCorner);\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(right) {\n      return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new BoundingSphere(this.center, this.radius);\n    }\n  }, {\n    key: \"union\",\n    value: function union(boundingSphere) {\n      var leftCenter = this.center;\n      var leftRadius = this.radius;\n      var rightCenter = boundingSphere.center;\n      var rightRadius = boundingSphere.radius;\n      var toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n      var centerSeparation = toRightCenter.magnitude();\n\n      if (leftRadius >= centerSeparation + rightRadius) {\n        return this.clone();\n      }\n\n      if (rightRadius >= centerSeparation + leftRadius) {\n        return boundingSphere.clone();\n      }\n\n      var halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n      scratchVector2.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);\n      this.center.copy(scratchVector2);\n      this.radius = halfDistanceBetweenTangentPoints;\n      return this;\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(point) {\n      point = scratchVector.from(point);\n      var radius = point.subtract(this.center).magnitude();\n\n      if (radius > this.radius) {\n        this.radius = radius;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(_transform) {\n      this.center.transform(_transform);\n      var scale = mat4.getScaling(scratchVector, _transform);\n      this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n      return this;\n    }\n  }, {\n    key: \"distanceSquaredTo\",\n    value: function distanceSquaredTo(point) {\n      var d = this.distanceTo(point);\n      return d * d;\n    }\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(point) {\n      point = scratchVector.from(point);\n      var delta = point.subtract(this.center);\n      return Math.max(0, delta.len() - this.radius);\n    }\n  }, {\n    key: \"intersectPlane\",\n    value: function intersectPlane(plane) {\n      var center = this.center;\n      var radius = this.radius;\n      var normal = plane.normal;\n      var distanceToPlane = normal.dot(center) + plane.distance;\n\n      if (distanceToPlane < -radius) {\n        return INTERSECTION.OUTSIDE;\n      }\n\n      if (distanceToPlane < radius) {\n        return INTERSECTION.INTERSECTING;\n      }\n\n      return INTERSECTION.INSIDE;\n    }\n  }]);\n\n  return BoundingSphere;\n}();\n\nexport { BoundingSphere as default };","map":{"version":3,"mappings":"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","names":["Vector3","mat4","INTERSECTION","scratchVector","scratchVector2","BoundingSphere","constructor","center","radius","fromCenterRadius","from","fromCornerPoints","corner","oppositeCorner","add","scale","distance","equals","right","Boolean","clone","union","boundingSphere","leftCenter","leftRadius","rightCenter","rightRadius","toRightCenter","copy","subtract","centerSeparation","magnitude","halfDistanceBetweenTangentPoints","expand","point","transform","getScaling","Math","max","distanceSquaredTo","d","distanceTo","delta","len","intersectPlane","plane","normal","distanceToPlane","dot","OUTSIDE","INTERSECTING","INSIDE"],"sources":["../../../../src/lib/bounding-volumes/bounding-sphere.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../../constants';\n\n// import Rectangle from './rectangle';\n\n// const defaultProjection = new GeographicProjection();\n// const fromRectangle2DLowerLeft = new Vector3();\n// const fromRectangle2DUpperRight = new Vector3();\n// const fromRectangle2DSouthwest = new Cartographic();\n// const fromRectangle2DNortheast = new Cartographic();\n\n// const fromRectangle3DScratch = [];\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\nexport default class BoundingSphere {\n  constructor(center = [0, 0, 0], radius = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  fromCenterRadius(center, radius) {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  fromCornerPoints(corner, oppositeCorner) {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  clone() {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  union(boundingSphere) {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  expand(point) {\n    point = scratchVector.from(point);\n    const radius = point.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  transform(transform) {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding sphere to a point.\n  distanceSquaredTo(point) {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  distanceTo(point) {\n    point = scratchVector.from(point);\n    const delta = point.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  // Determines which side of a plane a sphere is located.\n  intersectPlane(plane) {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}