{"ast":null,"code":"const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n\n  }\n};\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n\n  return propTypes;\n}\n\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n\n  if (type === 'object') {\n    if (!propDef) {\n      return {\n        type: 'object',\n        value: null\n      };\n    }\n\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n\n    if (!('value' in propDef)) {\n      return {\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    type = getTypeOf(propDef.value);\n    return Object.assign({\n      type\n    }, propDef, TYPE_DEFINITIONS[type]);\n  }\n\n  return Object.assign({\n    type,\n    value: propDef\n  }, TYPE_DEFINITIONS[type]);\n}\n\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n\n  return typeof value;\n}","map":{"version":3,"mappings":"AAAA,MAAMA,gBAAgB,GAAG;EACvBC,MAAM,EAAE;IACNC,QAAQ,CAACC,KAAD,EAAQC,QAAR,EAAkB;MACxB,OACEC,MAAM,CAACC,QAAPD,CAAgBF,KAAhBE,MACC,EAAE,SAASD,QAAX,KAAwBD,KAAK,IAAIC,QAAQ,CAACG,GAD3CF,MAEC,EAAE,SAASD,QAAX,KAAwBD,KAAK,IAAIC,QAAQ,CAACI,GAF3CH,CADF;IAKD;;EAPK,CADe;EAUvBI,KAAK,EAAE;IACLP,QAAQ,CAACC,KAAD,EAAQC,QAAR,EAAkB;MACxB,OAAOM,KAAK,CAACC,OAAND,CAAcP,KAAdO,KAAwBE,WAAW,CAACC,MAAZD,CAAmBT,KAAnBS,CAA/B;IACD;;EAHI;AAVgB,CAAzB;AAiBA,OAAO,SAASE,cAAT,CAAwBC,QAAxB,EAAkC;EACvC,MAAMC,SAAS,GAAG,EAAlB;;EACA,KAAK,MAAMC,QAAX,IAAuBF,QAAvB,EAAiC;IAC/B,MAAMG,OAAO,GAAGH,QAAQ,CAACE,QAAD,CAAxB;IACA,MAAMb,QAAQ,GAAGe,aAAa,CAACD,OAAD,CAA9B;IACAF,SAAS,CAACC,QAAD,CAATD,GAAsBZ,QAAtBY;EACD;;EACD,OAAOA,SAAP;AACD;;AAKD,SAASG,aAAT,CAAuBD,OAAvB,EAAgC;EAC9B,IAAIE,IAAI,GAAGC,SAAS,CAACH,OAAD,CAApB;;EACA,IAAIE,IAAI,KAAK,QAAb,EAAuB;IACrB,IAAI,CAACF,OAAL,EAAc;MACZ,OAAO;QAACE,IAAI,EAAE,QAAP;QAAiBjB,KAAK,EAAE;MAAxB,CAAP;IACD;;IACD,IAAI,UAAUe,OAAd,EAAuB;MACrB,OAAOI,MAAM,CAACC,MAAPD,CAAc,EAAdA,EAAkBJ,OAAlBI,EAA2BtB,gBAAgB,CAACkB,OAAO,CAACE,IAAT,CAA3CE,CAAP;IACD;;IACD,IAAI,EAAE,WAAWJ,OAAb,CAAJ,EAA2B;MAEzB,OAAO;QAACE,IAAI,EAAE,QAAP;QAAiBjB,KAAK,EAAEe;MAAxB,CAAP;IACD;;IACDE,IAAI,GAAGC,SAAS,CAACH,OAAO,CAACf,KAAT,CAAhBiB;IACA,OAAOE,MAAM,CAACC,MAAPD,CAAc;MAACF;IAAD,CAAdE,EAAsBJ,OAAtBI,EAA+BtB,gBAAgB,CAACoB,IAAD,CAA/CE,CAAP;EACD;;EACD,OAAOA,MAAM,CAACC,MAAPD,CAAc;IAACF,IAAD;IAAOjB,KAAK,EAAEe;EAAd,CAAdI,EAAsCtB,gBAAgB,CAACoB,IAAD,CAAtDE,CAAP;AACD;;AAGD,SAASD,SAAT,CAAmBlB,KAAnB,EAA0B;EACxB,IAAIO,KAAK,CAACC,OAAND,CAAcP,KAAdO,KAAwBE,WAAW,CAACC,MAAZD,CAAmBT,KAAnBS,CAA5B,EAAuD;IACrD,OAAO,OAAP;EACD;;EACD,OAAO,OAAOT,KAAd;AACD","names":["TYPE_DEFINITIONS","number","validate","value","propType","Number","isFinite","max","min","array","Array","isArray","ArrayBuffer","isView","parsePropTypes","propDefs","propTypes","propName","propDef","parsePropType","type","getTypeOf","Object","assign"],"sources":["../../../../src/lib/filters/prop-types.js"],"sourcesContent":["const TYPE_DEFINITIONS = {\n  number: {\n    validate(value, propType) {\n      return (\n        Number.isFinite(value) &&\n        (!('max' in propType) || value <= propType.max) &&\n        (!('min' in propType) || value >= propType.min)\n      );\n    }\n  },\n  array: {\n    validate(value, propType) {\n      return Array.isArray(value) || ArrayBuffer.isView(value);\n    }\n  }\n};\n\nexport function parsePropTypes(propDefs) {\n  const propTypes = {};\n  for (const propName in propDefs) {\n    const propDef = propDefs[propName];\n    const propType = parsePropType(propDef);\n    propTypes[propName] = propType;\n  }\n  return propTypes;\n}\n\n// Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\nfunction parsePropType(propDef) {\n  let type = getTypeOf(propDef);\n  if (type === 'object') {\n    if (!propDef) {\n      return {type: 'object', value: null};\n    }\n    if ('type' in propDef) {\n      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);\n    }\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {type: 'object', value: propDef};\n    }\n    type = getTypeOf(propDef.value);\n    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);\n  }\n  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);\n}\n\n// improved version of javascript typeof that can distinguish arrays and null values\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n  return typeof value;\n}\n"]},"metadata":{},"sourceType":"module"}