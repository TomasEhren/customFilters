{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _asyncIterator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { concatenateArrayBuffers, resolvePath } from '@loaders.gl/loader-utils';\nimport { isBrowser } from '@loaders.gl/loader-utils';\nimport { writeFile } from '../fetch/write-file';\nimport { fetchFile } from '../fetch/fetch-file';\nexport function encode(_x, _x2, _x3) {\n  return _encode.apply(this, arguments);\n}\n\nfunction _encode() {\n  _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data, writer, options) {\n    var batches, chunks, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!writer.encode) {\n              _context.next = 4;\n              break;\n            }\n\n            _context.next = 3;\n            return writer.encode(data, options);\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 4:\n            if (!writer.encodeSync) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", writer.encodeSync(data, options));\n\n          case 6:\n            if (!writer.encodeText) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.t0 = new TextEncoder();\n            _context.next = 10;\n            return writer.encodeText(data, options);\n\n          case 10:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", _context.t0.encode.call(_context.t0, _context.t1));\n\n          case 12:\n            if (!writer.encodeInBatches) {\n              _context.next = 44;\n              break;\n            }\n\n            batches = encodeInBatches(data, writer, options);\n            chunks = [];\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 17;\n            _iterator = _asyncIterator(batches);\n\n          case 19:\n            _context.next = 21;\n            return _iterator.next();\n\n          case 21:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 27;\n              break;\n            }\n\n            batch = _step.value;\n            chunks.push(batch);\n\n          case 24:\n            _iteratorAbruptCompletion = false;\n            _context.next = 19;\n            break;\n\n          case 27:\n            _context.next = 33;\n            break;\n\n          case 29:\n            _context.prev = 29;\n            _context.t2 = _context[\"catch\"](17);\n            _didIteratorError = true;\n            _iteratorError = _context.t2;\n\n          case 33:\n            _context.prev = 33;\n            _context.prev = 34;\n\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 38;\n              break;\n            }\n\n            _context.next = 38;\n            return _iterator.return();\n\n          case 38:\n            _context.prev = 38;\n\n            if (!_didIteratorError) {\n              _context.next = 41;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 41:\n            return _context.finish(38);\n\n          case 42:\n            return _context.finish(33);\n\n          case 43:\n            return _context.abrupt(\"return\", concatenateArrayBuffers.apply(void 0, chunks));\n\n          case 44:\n            if (!(!isBrowser && writer.encodeURLtoURL)) {\n              _context.next = 56;\n              break;\n            }\n\n            tmpInputFilename = getTemporaryFilename('input');\n            _context.next = 48;\n            return writeFile(tmpInputFilename, data);\n\n          case 48:\n            tmpOutputFilename = getTemporaryFilename('output');\n            _context.next = 51;\n            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);\n\n          case 51:\n            outputFilename = _context.sent;\n            _context.next = 54;\n            return fetchFile(outputFilename);\n\n          case 54:\n            response = _context.sent;\n            return _context.abrupt(\"return\", response.arrayBuffer());\n\n          case 56:\n            throw new Error('Writer could not encode data');\n\n          case 57:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[17, 29, 33, 43], [34,, 38, 42]]);\n  }));\n  return _encode.apply(this, arguments);\n}\n\nexport function encodeSync(data, writer, options) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  throw new Error('Writer could not synchronously encode data');\n}\nexport function encodeText(_x4, _x5, _x6) {\n  return _encodeText.apply(this, arguments);\n}\n\nfunction _encodeText() {\n  _encodeText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data, writer, options) {\n    var arrayBuffer;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(writer.text && writer.encodeText)) {\n              _context2.next = 4;\n              break;\n            }\n\n            _context2.next = 3;\n            return writer.encodeText(data, options);\n\n          case 3:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 4:\n            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {\n              _context2.next = 9;\n              break;\n            }\n\n            _context2.next = 7;\n            return encode(data, writer, options);\n\n          case 7:\n            arrayBuffer = _context2.sent;\n            return _context2.abrupt(\"return\", new TextDecoder().decode(arrayBuffer));\n\n          case 9:\n            throw new Error('Writer could not encode data as text');\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encodeText.apply(this, arguments);\n}\n\nexport function encodeInBatches(data, writer, options) {\n  if (writer.encodeInBatches) {\n    var dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n\n  throw new Error('Writer could not encode data in batches');\n}\nexport function encodeURLtoURL(_x7, _x8, _x9, _x10) {\n  return _encodeURLtoURL.apply(this, arguments);\n}\n\nfunction _encodeURLtoURL() {\n  _encodeURLtoURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(inputUrl, outputUrl, writer, options) {\n    var outputFilename;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            inputUrl = resolvePath(inputUrl);\n            outputUrl = resolvePath(outputUrl);\n\n            if (!(isBrowser || !writer.encodeURLtoURL)) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error();\n\n          case 4:\n            _context3.next = 6;\n            return writer.encodeURLtoURL(inputUrl, outputUrl, options);\n\n          case 6:\n            outputFilename = _context3.sent;\n            return _context3.abrupt(\"return\", outputFilename);\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _encodeURLtoURL.apply(this, arguments);\n}\n\nfunction getIterator(data) {\n  var dataIterator = [{\n    table: data,\n    start: 0,\n    end: data.length\n  }];\n  return dataIterator;\n}\n\nfunction getTemporaryFilename(filename) {\n  return \"/tmp/\".concat(filename);\n}","map":{"version":3,"mappings":"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","names":["concatenateArrayBuffers","resolvePath","isBrowser","writeFile","fetchFile","encode","data","writer","options","encodeSync","encodeText","TextEncoder","encodeInBatches","batches","chunks","batch","push","encodeURLtoURL","tmpInputFilename","getTemporaryFilename","tmpOutputFilename","outputFilename","response","arrayBuffer","Error","text","TextDecoder","decode","dataIterator","getIterator","inputUrl","outputUrl","table","start","end","length","filename"],"sources":["../../../../src/lib/api/encode.ts"],"sourcesContent":["import type {Writer, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {writeFile} from '../fetch/write-file';\nimport {fetchFile} from '../fetch/fetch-file';\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport async function encode(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<ArrayBuffer> {\n  // TODO Merge default writer options with options argument like it is done in load module.\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeInBatches(data, writer, options);\n\n    // Concatenate the output\n    const chunks: any[] = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    // @ts-ignore\n    return concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n\n    const tmpOutputFilename = getTemporaryFilename('output');\n\n    const outputFilename = await encodeURLtoURL(\n      tmpInputFilename,\n      tmpOutputFilename,\n      writer,\n      options\n    );\n\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\n\n/**\n * Encode loaded data into a binary ArrayBuffer using the specified Writer.\n */\nexport function encodeSync(data: any, writer: Writer, options?: LoaderOptions): ArrayBuffer {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\n/**\n * Encode loaded data to text using the specified Writer\n * @note This is a convenience function not intended for production use on large input data.\n * It is not optimized for performance. Data maybe converted from text to binary and back.\n * @throws if the writer does not generate text output\n */\nexport async function encodeText(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): Promise<string> {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\n\n/**\n * Encode loaded data into a sequence (iterator) of binary ArrayBuffers using the specified Writer.\n */\nexport function encodeInBatches(\n  data: any,\n  writer: Writer,\n  options?: LoaderOptions\n): AsyncIterable<ArrayBuffer> {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\n\n/**\n * Encode data stored in a file (on disk) to another file.\n * @note Node.js only. This function enables using command-line converters as \"writers\".\n */\nexport async function encodeURLtoURL(\n  inputUrl,\n  outputUrl,\n  writer: Writer,\n  options\n): Promise<string> {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n\n/**\n * @todo TODO - this is an unacceptable hack!!!\n */\nfunction getIterator(data) {\n  const dataIterator = [{table: data, start: 0, end: data.length}];\n  return dataIterator;\n}\n\n/**\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename: string): string {\n  return `/tmp/${filename}`;\n}\n"]},"metadata":{},"sourceType":"module"}