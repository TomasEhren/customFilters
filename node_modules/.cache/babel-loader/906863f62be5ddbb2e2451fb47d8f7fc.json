{"ast":null,"code":"import { equals } from '@math.gl/core';\nexport var WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\nexport function modifyPolygonWindingDirection(points, direction) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var windingDirection = getPolygonWindingDirection(points, options);\n\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirection(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedArea(points, options));\n}\nexport function getPolygonSignedArea(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$start = options.start,\n      start = _options$start === void 0 ? 0 : _options$start,\n      _options$end = options.end,\n      end = _options$end === void 0 ? points.length : _options$end;\n  var dim = options.size || 2;\n  var area = 0;\n\n  for (var i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygon(points, visitor) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$start2 = options.start,\n      start = _options$start2 === void 0 ? 0 : _options$start2,\n      _options$end2 = options.end,\n      end = _options$end2 === void 0 ? points.length : _options$end2,\n      _options$size = options.size,\n      size = _options$size === void 0 ? 2 : _options$size,\n      isClosed = options.isClosed;\n  var numPoints = (end - start) / size;\n\n  for (var i = 0; i < numPoints - 1; ++i) {\n    visitor(points[start + i * size], points[start + i * size + 1], points[start + (i + 1) * size], points[start + (i + 1) * size + 1], i, i + 1);\n  }\n\n  var endPointIndex = start + (numPoints - 1) * size;\n  var isClosedEx = isClosed || equals(points[start], points[endPointIndex]) && equals(points[start + 1], points[endPointIndex + 1]);\n\n  if (!isClosedEx) {\n    visitor(points[endPointIndex], points[endPointIndex + 1], points[start], points[start + 1], numPoints - 1, 0);\n  }\n}\n\nfunction reversePolygon(points, options) {\n  var _options$start3 = options.start,\n      start = _options$start3 === void 0 ? 0 : _options$start3,\n      _options$end3 = options.end,\n      end = _options$end3 === void 0 ? points.length : _options$end3,\n      _options$size2 = options.size,\n      size = _options$size2 === void 0 ? 2 : _options$size2;\n  var numPoints = (end - start) / size;\n  var numSwaps = Math.floor(numPoints / 2);\n\n  for (var i = 0; i < numSwaps; ++i) {\n    var b1 = start + i * size;\n    var b2 = start + (numPoints - 1 - i) * size;\n\n    for (var j = 0; j < size; ++j) {\n      var tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\nexport function modifyPolygonWindingDirectionPoints(points, direction) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var currentDirection = getPolygonWindingDirectionPoints(points, options);\n\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n\n  return false;\n}\nexport function getPolygonWindingDirectionPoints(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\nexport function getPolygonSignedAreaPoints(points) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$start4 = options.start,\n      start = _options$start4 === void 0 ? 0 : _options$start4,\n      _options$end4 = options.end,\n      end = _options$end4 === void 0 ? points.length : _options$end4;\n  var area = 0;\n\n  for (var i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n\n  return area / 2;\n}\nexport function forEachSegmentInPolygonPoints(points, visitor) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$start5 = options.start,\n      start = _options$start5 === void 0 ? 0 : _options$start5,\n      _options$end5 = options.end,\n      end = _options$end5 === void 0 ? points.length : _options$end5,\n      isClosed = options.isClosed;\n\n  for (var i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  var isClosedEx = isClosed || equals(points[end - 1], points[0]);\n\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}","map":{"version":3,"mappings":"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","names":["equals","WINDING","CLOCKWISE","COUNTER_CLOCKWISE","modifyPolygonWindingDirection","points","direction","options","windingDirection","getPolygonWindingDirection","reversePolygon","Math","sign","getPolygonSignedArea","start","end","length","dim","size","area","i","j","forEachSegmentInPolygon","visitor","isClosed","numPoints","endPointIndex","isClosedEx","numSwaps","floor","b1","b2","tmp","modifyPolygonWindingDirectionPoints","currentDirection","getPolygonWindingDirectionPoints","reverse","getPolygonSignedAreaPoints","forEachSegmentInPolygonPoints"],"sources":["../../src/polygon-utils.js"],"sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\n\n/** @type {typeof import('./polygon-utils').WINDING} */\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n};\n\n/** @type {typeof import('./polygon-utils').modifyPolygonWindingDirection} */\nexport function modifyPolygonWindingDirection(points, direction, options = {}) {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonWindingDirection} */\nexport function getPolygonWindingDirection(points, options = {}) {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonSignedArea} */\nexport function getPolygonSignedArea(points, options = {}) {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/** @type {typeof import('./polygon-utils').forEachSegmentInPolygon} */\nexport function forEachSegmentInPolygon(points, visitor, options = {}) {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(points, options) {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/** @type {typeof import('./polygon-utils').modifyPolygonWindingDirectionPoints} */\nexport function modifyPolygonWindingDirectionPoints(points, direction, options = {}) {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonWindingDirectionPoints} */\nexport function getPolygonWindingDirectionPoints(points, options = {}) {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/** @type {typeof import('./polygon-utils').getPolygonSignedAreaPoints} */\nexport function getPolygonSignedAreaPoints(points, options = {}) {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/** @type {typeof import('./polygon-utils').forEachSegmentInPolygonPoints} */\nexport function forEachSegmentInPolygonPoints(points, visitor, options = {}) {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}