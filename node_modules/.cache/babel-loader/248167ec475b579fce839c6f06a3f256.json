{"ast":null,"code":"import { getDefaultCredentials, buildMapsUrlFromBase } from '../config';\nimport { API_VERSIONS, COLUMNS_SUPPORT, encodeParameter, FORMATS, GEO_COLUMN_SUPPORT, MAP_TYPES, TILE_FORMATS } from './maps-api-common';\nimport { parseMap } from './parseMap';\nimport { log } from '@deck.gl/core';\nimport { assert } from '../utils';\nconst MAX_GET_LENGTH = 2048;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\n\nasync function request(_ref) {\n  let {\n    method,\n    url,\n    accessToken,\n    body\n  } = _ref;\n  const headers = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = \"Bearer \".concat(accessToken);\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(\"Failed to connect to Maps API: \".concat(error));\n  }\n}\n\nasync function requestJson(_ref2) {\n  let {\n    method,\n    url,\n    accessToken,\n    body\n  } = _ref2;\n  const response = await request({\n    method,\n    url,\n    accessToken,\n    body\n  });\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({\n      response,\n      error: json.error\n    });\n  }\n\n  return json;\n}\n\nasync function requestData(_ref3) {\n  let {\n    method,\n    url,\n    accessToken,\n    format,\n    body\n  } = _ref3;\n\n  if (format === FORMATS.NDJSON) {\n    return request({\n      method,\n      url,\n      accessToken,\n      body\n    });\n  }\n\n  const data = await requestJson({\n    method,\n    url,\n    accessToken,\n    body\n  });\n  return data.rows ? data.rows : data;\n}\n\nfunction dealWithError(_ref4) {\n  let {\n    response,\n    error\n  } = _ref4;\n\n  switch (response.status) {\n    case 400:\n      throw new Error(\"Bad request. \".concat(error));\n\n    case 401:\n    case 403:\n      throw new Error(\"Unauthorized access. \".concat(error));\n\n    default:\n      throw new Error(error);\n  }\n}\n\nfunction getParameters(_ref5) {\n  let {\n    type,\n    source,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  } = _ref5;\n  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (GEO_COLUMN_SUPPORT.includes(type) && geoColumn) {\n    parameters.push(encodeParameter('geo_column', geoColumn));\n  }\n\n  if (COLUMNS_SUPPORT.includes(type) && columns) {\n    parameters.push(encodeParameter('columns', columns.join(',')));\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation(_ref6) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  } = _ref6;\n  const baseUrl = \"\".concat(credentials.mapsUrl, \"/\").concat(connection, \"/\").concat(type);\n  const url = \"\".concat(baseUrl, \"?\").concat(getParameters({\n    type,\n    source,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  }));\n  const {\n    accessToken\n  } = credentials;\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    const body = JSON.stringify({\n      q: source,\n      client: clientId || DEFAULT_CLIENT\n    });\n    return await requestJson({\n      method: 'POST',\n      url: baseUrl,\n      accessToken,\n      body\n    });\n  }\n\n  return await requestJson({\n    url,\n    accessToken\n  });\n}\n\nfunction getUrlFromMetadata(metadata, format) {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters(_ref7) {\n  let {\n    type,\n    source,\n    connection,\n    credentials\n  } = _ref7;\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport async function fetchLayerData(_ref8) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  } = _ref8;\n  const {\n    url,\n    accessToken,\n    mapFormat,\n    metadata\n  } = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  });\n  const data = await requestData({\n    url,\n    format: mapFormat,\n    accessToken\n  });\n  const result = {\n    data,\n    format: mapFormat\n  };\n\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nasync function _fetchDataUrl(_ref9) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  } = _ref9;\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = { ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({\n    type,\n    source,\n    connection,\n    credentials: localCreds\n  });\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  });\n  let url = null;\n  let mapFormat;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, \"Format \".concat(format, \" not available\"));\n  } else {\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(Object.values(TILE_FORMATS).includes(formatTiles), \"Invalid value for formatTiles: \".concat(formatTiles, \". Use value from TILE_FORMATS\"));\n    url += \"&\".concat(encodeParameter('formatTiles', formatTiles));\n  }\n\n  const {\n    accessToken\n  } = localCreds;\n  return {\n    url,\n    accessToken,\n    mapFormat,\n    metadata\n  };\n}\n\nexport async function getData(_ref10) {\n  let {\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    clientId\n  } = _ref10;\n  log.deprecated('getData', 'fetchLayerData')();\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false,\n    clientId\n  });\n  return layerData.data;\n}\n\nasync function _fetchMapDataset(dataset, accessToken, credentials, clientId) {\n  const {\n    connectionName: connection,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type\n  } = dataset;\n  const {\n    url,\n    mapFormat\n  } = await _fetchDataUrl({\n    clientId,\n    credentials: { ...credentials,\n      accessToken\n    },\n    connection,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type\n  });\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n\n  dataset.cache = cache;\n  dataset.data = await requestData({\n    url,\n    format: mapFormat,\n    accessToken\n  });\n  return true;\n}\n\nasync function fillInMapDatasets(_ref11, clientId, credentials) {\n  let {\n    datasets,\n    token\n  } = _ref11;\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId));\n  return await Promise.all(promises);\n}\n\nexport async function fetchMap(_ref12) {\n  let {\n    cartoMapId,\n    clientId,\n    credentials,\n    autoRefresh,\n    onNewData\n  } = _ref12;\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = { ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  const {\n    accessToken\n  } = localCreds;\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(typeof autoRefresh === 'number' && autoRefresh > 0, '`autoRefresh` must be a positive number');\n  }\n\n  const url = \"\".concat(localCreds.mapsUrl, \"/public/\").concat(cartoMapId);\n  const map = await requestJson({\n    url,\n    accessToken\n  });\n  let stopAutoRefresh;\n\n  if (autoRefresh) {\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds);\n\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(_ref13 => {\n    let {\n      type\n    } = _ref13;\n    return type === 'geojson' || type === 'point';\n  });\n  const geojsonDatasetIds = geojsonLayers.map(_ref14 => {\n    let {\n      config\n    } = _ref14;\n    return config.dataId;\n  });\n  map.datasets.forEach(dataset => {\n    if (geojsonDatasetIds.includes(dataset.id)) {\n      dataset.format = 'geojson';\n    }\n  });\n  await fillInMapDatasets(map, clientId, localCreds);\n  return { ...parseMap(map),\n    ...{\n      stopAutoRefresh\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["getDefaultCredentials","buildMapsUrlFromBase","API_VERSIONS","COLUMNS_SUPPORT","encodeParameter","FORMATS","GEO_COLUMN_SUPPORT","MAP_TYPES","TILE_FORMATS","parseMap","log","assert","MAX_GET_LENGTH","DEFAULT_CLIENT","request","method","url","accessToken","body","headers","Accept","Authorization","fetch","error","Error","requestJson","response","json","ok","dealWithError","requestData","format","NDJSON","data","rows","status","getParameters","type","source","geoColumn","columns","schema","clientId","parameters","push","sourceName","QUERY","includes","join","mapInstantiation","connection","credentials","baseUrl","mapsUrl","length","JSON","stringify","q","client","getUrlFromMetadata","metadata","m","checkFetchLayerDataParameters","apiVersion","V3","apiBaseUrl","fetchLayerData","formatTiles","mapFormat","_fetchDataUrl","result","defaultCredentials","localCreds","prioritizedFormats","GEOJSON","TILEJSON","f","Object","values","getData","deprecated","layerData","_fetchMapDataset","dataset","connectionName","cache","parseInt","URL","searchParams","get","fillInMapDatasets","datasets","token","promises","map","Promise","all","fetchMap","cartoMapId","autoRefresh","onNewData","stopAutoRefresh","intervalId","setInterval","changed","some","v","clearInterval","geojsonLayers","keplerMapConfig","config","visState","layers","filter","geojsonDatasetIds","dataId","forEach","id"],"sources":["../../../src/api/maps-v3-client.ts"],"sourcesContent":["/**\n * Maps API Client for Carto 3\n */\nimport {getDefaultCredentials, buildMapsUrlFromBase, CloudNativeCredentials} from '../config';\nimport {\n  API_VERSIONS,\n  COLUMNS_SUPPORT,\n  encodeParameter,\n  Format,\n  FORMATS,\n  GEO_COLUMN_SUPPORT,\n  MapInstantiation,\n  MapType,\n  MAP_TYPES,\n  SchemaField,\n  TileFormat,\n  TILE_FORMATS\n} from './maps-api-common';\nimport {parseMap} from './parseMap';\nimport {log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nconst MAX_GET_LENGTH = 2048;\nconst DEFAULT_CLIENT = 'deck-gl-carto';\n\ninterface RequestParams {\n  method?: string;\n  url: string;\n  accessToken?: string;\n  body?: any;\n}\n\n/**\n * Request against Maps API\n */\nasync function request({method, url, accessToken, body}: RequestParams): Promise<Response> {\n  const headers: Record<string, string> = {\n    Accept: 'application/json'\n  };\n\n  if (accessToken) {\n    headers.Authorization = `Bearer ${accessToken}`;\n  }\n\n  if (method === 'POST') {\n    headers['Content-Type'] = 'application/json';\n  }\n\n  try {\n    /* global fetch */\n    return await fetch(url, {\n      method,\n      headers,\n      body\n    });\n  } catch (error) {\n    throw new Error(`Failed to connect to Maps API: ${error}`);\n  }\n}\n\nasync function requestJson<T = unknown>({\n  method,\n  url,\n  accessToken,\n  body\n}: RequestParams): Promise<T> {\n  const response = await request({method, url, accessToken, body});\n  const json = await response.json();\n\n  if (!response.ok) {\n    dealWithError({response, error: json.error});\n  }\n  return json as T;\n}\n\nasync function requestData({\n  method,\n  url,\n  accessToken,\n  format,\n  body\n}: RequestParams & {\n  format: Format;\n}): Promise<Response | unknown> {\n  if (format === FORMATS.NDJSON) {\n    return request({method, url, accessToken, body});\n  }\n\n  const data = await requestJson<any>({method, url, accessToken, body});\n  return data.rows ? data.rows : data;\n}\n\n/**\n * Display proper message from Maps API error\n */\nfunction dealWithError({response, error}: {response: Response; error?: string}): never {\n  switch (response.status) {\n    case 400:\n      throw new Error(`Bad request. ${error}`);\n    case 401:\n    case 403:\n      throw new Error(`Unauthorized access. ${error}`);\n    default:\n      throw new Error(error);\n  }\n}\n\ntype FetchLayerDataParams = {\n  type: MapType;\n  source: string;\n  connection: string;\n  credentials: CloudNativeCredentials;\n  geoColumn?: string;\n  columns?: string[];\n  schema?: boolean;\n  clientId?: string;\n  format?: Format;\n  formatTiles?: TileFormat;\n};\n\n/**\n * Build a URL with all required parameters\n */\nfunction getParameters({\n  type,\n  source,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: Omit<FetchLayerDataParams, 'connection' | 'credentials'>) {\n  const parameters = [encodeParameter('client', clientId || DEFAULT_CLIENT)];\n  if (schema) {\n    parameters.push(encodeParameter('schema', true));\n  }\n\n  const sourceName = type === MAP_TYPES.QUERY ? 'q' : 'name';\n  parameters.push(encodeParameter(sourceName, source));\n\n  if (GEO_COLUMN_SUPPORT.includes(type) && geoColumn) {\n    parameters.push(encodeParameter('geo_column', geoColumn));\n  }\n  if (COLUMNS_SUPPORT.includes(type) && columns) {\n    parameters.push(encodeParameter('columns', columns.join(',')));\n  }\n\n  return parameters.join('&');\n}\n\nexport async function mapInstantiation({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<MapInstantiation> {\n  const baseUrl = `${credentials.mapsUrl}/${connection}/${type}`;\n  const url = `${baseUrl}?${getParameters({type, source, geoColumn, columns, schema, clientId})}`;\n  const {accessToken} = credentials;\n\n  if (url.length > MAX_GET_LENGTH && type === MAP_TYPES.QUERY) {\n    // need to be a POST request\n    const body = JSON.stringify({\n      q: source,\n      client: clientId || DEFAULT_CLIENT\n    });\n    return await requestJson({method: 'POST', url: baseUrl, accessToken, body});\n  }\n\n  return await requestJson({url, accessToken});\n}\n\nfunction getUrlFromMetadata(metadata: MapInstantiation, format: Format): string | null {\n  const m = metadata[format];\n\n  if (m && !m.error && m.url) {\n    return m.url[0];\n  }\n\n  return null;\n}\n\nfunction checkFetchLayerDataParameters({\n  type,\n  source,\n  connection,\n  credentials\n}: FetchLayerDataParams) {\n  assert(connection, 'Must define connection');\n  assert(type, 'Must define a type');\n  assert(source, 'Must define a source');\n\n  assert(credentials.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(credentials.apiBaseUrl, 'Must define apiBaseUrl');\n  assert(credentials.accessToken, 'Must define an accessToken');\n}\n\nexport interface FetchLayerDataResult {\n  data: any;\n  format: Format;\n  schema?: SchemaField[];\n}\nexport async function fetchLayerData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams): Promise<FetchLayerDataResult> {\n  // Internally we split data fetching into two parts to allow us to\n  // conditionally fetch the actual data, depending on the metadata state\n  const {url, accessToken, mapFormat, metadata} = await _fetchDataUrl({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    formatTiles,\n    schema,\n    clientId\n  });\n\n  const data = await requestData({url, format: mapFormat, accessToken});\n  const result: FetchLayerDataResult = {data, format: mapFormat};\n  if (schema) {\n    result.schema = metadata.schema;\n  }\n\n  return result;\n}\n\nasync function _fetchDataUrl({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  formatTiles,\n  schema,\n  clientId\n}: FetchLayerDataParams) {\n  const defaultCredentials = getDefaultCredentials();\n  // Only pick up default credentials if they have been defined for\n  // correct API version\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  };\n  checkFetchLayerDataParameters({type, source, connection, credentials: localCreds});\n\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  const metadata = await mapInstantiation({\n    type,\n    source,\n    connection,\n    credentials: localCreds,\n    geoColumn,\n    columns,\n    schema,\n    clientId\n  });\n  let url: string | null = null;\n  let mapFormat: Format | undefined;\n\n  if (format) {\n    mapFormat = format;\n    url = getUrlFromMetadata(metadata, format);\n    assert(url, `Format ${format} not available`);\n  } else {\n    // guess map format\n    const prioritizedFormats = [FORMATS.GEOJSON, FORMATS.JSON, FORMATS.NDJSON, FORMATS.TILEJSON];\n    for (const f of prioritizedFormats) {\n      url = getUrlFromMetadata(metadata, f);\n      if (url) {\n        mapFormat = f;\n        break;\n      }\n    }\n    assert(url && mapFormat, 'Unsupported data formats received from backend.');\n  }\n\n  if (format === FORMATS.TILEJSON && formatTiles) {\n    log.assert(\n      Object.values(TILE_FORMATS).includes(formatTiles),\n      `Invalid value for formatTiles: ${formatTiles}. Use value from TILE_FORMATS`\n    );\n    url += `&${encodeParameter('formatTiles', formatTiles)}`;\n  }\n\n  const {accessToken} = localCreds;\n  return {url, accessToken, mapFormat, metadata};\n}\n\nexport async function getData({\n  type,\n  source,\n  connection,\n  credentials,\n  geoColumn,\n  columns,\n  format,\n  clientId\n}: FetchLayerDataParams) {\n  log.deprecated('getData', 'fetchLayerData')();\n  const layerData = await fetchLayerData({\n    type,\n    source,\n    connection,\n    credentials,\n    geoColumn,\n    columns,\n    format,\n    schema: false,\n    clientId\n  });\n  return layerData.data;\n}\n\n/* global clearInterval, setInterval, URL */\nasync function _fetchMapDataset(\n  dataset,\n  accessToken: string,\n  credentials: CloudNativeCredentials,\n  clientId?: string\n) {\n  const {connectionName: connection, columns, format, geoColumn, source, type} = dataset;\n  // First fetch metadata\n  const {url, mapFormat} = await _fetchDataUrl({\n    clientId,\n    credentials: {...credentials, accessToken},\n    connection,\n    columns,\n    format,\n    geoColumn,\n    source,\n    type\n  });\n\n  // Extract the last time the data changed\n  const cache = parseInt(new URL(url).searchParams.get('cache') || '', 10);\n  if (cache && dataset.cache === cache) {\n    return false;\n  }\n  dataset.cache = cache;\n\n  // Only fetch if the data has changed\n  dataset.data = await requestData({url, format: mapFormat, accessToken});\n\n  return true;\n}\n\nasync function fillInMapDatasets(\n  {datasets, token},\n  clientId: string,\n  credentials: CloudNativeCredentials\n) {\n  const promises = datasets.map(dataset => _fetchMapDataset(dataset, token, credentials, clientId));\n  return await Promise.all(promises);\n}\n\nexport async function fetchMap({\n  cartoMapId,\n  clientId,\n  credentials,\n  autoRefresh,\n  onNewData\n}: {\n  cartoMapId: string;\n  clientId: string;\n  credentials?: CloudNativeCredentials;\n  autoRefresh?: number;\n  onNewData?: (map: any) => void;\n}) {\n  const defaultCredentials = getDefaultCredentials();\n  const localCreds = {\n    ...(defaultCredentials.apiVersion === API_VERSIONS.V3 && defaultCredentials),\n    ...credentials\n  } as CloudNativeCredentials;\n  const {accessToken} = localCreds;\n\n  assert(cartoMapId, 'Must define CARTO map id: fetchMap({cartoMapId: \"XXXX-XXXX-XXXX\"})');\n\n  assert(localCreds.apiVersion === API_VERSIONS.V3, 'Method only available for v3');\n  assert(localCreds.apiBaseUrl, 'Must define apiBaseUrl');\n  if (!localCreds.mapsUrl) {\n    localCreds.mapsUrl = buildMapsUrlFromBase(localCreds.apiBaseUrl);\n  }\n\n  if (autoRefresh || onNewData) {\n    assert(onNewData, 'Must define `onNewData` when using autoRefresh');\n    assert(typeof onNewData === 'function', '`onNewData` must be a function');\n    assert(\n      typeof autoRefresh === 'number' && autoRefresh > 0,\n      '`autoRefresh` must be a positive number'\n    );\n  }\n\n  const url = `${localCreds.mapsUrl}/public/${cartoMapId}`;\n  const map = await requestJson<any>({url, accessToken});\n\n  // Periodically check if the data has changed. Note that this\n  // will not update when a map is published.\n  let stopAutoRefresh: (() => void) | undefined;\n  if (autoRefresh) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const intervalId = setInterval(async () => {\n      const changed = await fillInMapDatasets(map, clientId, localCreds);\n      if (onNewData && changed.some(v => v === true)) {\n        onNewData(parseMap(map));\n      }\n    }, autoRefresh * 1000);\n    stopAutoRefresh = () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  const geojsonLayers = map.keplerMapConfig.config.visState.layers.filter(\n    ({type}) => type === 'geojson' || type === 'point'\n  );\n  const geojsonDatasetIds = geojsonLayers.map(({config}) => config.dataId);\n  map.datasets.forEach(dataset => {\n    if (geojsonDatasetIds.includes(dataset.id)) {\n      dataset.format = 'geojson';\n    }\n  });\n\n  // Mutates map.datasets so that dataset.data contains data\n  await fillInMapDatasets(map, clientId, localCreds);\n  return {\n    ...parseMap(map),\n    ...{stopAutoRefresh}\n  };\n}\n"]},"metadata":{},"sourceType":"module"}