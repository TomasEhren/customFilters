{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { formatValue, equals as _equals, config } from '../lib/common';\nimport { degrees, radians, clamp } from '../lib/common';\nimport Vector3 from './vector3';\nimport * as vec3 from 'gl-matrix/vec3';\nvar EPSILON = 0.000001;\nvar EARTH_RADIUS_METERS = 6.371e6;\n\nvar SphericalCoordinates = /*#__PURE__*/function () {\n  function SphericalCoordinates() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$phi = _ref.phi,\n        phi = _ref$phi === void 0 ? 0 : _ref$phi,\n        _ref$theta = _ref.theta,\n        theta = _ref$theta === void 0 ? 0 : _ref$theta,\n        _ref$radius = _ref.radius,\n        radius = _ref$radius === void 0 ? 1 : _ref$radius,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? undefined : _ref$bearing,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? undefined : _ref$pitch,\n        _ref$altitude = _ref.altitude,\n        altitude = _ref$altitude === void 0 ? undefined : _ref$altitude,\n        _ref$radiusScale = _ref.radiusScale,\n        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;\n\n    _classCallCheck(this, SphericalCoordinates);\n\n    this.phi = phi;\n    this.theta = theta;\n    this.radius = radius || altitude || 1;\n    this.radiusScale = radiusScale || 1;\n\n    if (bearing !== undefined) {\n      this.bearing = bearing;\n    }\n\n    if (pitch !== undefined) {\n      this.pitch = pitch;\n    }\n\n    this.check();\n  }\n\n  _createClass(SphericalCoordinates, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.formatString(config);\n    }\n  }, {\n    key: \"formatString\",\n    value: function formatString(_ref2) {\n      var _ref2$printTypes = _ref2.printTypes,\n          printTypes = _ref2$printTypes === void 0 ? false : _ref2$printTypes;\n      var f = formatValue;\n      return \"\".concat(printTypes ? 'Spherical' : '', \"[rho:\").concat(f(this.radius), \",theta:\").concat(f(this.theta), \",phi:\").concat(f(this.phi), \"]\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return _equals(this.radius, other.radius) && _equals(this.theta, other.theta) && _equals(this.phi, other.phi);\n    }\n  }, {\n    key: \"exactEquals\",\n    value: function exactEquals(other) {\n      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n    }\n  }, {\n    key: \"bearing\",\n    get: function get() {\n      return 180 - degrees(this.phi);\n    },\n    set: function set(v) {\n      this.phi = Math.PI - radians(v);\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return degrees(this.theta);\n    },\n    set: function set(v) {\n      this.theta = radians(v);\n    }\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"latitude\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"lng\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"lat\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return (this.radius - 1) * this.radiusScale;\n    }\n  }, {\n    key: \"set\",\n    value: function set(radius, phi, theta) {\n      this.radius = radius;\n      this.phi = phi;\n      this.theta = theta;\n      return this.check();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new SphericalCoordinates().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.radius = other.radius;\n      this.phi = other.phi;\n      this.theta = other.theta;\n      return this.check();\n    }\n  }, {\n    key: \"fromLngLatZ\",\n    value: function fromLngLatZ(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 3),\n          lng = _ref4[0],\n          lat = _ref4[1],\n          z = _ref4[2];\n\n      this.radius = 1 + z / this.radiusScale;\n      this.phi = radians(lat);\n      this.theta = radians(lng);\n    }\n  }, {\n    key: \"fromVector3\",\n    value: function fromVector3(v) {\n      this.radius = vec3.length(v);\n\n      if (this.radius > 0) {\n        this.theta = Math.atan2(v[0], v[1]);\n        this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));\n      }\n\n      return this.check();\n    }\n  }, {\n    key: \"toVector3\",\n    value: function toVector3() {\n      return new Vector3(0, 0, this.radius).rotateX({\n        radians: this.theta\n      }).rotateZ({\n        radians: this.phi\n      });\n    }\n  }, {\n    key: \"makeSafe\",\n    value: function makeSafe() {\n      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n      return this;\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n        throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n      }\n\n      return this;\n    }\n  }]);\n\n  return SphericalCoordinates;\n}();\n\nexport { SphericalCoordinates as default };","map":{"version":3,"mappings":";;;AAqBA,SAAQA,WAAR,EAAqBC,MAArB,IAAqBA,OAArB,EAA6BC,MAA7B,QAA0C,eAA1C;AACA,SAAQC,OAAR,EAAiBC,OAAjB,EAA0BC,KAA1B,QAAsC,eAAtC;AACA,OAAOC,OAAP,MAAoB,WAApB;AAGA,OAAO,KAAKC,IAAZ,MAAsB,gBAAtB;AAGA,IAAMC,OAAO,GAAG,QAAhB;AAEA,IAAMC,mBAAmB,GAAG,OAA5B;;IAGqBC,oB;EAGnBC,gCAQQ;IAAA,+EAAJ,EAAI;IAAA,oBAPNC,GAOM;IAAA,IAPNA,GAOM,yBAPA,CAOA;IAAA,sBANNC,KAMM;IAAA,IANNA,KAMM,2BANE,CAMF;IAAA,uBALNC,MAKM;IAAA,IALNA,MAKM,4BALG,CAKH;IAAA,wBAJNC,OAIM;IAAA,IAJNA,OAIM,6BAJIC,SAIJ;IAAA,sBAHNC,KAGM;IAAA,IAHNA,KAGM,2BAHED,SAGF;IAAA,yBAFNE,QAEM;IAAA,IAFNA,QAEM,8BAFKF,SAEL;IAAA,4BADNG,WACM;IAAA,IADNA,WACM,iCADQV,mBACR;;IAAA;;IACN,KAAKG,GAAL,GAAWA,GAAX;IACA,KAAKC,KAAL,GAAaA,KAAb;IAEA,KAAKC,MAAL,GAAcA,MAAM,IAAII,QAAVJ,IAAsB,CAApC;IACA,KAAKK,WAAL,GAAmBA,WAAW,IAAI,CAAlC;;IAEA,IAAIJ,OAAO,KAAKC,SAAhB,EAA2B;MACzB,KAAKD,OAAL,GAAeA,OAAf;IACD;;IACD,IAAIE,KAAK,KAAKD,SAAd,EAAyB;MACvB,KAAKC,KAAL,GAAaA,KAAb;IACD;;IACD,KAAKG,KAAL;EACD;;;;WAEDC,oBAAW;MACT,OAAO,KAAKC,YAAL,CAAkBpB,MAAlB,CAAP;IACD;;;WAEDoB,6BAAmC;MAAA,6BAArBC,UAAqB;MAAA,IAArBA,UAAqB,iCAAR,KAAQ;MACjC,IAAMC,CAAC,GAAGxB,WAAV;MACA,iBAAUuB,UAAU,GAAG,WAAH,GAAiB,EAArC,kBACGC,CAAC,CAAC,KAAKV,MAAN,CADJ,oBAC2BU,CAAC,CAAC,KAAKX,KAAN,CAD5B,kBACgDW,CAAC,CAAC,KAAKZ,GAAN,CADjD;IAED;;;WAEDX,gBAAOwB,KAAPxB,EAAc;MACZ,OACEA,OAAM,CAAC,KAAKa,MAAN,EAAcW,KAAK,CAACX,MAApB,CAANb,IACAA,OAAM,CAAC,KAAKY,KAAN,EAAaY,KAAK,CAACZ,KAAnB,CADNZ,IAEAA,OAAM,CAAC,KAAKW,GAAN,EAAWa,KAAK,CAACb,GAAjB,CAHR;IAKD;;;WAEDc,qBAAYD,KAAZC,EAAmB;MACjB,OAAO,KAAKZ,MAAL,KAAgBW,KAAK,CAACX,MAAtB,IAAgC,KAAKD,KAAL,KAAeY,KAAK,CAACZ,KAArD,IAA8D,KAAKD,GAAL,KAAaa,KAAK,CAACb,GAAxF;IACD;;;SAIU,eAAG;MACZ,OAAO,MAAMT,OAAO,CAAC,KAAKS,GAAN,CAApB;IACD,C;SACU,aAACe,CAAD,EAAI;MACb,KAAKf,GAAL,GAAWgB,IAAI,CAACC,EAALD,GAAUxB,OAAO,CAACuB,CAAD,CAA5B;IACD;;;SACQ,eAAG;MACV,OAAOxB,OAAO,CAAC,KAAKU,KAAN,CAAd;IACD,C;SACQ,aAACc,CAAD,EAAI;MACX,KAAKd,KAAL,GAAaT,OAAO,CAACuB,CAAD,CAApB;IACD;;;SAMY,eAAG;MACd,OAAOxB,OAAO,CAAC,KAAKS,GAAN,CAAd;IACD;;;SACW,eAAG;MACb,OAAOT,OAAO,CAAC,KAAKU,KAAN,CAAd;IACD;;;SACM,eAAG;MACR,OAAOV,OAAO,CAAC,KAAKS,GAAN,CAAd;IACD;;;SACM,eAAG;MACR,OAAOT,OAAO,CAAC,KAAKU,KAAN,CAAd;IACD;;;SACI,eAAG;MACN,OAAO,CAAC,KAAKC,MAAL,GAAc,CAAf,IAAoB,KAAKK,WAAhC;IACD;;;WAGDW,aAAIhB,MAAJgB,EAAYlB,GAAZkB,EAAiBjB,KAAjBiB,EAAwB;MACtB,KAAKhB,MAAL,GAAcA,MAAd;MACA,KAAKF,GAAL,GAAWA,GAAX;MACA,KAAKC,KAAL,GAAaA,KAAb;MACA,OAAO,KAAKO,KAAL,EAAP;IACD;;;WAEDW,iBAAQ;MACN,OAAO,IAAIrB,oBAAJ,GAA2BsB,IAA3B,CAAgC,IAAhC,CAAP;IACD;;;WAEDA,cAAKP,KAALO,EAAY;MACV,KAAKlB,MAAL,GAAcW,KAAK,CAACX,MAApB;MACA,KAAKF,GAAL,GAAWa,KAAK,CAACb,GAAjB;MACA,KAAKC,KAAL,GAAaY,KAAK,CAACZ,KAAnB;MACA,OAAO,KAAKO,KAAL,EAAP;IACD;;;WAEDa,4BAA2B;MAAA;MAAA,IAAdC,GAAc;MAAA,IAATC,GAAS;MAAA,IAAJC,CAAI;;MACzB,KAAKtB,MAAL,GAAc,IAAIsB,CAAC,GAAG,KAAKjB,WAA3B;MACA,KAAKP,GAAL,GAAWR,OAAO,CAAC+B,GAAD,CAAlB;MACA,KAAKtB,KAAL,GAAaT,OAAO,CAAC8B,GAAD,CAApB;IACD;;;WAEDG,qBAAYV,CAAZU,EAAe;MACb,KAAKvB,MAAL,GAAcP,IAAI,CAAC+B,MAAL/B,CAAYoB,CAAZpB,CAAd;;MACA,IAAI,KAAKO,MAAL,GAAc,CAAlB,EAAqB;QACnB,KAAKD,KAAL,GAAae,IAAI,CAACW,KAALX,CAAWD,CAAC,CAAC,CAAD,CAAZC,EAAiBD,CAAC,CAAC,CAAD,CAAlBC,CAAb;QACA,KAAKhB,GAAL,GAAWgB,IAAI,CAACY,IAALZ,CAAUvB,KAAK,CAACsB,CAAC,CAAC,CAAD,CAADA,GAAO,KAAKb,MAAb,EAAqB,CAAC,CAAtB,EAAyB,CAAzB,CAAfc,CAAX;MACD;;MACD,OAAO,KAAKR,KAAL,EAAP;IACD;;;WAEDqB,qBAAY;MACV,OAAO,IAAInC,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,KAAKQ,MAAvB,EACJ4B,OADI,CACI;QAACtC,OAAO,EAAE,KAAKS;MAAf,CADJ,EAEJ8B,OAFI,CAEI;QAACvC,OAAO,EAAE,KAAKQ;MAAf,CAFJ,CAAP;IAGD;;;WAGDgC,oBAAW;MACT,KAAKhC,GAAL,GAAWgB,IAAI,CAACiB,GAALjB,CAASpB,OAAToB,EAAkBA,IAAI,CAACkB,GAALlB,CAASA,IAAI,CAACC,EAALD,GAAUpB,OAAnBoB,EAA4B,KAAKhB,GAAjCgB,CAAlBA,CAAX;MACA,OAAO,IAAP;IACD;;;WAEDR,iBAAQ;MAEN,IAAI,CAAC2B,MAAM,CAACC,QAAPD,CAAgB,KAAKnC,GAArBmC,CAAD,IAA8B,CAACA,MAAM,CAACC,QAAPD,CAAgB,KAAKlC,KAArBkC,CAA/B,IAA8D,EAAE,KAAKjC,MAAL,GAAc,CAAhB,CAAlE,EAAsF;QACpF,MAAM,IAAImC,KAAJ,CAAU,0DAAV,CAAN;MACD;;MACD,OAAO,IAAP;IACD;;;;;;SAxIkBvC,oB","names":["formatValue","equals","config","degrees","radians","clamp","Vector3","vec3","EPSILON","EARTH_RADIUS_METERS","SphericalCoordinates","constructor","phi","theta","radius","bearing","undefined","pitch","altitude","radiusScale","check","toString","formatString","printTypes","f","other","exactEquals","v","Math","PI","set","clone","copy","fromLngLatZ","lng","lat","z","fromVector3","length","atan2","acos","toVector3","rotateX","rotateZ","makeSafe","max","min","Number","isFinite","Error"],"sources":["../../../src/classes/spherical-coordinates.js"],"sourcesContent":["// Copyright (c) 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Adaptation of THREE.js Spherical class, under MIT license\nimport {formatValue, equals, config} from '../lib/common';\nimport {degrees, radians, clamp} from '../lib/common';\nimport Vector3 from './vector3';\n\n// @ts-ignore: error TS2307: Cannot find module 'gl-matrix/...'.\nimport * as vec3 from 'gl-matrix/vec3';\n\n// TODO - import epsilon\nconst EPSILON = 0.000001;\n\nconst EARTH_RADIUS_METERS = 6.371e6;\n\n// Todo [rho, theta, phi] ?\nexport default class SphericalCoordinates {\n  // @ts-ignore TS2740: Type '{}' is missing the following properties from type\n  // eslint-disable-next-line complexity\n  constructor({\n    phi = 0,\n    theta = 0,\n    radius = 1,\n    bearing = undefined,\n    pitch = undefined,\n    altitude = undefined,\n    radiusScale = EARTH_RADIUS_METERS\n  } = {}) {\n    this.phi = phi;\n    this.theta = theta;\n    // TODO - silently accepts illegal 0\n    this.radius = radius || altitude || 1; // radial distance from center\n    this.radiusScale = radiusScale || 1; // Used by lngLatZ\n\n    if (bearing !== undefined) {\n      this.bearing = bearing; // up / down towards top and bottom pole\n    }\n    if (pitch !== undefined) {\n      this.pitch = pitch; // around the equator of the sphere\n    }\n    this.check();\n  }\n\n  toString() {\n    return this.formatString(config);\n  }\n\n  formatString({printTypes = false}) {\n    const f = formatValue;\n    return `${printTypes ? 'Spherical' : ''}\\\n[rho:${f(this.radius)},theta:${f(this.theta)},phi:${f(this.phi)}]`;\n  }\n\n  equals(other) {\n    return (\n      equals(this.radius, other.radius) &&\n      equals(this.theta, other.theta) &&\n      equals(this.phi, other.phi)\n    );\n  }\n\n  exactEquals(other) {\n    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n  }\n\n  /* eslint-disable brace-style */\n  // Cartographic (bearing 0 north, pitch 0 look from above)\n  get bearing() {\n    return 180 - degrees(this.phi);\n  }\n  set bearing(v) {\n    this.phi = Math.PI - radians(v);\n  }\n  get pitch() {\n    return degrees(this.theta);\n  }\n  set pitch(v) {\n    this.theta = radians(v);\n  }\n  // get pitch() { return 90 - degrees(this.phi); }\n  // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }\n  // get altitude() { return this.radius - 1; } // relative altitude\n\n  // lnglatZ coordinates\n  get longitude() {\n    return degrees(this.phi);\n  }\n  get latitude() {\n    return degrees(this.theta);\n  }\n  get lng() {\n    return degrees(this.phi);\n  }\n  get lat() {\n    return degrees(this.theta);\n  }\n  get z() {\n    return (this.radius - 1) * this.radiusScale;\n  }\n  /* eslint-enable brace-style */\n\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this.check();\n  }\n\n  clone() {\n    return new SphericalCoordinates().copy(this);\n  }\n\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this.check();\n  }\n\n  fromLngLatZ([lng, lat, z]) {\n    this.radius = 1 + z / this.radiusScale;\n    this.phi = radians(lat);\n    this.theta = radians(lng);\n  }\n\n  fromVector3(v) {\n    this.radius = vec3.length(v);\n    if (this.radius > 0) {\n      this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis\n      this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1)); // polar angle\n    }\n    return this.check();\n  }\n\n  toVector3() {\n    return new Vector3(0, 0, this.radius)\n      .rotateX({radians: this.theta})\n      .rotateZ({radians: this.phi});\n  }\n\n  // restrict phi to be betwee EPS and PI-EPS\n  makeSafe() {\n    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    return this;\n  }\n\n  check() {\n    // this.makeSafe();\n    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n      throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n    }\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}