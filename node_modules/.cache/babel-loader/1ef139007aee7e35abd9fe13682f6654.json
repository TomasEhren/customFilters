{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport { WorkerBody } from '@loaders.gl/worker-utils';\nvar requestId = 0;\nexport function createLoaderWorker(loader) {\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, payload) {\n      var input, _payload$options, options, result, message;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = type;\n              _context.next = _context.t0 === 'process' ? 3 : 16;\n              break;\n\n            case 3:\n              _context.prev = 3;\n              input = payload.input, _payload$options = payload.options, options = _payload$options === void 0 ? {} : _payload$options;\n              _context.next = 7;\n              return parseData({\n                loader: loader,\n                arrayBuffer: input,\n                options: options,\n                context: {\n                  parse: parseOnMainThread\n                }\n              });\n\n            case 7:\n              result = _context.sent;\n              WorkerBody.postMessage('done', {\n                result: result\n              });\n              _context.next = 15;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t1 = _context[\"catch\"](3);\n              message = _context.t1 instanceof Error ? _context.t1.message : '';\n              WorkerBody.postMessage('error', {\n                error: message\n              });\n\n            case 15:\n              return _context.abrupt(\"break\", 16);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 11]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nfunction parseOnMainThread(arrayBuffer, options) {\n  return new Promise(function (resolve, reject) {\n    var id = requestId++;\n\n    var onMessage = function onMessage(type, payload) {\n      if (payload.id !== id) {\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n    var payload = {\n      id: id,\n      input: arrayBuffer,\n      options: options\n    };\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\nfunction parseData(_x3) {\n  return _parseData.apply(this, arguments);\n}\n\nfunction _parseData() {\n  _parseData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var loader, arrayBuffer, options, context, data, parser, textDecoder;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            loader = _ref2.loader, arrayBuffer = _ref2.arrayBuffer, options = _ref2.options, context = _ref2.context;\n\n            if (!(loader.parseSync || loader.parse)) {\n              _context2.next = 6;\n              break;\n            }\n\n            data = arrayBuffer;\n            parser = loader.parseSync || loader.parse;\n            _context2.next = 13;\n            break;\n\n          case 6:\n            if (!loader.parseTextSync) {\n              _context2.next = 12;\n              break;\n            }\n\n            textDecoder = new TextDecoder();\n            data = textDecoder.decode(arrayBuffer);\n            parser = loader.parseTextSync;\n            _context2.next = 13;\n            break;\n\n          case 12:\n            throw new Error(\"Could not load data with \".concat(loader.name, \" loader\"));\n\n          case 13:\n            options = _objectSpread(_objectSpread({}, options), {}, {\n              modules: loader && loader.options && loader.options.modules || {},\n              worker: false\n            });\n            _context2.next = 16;\n            return parser(data, _objectSpread({}, options), context, loader);\n\n          case 16:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 17:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _parseData.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["WorkerBody","requestId","createLoaderWorker","loader","self","onmessage","type","payload","input","options","parseData","arrayBuffer","context","parse","parseOnMainThread","result","postMessage","message","error","Error","Promise","resolve","reject","id","onMessage","removeEventListener","addEventListener","parseSync","data","parser","parseTextSync","textDecoder","TextDecoder","decode","name","modules","worker"],"sources":["../../../../src/lib/worker-loader-utils/create-loader-worker.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport type {LoaderWithParser} from '../../types';\nimport {WorkerBody} from '@loaders.gl/worker-utils';\n// import {validateLoaderVersion} from './validate-loader-version';\n\nlet requestId = 0;\n\n/**\n * Set up a WebWorkerGlobalScope to talk with the main thread\n * @param loader\n */\nexport function createLoaderWorker(loader: LoaderWithParser) {\n  // Check that we are actually in a worker thread\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  WorkerBody.onmessage = async (type, payload) => {\n    switch (type) {\n      case 'process':\n        try {\n          // validateLoaderVersion(loader, data.source.split('@')[1]);\n\n          const {input, options = {}} = payload;\n\n          const result = await parseData({\n            loader,\n            arrayBuffer: input,\n            options,\n            context: {\n              parse: parseOnMainThread\n            }\n          });\n          WorkerBody.postMessage('done', {result});\n        } catch (error) {\n          const message = error instanceof Error ? error.message : '';\n          WorkerBody.postMessage('error', {error: message});\n        }\n        break;\n      default:\n    }\n  };\n}\n\nfunction parseOnMainThread(arrayBuffer: ArrayBuffer, options: {[key: string]: any}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const id = requestId++;\n\n    /**\n     */\n    const onMessage = (type, payload) => {\n      if (payload.id !== id) {\n        // not ours\n        return;\n      }\n\n      switch (type) {\n        case 'done':\n          WorkerBody.removeEventListener(onMessage);\n          resolve(payload.result);\n          break;\n\n        case 'error':\n          WorkerBody.removeEventListener(onMessage);\n          reject(payload.error);\n          break;\n\n        default:\n        // ignore\n      }\n    };\n\n    WorkerBody.addEventListener(onMessage);\n\n    // Ask the main thread to decode data\n    const payload = {id, input: arrayBuffer, options};\n    WorkerBody.postMessage('process', payload);\n  });\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arrayBuffer, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arrayBuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arrayBuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n"]},"metadata":{},"sourceType":"module"}