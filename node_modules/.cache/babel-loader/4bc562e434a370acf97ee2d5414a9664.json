{"ast":null,"code":"import { Matrix4, Vector3 } from '@math.gl/core';\nimport { Ellipsoid } from '@math.gl/geospatial';\nexport function getLodStatus(tile, frameState) {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n\n  return 'OUT';\n}\nexport function getProjectedRadius(tile, frameState) {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom\n  } = originalViewport;\n  const viewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);\n  const extraZ = projection * projection / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian).subtract(mbsCenterCartesian).normalize();\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();\n  return projectedRadius;\n}","map":{"version":3,"mappings":"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","names":["Matrix4","Vector3","Ellipsoid","getLodStatus","tile","frameState","lodMetricValue","isNaN","screenSize","getProjectedRadius","header","children","originalViewport","viewport","ViewportClass","constructor","longitude","latitude","height","width","bearing","zoom","pitch","mbsLat","mbs","mbsLon","mbsZ","mbsR","mbsCenterCartesian","boundingVolume","center","cameraPositionCartographic","unprojectPosition","cameraPosition","cameraPositionCartesian","WGS84","cartographicToCartesian","toEye","subtract","normalize","enuToCartesianMatrix","eastNorthUpToFixedFrame","cartesianToEnuMatrix","invert","cameraPositionEnu","transform","projection","Math","sqrt","extraZ","extraVertexEnu","extraVertexCartesian","extraVectorCartesian","radiusVector","cross","scale","sphereMbsBorderVertexCartesian","add","sphereMbsBorderVertexCartographic","cartesianToCartographic","projectedOrigin","project","projectedMbsBorderVertex","projectedRadius","magnitude"],"sources":["../../../../src/tileset/helpers/i3s-lod.ts"],"sourcesContent":["import {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport Tile3D from '../tile-3d';\nimport {FrameState} from './frame-state';\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const originalViewport = frameState.viewport;\n  const ViewportClass = originalViewport.constructor;\n  const {longitude, latitude, height, width, bearing, zoom} = originalViewport;\n  // @ts-ignore\n  const viewport = new ViewportClass({longitude, latitude, height, width, bearing, zoom, pitch: 0});\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  const toEye = new Vector3(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  const enuToCartesianMatrix = new Matrix4();\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  const cartesianToEnuMatrix = new Matrix4(enuToCartesianMatrix).invert();\n  const cameraPositionEnu = new Vector3(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  const extraVertexEnu = new Vector3([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = new Vector3(extraVertexCartesian)\n    .subtract(mbsCenterCartesian)\n    .normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = new Vector3(mbsCenterCartesian).add(radiusVector);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);\n  const projectedRadius = new Vector3(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n"]},"metadata":{},"sourceType":"module"}