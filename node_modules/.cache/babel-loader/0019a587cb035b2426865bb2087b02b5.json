{"ast":null,"code":"import _asyncToGenerator from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/regenerator/index.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isMobile } from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\nvar WorkerPool = /*#__PURE__*/function () {\n  function WorkerPool(props) {\n    _classCallCheck(this, WorkerPool);\n\n    _defineProperty(this, \"name\", 'unnamed');\n\n    _defineProperty(this, \"source\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"maxConcurrency\", 1);\n\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n\n    _defineProperty(this, \"onDebug\", function () {});\n\n    _defineProperty(this, \"reuseWorkers\", true);\n\n    _defineProperty(this, \"props\", {});\n\n    _defineProperty(this, \"jobQueue\", []);\n\n    _defineProperty(this, \"idleQueue\", []);\n\n    _defineProperty(this, \"count\", 0);\n\n    _defineProperty(this, \"isDestroyed\", false);\n\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  _createClass(WorkerPool, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this.idleQueue.forEach(function (worker) {\n        return worker.destroy();\n      });\n      this.isDestroyed = true;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      this.props = _objectSpread(_objectSpread({}, this.props), props);\n\n      if (props.name !== undefined) {\n        this.name = props.name;\n      }\n\n      if (props.maxConcurrency !== undefined) {\n        this.maxConcurrency = props.maxConcurrency;\n      }\n\n      if (props.maxMobileConcurrency !== undefined) {\n        this.maxMobileConcurrency = props.maxMobileConcurrency;\n      }\n\n      if (props.reuseWorkers !== undefined) {\n        this.reuseWorkers = props.reuseWorkers;\n      }\n\n      if (props.onDebug !== undefined) {\n        this.onDebug = props.onDebug;\n      }\n    }\n  }, {\n    key: \"startJob\",\n    value: function () {\n      var _startJob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name) {\n        var _this = this;\n\n        var onMessage,\n            onError,\n            startPromise,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                onMessage = _args.length > 1 && _args[1] !== undefined ? _args[1] : function (job, type, data) {\n                  return job.done(data);\n                };\n                onError = _args.length > 2 && _args[2] !== undefined ? _args[2] : function (job, error) {\n                  return job.error(error);\n                };\n                startPromise = new Promise(function (onStart) {\n                  _this.jobQueue.push({\n                    name: name,\n                    onMessage: onMessage,\n                    onError: onError,\n                    onStart: onStart\n                  });\n\n                  return _this;\n                });\n\n                this._startQueuedJob();\n\n                _context.next = 6;\n                return startPromise;\n\n              case 6:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function startJob(_x) {\n        return _startJob.apply(this, arguments);\n      }\n\n      return startJob;\n    }()\n  }, {\n    key: \"_startQueuedJob\",\n    value: function () {\n      var _startQueuedJob2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var workerThread, queuedJob, job;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.jobQueue.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                workerThread = this._getAvailableWorker();\n\n                if (workerThread) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                queuedJob = this.jobQueue.shift();\n\n                if (!queuedJob) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                this.onDebug({\n                  message: 'Starting job',\n                  name: queuedJob.name,\n                  workerThread: workerThread,\n                  backlog: this.jobQueue.length\n                });\n                job = new WorkerJob(queuedJob.name, workerThread);\n\n                workerThread.onMessage = function (data) {\n                  return queuedJob.onMessage(job, data.type, data.payload);\n                };\n\n                workerThread.onError = function (error) {\n                  return queuedJob.onError(job, error);\n                };\n\n                queuedJob.onStart(job);\n                _context2.prev = 12;\n                _context2.next = 15;\n                return job.result;\n\n              case 15:\n                _context2.prev = 15;\n                this.returnWorkerToQueue(workerThread);\n                return _context2.finish(15);\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[12,, 15, 18]]);\n      }));\n\n      function _startQueuedJob() {\n        return _startQueuedJob2.apply(this, arguments);\n      }\n\n      return _startQueuedJob;\n    }()\n  }, {\n    key: \"returnWorkerToQueue\",\n    value: function returnWorkerToQueue(worker) {\n      var shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n      if (shouldDestroyWorker) {\n        worker.destroy();\n        this.count--;\n      } else {\n        this.idleQueue.push(worker);\n      }\n\n      if (!this.isDestroyed) {\n        this._startQueuedJob();\n      }\n    }\n  }, {\n    key: \"_getAvailableWorker\",\n    value: function _getAvailableWorker() {\n      if (this.idleQueue.length > 0) {\n        return this.idleQueue.shift() || null;\n      }\n\n      if (this.count < this._getMaxConcurrency()) {\n        this.count++;\n        var name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n        return new WorkerThread({\n          name: name,\n          source: this.source,\n          url: this.url\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getMaxConcurrency\",\n    value: function _getMaxConcurrency() {\n      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n    }\n  }]);\n\n  return WorkerPool;\n}();\n\nexport { WorkerPool as default };","map":{"version":3,"mappings":"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","names":["isMobile","WorkerThread","WorkerJob","WorkerPool","constructor","props","_defineProperty","source","url","setProps","destroy","idleQueue","forEach","worker","isDestroyed","name","undefined","maxConcurrency","maxMobileConcurrency","reuseWorkers","onDebug","onMessage","job","type","data","done","onError","error","startPromise","Promise","onStart","jobQueue","push","_startQueuedJob","length","workerThread","_getAvailableWorker","queuedJob","shift","message","backlog","payload","result","returnWorkerToQueue","shouldDestroyWorker","count","_getMaxConcurrency","toLowerCase"],"sources":["../../../../src/lib/worker-farm/worker-pool.ts"],"sourcesContent":["import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}