{"ast":null,"code":"import log from '../utils/log';\nimport { createMat4, getCameraPosition, getFrustumPlanes } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals, clamp } from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport { getDistanceScales, getMeterZoom, lngLatToWorld, worldToLngLat, worldToPixels, pixelsToWorld } from '@math.gl/web-mercator';\nimport { PROJECTION_MODE } from '../lib/constants';\nconst DEGREES_TO_RADIANS = Math.PI / 180;\nconst IDENTITY = createMat4();\nconst ZERO_VECTOR = [0, 0, 0];\nconst DEFAULT_ZOOM = 0;\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\nexport default class Viewport {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      id = null,\n      x = 0,\n      y = 0,\n      width = 1,\n      height = 1\n    } = opts;\n    this.id = id || this.constructor.displayName || 'viewport';\n    this.x = x;\n    this.y = y;\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n\n    this._initProjectionMatrix(opts);\n\n    this._initPixelMatrices();\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n\n    if (this === viewport) {\n      return true;\n    }\n\n    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);\n  }\n\n  project(xyz) {\n    let {\n      topLeft = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  unproject(xyz) {\n    let {\n      topLeft = true,\n      targetZ\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const [x, y, z] = xyz;\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n\n    return xyz;\n  }\n\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n\n    return xyz;\n  }\n\n  getBounds() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const unprojectOption = {\n      targetZ: options.z || 0\n    };\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];\n  }\n\n  getDistanceScales() {\n    let coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n\n    return this.distanceScales;\n  }\n\n  containsPixel(_ref) {\n    let {\n      x,\n      y,\n      width = 1,\n      height = 1\n    } = _ref;\n    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;\n  }\n\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n    return this._frustumPlanes;\n  }\n\n  panByPosition(coords, pixel) {\n    return null;\n  }\n\n  getCameraPosition() {\n    return this.cameraPosition;\n  }\n\n  getCameraDirection() {\n    return this.cameraDirection;\n  }\n\n  getCameraUp() {\n    return this.cameraUp;\n  }\n\n  _createProjectionMatrix(_ref2) {\n    let {\n      orthographic,\n      fovyRadians,\n      aspect,\n      focalDistance,\n      near,\n      far\n    } = _ref2;\n    return orthographic ? new Matrix4().orthographic({\n      fovy: fovyRadians,\n      aspect,\n      focalDistance,\n      near,\n      far\n    }) : new Matrix4().perspective({\n      fovy: fovyRadians,\n      aspect,\n      near,\n      far\n    });\n  }\n\n  _initViewMatrix(opts) {\n    const {\n      viewMatrix = IDENTITY,\n      longitude = null,\n      latitude = null,\n      zoom = null,\n      position = null,\n      modelMatrix = null,\n      focalDistance = 1,\n      distanceScales = null\n    } = opts;\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n    this.zoom = zoom;\n\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial ? getMeterZoom({\n        latitude\n      }) + Math.log2(focalDistance) : DEFAULT_ZOOM;\n    }\n\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n    this.distanceScales = this.isGeospatial ? getDistanceScales({\n      latitude,\n      longitude\n    }) : distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = focalDistance;\n    this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n    this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n\n    if (position) {\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    if (this.isGeospatial) {\n      this.longitude = longitude;\n      this.latitude = latitude;\n      this.center = this._getCenterInWorld({\n        longitude,\n        latitude\n      });\n    } else {\n      this.center = position ? this.projectPosition(position) : [0, 0, 0];\n    }\n\n    this.viewMatrixUncentered = viewMatrix;\n    this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR).negate());\n  }\n\n  _getCenterInWorld(_ref3) {\n    let {\n      longitude,\n      latitude\n    } = _ref3;\n    const {\n      meterOffset,\n      distanceScales\n    } = this;\n    const center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n    if (meterOffset) {\n      const commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);\n      center.add(commonPosition);\n    }\n\n    return center;\n  }\n\n  _initProjectionMatrix(opts) {\n    const {\n      projectionMatrix = null,\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1,\n      far = 1000,\n      focalDistance = 1\n    } = opts;\n    this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({\n      orthographic,\n      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n      aspect: this.width / this.height,\n      focalDistance,\n      near,\n      far\n    });\n  }\n\n  _initPixelMatrices() {\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n    const viewportMatrix = createMat4();\n    const pixelProjectionMatrix = createMat4();\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.viewportMatrix = viewportMatrix;\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n    }\n  }\n\n}\nViewport.displayName = 'Viewport';","map":{"version":3,"mappings":"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","names":["log","createMat4","getCameraPosition","getFrustumPlanes","Matrix4","Vector3","equals","clamp","mat4","getDistanceScales","getMeterZoom","lngLatToWorld","worldToLngLat","worldToPixels","pixelsToWorld","PROJECTION_MODE","DEGREES_TO_RADIANS","Math","PI","IDENTITY","ZERO_VECTOR","DEFAULT_ZOOM","DEFAULT_DISTANCE_SCALES","unitsPerMeter","metersPerUnit","Viewport","constructor","opts","id","x","y","width","height","displayName","_frustumPlanes","_initViewMatrix","_initProjectionMatrix","_initPixelMatrices","bind","project","unproject","projectPosition","unprojectPosition","projectFlat","unprojectFlat","metersPerPixel","distanceScales","scale","projectionMode","isGeospatial","zoom","WEB_MERCATOR","WEB_MERCATOR_AUTO_OFFSET","viewport","projectionMatrix","viewMatrix","xyz","topLeft","worldPosition","coord","pixelProjectionMatrix","y2","length","targetZ","z","targetZWorld","pixelUnprojectionMatrix","X","Y","Z","Number","isFinite","result","getBounds","options","unprojectOption","topRight","bottomLeft","bottomRight","min","max","coordinateOrigin","longitude","latitude","highPrecision","containsPixel","near","Object","assign","viewProjectionMatrix","panByPosition","coords","pixel","cameraPosition","getCameraDirection","cameraDirection","getCameraUp","cameraUp","_createProjectionMatrix","orthographic","fovyRadians","aspect","focalDistance","far","fovy","perspective","position","modelMatrix","log2","pow","meterOffset","transformVector","center","_getCenterInWorld","viewMatrixUncentered","multiplyRight","translate","negate","commonPosition","add","vpm","multiply","viewMatrixInverse","invert","viewportMatrix","warn"],"sources":["../../../src/viewports/viewport.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport log from '../utils/log';\nimport {createMat4, getCameraPosition, getFrustumPlanes} from '../utils/math-utils';\n\nimport {Matrix4, Vector3, equals, clamp} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\n\nimport {\n  getDistanceScales,\n  getMeterZoom,\n  lngLatToWorld,\n  worldToLngLat,\n  worldToPixels,\n  pixelsToWorld\n} from '@math.gl/web-mercator';\n\nimport {PROJECTION_MODE} from '../lib/constants';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nconst IDENTITY = createMat4();\n\nconst ZERO_VECTOR = [0, 0, 0];\n\nconst DEFAULT_ZOOM = 0;\n\nconst DEFAULT_DISTANCE_SCALES = {\n  unitsPerMeter: [1, 1, 1],\n  metersPerUnit: [1, 1, 1]\n};\n\nexport default class Viewport {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n  constructor(opts = {}) {\n    const {\n      id = null,\n      // Window width/height in pixels (for pixel projection)\n      x = 0,\n      y = 0,\n      width = 1,\n      height = 1\n    } = opts;\n\n    this.id = id || this.constructor.displayName || 'viewport';\n\n    this.x = x;\n    this.y = y;\n    // Silently allow apps to send in w,h = 0,0\n    this.width = width || 1;\n    this.height = height || 1;\n    this._frustumPlanes = {};\n\n    this._initViewMatrix(opts);\n    this._initProjectionMatrix(opts);\n    this._initPixelMatrices();\n\n    // Bind methods for easy access\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectPosition = this.projectPosition.bind(this);\n    this.unprojectPosition = this.unprojectPosition.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n  }\n\n  get metersPerPixel() {\n    return this.distanceScales.metersPerUnit[2] / this.scale;\n  }\n\n  get projectionMode() {\n    if (this.isGeospatial) {\n      return this.zoom < 12\n        ? PROJECTION_MODE.WEB_MERCATOR\n        : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;\n    }\n    return PROJECTION_MODE.IDENTITY;\n  }\n\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n  equals(viewport) {\n    if (!(viewport instanceof Viewport)) {\n      return false;\n    }\n    if (this === viewport) {\n      return true;\n    }\n\n    return (\n      viewport.width === this.width &&\n      viewport.height === this.height &&\n      viewport.scale === this.scale &&\n      equals(viewport.projectionMatrix, this.projectionMatrix) &&\n      equals(viewport.viewMatrix, this.viewMatrix)\n    );\n    // TODO - check distance scales?\n  }\n\n  /**\n   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n   * using viewport projection parameters\n   * - [longitude, latitude] to [x, y]\n   * - [longitude, latitude, Z] => [x, y, z]\n   * Note: By default, returns top-left coordinates for canvas/SVG type render\n   *\n   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether projected coords are top left\n   * @return {Array} - [x, y] or [x, y, z] in top left coords\n   */\n  project(xyz, {topLeft = true} = {}) {\n    const worldPosition = this.projectPosition(xyz);\n    const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);\n\n    const [x, y] = coord;\n    const y2 = topLeft ? y : this.height - y;\n    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];\n  }\n\n  /**\n   * Unproject pixel coordinates on screen onto world coordinates,\n   * (possibly [lon, lat]) on map.\n   * - [x, y] => [lng, lat]\n   * - [x, y, z] => [lng, lat, Z]\n   * @param {Array} xyz -\n   * @param {Object} opts - options\n   * @param {Object} opts.topLeft=true - Whether origin is top left\n   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n   */\n  unproject(xyz, {topLeft = true, targetZ} = {}) {\n    const [x, y, z] = xyz;\n\n    const y2 = topLeft ? y : this.height - y;\n    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];\n    const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);\n    const [X, Y, Z] = this.unprojectPosition(coord);\n\n    if (Number.isFinite(z)) {\n      return [X, Y, Z];\n    }\n    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];\n  }\n\n  // NON_LINEAR PROJECTION HOOKS\n  // Used for web meractor projection\n\n  projectPosition(xyz) {\n    const [X, Y] = this.projectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];\n    return [X, Y, Z];\n  }\n\n  unprojectPosition(xyz) {\n    const [X, Y] = this.unprojectFlat(xyz);\n    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];\n    return [X, Y, Z];\n  }\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n  projectFlat(xyz) {\n    if (this.isGeospatial) {\n      // Shader clamps latitude to +-89.9, see /shaderlib/project/project.glsl.js\n      // lngLatToWorld([0, -89.9])[1] = -317.9934163758329\n      // lngLatToWorld([0, 89.9])[1] = 829.9934163758271\n      const result = lngLatToWorld(xyz);\n      result[1] = clamp(result[1], -318, 830);\n      return result;\n    }\n    return xyz;\n  }\n\n  /**\n   * Unproject world point [x,y] on map onto {lat, lon} on sphere\n   * @param {object|Vector} xy - object with {x,y} members\n   *  representing point on projected map plane\n   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n   *   Has toArray method if you need a GeoJSON Array.\n   *   Per cartographic tradition, lat and lon are specified as degrees.\n   */\n  unprojectFlat(xyz) {\n    if (this.isGeospatial) {\n      return worldToLngLat(xyz);\n    }\n    return xyz;\n  }\n\n  getBounds(options = {}) {\n    const unprojectOption = {targetZ: options.z || 0};\n\n    const topLeft = this.unproject([0, 0], unprojectOption);\n    const topRight = this.unproject([this.width, 0], unprojectOption);\n    const bottomLeft = this.unproject([0, this.height], unprojectOption);\n    const bottomRight = this.unproject([this.width, this.height], unprojectOption);\n\n    return [\n      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),\n      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),\n      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])\n    ];\n  }\n\n  getDistanceScales(coordinateOrigin = null) {\n    if (coordinateOrigin) {\n      return getDistanceScales({\n        longitude: coordinateOrigin[0],\n        latitude: coordinateOrigin[1],\n        highPrecision: true\n      });\n    }\n    return this.distanceScales;\n  }\n\n  containsPixel({x, y, width = 1, height = 1}) {\n    return (\n      x < this.x + this.width &&\n      this.x < x + width &&\n      y < this.y + this.height &&\n      this.y < y + height\n    );\n  }\n\n  // Extract frustum planes in common space\n  getFrustumPlanes() {\n    if (this._frustumPlanes.near) {\n      return this._frustumPlanes;\n    }\n\n    Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));\n\n    return this._frustumPlanes;\n  }\n\n  // EXPERIMENTAL METHODS\n\n  /**\n   * Needed by panning and linear transition\n   * Pan the viewport to place a given world coordinate at screen point [x, y]\n   *\n   * @param {Array} coords - world coordinates\n   * @param {Array} pixel - [x,y] coordinates on screen\n   * @return {Object} props of the new viewport\n   */\n  panByPosition(coords, pixel) {\n    return null;\n  }\n\n  getCameraPosition() {\n    return this.cameraPosition;\n  }\n\n  getCameraDirection() {\n    return this.cameraDirection;\n  }\n\n  getCameraUp() {\n    return this.cameraUp;\n  }\n\n  // INTERNAL METHODS\n\n  _createProjectionMatrix({orthographic, fovyRadians, aspect, focalDistance, near, far}) {\n    return orthographic\n      ? new Matrix4().orthographic({fovy: fovyRadians, aspect, focalDistance, near, far})\n      : new Matrix4().perspective({fovy: fovyRadians, aspect, near, far});\n  }\n\n  /* eslint-disable complexity, max-statements */\n  _initViewMatrix(opts) {\n    const {\n      // view matrix\n      viewMatrix = IDENTITY,\n\n      longitude = null, // Anchor: lng lat zoom makes viewport work w/ geospatial coordinate systems\n      latitude = null,\n      zoom = null,\n\n      position = null, // Anchor position offset (in meters for geospatial viewports)\n      modelMatrix = null, // A model matrix to be applied to position, to match the layer props API\n      focalDistance = 1, // Only needed for orthographic views\n\n      distanceScales = null\n    } = opts;\n\n    // Check if we have a geospatial anchor\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);\n\n    this.zoom = zoom;\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial\n        ? getMeterZoom({latitude}) + Math.log2(focalDistance)\n        : DEFAULT_ZOOM;\n    }\n    const scale = Math.pow(2, this.zoom);\n    this.scale = scale;\n\n    // Calculate distance scales if lng/lat/zoom are provided\n    this.distanceScales = this.isGeospatial\n      ? getDistanceScales({latitude, longitude})\n      : distanceScales || DEFAULT_DISTANCE_SCALES;\n\n    this.focalDistance = focalDistance;\n\n    this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);\n    this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);\n\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n    if (position) {\n      // Apply model matrix if supplied\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    if (this.isGeospatial) {\n      // Determine camera center\n      this.longitude = longitude;\n      this.latitude = latitude;\n      this.center = this._getCenterInWorld({longitude, latitude});\n    } else {\n      this.center = position ? this.projectPosition(position) : [0, 0, 0];\n    }\n    this.viewMatrixUncentered = viewMatrix;\n    // Make a centered version of the matrix for projection modes without an offset\n    this.viewMatrix = new Matrix4()\n      // Apply the uncentered view matrix\n      .multiplyRight(this.viewMatrixUncentered)\n      // And center it\n      .translate(new Vector3(this.center || ZERO_VECTOR).negate());\n  }\n  /* eslint-enable complexity, max-statements */\n\n  _getCenterInWorld({longitude, latitude}) {\n    const {meterOffset, distanceScales} = this;\n\n    // Make a centered version of the matrix for projection modes without an offset\n    const center = new Vector3(this.projectPosition([longitude, latitude, 0]));\n\n    if (meterOffset) {\n      const commonPosition = new Vector3(meterOffset)\n        // Convert to pixels in current zoom\n        .scale(distanceScales.unitsPerMeter);\n      center.add(commonPosition);\n    }\n\n    return center;\n  }\n\n  _initProjectionMatrix(opts) {\n    const {\n      // Projection matrix\n      projectionMatrix = null,\n\n      // Projection matrix parameters, used if projectionMatrix not supplied\n      orthographic = false,\n      fovyRadians,\n      fovy = 75,\n      near = 0.1, // Distance of near clipping plane\n      far = 1000, // Distance of far clipping plane\n      focalDistance = 1\n    } = opts;\n\n    this.projectionMatrix =\n      projectionMatrix ||\n      this._createProjectionMatrix({\n        orthographic,\n        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,\n        aspect: this.width / this.height,\n        focalDistance,\n        near,\n        far\n      });\n  }\n\n  _initPixelMatrices() {\n    // Note: As usual, matrix operations should be applied in \"reverse\" order\n    // since vectors will be multiplied in from the right during transformation\n    const vpm = createMat4();\n    mat4.multiply(vpm, vpm, this.projectionMatrix);\n    mat4.multiply(vpm, vpm, this.viewMatrix);\n    this.viewProjectionMatrix = vpm;\n\n    // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n\n    // Calculate inverse view matrix\n    this.viewMatrixInverse = mat4.invert([], this.viewMatrix) || this.viewMatrix;\n\n    // Decompose camera parameters\n    this.cameraPosition = getCameraPosition(this.viewMatrixInverse);\n\n    /*\n     * Builds matrices that converts preprojected lngLats to screen pixels\n     * and vice versa.\n     * Note: Currently returns bottom-left coordinates!\n     * Note: Starts with the GL projection matrix and adds steps to the\n     *       scale and translate that matrix onto the window.\n     * Note: WebGL controls clip space to screen projection with gl.viewport\n     *       and does not need this step.\n     */\n\n    // matrix for conversion from world location to screen (pixel) coordinates\n    const viewportMatrix = createMat4(); // matrix from NDC to viewport.\n    const pixelProjectionMatrix = createMat4(); // matrix from world space to viewport.\n    mat4.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);\n    mat4.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);\n    mat4.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);\n    this.pixelProjectionMatrix = pixelProjectionMatrix;\n    this.viewportMatrix = viewportMatrix;\n\n    this.pixelUnprojectionMatrix = mat4.invert(createMat4(), this.pixelProjectionMatrix);\n    if (!this.pixelUnprojectionMatrix) {\n      log.warn('Pixel project matrix not invertible')();\n      // throw new Error('Pixel project matrix not invertible');\n    }\n  }\n}\n\nViewport.displayName = 'Viewport';\n"]},"metadata":{},"sourceType":"module"}