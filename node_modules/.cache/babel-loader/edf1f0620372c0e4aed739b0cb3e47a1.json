{"ast":null,"code":"import { COORDINATE_SYSTEM } from '../../lib/constants';\nimport { getOffsetOrigin } from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport { addMetersToLngLat } from '@math.gl/web-mercator';\n\nfunction lngLatZToWorldPosition(lngLatZ, viewport) {\n  let offsetMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const p = viewport.projectPosition(lngLatZ);\n\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  const normalizedParams = { ...opts\n  };\n  let {\n    coordinateSystem\n  } = opts;\n  const {\n    viewport,\n    coordinateOrigin,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  normalizedParams.coordinateSystem = coordinateSystem;\n  return normalizedParams;\n}\n\nexport function getWorldPosition(position, _ref) {\n  let {\n    viewport,\n    modelMatrix,\n    coordinateSystem,\n    coordinateOrigin,\n    offsetMode\n  } = _ref;\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);\n  }\n}\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n  const {\n    geospatialOrigin,\n    shaderCoordinateOrigin,\n    offsetMode\n  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}","map":{"version":3,"mappings":"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","names":["COORDINATE_SYSTEM","getOffsetOrigin","WebMercatorViewport","vec4","vec3","addMetersToLngLat","lngLatZToWorldPosition","lngLatZ","viewport","offsetMode","p","projectPosition","longitude","latitude","z","distanceScales","getDistanceScales","unitsPerMeter","normalizeParameters","opts","normalizedParams","coordinateSystem","coordinateOrigin","fromCoordinateSystem","fromCoordinateOrigin","DEFAULT","isGeospatial","LNGLAT","CARTESIAN","undefined","getWorldPosition","position","modelMatrix","x","y","transformMat4","LNGLAT_OFFSETS","METER_OFFSETS","params","geospatialOrigin","shaderCoordinateOrigin","worldPosition","positionCommonSpace","sub"],"sources":["../../../../src/shaderlib/project/project-functions.js"],"sourcesContent":["/**\n * Projection utils\n * TODO: move to Viewport class?\n */\nimport {COORDINATE_SYSTEM} from '../../lib/constants';\nimport {getOffsetOrigin} from './viewport-uniforms';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\n\nimport * as vec4 from 'gl-matrix/vec4';\nimport * as vec3 from 'gl-matrix/vec3';\nimport {addMetersToLngLat} from '@math.gl/web-mercator';\n\n// In project.glsl, offset modes calculate z differently from LNG_LAT mode.\n// offset modes apply the y adjustment (unitsPerMeter2) when projecting z\n// LNG_LAT mode only use the linear scale.\nfunction lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {\n  const p = viewport.projectPosition(lngLatZ);\n\n  // TODO - avoid using instanceof\n  if (offsetMode && viewport instanceof WebMercatorViewport) {\n    const [longitude, latitude, z = 0] = lngLatZ;\n    const distanceScales = viewport.getDistanceScales([longitude, latitude]);\n    p[2] = z * distanceScales.unitsPerMeter[2];\n  }\n  return p;\n}\n\nfunction normalizeParameters(opts) {\n  const normalizedParams = {...opts};\n\n  let {coordinateSystem} = opts;\n  const {viewport, coordinateOrigin, fromCoordinateSystem, fromCoordinateOrigin} = opts;\n\n  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n    coordinateSystem = viewport.isGeospatial\n      ? COORDINATE_SYSTEM.LNGLAT\n      : COORDINATE_SYSTEM.CARTESIAN;\n  }\n\n  if (fromCoordinateSystem === undefined) {\n    normalizedParams.fromCoordinateSystem = coordinateSystem;\n  }\n  if (fromCoordinateOrigin === undefined) {\n    normalizedParams.fromCoordinateOrigin = coordinateOrigin;\n  }\n\n  normalizedParams.coordinateSystem = coordinateSystem;\n\n  return normalizedParams;\n}\n\nexport function getWorldPosition(\n  position,\n  {viewport, modelMatrix, coordinateSystem, coordinateOrigin, offsetMode}\n) {\n  let [x, y, z = 0] = position;\n\n  if (modelMatrix) {\n    [x, y, z] = vec4.transformMat4([], [x, y, z, 1.0], modelMatrix);\n  }\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return lngLatZToWorldPosition(\n        [x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)],\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      return lngLatZToWorldPosition(\n        addMetersToLngLat(coordinateOrigin, [x, y, z]),\n        viewport,\n        offsetMode\n      );\n\n    case COORDINATE_SYSTEM.CARTESIAN:\n    default:\n      return viewport.isGeospatial\n        ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]]\n        : viewport.projectPosition([x, y, z]);\n  }\n}\n\n/**\n * Equivalent to project_position in project.glsl\n * projects a user supplied position to world position directly with or without\n * a reference coordinate system\n * @param {array} position - [x, y, z]\n * @param {object} params\n * @param {Viewport} params.viewport - the current viewport\n * @param {number} params.coordinateSystem - the reference coordinate system used\n *   align world position\n * @param {array} params.coordinateOrigin - the reference coordinate origin used\n *   to align world position\n * @param {Matrix4} [params.modelMatrix] - the model matrix of the supplied position\n * @param {number} [params.fromCoordinateSystem] - the coordinate system that the\n *   supplied position is in. Default to the same as `coordinateSystem`.\n * @param {array} [params.fromCoordinateOrigin] - the coordinate origin that the\n *   supplied position is in. Default to the same as `coordinateOrigin`.\n */\nexport function projectPosition(position, params) {\n  const {\n    viewport,\n    coordinateSystem,\n    coordinateOrigin,\n    // optional\n    modelMatrix,\n    fromCoordinateSystem,\n    fromCoordinateOrigin\n  } = normalizeParameters(params);\n\n  const {geospatialOrigin, shaderCoordinateOrigin, offsetMode} = getOffsetOrigin(\n    viewport,\n    coordinateSystem,\n    coordinateOrigin\n  );\n\n  const worldPosition = getWorldPosition(position, {\n    viewport,\n    modelMatrix,\n    coordinateSystem: fromCoordinateSystem,\n    coordinateOrigin: fromCoordinateOrigin,\n    offsetMode\n  });\n\n  if (offsetMode) {\n    const positionCommonSpace = viewport.projectPosition(\n      geospatialOrigin || shaderCoordinateOrigin\n    );\n    vec3.sub(worldPosition, worldPosition, positionCommonSpace);\n  }\n\n  return worldPosition;\n}\n"]},"metadata":{},"sourceType":"module"}