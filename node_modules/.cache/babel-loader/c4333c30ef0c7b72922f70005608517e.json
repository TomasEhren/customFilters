{"ast":null,"code":"import { Vector3, assert, _MathUtils } from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\nexport default function scaleToGeodeticSurface(cartesian, ellipsoid) {\n  let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();\n  const {\n    oneOverRadii,\n    oneOverRadiiSquared,\n    centerToleranceSquared\n  } = ellipsoid;\n  scratchVector.from(cartesian);\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(intersection.x * oneOverRadiiSquaredX * 2.0, intersection.y * oneOverRadiiSquaredY * 2.0, intersection.z * oneOverRadiiSquaredZ * 2.0);\n  let lambda = (1.0 - ratio) * cartesian.len() / (0.5 * gradient.len());\n  let correction = 0.0;\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n    const derivative = -2.0 * denominator;\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}","map":{"version":3,"mappings":"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","names":["Vector3","assert","_MathUtils","vec3","scratchVector","scaleToGeodeticSurfaceIntersection","scaleToGeodeticSurfaceGradient","scaleToGeodeticSurface","cartesian","ellipsoid","result","oneOverRadii","oneOverRadiiSquared","centerToleranceSquared","from","positionX","x","positionY","y","positionZ","z","oneOverRadiiX","oneOverRadiiY","oneOverRadiiZ","x2","y2","z2","squaredNorm","ratio","Math","sqrt","Number","isFinite","undefined","intersection","copy","scale","to","oneOverRadiiSquaredX","oneOverRadiiSquaredY","oneOverRadiiSquaredZ","gradient","set","lambda","len","correction","xMultiplier","yMultiplier","zMultiplier","func","xMultiplier2","yMultiplier2","zMultiplier2","xMultiplier3","yMultiplier3","zMultiplier3","denominator","derivative","abs","EPSILON12"],"sources":["../../../../src/ellipsoid/helpers/scale-to-geodetic-surface.js"],"sourcesContent":["/* eslint-disable */\nimport {Vector3, assert, _MathUtils} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport default function scaleToGeodeticSurface(cartesian, ellipsoid, result = new Vector3()) {\n  const {oneOverRadii, oneOverRadiiSquared, centerToleranceSquared} = ellipsoid;\n\n  scratchVector.from(cartesian);\n\n  const positionX = cartesian.x;\n  const positionY = cartesian.y;\n  const positionZ = cartesian.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(\n    intersection.x * oneOverRadiiSquaredX * 2.0,\n    intersection.y * oneOverRadiiSquaredY * 2.0,\n    intersection.z * oneOverRadiiSquaredZ * 2.0\n  );\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = ((1.0 - ratio) * cartesian.len()) / (0.5 * gradient.len());\n  let correction = 0.0;\n\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n"]},"metadata":{},"sourceType":"module"}