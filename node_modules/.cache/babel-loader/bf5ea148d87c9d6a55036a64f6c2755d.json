{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\nvar _STRATEGIES;\n\nimport Tile2DHeader from './tile-2d-header';\nimport { getTileIndices as _getTileIndices, tileToBoundingBox } from './utils';\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4 } from '@math.gl/core';\nvar TILE_STATE_VISITED = 1;\nvar TILE_STATE_VISIBLE = 2;\nexport var STRATEGY_NEVER = 'never';\nexport var STRATEGY_REPLACE = 'no-overlap';\nexport var STRATEGY_DEFAULT = 'best-available';\nvar DEFAULT_CACHE_SCALE = 5;\nvar STRATEGIES = (_STRATEGIES = {}, _defineProperty(_STRATEGIES, STRATEGY_DEFAULT, updateTileStateDefault), _defineProperty(_STRATEGIES, STRATEGY_REPLACE, updateTileStateReplace), _defineProperty(_STRATEGIES, STRATEGY_NEVER, function () {}), _STRATEGIES);\n\nvar Tileset2D = /*#__PURE__*/function () {\n  function Tileset2D(opts) {\n    var _this = this;\n\n    _classCallCheck(this, Tileset2D);\n\n    this.opts = opts;\n\n    this.onTileLoad = function (tile) {\n      _this.opts.onTileLoad(tile);\n\n      if (_this.opts.maxCacheByteSize) {\n        _this._cacheByteSize += tile.byteLength;\n\n        _this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n    this.setOptions(opts);\n  }\n\n  _createClass(Tileset2D, [{\n    key: \"tiles\",\n    get: function get() {\n      return this._tiles;\n    }\n  }, {\n    key: \"selectedTiles\",\n    get: function get() {\n      return this._selectedTiles;\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return this._selectedTiles.every(function (tile) {\n        return tile.isLoaded;\n      });\n    }\n  }, {\n    key: \"needsReload\",\n    get: function get() {\n      return this._selectedTiles.some(function (tile) {\n        return tile.needsReload;\n      });\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(opts) {\n      Object.assign(this.opts, opts);\n\n      if (Number.isFinite(opts.maxZoom)) {\n        this._maxZoom = Math.floor(opts.maxZoom);\n      }\n\n      if (Number.isFinite(opts.minZoom)) {\n        this._minZoom = Math.ceil(opts.minZoom);\n      }\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var _iterator = _createForOfIteratorHelper(this._cache.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tile = _step.value;\n\n          if (tile.isLoading) {\n            tile.abort();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._cache.clear();\n\n      this._tiles = [];\n      this._selectedTiles = null;\n    }\n  }, {\n    key: \"reloadAll\",\n    value: function reloadAll() {\n      var _iterator2 = _createForOfIteratorHelper(this._cache.keys()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tileId = _step2.value;\n\n          var tile = this._cache.get(tileId);\n\n          if (!this._selectedTiles.includes(tile)) {\n            this._cache.delete(tileId);\n          } else {\n            tile.setNeedsReload();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(viewport) {\n      var _this2 = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          zRange = _ref.zRange,\n          modelMatrix = _ref.modelMatrix;\n\n      var modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n      var isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n\n      if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n        if (isModelMatrixNew) {\n          this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n          this._modelMatrix = modelMatrixAsMatrix4;\n        }\n\n        this._viewport = viewport;\n        var tileIndices = this.getTileIndices({\n          viewport: viewport,\n          maxZoom: this._maxZoom,\n          minZoom: this._minZoom,\n          zRange: zRange,\n          modelMatrix: this._modelMatrix,\n          modelMatrixInverse: this._modelMatrixInverse\n        });\n        this._selectedTiles = tileIndices.map(function (index) {\n          return _this2._getTile(index, true);\n        });\n\n        if (this._dirty) {\n          this._rebuildTree();\n        }\n      } else if (this.needsReload) {\n        this._selectedTiles = this._selectedTiles.map(function (tile) {\n          return _this2._getTile({\n            x: tile.x,\n            y: tile.y,\n            z: tile.z\n          });\n        });\n      }\n\n      var changed = this.updateTileStates();\n\n      this._pruneRequests();\n\n      if (this._dirty) {\n        this._resizeCache();\n      }\n\n      if (changed) {\n        this._frameNumber++;\n      }\n\n      return this._frameNumber;\n    }\n  }, {\n    key: \"getTileIndices\",\n    value: function getTileIndices(_ref2) {\n      var viewport = _ref2.viewport,\n          maxZoom = _ref2.maxZoom,\n          minZoom = _ref2.minZoom,\n          zRange = _ref2.zRange,\n          modelMatrix = _ref2.modelMatrix,\n          modelMatrixInverse = _ref2.modelMatrixInverse;\n      var _this$opts = this.opts,\n          tileSize = _this$opts.tileSize,\n          extent = _this$opts.extent,\n          zoomOffset = _this$opts.zoomOffset;\n      return _getTileIndices({\n        viewport: viewport,\n        maxZoom: maxZoom,\n        minZoom: minZoom,\n        zRange: zRange,\n        tileSize: tileSize,\n        extent: extent,\n        modelMatrix: modelMatrix,\n        modelMatrixInverse: modelMatrixInverse,\n        zoomOffset: zoomOffset\n      });\n    }\n  }, {\n    key: \"getTileMetadata\",\n    value: function getTileMetadata(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          z = _ref3.z;\n      var tileSize = this.opts.tileSize;\n      return {\n        bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)\n      };\n    }\n  }, {\n    key: \"getParentIndex\",\n    value: function getParentIndex(tileIndex) {\n      tileIndex.x = Math.floor(tileIndex.x / 2);\n      tileIndex.y = Math.floor(tileIndex.y / 2);\n      tileIndex.z -= 1;\n      return tileIndex;\n    }\n  }, {\n    key: \"updateTileStates\",\n    value: function updateTileStates() {\n      var refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n      var visibilities = new Array(this._cache.size);\n      var i = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(this._cache.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var tile = _step3.value;\n          visibilities[i++] = tile.isVisible;\n          tile.isSelected = false;\n          tile.isVisible = false;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(this._selectedTiles),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _tile = _step4.value;\n          _tile.isSelected = true;\n          _tile.isVisible = true;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n      i = 0;\n\n      var _iterator5 = _createForOfIteratorHelper(this._cache.values()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _tile2 = _step5.value;\n\n          if (visibilities[i++] !== _tile2.isVisible) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_pruneRequests\",\n    value: function _pruneRequests() {\n      var maxRequests = this.opts.maxRequests;\n      var abortCandidates = [];\n      var ongoingRequestCount = 0;\n\n      var _iterator6 = _createForOfIteratorHelper(this._cache.values()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _tile3 = _step6.value;\n\n          if (_tile3.isLoading) {\n            ongoingRequestCount++;\n\n            if (!_tile3.isSelected && !_tile3.isVisible) {\n              abortCandidates.push(_tile3);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n        var tile = abortCandidates.shift();\n        tile.abort();\n        ongoingRequestCount--;\n      }\n    }\n  }, {\n    key: \"_rebuildTree\",\n    value: function _rebuildTree() {\n      var _cache = this._cache;\n\n      var _iterator7 = _createForOfIteratorHelper(_cache.values()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var tile = _step7.value;\n          tile.parent = null;\n          tile.children.length = 0;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(_cache.values()),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _tile4 = _step8.value;\n\n          var parent = this._getNearestAncestor(_tile4.x, _tile4.y, _tile4.z);\n\n          _tile4.parent = parent;\n\n          if (parent) {\n            parent.children.push(_tile4);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"_resizeCache\",\n    value: function _resizeCache() {\n      var _cache = this._cache,\n          opts = this.opts;\n      var maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n      var maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n      var overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n      if (overflown) {\n        var _iterator9 = _createForOfIteratorHelper(_cache),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var _step9$value = _slicedToArray(_step9.value, 2),\n                tileId = _step9$value[0],\n                tile = _step9$value[1];\n\n            if (!tile.isVisible) {\n              this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n\n              _cache.delete(tileId);\n\n              this.opts.onTileUnload(tile);\n            }\n\n            if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        this._rebuildTree();\n\n        this._dirty = true;\n      }\n\n      if (this._dirty) {\n        this._tiles = Array.from(this._cache.values()).sort(function (t1, t2) {\n          return t1.z - t2.z;\n        });\n        this._dirty = false;\n      }\n    }\n  }, {\n    key: \"_getTile\",\n    value: function _getTile(_ref4, create) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          z = _ref4.z;\n      var tileId = \"\".concat(x, \",\").concat(y, \",\").concat(z);\n\n      var tile = this._cache.get(tileId);\n\n      var needsReload = false;\n\n      if (!tile && create) {\n        tile = new Tile2DHeader({\n          x: x,\n          y: y,\n          z: z\n        });\n        Object.assign(tile, this.getTileMetadata(tile));\n        needsReload = true;\n\n        this._cache.set(tileId, tile);\n\n        this._dirty = true;\n      } else if (tile && tile.needsReload) {\n        needsReload = true;\n      }\n\n      if (needsReload) {\n        tile.loadData({\n          getData: this.opts.getTileData,\n          requestScheduler: this._requestScheduler,\n          onLoad: this.onTileLoad,\n          onError: this.opts.onTileError\n        });\n      }\n\n      return tile;\n    }\n  }, {\n    key: \"_getNearestAncestor\",\n    value: function _getNearestAncestor(x, y, z) {\n      var _this$_minZoom = this._minZoom,\n          _minZoom = _this$_minZoom === void 0 ? 0 : _this$_minZoom;\n\n      var index = {\n        x: x,\n        y: y,\n        z: z\n      };\n\n      while (index.z > _minZoom) {\n        index = this.getParentIndex(index);\n\n        var parent = this._getTile(index);\n\n        if (parent) {\n          return parent;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Tileset2D;\n}();\n\nexport { Tileset2D as default };\n\nfunction updateTileStateDefault(allTiles) {\n  var _iterator10 = _createForOfIteratorHelper(allTiles),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var tile = _step10.value;\n      tile.state = 0;\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  var _iterator11 = _createForOfIteratorHelper(allTiles),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _tile5 = _step11.value;\n\n      if (_tile5.isSelected && !getPlaceholderInAncestors(_tile5)) {\n        getPlaceholderInChildren(_tile5);\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  var _iterator12 = _createForOfIteratorHelper(allTiles),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var _tile6 = _step12.value;\n      _tile6.isVisible = Boolean(_tile6.state & TILE_STATE_VISIBLE);\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n}\n\nfunction updateTileStateReplace(allTiles) {\n  var _iterator13 = _createForOfIteratorHelper(allTiles),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var tile = _step13.value;\n      tile.state = 0;\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  var _iterator14 = _createForOfIteratorHelper(allTiles),\n      _step14;\n\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var _tile7 = _step14.value;\n\n      if (_tile7.isSelected) {\n        getPlaceholderInAncestors(_tile7);\n      }\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n\n  var sortedTiles = Array.from(allTiles).sort(function (t1, t2) {\n    return t1.z - t2.z;\n  });\n\n  var _iterator15 = _createForOfIteratorHelper(sortedTiles),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var _tile8 = _step15.value;\n      _tile8.isVisible = Boolean(_tile8.state & TILE_STATE_VISIBLE);\n\n      if (_tile8.isVisible || _tile8.state & TILE_STATE_VISITED) {\n        var _iterator16 = _createForOfIteratorHelper(_tile8.children),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var child = _step16.value;\n            child.state = TILE_STATE_VISITED;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      } else if (_tile8.isSelected) {\n        getPlaceholderInChildren(_tile8);\n      }\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n}\n\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n\n    tile = tile.parent;\n  }\n\n  return false;\n}\n\nfunction getPlaceholderInChildren(tile) {\n  var _iterator17 = _createForOfIteratorHelper(tile.children),\n      _step17;\n\n  try {\n    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n      var child = _step17.value;\n\n      if (child.isLoaded || child.content) {\n        child.state |= TILE_STATE_VISIBLE;\n      } else {\n        getPlaceholderInChildren(child);\n      }\n    }\n  } catch (err) {\n    _iterator17.e(err);\n  } finally {\n    _iterator17.f();\n  }\n}","map":{"version":3,"mappings":"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","names":["Tile2DHeader","getTileIndices","tileToBoundingBox","RequestScheduler","Matrix4","TILE_STATE_VISITED","TILE_STATE_VISIBLE","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","STRATEGIES","updateTileStateDefault","updateTileStateReplace","Tileset2D","constructor","opts","onTileLoad","tile","maxCacheByteSize","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","_modelMatrix","_modelMatrixInverse","setOptions","every","isLoaded","some","needsReload","Object","assign","Number","isFinite","maxZoom","_maxZoom","Math","floor","minZoom","_minZoom","ceil","finalize","values","isLoading","abort","clear","reloadAll","keys","tileId","get","includes","delete","setNeedsReload","update","viewport","zRange","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","equals","clone","invert","tileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","x","y","z","changed","updateTileStates","_pruneRequests","tileSize","extent","zoomOffset","getTileMetadata","bbox","getParentIndex","tileIndex","refinementStrategy","visibilities","Array","size","i","isVisible","isSelected","from","abortCandidates","ongoingRequestCount","push","length","shift","parent","children","_getNearestAncestor","maxCacheSize","Infinity","selectedTiles","overflown","onTileUnload","sort","t1","t2","create","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","onTileError","allTiles","state","getPlaceholderInAncestors","getPlaceholderInChildren","Boolean","sortedTiles","child","content"],"sources":["../../../src/tile-layer/tileset-2d.js"],"sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4} from '@math.gl/core';\n\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload() {\n    return this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   * @param {*} modelMatrix\n   */\n  update(viewport, {zRange, modelMatrix} = {}) {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile =>\n        this._getTile({x: tile.x, y: tile.y, z: tile.z})\n      );\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse}) {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    const {tileSize} = this.opts;\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function'\n      ? refinementStrategy\n      : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Private methods */\n\n  _pruneRequests() {\n    const {maxRequests} = this.opts;\n\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n          this.opts.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({x, y, z});\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\n\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.z - t2.z);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n\n    if (tile.isVisible || tile.state & TILE_STATE_VISITED) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(tile) {\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}