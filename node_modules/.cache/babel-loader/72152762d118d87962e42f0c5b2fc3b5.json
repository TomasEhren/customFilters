{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { Model, Texture2D, Framebuffer, isWebGL2 } from '@luma.gl/core';\nvar AGGREGATE_VS = \"#define SHADER_NAME data-filter-vertex-shader\\n\\n#ifdef FLOAT_TARGET\\n  attribute float filterIndices;\\n  attribute float filterPrevIndices;\\n#else\\n  attribute vec2 filterIndices;\\n  attribute vec2 filterPrevIndices;\\n#endif\\n\\nvarying vec4 vColor;\\nconst float component = 1.0 / 255.0;\\n\\nvoid main() {\\n  #ifdef FLOAT_TARGET\\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\\n  #else\\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\\n    float col = filterIndices.x;\\n    float row = filterIndices.y * 4.0;\\n    float channel = floor(row);\\n    row = fract(row);\\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\\n  #endif\\n  gl_PointSize = 1.0;\\n}\\n\";\nvar AGGREGATE_FS = \"#define SHADER_NAME data-filter-fragment-shader\\nprecision highp float;\\n\\nvarying vec4 vColor;\\n\\nvoid main() {\\n  if (dataFilter_value < 0.5) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n}\\n\";\nexport function supportsFloatTarget(gl) {\n  return gl.getExtension('EXT_float_blend') && (gl.getExtension('EXT_color_buffer_float') || gl.getExtension('WEBGL_color_buffer_float'));\n}\nexport function getFramebuffer(gl, useFloatTarget) {\n  if (useFloatTarget) {\n    return new Framebuffer(gl, {\n      width: 1,\n      height: 1,\n      attachments: _defineProperty({}, 36064, new Texture2D(gl, {\n        format: isWebGL2(gl) ? 34836 : 6408,\n        type: 5126,\n        mipmaps: false\n      }))\n    });\n  }\n\n  return new Framebuffer(gl, {\n    width: 256,\n    height: 64,\n    depth: false\n  });\n}\nexport function getModel(gl, shaderOptions, useFloatTarget) {\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n\n  if (useFloatTarget) {\n    shaderOptions.defines.FLOAT_TARGET = 1;\n  }\n\n  return new Model(gl, _objectSpread({\n    id: 'data-filter-aggregation-model',\n    vertexCount: 1,\n    isInstanced: false,\n    drawMode: 0,\n    vs: AGGREGATE_VS,\n    fs: AGGREGATE_FS\n  }, shaderOptions));\n}\nexport var parameters = {\n  blend: true,\n  blendFunc: [1, 1, 1, 1],\n  blendEquation: [32774, 32774],\n  depthTest: false\n};","map":{"version":3,"mappings":";;AAAA,SAAQA,KAAR,EAAeC,SAAf,EAA0BC,WAA1B,EAAuCC,QAAvC,QAAsD,eAAtD;AAGA,IAAMC,YAAY,89BAAlB;AAiCA,IAAMC,YAAY,wMAAlB;AAcA,OAAO,SAASC,mBAAT,CAA6BC,EAA7B,EAAiC;EAEtC,OACEA,EAAE,CAACC,YAAHD,CAAgB,iBAAhBA,MAECA,EAAE,CAACC,YAAHD,CAAgB,wBAAhBA,KAECA,EAAE,CAACC,YAAHD,CAAgB,0BAAhBA,CAJFA,CADF;AAOD;AAGD,OAAO,SAASE,cAAT,CAAwBF,EAAxB,EAA4BG,cAA5B,EAA4C;EACjD,IAAIA,cAAJ,EAAoB;IAClB,OAAO,IAAIR,WAAJ,CAAgBK,EAAhB,EAAoB;MACzBI,KAAK,EAAE,CADkB;MAEzBC,MAAM,EAAE,CAFiB;MAGzBC,WAAW,sBACT,KADS,EACe,IAAIZ,SAAJ,CAAcM,EAAd,EAAkB;QACxCO,MAAM,EAAEX,QAAQ,CAACI,EAAD,CAARJ,eADgC;QAExCY,IAAI,MAFoC;QAGxCC,OAAO,EAAE;MAH+B,CAAlB,CADf;IAHc,CAApB,CAAP;EAWD;;EACD,OAAO,IAAId,WAAJ,CAAgBK,EAAhB,EAAoB;IACzBI,KAAK,EAAE,GADkB;IAEzBC,MAAM,EAAE,EAFiB;IAGzBK,KAAK,EAAE;EAHkB,CAApB,CAAP;AAKD;AAGD,OAAO,SAASC,QAAT,CAAkBX,EAAlB,EAAsBY,aAAtB,EAAqCT,cAArC,EAAqD;EAC1DS,aAAa,CAACC,OAAdD,CAAsBE,mBAAtBF,GAA4C,CAA5CA;;EACA,IAAIT,cAAJ,EAAoB;IAClBS,aAAa,CAACC,OAAdD,CAAsBG,YAAtBH,GAAqC,CAArCA;EACD;;EAED,OAAO,IAAInB,KAAJ,CAAUO,EAAV;IACLgB,EAAE,EAAE,+BADC;IAELC,WAAW,EAAE,CAFR;IAGLC,WAAW,EAAE,KAHR;IAILC,QAAQ,GAJH;IAKLC,EAAE,EAAEvB,YALC;IAMLwB,EAAE,EAAEvB;EANC,GAOFc,aAPE,EAAP;AASD;AAED,OAAO,IAAMU,UAAU,GAAG;EACxBC,KAAK,EAAE,IADiB;EAExBC,SAAS,EAAE,YAFa;EAGxBC,aAAa,EAAE,cAHS;EAIxBC,SAAS,EAAE;AAJa,CAAnB","names":["Model","Texture2D","Framebuffer","isWebGL2","AGGREGATE_VS","AGGREGATE_FS","supportsFloatTarget","gl","getExtension","getFramebuffer","useFloatTarget","width","height","attachments","format","type","mipmaps","depth","getModel","shaderOptions","defines","NON_INSTANCED_MODEL","FLOAT_TARGET","id","vertexCount","isInstanced","drawMode","vs","fs","parameters","blend","blendFunc","blendEquation","depthTest"],"sources":["../../../src/data-filter/aggregator.js"],"sourcesContent":["import {Model, Texture2D, Framebuffer, isWebGL2} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nconst AGGREGATE_VS = `\\\n#define SHADER_NAME data-filter-vertex-shader\n\n#ifdef FLOAT_TARGET\n  attribute float filterIndices;\n  attribute float filterPrevIndices;\n#else\n  attribute vec2 filterIndices;\n  attribute vec2 filterPrevIndices;\n#endif\n\nvarying vec4 vColor;\nconst float component = 1.0 / 255.0;\n\nvoid main() {\n  #ifdef FLOAT_TARGET\n    dataFilter_value *= float(filterIndices != filterPrevIndices);\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n    vColor = vec4(0.0, 0.0, 0.0, 1.0);\n  #else\n    // Float texture is not supported: pack result into 4 channels x 256 px x 64px\n    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);\n    float col = filterIndices.x;\n    float row = filterIndices.y * 4.0;\n    float channel = floor(row);\n    row = fract(row);\n    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));\n    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);\n  #endif\n  gl_PointSize = 1.0;\n}\n`;\n\nconst AGGREGATE_FS = `\\\n#define SHADER_NAME data-filter-fragment-shader\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main() {\n  if (dataFilter_value < 0.5) {\n    discard;\n  }\n  gl_FragColor = vColor;\n}\n`;\n\nexport function supportsFloatTarget(gl) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#Support_for_float_textures_doesnt_mean_you_can_render_into_them!\n  return (\n    gl.getExtension('EXT_float_blend') &&\n    // WebGL 2\n    (gl.getExtension('EXT_color_buffer_float') ||\n      // WebGL 1\n      gl.getExtension('WEBGL_color_buffer_float'))\n  );\n}\n\n// A 1x1 framebuffer object that encodes the total count of filtered items\nexport function getFramebuffer(gl, useFloatTarget) {\n  if (useFloatTarget) {\n    return new Framebuffer(gl, {\n      width: 1,\n      height: 1,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: new Texture2D(gl, {\n          format: isWebGL2(gl) ? GL.RGBA32F : GL.RGBA,\n          type: GL.FLOAT,\n          mipmaps: false\n        })\n      }\n    });\n  }\n  return new Framebuffer(gl, {\n    width: 256,\n    height: 64,\n    depth: false\n  });\n}\n\n// Increments the counter based on dataFilter_value\nexport function getModel(gl, shaderOptions, useFloatTarget) {\n  shaderOptions.defines.NON_INSTANCED_MODEL = 1;\n  if (useFloatTarget) {\n    shaderOptions.defines.FLOAT_TARGET = 1;\n  }\n\n  return new Model(gl, {\n    id: 'data-filter-aggregation-model',\n    vertexCount: 1,\n    isInstanced: false,\n    drawMode: GL.POINTS,\n    vs: AGGREGATE_VS,\n    fs: AGGREGATE_FS,\n    ...shaderOptions\n  });\n}\n\nexport const parameters = {\n  blend: true,\n  blendFunc: [GL.ONE, GL.ONE, GL.ONE, GL.ONE],\n  blendEquation: [GL.FUNC_ADD, GL.FUNC_ADD],\n  depthTest: false\n};\n"]},"metadata":{},"sourceType":"module"}