{"ast":null,"code":"import { isResponse } from '../../javascript-utils/is-type';\nimport { getResourceContentLength, getResourceUrlAndType } from './resource-utils';\nexport async function makeResponse(resource) {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  const headers = {};\n  const contentLength = getResourceContentLength(resource);\n\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  const {\n    url,\n    type\n  } = getResourceUrlAndType(resource);\n\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  const initialDataUrl = await getInitialDataUrl(resource);\n\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  if (typeof resource === 'string') {\n    resource = new TextEncoder().encode(resource);\n  }\n\n  const response = new Response(resource, {\n    headers\n  });\n  Object.defineProperty(response, 'url', {\n    value: url\n  });\n  return response;\n}\nexport async function checkResponse(response) {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\nexport function checkResponseSync(response) {\n  if (!response.ok) {\n    let message = \"\".concat(response.status, \" \").concat(response.statusText);\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n    throw new Error(message);\n  }\n}\n\nasync function getResponseError(response) {\n  let message = \"Failed to fetch resource \".concat(response.url, \" (\").concat(response.status, \"): \");\n\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n\n    if (contentType.includes('application/json')) {\n      text += \" \".concat(await response.text());\n    }\n\n    message += text;\n    message = message.length > 60 ? \"\".concat(message.slice(60), \"...\") : message;\n  } catch (error) {}\n\n  return message;\n}\n\nasync function getInitialDataUrl(resource) {\n  const INITIAL_DATA_LENGTH = 5;\n\n  if (typeof resource === 'string') {\n    return \"data:,\".concat(resource.slice(0, INITIAL_DATA_LENGTH));\n  }\n\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise(resolve => {\n      const reader = new FileReader();\n\n      reader.onload = event => {\n        var _event$target;\n\n        return resolve(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);\n      };\n\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return \"data:base64,\".concat(base64);\n  }\n\n  return null;\n}\n\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n\n  return btoa(binary);\n}","map":{"version":3,"mappings":"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","names":["isResponse","getResourceContentLength","getResourceUrlAndType","makeResponse","resource","headers","contentLength","String","url","type","initialDataUrl","getInitialDataUrl","TextEncoder","encode","response","Response","Object","defineProperty","value","checkResponse","ok","message","getResponseError","Error","checkResponseSync","status","statusText","length","slice","contentType","get","text","includes","error","INITIAL_DATA_LENGTH","Blob","blobSlice","Promise","resolve","reader","FileReader","onload","event","target","_event$target","result","readAsDataURL","ArrayBuffer","base64","arrayBufferToBase64","buffer","binary","bytes","Uint8Array","i","byteLength","fromCharCode","btoa"],"sources":["../../../../src/lib/utils/response-utils.ts"],"sourcesContent":["import {isResponse} from '../../javascript-utils/is-type';\nimport {getResourceContentLength, getResourceUrlAndType} from './resource-utils';\n\n/**\n * Returns a Response object\n * Adds content-length header when possible\n *\n * @param resource\n */\nexport async function makeResponse(resource: any): Promise<Response> {\n  if (isResponse(resource)) {\n    return resource;\n  }\n\n  // Add content-length header if possible\n  const headers: {[header: string]: string} = {};\n\n  const contentLength = getResourceContentLength(resource);\n  if (contentLength >= 0) {\n    headers['content-length'] = String(contentLength);\n  }\n\n  // `new Response(File)` does not preserve content-type and URL\n  // so we add them here\n  const {url, type} = getResourceUrlAndType(resource);\n  if (type) {\n    headers['content-type'] = type;\n  }\n\n  // Add a custom header with initial bytes if available\n  const initialDataUrl = await getInitialDataUrl(resource);\n  if (initialDataUrl) {\n    headers['x-first-bytes'] = initialDataUrl;\n  }\n\n  // TODO - is this the best way of handling strings?\n  // Maybe package as data URL instead?\n  if (typeof resource === 'string') {\n    // Convert to ArrayBuffer to avoid Response treating it as a URL\n    resource = new TextEncoder().encode(resource);\n  }\n\n  // Attempt to create a Response from the resource, adding headers and setting url\n  const response = new Response(resource, {headers});\n  // We can't control `Response.url` via constructor, use a property override to record URL.\n  Object.defineProperty(response, 'url', {value: url});\n  return response;\n}\n\n/**\n * Checks response status (async) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport async function checkResponse(response: Response): Promise<void> {\n  if (!response.ok) {\n    const message = await getResponseError(response);\n    throw new Error(message);\n  }\n}\n\n/**\n * Checks response status (sync) and throws a helpful error message if status is not OK.\n * @param response\n */\nexport function checkResponseSync(response: Response): void {\n  if (!response.ok) {\n    let message = `${response.status} ${response.statusText}`;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n    throw new Error(message);\n  }\n}\n\n// HELPERS\n\nasync function getResponseError(response): Promise<string> {\n  let message = `Failed to fetch resource ${response.url} (${response.status}): `;\n  try {\n    const contentType = response.headers.get('Content-Type');\n    let text = response.statusText;\n    if (contentType.includes('application/json')) {\n      text += ` ${await response.text()}`;\n    }\n    message += text;\n    message = message.length > 60 ? `${message.slice(60)}...` : message;\n  } catch (error) {\n    // eslint forbids return in a finally statement, so we just catch here\n  }\n  return message;\n}\n\nasync function getInitialDataUrl(resource): Promise<string | null> {\n  const INITIAL_DATA_LENGTH = 5;\n  if (typeof resource === 'string') {\n    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;\n  }\n  if (resource instanceof Blob) {\n    const blobSlice = resource.slice(0, 5);\n    return await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event?.target?.result as string);\n      reader.readAsDataURL(blobSlice);\n    });\n  }\n  if (resource instanceof ArrayBuffer) {\n    const slice = resource.slice(0, INITIAL_DATA_LENGTH);\n    const base64 = arrayBufferToBase64(slice);\n    return `data:base64,${base64}`;\n  }\n  return null;\n}\n\n// https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n"]},"metadata":{},"sourceType":"module"}