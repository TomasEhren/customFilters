{"ast":null,"code":"import { copyPaddedStringToDataView, copyPaddedArrayBufferToDataView } from '@loaders.gl/loader-utils';\nconst MAGIC_glTF = 0x46546c67;\nconst MAGIC_JSON = 0x4e4f534a;\nconst MAGIC_BIN = 0x004e4942;\nconst LE = true;\nexport default function encodeGLBSync(glb, dataView) {\n  let byteOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    magic = MAGIC_glTF,\n    version = 2,\n    json = {},\n    binary\n  } = glb;\n  const byteOffsetStart = byteOffset;\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE);\n    dataView.setUint32(byteOffset + 4, version, LE);\n    dataView.setUint32(byteOffset + 8, 0, LE);\n  }\n\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12;\n  const byteOffsetJsonHeader = byteOffset;\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE);\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE);\n  }\n\n  byteOffset += 8;\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8;\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE);\n  }\n\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE);\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE);\n    }\n\n    byteOffset += 8;\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8;\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE);\n    }\n  }\n\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE);\n  }\n\n  return byteOffset;\n}","map":{"version":3,"mappings":"AACA,SACEA,0BADF,EAEEC,+BAFF,QAGO,0BAHP;AAKA,MAAMC,UAAU,GAAG,UAAnB;AACA,MAAMC,UAAU,GAAG,UAAnB;AACA,MAAMC,SAAS,GAAG,UAAlB;AAEA,MAAMC,EAAE,GAAG,IAAX;AAKA,eAAe,SAASC,aAAT,CAAuBC,GAAvB,EAA4BC,QAA5B,EAAoE;EAAA,IAA9BC,UAA8B,uEAAjB,CAAiB;EAAA,IAAdC,OAAc,uEAAJ,EAAI;EACjF,MAAM;IAACC,KAAK,GAAGT,UAAT;IAAqBU,OAAO,GAAG,CAA/B;IAAkCC,IAAI,GAAG,EAAzC;IAA6CC;EAA7C,IAAuDP,GAA7D;EAEA,MAAMQ,eAAe,GAAGN,UAAxB;;EAGA,IAAID,QAAJ,EAAc;IACZA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCG,KAAnCH,EAA0CH,EAA1CG;IACAA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCI,OAAnCJ,EAA4CH,EAA5CG;IACAA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmC,CAAnCA,EAAsCH,EAAtCG;EACD;;EACD,MAAMS,oBAAoB,GAAGR,UAAU,GAAG,CAA1C;EACAA,UAAU,IAAI,EAAdA;EAGA,MAAMS,oBAAoB,GAAGT,UAA7B;;EACA,IAAID,QAAJ,EAAc;IACZA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmC,CAAnCA,EAAsCH,EAAtCG;IACAA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCL,UAAnCK,EAA+CH,EAA/CG;EACD;;EACDC,UAAU,IAAI,CAAdA;EAGA,MAAMU,UAAU,GAAGC,IAAI,CAACC,SAALD,CAAeP,IAAfO,CAAnB;EACAX,UAAU,GAAGT,0BAA0B,CAACQ,QAAD,EAAWC,UAAX,EAAuBU,UAAvB,EAAmC,CAAnC,CAAvCV;;EAGA,IAAID,QAAJ,EAAc;IACZ,MAAMc,cAAc,GAAGb,UAAU,GAAGS,oBAAbT,GAAoC,CAA3D;IACAD,QAAQ,CAACQ,SAATR,CAAmBU,oBAAoB,GAAG,CAA1CV,EAA6Cc,cAA7Cd,EAA6DH,EAA7DG;EACD;;EAGD,IAAIM,MAAJ,EAAY;IACV,MAAMS,mBAAmB,GAAGd,UAA5B;;IAGA,IAAID,QAAJ,EAAc;MACZA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmC,CAAnCA,EAAsCH,EAAtCG;MACAA,QAAQ,CAACQ,SAATR,CAAmBC,UAAU,GAAG,CAAhCD,EAAmCJ,SAAnCI,EAA8CH,EAA9CG;IACD;;IACDC,UAAU,IAAI,CAAdA;IAEAA,UAAU,GAAGR,+BAA+B,CAACO,QAAD,EAAWC,UAAX,EAAuBK,MAAvB,EAA+B,CAA/B,CAA5CL;;IAGA,IAAID,QAAJ,EAAc;MACZ,MAAMgB,aAAa,GAAGf,UAAU,GAAGc,mBAAbd,GAAmC,CAAzD;MACAD,QAAQ,CAACQ,SAATR,CAAmBe,mBAAmB,GAAG,CAAzCf,EAA4CgB,aAA5ChB,EAA2DH,EAA3DG;IACD;EACF;;EAGD,IAAIA,QAAJ,EAAc;IACZ,MAAMiB,cAAc,GAAGhB,UAAU,GAAGM,eAApC;IACAP,QAAQ,CAACQ,SAATR,CAAmBS,oBAAnBT,EAAyCiB,cAAzCjB,EAAyDH,EAAzDG;EACD;;EAED,OAAOC,UAAP;AACD","names":["copyPaddedStringToDataView","copyPaddedArrayBufferToDataView","MAGIC_glTF","MAGIC_JSON","MAGIC_BIN","LE","encodeGLBSync","glb","dataView","byteOffset","options","magic","version","json","binary","byteOffsetStart","setUint32","byteOffsetFileLength","byteOffsetJsonHeader","jsonString","JSON","stringify","jsonByteLength","byteOffsetBinHeader","binByteLength","fileByteLength"],"sources":["../../../../src/lib/encoders/encode-glb.ts"],"sourcesContent":["/* eslint-disable camelcase, max-statements */\nimport {\n  copyPaddedStringToDataView,\n  copyPaddedArrayBufferToDataView\n} from '@loaders.gl/loader-utils';\n\nconst MAGIC_glTF = 0x46546c67; // glTF in ASCII\nconst MAGIC_JSON = 0x4e4f534a; // JSON in ASCII\nconst MAGIC_BIN = 0x004e4942; // BIN\\0 in ASCII\n\nconst LE = true; // Binary GLTF is little endian.\n\n// Encode the full GLB buffer with header etc\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#\n// glb-file-format-specification\nexport default function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {\n  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;\n\n  const byteOffsetStart = byteOffset;\n\n  // Write GLB Header\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').\n    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32\n    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last\n  }\n  const byteOffsetFileLength = byteOffset + 8;\n  byteOffset += 12; // GLB_FILE_HEADER_SIZE\n\n  // Write the JSON chunk header\n  const byteOffsetJsonHeader = byteOffset;\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)\n    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type\n  }\n  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n  // Write the JSON chunk\n  const jsonString = JSON.stringify(json);\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, jsonString, 4);\n\n  // Now we know the JSON chunk length so we can write it.\n  if (dataView) {\n    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE\n    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)\n  }\n\n  // Write the BIN chunk if present. The BIN chunk is optional.\n  if (binary) {\n    const byteOffsetBinHeader = byteOffset;\n\n    // Write the BIN chunk header\n    if (dataView) {\n      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)\n      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type\n    }\n    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE\n\n    byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, binary, 4);\n\n    // Now we know the BIN chunk length so we can write it.\n    if (dataView) {\n      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE\n      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)\n    }\n  }\n\n  // Now we know the glb file length so we can write it.\n  if (dataView) {\n    const fileByteLength = byteOffset - byteOffsetStart;\n    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)\n  }\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}