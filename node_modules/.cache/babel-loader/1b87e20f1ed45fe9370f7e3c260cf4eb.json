{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength } from '../gltf-utils/gltf-utils';\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst BYTES = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\nconst GL_SAMPLER = {\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  constructor() {\n    _defineProperty(this, \"baseUri\", '');\n\n    _defineProperty(this, \"json\", {});\n\n    _defineProperty(this, \"buffers\", []);\n\n    _defineProperty(this, \"images\", []);\n  }\n\n  postProcess(gltf) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      json,\n      buffers = [],\n      images = [],\n      baseUri = ''\n    } = gltf;\n    assert(json);\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  _resolveTree(json) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null;\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    if (typeof index === 'object') {\n      return index;\n    }\n\n    const object = this.json[array] && this.json[array][index];\n\n    if (!object) {\n      console.warn(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n    }\n\n    return object;\n  }\n\n  _resolveScene(scene, index) {\n    scene.id = scene.id || \"scene-\".concat(index);\n    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    node.id = node.id || \"node-\".concat(index);\n\n    if (node.children) {\n      node.children = node.children.map(child => this.getNode(child));\n    }\n\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce((accum, meshIndex) => {\n        const mesh = this.getMesh(meshIndex);\n        accum.id = mesh.id;\n        accum.primitives = accum.primitives.concat(mesh.primitives);\n        return accum;\n      }, {\n        primitives: []\n      });\n    }\n\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    skin.id = skin.id || \"skin-\".concat(index);\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    mesh.id = mesh.id || \"mesh-\".concat(index);\n\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map(primitive => {\n        primitive = { ...primitive\n        };\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n\n        return primitive;\n      });\n    }\n\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    material.id = material.id || \"material-\".concat(index);\n\n    if (material.normalTexture) {\n      material.normalTexture = { ...material.normalTexture\n      };\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n\n    if (material.occlusionTexture) {\n      material.occlustionTexture = { ...material.occlustionTexture\n      };\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = { ...material.emmisiveTexture\n      };\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness\n      };\n      const mr = material.pbrMetallicRoughness;\n\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = { ...mr.baseColorTexture\n        };\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture\n        };\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    accessor.id = accessor.id || \"accessor-\".concat(index);\n\n    if (accessor.bufferView !== undefined) {\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {\n        ArrayType,\n        byteLength\n      } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);\n      }\n\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);\n    }\n\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    texture.id = texture.id || \"texture-\".concat(index);\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    sampler.id = sampler.id || \"sampler-\".concat(index);\n    sampler.parameters = {};\n\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    image.id = image.id || \"image-\".concat(index);\n\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    const preloadedImage = this.images[index];\n\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView, index) {\n    const bufferIndex = bufferView.buffer;\n    const result = {\n      id: \"bufferView-\".concat(index),\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || \"camera-\".concat(index);\n\n    if (camera.perspective) {}\n\n    if (camera.orthographic) {}\n\n    return camera;\n  }\n\n}\n\nexport function postProcessGLTF(gltf, options) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}","map":{"version":3,"mappings":"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","names":["assert","getAccessorArrayTypeAndLength","COMPONENTS","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","BYTES","GL_SAMPLER","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","REPEAT","LINEAR","NEAREST_MIPMAP_LINEAR","SAMPLER_PARAMETER_GLTF_TO_GL","magFilter","minFilter","wrapS","wrapT","DEFAULT_SAMPLER","getBytesFromComponentType","componentType","getSizeFromAccessorType","type","GLTFPostProcessor","constructor","_defineProperty","postProcess","gltf","options","json","buffers","images","baseUri","_resolveTree","bufferViews","map","bufView","i","_resolveBufferView","image","_resolveImage","samplers","sampler","_resolveSampler","textures","texture","_resolveTexture","accessors","accessor","_resolveAccessor","materials","material","_resolveMaterial","meshes","mesh","_resolveMesh","nodes","node","_resolveNode","skins","skin","_resolveSkin","scenes","scene","_resolveScene","undefined","getScene","index","_get","getNode","getSkin","getMesh","getMaterial","getAccessor","getCamera","getTexture","getSampler","getImage","getBufferView","getBuffer","array","object","console","warn","id","children","child","length","reduce","accum","meshIndex","primitives","concat","camera","inverseBindMatrices","primitive","attributes","attribute","indices","normalTexture","occlusionTexture","occlustionTexture","emissiveTexture","emmisiveTexture","emissiveFactor","pbrMetallicRoughness","mr","baseColorTexture","metallicRoughnessTexture","bufferView","bytesPerComponent","components","bytesPerElement","buffer","ArrayType","byteLength","byteOffset","cutBuffer","arrayBuffer","slice","byteStride","_getValueFromInterleavedBuffer","count","value","result","Uint8Array","elementOffset","set","source","parameters","key","glEnum","_enumSamplerParameter","preloadedImage","bufferIndex","data","_resolveCamera","perspective","orthographic","postProcessGLTF"],"sources":["../../../../src/lib/api/post-process-gltf.ts"],"sourcesContent":["import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n"]},"metadata":{},"sourceType":"module"}