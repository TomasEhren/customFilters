{"ast":null,"code":"import { assert } from '@loaders.gl/loader-utils';\nimport { GL_EXTENSIONS_CONSTANTS } from '../gl-extensions';\nimport { extractMipmapImages } from '../utils/extract-mipmap-images';\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\nconst DDS_PIXEL_FORMATS = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\nconst DDS_SIZE_FUNCTIONS = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\nexport function isDDS(data) {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\nexport function parseDDS(data) {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), 'DDS: Unsupported format, must contain a FourCC code');\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, \"DDS: Unknown pixel format \".concat(pixelFormatNumber));\n  let mipMapLevels = 1;\n\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\nexport function getDxt1LevelSize(width, height) {\n  return (width + 3 >> 2) * (height + 3 >> 2) * 8;\n}\nexport function getDxtXLevelSize(width, height) {\n  return (width + 3 >> 2) * (height + 3 >> 2) * 16;\n}\n\nfunction int32ToFourCC(value) {\n  return String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n}","map":{"version":3,"mappings":"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","names":["assert","GL_EXTENSIONS_CONSTANTS","extractMipmapImages","DDS_CONSTANTS","MAGIC_NUMBER","HEADER_LENGTH","MAGIC_NUMBER_INDEX","HEADER_SIZE_INDEX","HEADER_FLAGS_INDEX","HEADER_HEIGHT_INDEX","HEADER_WIDTH_INDEX","MIPMAPCOUNT_INDEX","HEADER_PF_FLAGS_INDEX","HEADER_PF_FOURCC_INDEX","DDSD_MIPMAPCOUNT","DDPF_FOURCC","DDS_PIXEL_FORMATS","DXT1","COMPRESSED_RGB_S3TC_DXT1_EXT","DXT3","COMPRESSED_RGBA_S3TC_DXT3_EXT","DXT5","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_ATC_WEBGL","ATCA","COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL","ATCI","COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL","getATCLevelSize","getDxt1LevelSize","getATCALevelSize","getDxtXLevelSize","getATCILevelSize","DDS_SIZE_FUNCTIONS","isDDS","data","header","Uint32Array","magic","parseDDS","Int32Array","pixelFormatNumber","Boolean","fourCC","int32ToFourCC","internalFormat","sizeFunction","mipMapLevels","Math","max","width","height","dataOffset","image","Uint8Array","value","String","fromCharCode"],"sources":["../../../../src/lib/parsers/parse-dds.ts"],"sourcesContent":["import type {TextureLevel} from '../../types';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\n\nconst DDS_PIXEL_FORMATS: Record<string, number> = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\n\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\n\nconst DDS_SIZE_FUNCTIONS: Record<string, (width: number, height: number) => number> = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\n\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data: ArrayBuffer): TextureLevel[] {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(\n    Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC),\n    'DDS: Unsupported format, must contain a FourCC code'\n  );\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n\n  let mipMapLevels = 1;\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value: number): string {\n  return String.fromCharCode(\n    value & 0xff,\n    (value >> 8) & 0xff,\n    (value >> 16) & 0xff,\n    (value >> 24) & 0xff\n  );\n}\n"]},"metadata":{},"sourceType":"module"}