{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { classifyRings, project, readFeature } from '../../helpers/binary-util-functions';\nlet endPos;\nlet cmd;\nlet cmdLen;\nlet length;\nlet x;\nlet y;\nlet i;\nexport const TEST_EXPORTS = {\n  classifyRings\n};\nexport default class VectorTileFeature {\n  constructor(pbf, end, extent, keys, values, geometryInfo) {\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"extent\", void 0);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"_pbf\", void 0);\n\n    _defineProperty(this, \"_geometry\", void 0);\n\n    _defineProperty(this, \"_keys\", void 0);\n\n    _defineProperty(this, \"_values\", void 0);\n\n    _defineProperty(this, \"_geometryInfo\", void 0);\n\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._geometryInfo = geometryInfo;\n    pbf.readFields(readFeature, this, end);\n  }\n\n  loadGeometry() {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n    endPos = pbf.readVarint() + pbf.pos;\n    cmd = 1;\n    length = 0;\n    x = 0;\n    y = 0;\n    i = 0;\n    const indices = [];\n    const data = [];\n\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          indices.push(i);\n        }\n\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        if (i > 0) {\n          const start = indices[indices.length - 1];\n          data.push(data[start], data[start + 1]);\n          i += 2;\n        }\n      } else {\n        throw new Error(\"unknown command \".concat(cmd));\n      }\n    }\n\n    return {\n      data,\n      indices\n    };\n  }\n\n  _toBinaryCoordinates(transform) {\n    const geom = this.loadGeometry();\n    let geometry;\n    transform(geom.data, this);\n    const coordLength = 2;\n\n    switch (this.type) {\n      case 1:\n        this._geometryInfo.pointFeaturesCount++;\n        this._geometryInfo.pointPositionsCount += geom.indices.length;\n        geometry = {\n          type: 'Point',\n          ...geom\n        };\n        break;\n\n      case 2:\n        this._geometryInfo.lineFeaturesCount++;\n        this._geometryInfo.linePathsCount += geom.indices.length;\n        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n        geometry = {\n          type: 'LineString',\n          ...geom\n        };\n        break;\n\n      case 3:\n        geometry = classifyRings(geom);\n        this._geometryInfo.polygonFeaturesCount++;\n        this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n\n        for (const indices of geometry.indices) {\n          this._geometryInfo.polygonRingsCount += indices.length;\n        }\n\n        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n        break;\n\n      default:\n        throw new Error(\"Invalid geometry type: \".concat(this.type));\n    }\n\n    const result = {\n      type: 'Feature',\n      geometry,\n      properties: this.properties\n    };\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toBinaryCoordinates(options) {\n    if (typeof options === 'function') {\n      return this._toBinaryCoordinates(options);\n    }\n\n    const {\n      x,\n      y,\n      z\n    } = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n    return this._toBinaryCoordinates(data => project(data, x0, y0, size));\n  }\n\n}","map":{"version":3,"mappings":"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","names":["classifyRings","project","readFeature","endPos","cmd","cmdLen","length","x","y","i","TEST_EXPORTS","VectorTileFeature","constructor","pbf","end","extent","keys","values","geometryInfo","_defineProperty","properties","type","id","_pbf","_geometry","_keys","_values","_geometryInfo","readFields","loadGeometry","pos","readVarint","indices","data","readSVarint","push","start","Error","_toBinaryCoordinates","transform","geom","geometry","coordLength","pointFeaturesCount","pointPositionsCount","lineFeaturesCount","linePathsCount","linePositionsCount","polygonFeaturesCount","polygonObjectsCount","polygonRingsCount","polygonPositionsCount","result","toBinaryCoordinates","options","z","size","Math","pow","x0","y0"],"sources":["../../../../src/lib/binary-vector-tile/vector-tile-feature.ts"],"sourcesContent":["// This code is forked from https://github.com/mapbox/vector-tile-js under BSD 3-clause license.\n\nimport Protobuf from 'pbf';\nimport {FlatFeature, FlatIndexedGeometry, GeojsonGeometryInfo} from '@loaders.gl/schema';\nimport {classifyRings, project, readFeature} from '../../helpers/binary-util-functions';\n\n// Reduce GC by reusing variables\nlet endPos: number;\nlet cmd: number;\nlet cmdLen: number;\nlet length: number;\nlet x: number;\nlet y: number;\nlet i: number;\n\nexport const TEST_EXPORTS = {\n  classifyRings\n};\n\nexport default class VectorTileFeature {\n  properties: {[x: string]: string | number | boolean | null};\n  extent: any;\n  type: number;\n  id: number | null;\n  _pbf: Protobuf;\n  _geometry: number;\n  _keys: string[];\n  _values: (string | number | boolean | null)[];\n  _geometryInfo: GeojsonGeometryInfo;\n\n  // eslint-disable-next-line max-params\n  constructor(\n    pbf: Protobuf,\n    end: number,\n    extent: any,\n    keys: string[],\n    values: (string | number | boolean | null)[],\n    geometryInfo: GeojsonGeometryInfo\n  ) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n    this.id = null;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n    this._geometryInfo = geometryInfo;\n\n    pbf.readFields(readFeature, this, end);\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  loadGeometry(): FlatIndexedGeometry {\n    const pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    endPos = pbf.readVarint() + pbf.pos;\n    cmd = 1;\n    length = 0;\n    x = 0;\n    y = 0;\n    i = 0;\n\n    // Note: I attempted to replace the `data` array with a\n    // Float32Array, but performance was worse, both using\n    // `set()` and direct index access. Also, we cannot\n    // know how large the buffer should be, so it would\n    // increase memory usage\n    const indices: number[] = []; // Indices where geometries start\n    const data: number[] = []; // Flat array of coordinate data\n\n    while (pbf.pos < endPos) {\n      if (length <= 0) {\n        cmdLen = pbf.readVarint();\n        cmd = cmdLen & 0x7;\n        length = cmdLen >> 3;\n      }\n\n      length--;\n\n      if (cmd === 1 || cmd === 2) {\n        x += pbf.readSVarint();\n        y += pbf.readSVarint();\n\n        if (cmd === 1) {\n          // New line\n          indices.push(i);\n        }\n        data.push(x, y);\n        i += 2;\n      } else if (cmd === 7) {\n        // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n        if (i > 0) {\n          const start = indices[indices.length - 1]; // start index of polygon\n          data.push(data[start], data[start + 1]); // closePolygon\n          i += 2;\n        }\n      } else {\n        throw new Error(`unknown command ${cmd}`);\n      }\n    }\n\n    return {data, indices};\n  }\n\n  /**\n   *\n   * @param transform\n   * @returns result\n   */\n  _toBinaryCoordinates(transform) {\n    // Expands the protobuf data to an intermediate Flat GeoJSON\n    // data format, which maps closely to the binary data buffers.\n    // It is similar to GeoJSON, but rather than storing the coordinates\n    // in multidimensional arrays, we have a 1D `data` with all the\n    // coordinates, and then index into this using the `indices`\n    // parameter, e.g.\n    //\n    // geometry: {\n    //   type: 'Point', data: [1,2], indices: [0]\n    // }\n    // geometry: {\n    //   type: 'LineString', data: [1,2,3,4,...], indices: [0]\n    // }\n    // geometry: {\n    //   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]\n    // }\n    // Thus the indices member lets us look up the relevant range\n    // from the data array.\n    // The Multi* versions of the above types share the same data\n    // structure, just with multiple elements in the indices array\n    const geom = this.loadGeometry();\n    let geometry;\n\n    // Apply the supplied transformation to data\n    transform(geom.data, this);\n\n    const coordLength = 2;\n\n    // eslint-disable-next-line default-case\n    switch (this.type) {\n      case 1: // Point\n        this._geometryInfo.pointFeaturesCount++;\n        this._geometryInfo.pointPositionsCount += geom.indices.length;\n        geometry = {type: 'Point', ...geom};\n        break;\n\n      case 2: // LineString\n        this._geometryInfo.lineFeaturesCount++;\n        this._geometryInfo.linePathsCount += geom.indices.length;\n        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;\n        geometry = {type: 'LineString', ...geom};\n        break;\n\n      case 3: // Polygon\n        geometry = classifyRings(geom);\n\n        // Unlike Point & LineString geom.indices is a 2D array, thanks\n        // to the classifyRings method\n        this._geometryInfo.polygonFeaturesCount++;\n        this._geometryInfo.polygonObjectsCount += geometry.indices.length;\n\n        for (const indices of geometry.indices) {\n          this._geometryInfo.polygonRingsCount += indices.length;\n        }\n        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;\n\n        break;\n      default:\n        throw new Error(`Invalid geometry type: ${this.type}`);\n    }\n\n    const result: FlatFeature = {type: 'Feature', geometry, properties: this.properties};\n\n    if (this.id !== null) {\n      result.id = this.id;\n    }\n\n    return result;\n  }\n\n  toBinaryCoordinates(\n    options: {x: number; y: number; z: number} | ((data: number[], feature: {extent: any}) => void)\n  ): FlatFeature {\n    if (typeof options === 'function') {\n      return this._toBinaryCoordinates(options);\n    }\n    const {x, y, z} = options;\n    const size = this.extent * Math.pow(2, z);\n    const x0 = this.extent * x;\n    const y0 = this.extent * y;\n\n    return this._toBinaryCoordinates((data: number[]) => project(data, x0, y0, size));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}