{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { getBinaryImageMetadata } from '@loaders.gl/images';\nimport { padToNBytes, copyToArray } from '@loaders.gl/loader-utils';\nimport { assert } from '../utils/assert';\nimport { getAccessorArrayTypeAndLength, getAccessorTypeFromSize, getComponentTypeFromArray } from '../gltf-utils/gltf-utils';\nvar DEFAULT_GLTF_JSON = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\nvar GLTFScenegraph = /*#__PURE__*/function () {\n  function GLTFScenegraph(gltf) {\n    _classCallCheck(this, GLTFScenegraph);\n\n    _defineProperty(this, \"gltf\", void 0);\n\n    _defineProperty(this, \"sourceBuffers\", void 0);\n\n    _defineProperty(this, \"byteLength\", void 0);\n\n    this.gltf = gltf || {\n      json: _objectSpread({}, DEFAULT_GLTF_JSON),\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  _createClass(GLTFScenegraph, [{\n    key: \"json\",\n    get: function get() {\n      return this.gltf.json;\n    }\n  }, {\n    key: \"getApplicationData\",\n    value: function getApplicationData(key) {\n      var data = this.json[key];\n      return data;\n    }\n  }, {\n    key: \"getExtraData\",\n    value: function getExtraData(key) {\n      var extras = this.json.extras || {};\n      return extras[key];\n    }\n  }, {\n    key: \"getExtension\",\n    value: function getExtension(extensionName) {\n      var isExtension = this.getUsedExtensions().find(function (name) {\n        return name === extensionName;\n      });\n      var extensions = this.json.extensions || {};\n      return isExtension ? extensions[extensionName] || true : null;\n    }\n  }, {\n    key: \"getRequiredExtension\",\n    value: function getRequiredExtension(extensionName) {\n      var isRequired = this.getRequiredExtensions().find(function (name) {\n        return name === extensionName;\n      });\n      return isRequired ? this.getExtension(extensionName) : null;\n    }\n  }, {\n    key: \"getRequiredExtensions\",\n    value: function getRequiredExtensions() {\n      return this.json.extensionsRequired || [];\n    }\n  }, {\n    key: \"getUsedExtensions\",\n    value: function getUsedExtensions() {\n      return this.json.extensionsUsed || [];\n    }\n  }, {\n    key: \"getObjectExtension\",\n    value: function getObjectExtension(object, extensionName) {\n      var extensions = object.extensions || {};\n      return extensions[extensionName];\n    }\n  }, {\n    key: \"getScene\",\n    value: function getScene(index) {\n      return this.getObject('scenes', index);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(index) {\n      return this.getObject('nodes', index);\n    }\n  }, {\n    key: \"getSkin\",\n    value: function getSkin(index) {\n      return this.getObject('skins', index);\n    }\n  }, {\n    key: \"getMesh\",\n    value: function getMesh(index) {\n      return this.getObject('meshes', index);\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(index) {\n      return this.getObject('materials', index);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor(index) {\n      return this.getObject('accessors', index);\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture(index) {\n      return this.getObject('textures', index);\n    }\n  }, {\n    key: \"getSampler\",\n    value: function getSampler(index) {\n      return this.getObject('samplers', index);\n    }\n  }, {\n    key: \"getImage\",\n    value: function getImage(index) {\n      return this.getObject('images', index);\n    }\n  }, {\n    key: \"getBufferView\",\n    value: function getBufferView(index) {\n      return this.getObject('bufferViews', index);\n    }\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer(index) {\n      return this.getObject('buffers', index);\n    }\n  }, {\n    key: \"getObject\",\n    value: function getObject(array, index) {\n      if (typeof index === 'object') {\n        return index;\n      }\n\n      var object = this.json[array] && this.json[array][index];\n\n      if (!object) {\n        throw new Error(\"glTF file error: Could not find \".concat(array, \"[\").concat(index, \"]\"));\n      }\n\n      return object;\n    }\n  }, {\n    key: \"getTypedArrayForBufferView\",\n    value: function getTypedArrayForBufferView(bufferView) {\n      bufferView = this.getBufferView(bufferView);\n      var bufferIndex = bufferView.buffer;\n      var binChunk = this.gltf.buffers[bufferIndex];\n      assert(binChunk);\n      var byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n      return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n  }, {\n    key: \"getTypedArrayForAccessor\",\n    value: function getTypedArrayForAccessor(accessor) {\n      accessor = this.getAccessor(accessor);\n      var bufferView = this.getBufferView(accessor.bufferView);\n      var buffer = this.getBuffer(bufferView.buffer);\n      var arrayBuffer = buffer.data;\n\n      var _getAccessorArrayType = getAccessorArrayTypeAndLength(accessor, bufferView),\n          ArrayType = _getAccessorArrayType.ArrayType,\n          length = _getAccessorArrayType.length;\n\n      var byteOffset = bufferView.byteOffset + accessor.byteOffset;\n      return new ArrayType(arrayBuffer, byteOffset, length);\n    }\n  }, {\n    key: \"getTypedArrayForImageData\",\n    value: function getTypedArrayForImageData(image) {\n      image = this.getAccessor(image);\n      var bufferView = this.getBufferView(image.bufferView);\n      var buffer = this.getBuffer(bufferView.buffer);\n      var arrayBuffer = buffer.data;\n      var byteOffset = bufferView.byteOffset || 0;\n      return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    }\n  }, {\n    key: \"addApplicationData\",\n    value: function addApplicationData(key, data) {\n      this.json[key] = data;\n      return this;\n    }\n  }, {\n    key: \"addExtraData\",\n    value: function addExtraData(key, data) {\n      this.json.extras = this.json.extras || {};\n      this.json.extras[key] = data;\n      return this;\n    }\n  }, {\n    key: \"addObjectExtension\",\n    value: function addObjectExtension(object, extensionName, data) {\n      object.extensions = object.extensions || {};\n      object.extensions[extensionName] = data;\n      this.registerUsedExtension(extensionName);\n      return this;\n    }\n  }, {\n    key: \"setObjectExtension\",\n    value: function setObjectExtension(object, extensionName, data) {\n      var extensions = object.extensions || {};\n      extensions[extensionName] = data;\n    }\n  }, {\n    key: \"removeObjectExtension\",\n    value: function removeObjectExtension(object, extensionName) {\n      var extensions = object.extensions || {};\n      var extension = extensions[extensionName];\n      delete extensions[extensionName];\n      return extension;\n    }\n  }, {\n    key: \"addExtension\",\n    value: function addExtension(extensionName) {\n      var extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      assert(extensionData);\n      this.json.extensions = this.json.extensions || {};\n      this.json.extensions[extensionName] = extensionData;\n      this.registerUsedExtension(extensionName);\n      return extensionData;\n    }\n  }, {\n    key: \"addRequiredExtension\",\n    value: function addRequiredExtension(extensionName) {\n      var extensionData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      assert(extensionData);\n      this.addExtension(extensionName, extensionData);\n      this.registerRequiredExtension(extensionName);\n      return extensionData;\n    }\n  }, {\n    key: \"registerUsedExtension\",\n    value: function registerUsedExtension(extensionName) {\n      this.json.extensionsUsed = this.json.extensionsUsed || [];\n\n      if (!this.json.extensionsUsed.find(function (ext) {\n        return ext === extensionName;\n      })) {\n        this.json.extensionsUsed.push(extensionName);\n      }\n    }\n  }, {\n    key: \"registerRequiredExtension\",\n    value: function registerRequiredExtension(extensionName) {\n      this.registerUsedExtension(extensionName);\n      this.json.extensionsRequired = this.json.extensionsRequired || [];\n\n      if (!this.json.extensionsRequired.find(function (ext) {\n        return ext === extensionName;\n      })) {\n        this.json.extensionsRequired.push(extensionName);\n      }\n    }\n  }, {\n    key: \"removeExtension\",\n    value: function removeExtension(extensionName) {\n      if (this.json.extensionsRequired) {\n        this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n      }\n\n      if (this.json.extensionsUsed) {\n        this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n      }\n\n      if (this.json.extensions) {\n        delete this.json.extensions[extensionName];\n      }\n    }\n  }, {\n    key: \"setDefaultScene\",\n    value: function setDefaultScene(sceneIndex) {\n      this.json.scene = sceneIndex;\n    }\n  }, {\n    key: \"addScene\",\n    value: function addScene(scene) {\n      var nodeIndices = scene.nodeIndices;\n      this.json.scenes = this.json.scenes || [];\n      this.json.scenes.push({\n        nodes: nodeIndices\n      });\n      return this.json.scenes.length - 1;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      var meshIndex = node.meshIndex,\n          matrix = node.matrix;\n      this.json.nodes = this.json.nodes || [];\n      var nodeData = {\n        mesh: meshIndex\n      };\n\n      if (matrix) {\n        nodeData.matrix = matrix;\n      }\n\n      this.json.nodes.push(nodeData);\n      return this.json.nodes.length - 1;\n    }\n  }, {\n    key: \"addMesh\",\n    value: function addMesh(mesh) {\n      var attributes = mesh.attributes,\n          indices = mesh.indices,\n          material = mesh.material,\n          _mesh$mode = mesh.mode,\n          mode = _mesh$mode === void 0 ? 4 : _mesh$mode;\n\n      var accessors = this._addAttributes(attributes);\n\n      var glTFMesh = {\n        primitives: [{\n          attributes: accessors,\n          mode: mode\n        }]\n      };\n\n      if (indices) {\n        var indicesAccessor = this._addIndices(indices);\n\n        glTFMesh.primitives[0].indices = indicesAccessor;\n      }\n\n      if (Number.isFinite(material)) {\n        glTFMesh.primitives[0].material = material;\n      }\n\n      this.json.meshes = this.json.meshes || [];\n      this.json.meshes.push(glTFMesh);\n      return this.json.meshes.length - 1;\n    }\n  }, {\n    key: \"addPointCloud\",\n    value: function addPointCloud(attributes) {\n      var accessorIndices = this._addAttributes(attributes);\n\n      var glTFMesh = {\n        primitives: [{\n          attributes: accessorIndices,\n          mode: 0\n        }]\n      };\n      this.json.meshes = this.json.meshes || [];\n      this.json.meshes.push(glTFMesh);\n      return this.json.meshes.length - 1;\n    }\n  }, {\n    key: \"addImage\",\n    value: function addImage(imageData, mimeTypeOpt) {\n      var metadata = getBinaryImageMetadata(imageData);\n      var mimeType = mimeTypeOpt || (metadata === null || metadata === void 0 ? void 0 : metadata.mimeType);\n      var bufferViewIndex = this.addBufferView(imageData);\n      var glTFImage = {\n        bufferView: bufferViewIndex,\n        mimeType: mimeType\n      };\n      this.json.images = this.json.images || [];\n      this.json.images.push(glTFImage);\n      return this.json.images.length - 1;\n    }\n  }, {\n    key: \"addBufferView\",\n    value: function addBufferView(buffer) {\n      var byteLength = buffer.byteLength;\n      assert(Number.isFinite(byteLength));\n      this.sourceBuffers = this.sourceBuffers || [];\n      this.sourceBuffers.push(buffer);\n      var glTFBufferView = {\n        buffer: 0,\n        byteOffset: this.byteLength,\n        byteLength: byteLength\n      };\n      this.byteLength += padToNBytes(byteLength, 4);\n      this.json.bufferViews = this.json.bufferViews || [];\n      this.json.bufferViews.push(glTFBufferView);\n      return this.json.bufferViews.length - 1;\n    }\n  }, {\n    key: \"addAccessor\",\n    value: function addAccessor(bufferViewIndex, accessor) {\n      var glTFAccessor = {\n        bufferView: bufferViewIndex,\n        type: getAccessorTypeFromSize(accessor.size),\n        componentType: accessor.componentType,\n        count: accessor.count,\n        max: accessor.max,\n        min: accessor.min\n      };\n      this.json.accessors = this.json.accessors || [];\n      this.json.accessors.push(glTFAccessor);\n      return this.json.accessors.length - 1;\n    }\n  }, {\n    key: \"addBinaryBuffer\",\n    value: function addBinaryBuffer(sourceBuffer) {\n      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        size: 3\n      };\n      var bufferViewIndex = this.addBufferView(sourceBuffer);\n      var minMax = {\n        min: accessor.min,\n        max: accessor.max\n      };\n\n      if (!minMax.min || !minMax.max) {\n        minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n      }\n\n      var accessorDefaults = {\n        size: accessor.size,\n        componentType: getComponentTypeFromArray(sourceBuffer),\n        count: Math.round(sourceBuffer.length / accessor.size),\n        min: minMax.min,\n        max: minMax.max\n      };\n      return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n    }\n  }, {\n    key: \"addTexture\",\n    value: function addTexture(texture) {\n      var imageIndex = texture.imageIndex;\n      var glTFTexture = {\n        source: imageIndex\n      };\n      this.json.textures = this.json.textures || [];\n      this.json.textures.push(glTFTexture);\n      return this.json.textures.length - 1;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(pbrMaterialInfo) {\n      this.json.materials = this.json.materials || [];\n      this.json.materials.push(pbrMaterialInfo);\n      return this.json.materials.length - 1;\n    }\n  }, {\n    key: \"createBinaryChunk\",\n    value: function createBinaryChunk() {\n      var _this$json, _this$json$buffers;\n\n      this.gltf.buffers = [];\n      var totalByteLength = this.byteLength;\n      var arrayBuffer = new ArrayBuffer(totalByteLength);\n      var targetArray = new Uint8Array(arrayBuffer);\n      var dstByteOffset = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.sourceBuffers || []),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var sourceBuffer = _step.value;\n          dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if ((_this$json = this.json) !== null && _this$json !== void 0 && (_this$json$buffers = _this$json.buffers) !== null && _this$json$buffers !== void 0 && _this$json$buffers[0]) {\n        this.json.buffers[0].byteLength = totalByteLength;\n      } else {\n        this.json.buffers = [{\n          byteLength: totalByteLength\n        }];\n      }\n\n      this.gltf.binary = arrayBuffer;\n      this.sourceBuffers = [arrayBuffer];\n    }\n  }, {\n    key: \"_removeStringFromArray\",\n    value: function _removeStringFromArray(array, string) {\n      var found = true;\n\n      while (found) {\n        var index = array.indexOf(string);\n\n        if (index > -1) {\n          array.splice(index, 1);\n        } else {\n          found = false;\n        }\n      }\n    }\n  }, {\n    key: \"_addAttributes\",\n    value: function _addAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var result = {};\n\n      for (var attributeKey in attributes) {\n        var attributeData = attributes[attributeKey];\n\n        var attrName = this._getGltfAttributeName(attributeKey);\n\n        var accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n        result[attrName] = accessor;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_addIndices\",\n    value: function _addIndices(indices) {\n      return this.addBinaryBuffer(indices, {\n        size: 1\n      });\n    }\n  }, {\n    key: \"_getGltfAttributeName\",\n    value: function _getGltfAttributeName(attributeName) {\n      switch (attributeName.toLowerCase()) {\n        case 'position':\n        case 'positions':\n        case 'vertices':\n          return 'POSITION';\n\n        case 'normal':\n        case 'normals':\n          return 'NORMAL';\n\n        case 'color':\n        case 'colors':\n          return 'COLOR_0';\n\n        case 'texcoord':\n        case 'texcoords':\n          return 'TEXCOORD_0';\n\n        default:\n          return attributeName;\n      }\n    }\n  }, {\n    key: \"_getAccessorMinMax\",\n    value: function _getAccessorMinMax(buffer, size) {\n      var result = {\n        min: null,\n        max: null\n      };\n\n      if (buffer.length < size) {\n        return result;\n      }\n\n      result.min = [];\n      result.max = [];\n      var initValues = buffer.subarray(0, size);\n\n      var _iterator2 = _createForOfIteratorHelper(initValues),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          result.min.push(value);\n          result.max.push(value);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      for (var index = size; index < buffer.length; index += size) {\n        for (var componentIndex = 0; componentIndex < size; componentIndex++) {\n          result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);\n          result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);\n        }\n      }\n\n      return result;\n    }\n  }]);\n\n  return GLTFScenegraph;\n}();\n\nexport { GLTFScenegraph as default };","map":{"version":3,"mappings":";;;;;AAeA,SAAQA,sBAAR,QAAqC,oBAArC;AACA,SAAQC,WAAR,EAAqBC,WAArB,QAAuC,0BAAvC;AACA,SAAQC,MAAR,QAAqB,iBAArB;AACA,SACEC,6BADF,EAEEC,uBAFF,EAGEC,yBAHF,QAIO,0BAJP;AAYA,IAAMC,iBAAuB,GAAG;EAC9BC,KAAK,EAAE;IACLC,OAAO,EAAE,KADJ;IAELC,SAAS,EAAE;EAFN,CADuB;EAK9BC,OAAO,EAAE;AALqB,CAAhC;;IAYqBC,c;EAMnBC,wBAAYC,IAAZD,EAAkD;IAAA;;IAAAE;;IAAAA;;IAAAA;;IAEhD,KAAKD,IAAL,GAAYA,IAAI,IAAI;MAClBE,IAAI,oBAAMT,iBAAN,CADc;MAElBI,OAAO,EAAE;IAFS,CAApB;IAIA,KAAKM,aAAL,GAAqB,EAArB;IACA,KAAKC,UAAL,GAAkB,CAAlB;;IAGA,IAAI,KAAKJ,IAAL,CAAUH,OAAV,IAAqB,KAAKG,IAAL,CAAUH,OAAV,CAAkB,CAAlB,CAAzB,EAA+C;MAC7C,KAAKO,UAAL,GAAkB,KAAKJ,IAAL,CAAUH,OAAV,CAAkB,CAAlB,EAAqBO,UAAvC;MACA,KAAKD,aAAL,GAAqB,CAAC,KAAKH,IAAL,CAAUH,OAAV,CAAkB,CAAlB,CAAD,CAArB;IACD;EACF;;;;SAIO,eAAS;MACf,OAAO,KAAKG,IAAL,CAAUE,IAAjB;IACD;;;WAEDG,4BAAmBC,GAAnBD,EAAsD;MAEpD,IAAME,IAAI,GAAG,KAAKL,IAAL,CAAUI,GAAV,CAAb;MACA,OAAOC,IAAP;IACD;;;WAEDC,sBAAaF,GAAbE,EAAgD;MAE9C,IAAMC,MAAM,GAAG,KAAKP,IAAL,CAAUO,MAAV,IAAoB,EAAnC;MACA,OAAOA,MAAM,CAACH,GAAD,CAAb;IACD;;;WAEDI,sBAA4BC,aAA5BD,EAA6D;MAC3D,IAAME,WAAW,GAAG,KAAKC,iBAAL,GAAyBC,IAAzB,CAA+BC,cAAD;QAAA,OAAUA,IAAI,KAAKJ,aAAnB;MAAA,CAA9B,CAApB;MACA,IAAMK,UAAU,GAAG,KAAKd,IAAL,CAAUc,UAAV,IAAwB,EAA3C;MACA,OAAOJ,WAAW,GAAGI,UAAU,CAACL,aAAD,CAAVK,IAA6B,IAAhC,GAAuC,IAAzD;IACD;;;WAEDC,8BAAoCN,aAApCM,EAAqE;MACnE,IAAMC,UAAU,GAAG,KAAKC,qBAAL,GAA6BL,IAA7B,CAAmCC,cAAD;QAAA,OAAUA,IAAI,KAAKJ,aAAnB;MAAA,CAAlC,CAAnB;MACA,OAAOO,UAAU,GAAG,KAAKR,YAAL,CAAkBC,aAAlB,CAAH,GAAsC,IAAvD;IACD;;;WAEDQ,iCAAkC;MAChC,OAAO,KAAKjB,IAAL,CAAUkB,kBAAV,IAAgC,EAAvC;IACD;;;WAEDP,6BAA8B;MAC5B,OAAO,KAAKX,IAAL,CAAUmB,cAAV,IAA4B,EAAnC;IACD;;;WAEDC,4BAAkCC,MAAlCD,EAAgEX,aAAhEW,EAAiG;MAC/F,IAAMN,UAAU,GAAGO,MAAM,CAACP,UAAPO,IAAqB,EAAxC;MACA,OAAOP,UAAU,CAACL,aAAD,CAAjB;IACD;;;WAEDa,kBAASC,KAATD,EAAmC;MACjC,OAAO,KAAKE,SAAL,CAAe,QAAf,EAAyBD,KAAzB,CAAP;IACD;;;WAEDE,iBAAQF,KAARE,EAAiC;MAC/B,OAAO,KAAKD,SAAL,CAAe,OAAf,EAAwBD,KAAxB,CAAP;IACD;;;WAEDG,iBAAQH,KAARG,EAAiC;MAC/B,OAAO,KAAKF,SAAL,CAAe,OAAf,EAAwBD,KAAxB,CAAP;IACD;;;WAEDI,iBAAQJ,KAARI,EAAiC;MAC/B,OAAO,KAAKH,SAAL,CAAe,QAAf,EAAyBD,KAAzB,CAAP;IACD;;;WAEDK,qBAAYL,KAAZK,EAAyC;MACvC,OAAO,KAAKJ,SAAL,CAAe,WAAf,EAA4BD,KAA5B,CAAP;IACD;;;WAEDM,qBAAYN,KAAZM,EAAyC;MACvC,OAAO,KAAKL,SAAL,CAAe,WAAf,EAA4BD,KAA5B,CAAP;IACD;;;WAMDO,oBAAWP,KAAXO,EAAuC;MACrC,OAAO,KAAKN,SAAL,CAAe,UAAf,EAA2BD,KAA3B,CAAP;IACD;;;WAEDQ,oBAAWR,KAAXQ,EAAuC;MACrC,OAAO,KAAKP,SAAL,CAAe,UAAf,EAA2BD,KAA3B,CAAP;IACD;;;WAEDS,kBAAST,KAATS,EAAmC;MACjC,OAAO,KAAKR,SAAL,CAAe,QAAf,EAAyBD,KAAzB,CAAP;IACD;;;WAEDU,uBAAcV,KAAdU,EAAsD;MACpD,OAAO,KAAKT,SAAL,CAAe,aAAf,EAA8BD,KAA9B,CAAP;IACD;;;WAEDW,mBAAUX,KAAVW,EAAqC;MACnC,OAAO,KAAKV,SAAL,CAAe,SAAf,EAA0BD,KAA1B,CAAP;IACD;;;WAEDC,mBAAUW,KAAVX,EAAyBD,KAAzBC,EAAyD;MAEvD,IAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;QAC7B,OAAOA,KAAP;MACD;;MACD,IAAMF,MAAM,GAAG,KAAKrB,IAAL,CAAUmC,KAAV,KAAoB,KAAKnC,IAAL,CAAUmC,KAAV,EAAiBZ,KAAjB,CAAnC;;MACA,IAAI,CAACF,MAAL,EAAa;QACX,MAAM,IAAIe,KAAJ,2CAA6CD,KAA7C,cAAsDZ,KAAtD,OAAN;MACD;;MACD,OAAOF,MAAP;IACD;;;WAMDgB,oCAA2BC,UAA3BD,EAAoE;MAClEC,UAAU,GAAG,KAAKL,aAAL,CAAmBK,UAAnB,CAAbA;MAEA,IAAMC,WAAW,GAAGD,UAAU,CAACE,MAA/B;MAIA,IAAMC,QAAQ,GAAG,KAAK3C,IAAL,CAAUH,OAAV,CAAkB4C,WAAlB,CAAjB;MACApD,MAAM,CAACsD,QAAD,CAANtD;MAGA,IAAMuD,UAAU,GAAG,CAACJ,UAAU,CAACI,UAAXJ,IAAyB,CAA1B,IAA+BG,QAAQ,CAACC,UAA3D;MAEA,OAAO,IAAIC,UAAJ,CAAeF,QAAQ,CAACG,WAAxB,EAAqCF,UAArC,EAAiDJ,UAAU,CAACpC,UAA5D,CAAP;IACD;;;WAKD2C,kCAAyBC,QAAzBD,EAAyD;MAEvDC,QAAQ,GAAG,KAAKjB,WAAL,CAAiBiB,QAAjB,CAAXA;MAEA,IAAMR,UAAU,GAAG,KAAKL,aAAL,CAAmBa,QAAQ,CAACR,UAA5B,CAAnB;MACA,IAAME,MAAM,GAAG,KAAKN,SAAL,CAAeI,UAAU,CAACE,MAA1B,CAAf;MAEA,IAAMI,WAAW,GAAGJ,MAAM,CAACnC,IAA3B;;MAGA,4BAA4BjB,6BAA6B,CAAC0D,QAAD,EAAWR,UAAX,CAAzD;MAAA,IAAOS,SAAP,yBAAOA,SAAP;MAAA,IAAkBC,MAAlB,yBAAkBA,MAAlB;;MAEA,IAAMN,UAAU,GAAGJ,UAAU,CAACI,UAAXJ,GAAwBQ,QAAQ,CAACJ,UAApD;MACA,OAAO,IAAIK,SAAJ,CAAcH,WAAd,EAA2BF,UAA3B,EAAuCM,MAAvC,CAAP;IACD;;;WAKDC,mCAA0BC,KAA1BD,EAA8D;MAE5DC,KAAK,GAAG,KAAKrB,WAAL,CAAiBqB,KAAjB,CAARA;MAEA,IAAMZ,UAAU,GAAG,KAAKL,aAAL,CAAmBiB,KAAK,CAACZ,UAAzB,CAAnB;MACA,IAAME,MAAM,GAAG,KAAKN,SAAL,CAAeI,UAAU,CAACE,MAA1B,CAAf;MAEA,IAAMI,WAAW,GAAGJ,MAAM,CAACnC,IAA3B;MAEA,IAAMqC,UAAU,GAAGJ,UAAU,CAACI,UAAXJ,IAAyB,CAA5C;MACA,OAAO,IAAIK,UAAJ,CAAeC,WAAf,EAA4BF,UAA5B,EAAwCJ,UAAU,CAACpC,UAAnD,CAAP;IACD;;;WAODiD,4BAAmB/C,GAAnB+C,EAAgC9C,IAAhC8C,EAA8D;MAC5D,KAAKnD,IAAL,CAAUI,GAAV,IAAiBC,IAAjB;MACA,OAAO,IAAP;IACD;;;WAKD+C,sBAAahD,GAAbgD,EAA0B/C,IAA1B+C,EAAwD;MACtD,KAAKpD,IAAL,CAAUO,MAAV,GAAmB,KAAKP,IAAL,CAAUO,MAAV,IAAoB,EAAvC;MACA,KAAKP,IAAL,CAAUO,MAAV,CAAiBH,GAAjB,IAAwBC,IAAxB;MACA,OAAO,IAAP;IACD;;;WAEDgD,4BAAmBhC,MAAnBgC,EAAmC5C,aAAnC4C,EAA0DhD,IAA1DgD,EAAwF;MAEtFhC,MAAM,CAACP,UAAPO,GAAoBA,MAAM,CAACP,UAAPO,IAAqB,EAAzCA;MAGAA,MAAM,CAACP,UAAPO,CAAkBZ,aAAlBY,IAAmChB,IAAnCgB;MACA,KAAKiC,qBAAL,CAA2B7C,aAA3B;MACA,OAAO,IAAP;IACD;;;WAED8C,4BAAmBlC,MAAnBkC,EAAmC9C,aAAnC8C,EAA0DlD,IAA1DkD,EAA8E;MAE5E,IAAMzC,UAAU,GAAGO,MAAM,CAACP,UAAPO,IAAqB,EAAxC;MACAP,UAAU,CAACL,aAAD,CAAVK,GAA4BT,IAA5BS;IAED;;;WAED0C,+BAAsBnC,MAAtBmC,EAAsC/C,aAAtC+C,EAAqE;MAEnE,IAAM1C,UAAU,GAAGO,MAAM,CAACP,UAAPO,IAAqB,EAAxC;MACA,IAAMoC,SAAS,GAAG3C,UAAU,CAACL,aAAD,CAA5B;MACA,OAAOK,UAAU,CAACL,aAAD,CAAjB;MACA,OAAOgD,SAAP;IACD;;;WAKDC,sBAAajD,aAAbiD,EAAwE;MAAA,IAApCC,aAAoC,uEAAZ,EAAY;MACtExE,MAAM,CAACwE,aAAD,CAANxE;MACA,KAAKa,IAAL,CAAUc,UAAV,GAAuB,KAAKd,IAAL,CAAUc,UAAV,IAAwB,EAA/C;MACA,KAAKd,IAAL,CAAUc,UAAV,CAAqBL,aAArB,IAAsCkD,aAAtC;MACA,KAAKL,qBAAL,CAA2B7C,aAA3B;MACA,OAAOkD,aAAP;IACD;;;WAKDC,8BAAqBnD,aAArBmD,EAAwE;MAAA,IAApCD,aAAoC,uEAAZ,EAAY;MACtExE,MAAM,CAACwE,aAAD,CAANxE;MACA,KAAKuE,YAAL,CAAkBjD,aAAlB,EAAiCkD,aAAjC;MACA,KAAKE,yBAAL,CAA+BpD,aAA/B;MACA,OAAOkD,aAAP;IACD;;;WAKDL,+BAAsB7C,aAAtB6C,EAAmD;MACjD,KAAKtD,IAAL,CAAUmB,cAAV,GAA2B,KAAKnB,IAAL,CAAUmB,cAAV,IAA4B,EAAvD;;MACA,IAAI,CAAC,KAAKnB,IAAL,CAAUmB,cAAV,CAAyBP,IAAzB,CAA+BkD,aAAD;QAAA,OAASA,GAAG,KAAKrD,aAAjB;MAAA,CAA9B,CAAL,EAAoE;QAClE,KAAKT,IAAL,CAAUmB,cAAV,CAAyB4C,IAAzB,CAA8BtD,aAA9B;MACD;IACF;;;WAKDoD,mCAA0BpD,aAA1BoD,EAAuD;MACrD,KAAKP,qBAAL,CAA2B7C,aAA3B;MACA,KAAKT,IAAL,CAAUkB,kBAAV,GAA+B,KAAKlB,IAAL,CAAUkB,kBAAV,IAAgC,EAA/D;;MACA,IAAI,CAAC,KAAKlB,IAAL,CAAUkB,kBAAV,CAA6BN,IAA7B,CAAmCkD,aAAD;QAAA,OAASA,GAAG,KAAKrD,aAAjB;MAAA,CAAlC,CAAL,EAAwE;QACtE,KAAKT,IAAL,CAAUkB,kBAAV,CAA6B6C,IAA7B,CAAkCtD,aAAlC;MACD;IACF;;;WAKDuD,yBAAgBvD,aAAhBuD,EAA6C;MAC3C,IAAI,KAAKhE,IAAL,CAAUkB,kBAAd,EAAkC;QAChC,KAAK+C,sBAAL,CAA4B,KAAKjE,IAAL,CAAUkB,kBAAtC,EAA0DT,aAA1D;MACD;;MACD,IAAI,KAAKT,IAAL,CAAUmB,cAAd,EAA8B;QAC5B,KAAK8C,sBAAL,CAA4B,KAAKjE,IAAL,CAAUmB,cAAtC,EAAsDV,aAAtD;MACD;;MACD,IAAI,KAAKT,IAAL,CAAUc,UAAd,EAA0B;QACxB,OAAO,KAAKd,IAAL,CAAUc,UAAV,CAAqBL,aAArB,CAAP;MACD;IACF;;;WAKDyD,yBAAgBC,UAAhBD,EAA0C;MACxC,KAAKlE,IAAL,CAAUoE,KAAV,GAAkBD,UAAlB;IACD;;;WAODE,kBAASD,KAATC,EAAiD;MAC/C,IAAOC,WAAP,GAAsBF,KAAtB,CAAOE,WAAP;MACA,KAAKtE,IAAL,CAAUuE,MAAV,GAAmB,KAAKvE,IAAL,CAAUuE,MAAV,IAAoB,EAAvC;MACA,KAAKvE,IAAL,CAAUuE,MAAV,CAAiBR,IAAjB,CAAsB;QAACS,KAAK,EAAEF;MAAR,CAAtB;MACA,OAAO,KAAKtE,IAAL,CAAUuE,MAAV,CAAiBvB,MAAjB,GAA0B,CAAjC;IACD;;;WAODyB,iBAAQC,IAARD,EAA8D;MAC5D,IAAOE,SAAP,GAA4BD,IAA5B,CAAOC,SAAP;MAAA,IAAkBC,MAAlB,GAA4BF,IAA5B,CAAkBE,MAAlB;MACA,KAAK5E,IAAL,CAAUwE,KAAV,GAAkB,KAAKxE,IAAL,CAAUwE,KAAV,IAAmB,EAArC;MACA,IAAMK,QAAQ,GAAG;QAACC,IAAI,EAAEH;MAAP,CAAjB;;MACA,IAAIC,MAAJ,EAAY;QAEVC,QAAQ,CAACD,MAATC,GAAkBD,MAAlBC;MACD;;MACD,KAAK7E,IAAL,CAAUwE,KAAV,CAAgBT,IAAhB,CAAqBc,QAArB;MACA,OAAO,KAAK7E,IAAL,CAAUwE,KAAV,CAAgBxB,MAAhB,GAAyB,CAAhC;IACD;;;WAGD+B,iBAAQD,IAARC,EAAgG;MAC9F,IAAOC,UAAP,GAAkDF,IAAlD,CAAOE,UAAP;MAAA,IAAmBC,OAAnB,GAAkDH,IAAlD,CAAmBG,OAAnB;MAAA,IAA4BC,QAA5B,GAAkDJ,IAAlD,CAA4BI,QAA5B;MAAA,iBAAkDJ,IAAlD,CAAsCK,IAAtC;MAAA,IAAsCA,IAAtC,2BAA6C,CAA7C;;MACA,IAAMC,SAAS,GAAG,KAAKC,cAAL,CAAoBL,UAApB,CAAlB;;MAEA,IAAMM,QAAQ,GAAG;QACfC,UAAU,EAAE,CACV;UACEP,UAAU,EAAEI,SADd;UAEED;QAFF,CADU;MADG,CAAjB;;MASA,IAAIF,OAAJ,EAAa;QACX,IAAMO,eAAe,GAAG,KAAKC,WAAL,CAAiBR,OAAjB,CAAxB;;QAEAK,QAAQ,CAACC,UAATD,CAAoB,CAApBA,EAAuBL,OAAvBK,GAAiCE,eAAjCF;MACD;;MAED,IAAII,MAAM,CAACC,QAAPD,CAAgBR,QAAhBQ,CAAJ,EAA+B;QAE7BJ,QAAQ,CAACC,UAATD,CAAoB,CAApBA,EAAuBJ,QAAvBI,GAAkCJ,QAAlCI;MACD;;MAED,KAAKtF,IAAL,CAAU4F,MAAV,GAAmB,KAAK5F,IAAL,CAAU4F,MAAV,IAAoB,EAAvC;MACA,KAAK5F,IAAL,CAAU4F,MAAV,CAAiB7B,IAAjB,CAAsBuB,QAAtB;MACA,OAAO,KAAKtF,IAAL,CAAU4F,MAAV,CAAiB5C,MAAjB,GAA0B,CAAjC;IACD;;;WAED6C,uBAAcb,UAAda,EAA0C;MAExC,IAAMC,eAAe,GAAG,KAAKT,cAAL,CAAoBL,UAApB,CAAxB;;MAEA,IAAMM,QAAQ,GAAG;QACfC,UAAU,EAAE,CACV;UACEP,UAAU,EAAEc,eADd;UAEEX,IAAI,EAAE;QAFR,CADU;MADG,CAAjB;MASA,KAAKnF,IAAL,CAAU4F,MAAV,GAAmB,KAAK5F,IAAL,CAAU4F,MAAV,IAAoB,EAAvC;MACA,KAAK5F,IAAL,CAAU4F,MAAV,CAAiB7B,IAAjB,CAAsBuB,QAAtB;MACA,OAAO,KAAKtF,IAAL,CAAU4F,MAAV,CAAiB5C,MAAjB,GAA0B,CAAjC;IACD;;;WASD+C,kBAASC,SAATD,EAAyBE,WAAzBF,EAAuD;MAIrD,IAAMG,QAAQ,GAAGlH,sBAAsB,CAACgH,SAAD,CAAvC;MACA,IAAMG,QAAQ,GAAGF,WAAW,KAAIC,QAAJ,SAAIA,YAAJ,WAAIA,GAAJ,MAAIA,WAAQ,CAAEC,QAAd,CAA5B;MAEA,IAAMC,eAAe,GAAG,KAAKC,aAAL,CAAmBL,SAAnB,CAAxB;MAEA,IAAMM,SAAS,GAAG;QAChBhE,UAAU,EAAE8D,eADI;QAEhBD;MAFgB,CAAlB;MAKA,KAAKnG,IAAL,CAAUuG,MAAV,GAAmB,KAAKvG,IAAL,CAAUuG,MAAV,IAAoB,EAAvC;MACA,KAAKvG,IAAL,CAAUuG,MAAV,CAAiBxC,IAAjB,CAAsBuC,SAAtB;MACA,OAAO,KAAKtG,IAAL,CAAUuG,MAAV,CAAiBvD,MAAjB,GAA0B,CAAjC;IACD;;;WAMDqD,uBAAc7D,MAAd6D,EAAmC;MACjC,IAAMnG,UAAU,GAAGsC,MAAM,CAACtC,UAA1B;MACAf,MAAM,CAACuG,MAAM,CAACC,QAAPD,CAAgBxF,UAAhBwF,CAAD,CAANvG;MAGA,KAAKc,aAAL,GAAqB,KAAKA,aAAL,IAAsB,EAA3C;MACA,KAAKA,aAAL,CAAmB8D,IAAnB,CAAwBvB,MAAxB;MAEA,IAAMgE,cAAc,GAAG;QACrBhE,MAAM,EAAE,CADa;QAGrBE,UAAU,EAAE,KAAKxC,UAHI;QAIrBA;MAJqB,CAAvB;MASA,KAAKA,UAAL,IAAmBjB,WAAW,CAACiB,UAAD,EAAa,CAAb,CAA9B;MAGA,KAAKF,IAAL,CAAUyG,WAAV,GAAwB,KAAKzG,IAAL,CAAUyG,WAAV,IAAyB,EAAjD;MACA,KAAKzG,IAAL,CAAUyG,WAAV,CAAsB1C,IAAtB,CAA2ByC,cAA3B;MACA,OAAO,KAAKxG,IAAL,CAAUyG,WAAV,CAAsBzD,MAAtB,GAA+B,CAAtC;IACD;;;WAOD0D,qBAAYN,eAAZM,EAAqC5D,QAArC4D,EAA+D;MAC7D,IAAMC,YAAY,GAAG;QACnBrE,UAAU,EAAE8D,eADO;QAGnBQ,IAAI,EAAEvH,uBAAuB,CAACyD,QAAQ,CAAC+D,IAAV,CAHV;QAKnBC,aAAa,EAAEhE,QAAQ,CAACgE,aALL;QAOnBC,KAAK,EAAEjE,QAAQ,CAACiE,KAPG;QASnBC,GAAG,EAAElE,QAAQ,CAACkE,GATK;QAWnBC,GAAG,EAAEnE,QAAQ,CAACmE;MAXK,CAArB;MAcA,KAAKjH,IAAL,CAAUoF,SAAV,GAAsB,KAAKpF,IAAL,CAAUoF,SAAV,IAAuB,EAA7C;MACA,KAAKpF,IAAL,CAAUoF,SAAV,CAAoBrB,IAApB,CAAyB4C,YAAzB;MACA,OAAO,KAAK3G,IAAL,CAAUoF,SAAV,CAAoBpC,MAApB,GAA6B,CAApC;IACD;;;WASDkE,yBAAgBC,YAAhBD,EAAyE;MAAA,IAAtCpE,QAAsC,uEAAnB;QAAC+D,IAAI,EAAE;MAAP,CAAmB;MACvE,IAAMT,eAAe,GAAG,KAAKC,aAAL,CAAmBc,YAAnB,CAAxB;MAEA,IAAIC,MAAM,GAAG;QAACH,GAAG,EAAEnE,QAAQ,CAACmE,GAAf;QAAoBD,GAAG,EAAElE,QAAQ,CAACkE;MAAlC,CAAb;;MACA,IAAI,CAACI,MAAM,CAACH,GAAR,IAAe,CAACG,MAAM,CAACJ,GAA3B,EAAgC;QAE9BI,MAAM,GAAG,KAAKC,kBAAL,CAAwBF,YAAxB,EAAsCrE,QAAQ,CAAC+D,IAA/C,CAATO;MACD;;MAED,IAAME,gBAAgB,GAAG;QAEvBT,IAAI,EAAE/D,QAAQ,CAAC+D,IAFQ;QAGvBC,aAAa,EAAExH,yBAAyB,CAAC6H,YAAD,CAHjB;QAKvBJ,KAAK,EAAEQ,IAAI,CAACC,KAALD,CAAWJ,YAAY,CAACnE,MAAbmE,GAAsBrE,QAAQ,CAAC+D,IAA1CU,CALgB;QAMvBN,GAAG,EAAEG,MAAM,CAACH,GANW;QAOvBD,GAAG,EAAEI,MAAM,CAACJ;MAPW,CAAzB;MAUA,OAAO,KAAKN,WAAL,CAAiBN,eAAjB,EAAkCqB,MAAM,CAACC,MAAPD,CAAcH,gBAAdG,EAAgC3E,QAAhC2E,CAAlC,CAAP;IACD;;;WAQDE,oBAAWC,OAAXD,EAAkD;MAChD,IAAOE,UAAP,GAAqBD,OAArB,CAAOC,UAAP;MACA,IAAMC,WAAW,GAAG;QAClBC,MAAM,EAAEF;MADU,CAApB;MAIA,KAAK7H,IAAL,CAAUgI,QAAV,GAAqB,KAAKhI,IAAL,CAAUgI,QAAV,IAAsB,EAA3C;MACA,KAAKhI,IAAL,CAAUgI,QAAV,CAAmBjE,IAAnB,CAAwB+D,WAAxB;MACA,OAAO,KAAK9H,IAAL,CAAUgI,QAAV,CAAmBhF,MAAnB,GAA4B,CAAnC;IACD;;;WAGDiF,qBAAYC,eAAZD,EAA6C;MAC3C,KAAKjI,IAAL,CAAUmI,SAAV,GAAsB,KAAKnI,IAAL,CAAUmI,SAAV,IAAuB,EAA7C;MACA,KAAKnI,IAAL,CAAUmI,SAAV,CAAoBpE,IAApB,CAAyBmE,eAAzB;MACA,OAAO,KAAKlI,IAAL,CAAUmI,SAAV,CAAoBnF,MAApB,GAA6B,CAApC;IACD;;;WAGDoF,6BAA0B;MAAA;;MAExB,KAAKtI,IAAL,CAAUH,OAAV,GAAoB,EAApB;MAGA,IAAM0I,eAAe,GAAG,KAAKnI,UAA7B;MACA,IAAM0C,WAAW,GAAG,IAAI0F,WAAJ,CAAgBD,eAAhB,CAApB;MACA,IAAME,WAAW,GAAG,IAAI5F,UAAJ,CAAeC,WAAf,CAApB;MAGA,IAAI4F,aAAa,GAAG,CAApB;;MAVwB,2CAWG,KAAKvI,aAAL,IAAsB,EAXzB;MAAA;;MAAA;QAWxB,oDAAqD;UAAA,IAA1CkH,YAA0C;UACnDqB,aAAa,GAAGtJ,WAAW,CAACiI,YAAD,EAAeoB,WAAf,EAA4BC,aAA5B,CAA3BA;QACD;MAbuB;QAAA;MAAA;QAAA;MAAA;;MAgBxB,kBAAI,KAAKxI,IAAT,6DAAIyI,WAAW9I,OAAf,+CAAI+I,mBAAqB,CAArB,CAAJ,EAA6B;QAC3B,KAAK1I,IAAL,CAAUL,OAAV,CAAkB,CAAlB,EAAqBO,UAArB,GAAkCmI,eAAlC;MADF,OAEO;QACL,KAAKrI,IAAL,CAAUL,OAAV,GAAoB,CAAC;UAACO,UAAU,EAAEmI;QAAb,CAAD,CAApB;MACD;;MAGD,KAAKvI,IAAL,CAAU6I,MAAV,GAAmB/F,WAAnB;MAGA,KAAK3C,aAAL,GAAqB,CAAC2C,WAAD,CAArB;IACD;;;WAIDqB,gCAAuB9B,KAAvB8B,EAA8B2E,MAA9B3E,EAAsC;MACpC,IAAI4E,KAAK,GAAG,IAAZ;;MACA,OAAOA,KAAP,EAAc;QACZ,IAAMtH,KAAK,GAAGY,KAAK,CAAC2G,OAAN3G,CAAcyG,MAAdzG,CAAd;;QACA,IAAIZ,KAAK,GAAG,CAAC,CAAb,EAAgB;UACdY,KAAK,CAAC4G,MAAN5G,CAAaZ,KAAbY,EAAoB,CAApBA;QADF,OAEO;UACL0G,KAAK,GAAG,KAARA;QACD;MACF;IACF;;;WAKDxD,0BAAgC;MAAA,IAAjBL,UAAiB,uEAAJ,EAAI;MAC9B,IAAMgE,MAAM,GAAG,EAAf;;MACA,KAAK,IAAMC,YAAX,IAA2BjE,UAA3B,EAAuC;QACrC,IAAMkE,aAAa,GAAGlE,UAAU,CAACiE,YAAD,CAAhC;;QACA,IAAME,QAAQ,GAAG,KAAKC,qBAAL,CAA2BH,YAA3B,CAAjB;;QACA,IAAMnG,QAAQ,GAAG,KAAKoE,eAAL,CAAqBgC,aAAa,CAACG,KAAnC,EAA0CH,aAA1C,CAAjB;QACAF,MAAM,CAACG,QAAD,CAANH,GAAmBlG,QAAnBkG;MACD;;MACD,OAAOA,MAAP;IACD;;;WAKDvD,qBAAYR,OAAZQ,EAAqB;MACnB,OAAO,KAAKyB,eAAL,CAAqBjC,OAArB,EAA8B;QAAC4B,IAAI,EAAE;MAAP,CAA9B,CAAP;IACD;;;WAKDuC,+BAAsBE,aAAtBF,EAAqC;MACnC,QAAQE,aAAa,CAACC,WAAdD,EAAR;QACE,KAAK,UAAL;QACA,KAAK,WAAL;QACA,KAAK,UAAL;UACE,OAAO,UAAP;;QACF,KAAK,QAAL;QACA,KAAK,SAAL;UACE,OAAO,QAAP;;QACF,KAAK,OAAL;QACA,KAAK,QAAL;UACE,OAAO,SAAP;;QACF,KAAK,UAAL;QACA,KAAK,WAAL;UACE,OAAO,YAAP;;QACF;UACE,OAAOA,aAAP;MAfJ;IAiBD;;;WAMDjC,4BAAmB7E,MAAnB6E,EAA2BR,IAA3BQ,EAAiC;MAC/B,IAAM2B,MAAM,GAAG;QAAC/B,GAAG,EAAE,IAAN;QAAYD,GAAG,EAAE;MAAjB,CAAf;;MACA,IAAIxE,MAAM,CAACQ,MAAPR,GAAgBqE,IAApB,EAA0B;QACxB,OAAOmC,MAAP;MACD;;MAEDA,MAAM,CAAC/B,GAAP+B,GAAa,EAAbA;MAEAA,MAAM,CAAChC,GAAPgC,GAAa,EAAbA;MACA,IAAMQ,UAAU,GAAGhH,MAAM,CAACiH,QAAPjH,CAAgB,CAAhBA,EAAmBqE,IAAnBrE,CAAnB;;MAT+B,4CAUXgH,UAVW;MAAA;;MAAA;QAU/B,uDAAgC;UAAA,IAArBH,KAAqB;UAE9BL,MAAM,CAAC/B,GAAP+B,CAAWjF,IAAXiF,CAAgBK,KAAhBL;UAEAA,MAAM,CAAChC,GAAPgC,CAAWjF,IAAXiF,CAAgBK,KAAhBL;QACD;MAf8B;QAAA;MAAA;QAAA;MAAA;;MAiB/B,KAAK,IAAIzH,KAAK,GAAGsF,IAAjB,EAAuBtF,KAAK,GAAGiB,MAAM,CAACQ,MAAtC,EAA8CzB,KAAK,IAAIsF,IAAvD,EAA6D;QAC3D,KAAK,IAAI6C,cAAc,GAAG,CAA1B,EAA6BA,cAAc,GAAG7C,IAA9C,EAAoD6C,cAAc,EAAlE,EAAsE;UAEpEV,MAAM,CAAC/B,GAAP+B,CAAW,IAAIU,cAAfV,IAAiCzB,IAAI,CAACN,GAALM,CAE/ByB,MAAM,CAAC/B,GAAP+B,CAAW,IAAIU,cAAfV,CAF+BzB,EAG/B/E,MAAM,CAACjB,KAAK,GAAGmI,cAAT,CAHyBnC,CAAjCyB;UAMAA,MAAM,CAAChC,GAAPgC,CAAW,IAAIU,cAAfV,IAAiCzB,IAAI,CAACP,GAALO,CAE/ByB,MAAM,CAAChC,GAAPgC,CAAW,IAAIU,cAAfV,CAF+BzB,EAG/B/E,MAAM,CAACjB,KAAK,GAAGmI,cAAT,CAHyBnC,CAAjCyB;QAKD;MACF;;MACD,OAAOA,MAAP;IACD;;;;;;SA/mBkBpJ,c","names":["getBinaryImageMetadata","padToNBytes","copyToArray","assert","getAccessorArrayTypeAndLength","getAccessorTypeFromSize","getComponentTypeFromArray","DEFAULT_GLTF_JSON","asset","version","generator","buffers","GLTFScenegraph","constructor","gltf","_defineProperty","json","sourceBuffers","byteLength","getApplicationData","key","data","getExtraData","extras","getExtension","extensionName","isExtension","getUsedExtensions","find","name","extensions","getRequiredExtension","isRequired","getRequiredExtensions","extensionsRequired","extensionsUsed","getObjectExtension","object","getScene","index","getObject","getNode","getSkin","getMesh","getMaterial","getAccessor","getTexture","getSampler","getImage","getBufferView","getBuffer","array","Error","getTypedArrayForBufferView","bufferView","bufferIndex","buffer","binChunk","byteOffset","Uint8Array","arrayBuffer","getTypedArrayForAccessor","accessor","ArrayType","length","getTypedArrayForImageData","image","addApplicationData","addExtraData","addObjectExtension","registerUsedExtension","setObjectExtension","removeObjectExtension","extension","addExtension","extensionData","addRequiredExtension","registerRequiredExtension","ext","push","removeExtension","_removeStringFromArray","setDefaultScene","sceneIndex","scene","addScene","nodeIndices","scenes","nodes","addNode","node","meshIndex","matrix","nodeData","mesh","addMesh","attributes","indices","material","mode","accessors","_addAttributes","glTFMesh","primitives","indicesAccessor","_addIndices","Number","isFinite","meshes","addPointCloud","accessorIndices","addImage","imageData","mimeTypeOpt","metadata","mimeType","bufferViewIndex","addBufferView","glTFImage","images","glTFBufferView","bufferViews","addAccessor","glTFAccessor","type","size","componentType","count","max","min","addBinaryBuffer","sourceBuffer","minMax","_getAccessorMinMax","accessorDefaults","Math","round","Object","assign","addTexture","texture","imageIndex","glTFTexture","source","textures","addMaterial","pbrMaterialInfo","materials","createBinaryChunk","totalByteLength","ArrayBuffer","targetArray","dstByteOffset","_this$json","_this$json$buffers","binary","string","found","indexOf","splice","result","attributeKey","attributeData","attrName","_getGltfAttributeName","value","attributeName","toLowerCase","initValues","subarray","componentIndex"],"sources":["../../../../src/lib/api/gltf-scenegraph.ts"],"sourcesContent":["import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\ntype GLTFWithBuffers = {\n  json: GLTF;\n  buffers: any[];\n  binary?: ArrayBuffer;\n};\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\ntype Extension = {[key: string]: any};\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: any} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension<T = Extension>(extensionName: string): T | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension<T = Extension>(extensionName: string): T | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getObjectExtension<T = Extension>(object: {[key: string]: any}, extensionName: string): T | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    this.json.extras[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    this.json.extensions[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix?: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices?: object; material?: number; mode?: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}