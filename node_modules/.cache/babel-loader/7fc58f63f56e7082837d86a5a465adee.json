{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _geoLayers = require(\"@deck.gl/geo-layers\");\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _h3Js = require(\"h3-js\");\n\nvar _constants = require(\"../constants\");\n\nvar _editableGeojsonLayer = _interopRequireDefault(require(\"./editable-geojson-layer\"));\n\nvar _editableLayer = _interopRequireDefault(require(\"./editable-layer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DEFAULT_EDIT_MODE = _editModes.ViewMode;\nvar DEFAULT_H3_RESOLUTION = 9;\nvar EMPTY_FEATURE_COLLECTION = {\n  type: 'FeatureCollection',\n  features: []\n};\n\nvar defaultProps = _objectSpread({\n  mode: DEFAULT_EDIT_MODE\n}, _editableGeojsonLayer[\"default\"].defaultProps, {\n  // h3 layer\n  data: [],\n  selectedIndexes: [],\n  filled: false,\n  stroked: true,\n  lineWidthScale: _constants.PROJECTED_PIXEL_SIZE_MULTIPLIER,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  getHexagons: function getHexagons(d) {\n    return d.hexIds;\n  },\n  getEditedCluster: function getEditedCluster(updatedHexagons, existingCluster) {\n    if (existingCluster) {\n      return _objectSpread({}, existingCluster, {\n        hexIds: updatedHexagons\n      });\n    }\n\n    return {\n      hexIds: updatedHexagons\n    };\n  },\n  resolution: DEFAULT_H3_RESOLUTION\n});\n\nvar EditableH3ClusterLayer = /*#__PURE__*/function (_EditableLayer) {\n  _inherits(EditableH3ClusterLayer, _EditableLayer);\n\n  var _super = _createSuper(EditableH3ClusterLayer);\n\n  function EditableH3ClusterLayer() {\n    _classCallCheck(this, EditableH3ClusterLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EditableH3ClusterLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      _get(_getPrototypeOf(EditableH3ClusterLayer.prototype), \"initializeState\", this).call(this);\n\n      this.setState({\n        tentativeHexagonIDs: []\n      });\n    } // convert array of (lng, lat) coords to cluster of hexes\n\n  }, {\n    key: \"getDerivedHexagonIDs\",\n    value: function getDerivedHexagonIDs(coords) {\n      return (0, _h3Js.polyfill)(coords, this.props.resolution, true);\n    } // convert pair of (lng, lat) coords into single hex\n\n  }, {\n    key: \"getDerivedHexagonID\",\n    value: function getDerivedHexagonID(coords) {\n      return (0, _h3Js.geoToH3)(coords[1], coords[0], this.props.resolution);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this = this;\n\n      var layers = [new _editableGeojsonLayer[\"default\"](this.getSubLayerProps({\n        id: 'editable-geojson',\n        mode: this.props.mode,\n        data: EMPTY_FEATURE_COLLECTION,\n        selectedFeatureIndexes: [],\n        onEdit: function onEdit(editAction) {\n          var editType = editAction.editType,\n              editContext = editAction.editContext;\n\n          switch (editType) {\n            case 'updateTentativeFeature':\n              // tentative feature updates, updated on every pointer move\n              if (editContext.feature.geometry.type === 'Polygon') {\n                var coords = editContext.feature.geometry.coordinates;\n\n                var hexIDs = _this.getDerivedHexagonIDs(coords);\n\n                _this.setState({\n                  tentativeHexagonIDs: hexIDs\n                });\n              } else if (editContext.feature.geometry.type === 'Point') {\n                var _coords = editContext.feature.geometry.coordinates;\n\n                var hexID = _this.getDerivedHexagonID(_coords);\n\n                _this.setState({\n                  tentativeHexagonIDs: [hexID]\n                });\n              }\n\n              break;\n\n            case 'addFeature':\n              var _updatedData = _toConsumableArray(_this.props.data);\n\n              var modeConfig = _this.props.modeConfig;\n\n              if (!modeConfig || !modeConfig.booleanOperation) {\n                // add new h3 cluster\n                _updatedData.push(_this.props.getEditedCluster(_this.state.tentativeHexagonIDs, null));\n              } else if (_this.props.selectedIndexes.length !== 1) {\n                // eslint-disable-next-line no-console,no-undef\n                console.warn('booleanOperation only supported for single cluster selection');\n              } else {\n                // they're affecting a selected cluster\n                var finalHexagonIDs;\n                var committedHexagonIDs = new Set(_this.getSelectedHexIDs());\n                var tentativeHexagonIDs = new Set(_this.state.tentativeHexagonIDs);\n\n                switch (modeConfig.booleanOperation) {\n                  case 'union':\n                  default:\n                    finalHexagonIDs = _toConsumableArray(new Set([].concat(_toConsumableArray(committedHexagonIDs), _toConsumableArray(tentativeHexagonIDs))));\n                    break;\n\n                  case 'intersection':\n                    finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function (hexID) {\n                      return tentativeHexagonIDs.has(hexID);\n                    });\n                    break;\n\n                  case 'difference':\n                    finalHexagonIDs = _toConsumableArray(committedHexagonIDs).filter(function (hexID) {\n                      return !tentativeHexagonIDs.has(hexID);\n                    });\n                    break;\n                }\n\n                var selectedIndex = _this.props.selectedIndexes[0];\n                var _existingCluster = _this.props.data[selectedIndex];\n                _updatedData[selectedIndex] = _this.props.getEditedCluster(finalHexagonIDs, _existingCluster);\n              }\n\n              _this.setState({\n                tentativeHexagonIDs: []\n              });\n\n              _this.props.onEdit({\n                updatedData: _updatedData\n              });\n\n              break;\n\n            default:\n              break;\n          }\n        }\n      })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({\n        id: 'hexagons',\n        data: this.props.data,\n        getHexagons: this.props.getHexagons\n      })), new _geoLayers.H3ClusterLayer(this.getSubLayerProps({\n        id: 'tentative-hexagons',\n        data: [{\n          hexIds: this.state.tentativeHexagonIDs\n        }],\n        getHexagons: function getHexagons(d) {\n          return d.hexIds;\n        }\n      }))];\n      return layers;\n    } // because data is an array of hexagon data, we take the cumulative of all selected indexes,\n    // using props.getHexagons to support multiple data types\n\n  }, {\n    key: \"getSelectedHexIDs\",\n    value: function getSelectedHexIDs() {\n      var _this2 = this;\n\n      var cumulativeHexIDs = [];\n      this.props.selectedIndexes.forEach(function (index) {\n        var selectedCluster = _this2.props.data[index];\n\n        var hexIDs = _this2.props.getHexagons(selectedCluster);\n\n        cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);\n      });\n      return cumulativeHexIDs;\n    }\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(_ref) {\n      var isDragging = _ref.isDragging;\n\n      var _ref2 = this.state || {},\n          cursor = _ref2.cursor;\n\n      if (!cursor) {\n        // default cursor\n        cursor = isDragging ? 'grabbing' : 'grab';\n      }\n\n      return cursor;\n    }\n  }]);\n\n  return EditableH3ClusterLayer;\n}(_editableLayer[\"default\"]);\n\nexports[\"default\"] = EditableH3ClusterLayer;\n\n_defineProperty(EditableH3ClusterLayer, \"layerName\", 'EditableH3ClusterLayer');\n\n_defineProperty(EditableH3ClusterLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["DEFAULT_EDIT_MODE","ViewMode","DEFAULT_H3_RESOLUTION","EMPTY_FEATURE_COLLECTION","type","features","defaultProps","mode","EditableGeoJsonLayer","data","selectedIndexes","filled","stroked","lineWidthScale","PROJECTED_PIXEL_SIZE_MULTIPLIER","lineWidthMinPixels","lineWidthMaxPixels","Number","MAX_SAFE_INTEGER","lineWidthUnits","getHexagons","d","hexIds","getEditedCluster","updatedHexagons","existingCluster","resolution","EditableH3ClusterLayer","_get","setState","tentativeHexagonIDs","coords","props","layers","getSubLayerProps","id","selectedFeatureIndexes","onEdit","editAction","editType","editContext","feature","geometry","coordinates","hexIDs","_this","getDerivedHexagonIDs","hexID","getDerivedHexagonID","updatedData","modeConfig","booleanOperation","push","state","length","console","warn","finalHexagonIDs","committedHexagonIDs","Set","getSelectedHexIDs","_toConsumableArray","filter","has","selectedIndex","H3ClusterLayer","cumulativeHexIDs","forEach","index","selectedCluster","_this2","concat","isDragging","cursor","EditableLayer"],"sources":["../../src/layers/editable-h3-cluster-layer.ts"],"sourcesContent":["/* eslint-env browser */\n\nimport { H3ClusterLayer } from '@deck.gl/geo-layers';\nimport { ViewMode } from '@nebula.gl/edit-modes';\nimport { polyfill, geoToH3 } from 'h3-js';\nimport { PROJECTED_PIXEL_SIZE_MULTIPLIER } from '../constants';\nimport EditableGeoJsonLayer from './editable-geojson-layer';\nimport EditableLayer, { EditableLayerProps } from './editable-layer';\n\nconst DEFAULT_EDIT_MODE = ViewMode;\nconst DEFAULT_H3_RESOLUTION = 9;\nconst EMPTY_FEATURE_COLLECTION = {\n  type: 'FeatureCollection',\n  features: [],\n};\n\nexport interface EditableH3ClusterLayerProps<D> extends EditableLayerProps<D> {\n  resolution?: number;\n  mode?: any;\n  modeConfig?: any;\n  selectedIndexes?: number[];\n  getEditedCluster?: (updatedHexagons: any[], existingCluster: any) => any;\n  getHexagons?: (d) => number[];\n  onEdit?: (updatedData?, editType?: string, featureIndexes?: number[], editContext?) => void;\n  filled?: boolean;\n  stroked?: boolean;\n  lineWidthScale?: number;\n  lineWidthMinPixels?: number;\n  lineWidthMaxPixels?: number;\n  lineWidthUnits?: string;\n}\n\nconst defaultProps: EditableH3ClusterLayerProps<any> = {\n  mode: DEFAULT_EDIT_MODE,\n\n  ...EditableGeoJsonLayer.defaultProps,\n\n  // h3 layer\n  data: [],\n  selectedIndexes: [],\n  filled: false,\n  stroked: true,\n  lineWidthScale: PROJECTED_PIXEL_SIZE_MULTIPLIER,\n  lineWidthMinPixels: 1,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineWidthUnits: 'pixels',\n  getHexagons: (d) => d.hexIds,\n  getEditedCluster: (updatedHexagons, existingCluster) => {\n    if (existingCluster) {\n      return {\n        ...existingCluster,\n        hexIds: updatedHexagons,\n      };\n    }\n    return {\n      hexIds: updatedHexagons,\n    };\n  },\n  resolution: DEFAULT_H3_RESOLUTION,\n};\n\nexport default class EditableH3ClusterLayer extends EditableLayer<\n  any,\n  EditableH3ClusterLayerProps<any>\n> {\n  static layerName = 'EditableH3ClusterLayer';\n  static defaultProps = defaultProps;\n\n  initializeState() {\n    super.initializeState();\n\n    this.setState({\n      tentativeHexagonIDs: [],\n    });\n  }\n\n  // convert array of (lng, lat) coords to cluster of hexes\n  getDerivedHexagonIDs(coords) {\n    return polyfill(coords, this.props.resolution, true);\n  }\n\n  // convert pair of (lng, lat) coords into single hex\n  getDerivedHexagonID(coords) {\n    return geoToH3(coords[1], coords[0], this.props.resolution);\n  }\n\n  renderLayers() {\n    const layers: any = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: 'editable-geojson',\n\n          mode: this.props.mode,\n          data: EMPTY_FEATURE_COLLECTION,\n          selectedFeatureIndexes: [],\n\n          onEdit: (editAction) => {\n            const { editType, editContext } = editAction;\n\n            switch (editType) {\n              case 'updateTentativeFeature':\n                // tentative feature updates, updated on every pointer move\n                if (editContext.feature.geometry.type === 'Polygon') {\n                  const coords = editContext.feature.geometry.coordinates;\n                  const hexIDs = this.getDerivedHexagonIDs(coords);\n\n                  this.setState({ tentativeHexagonIDs: hexIDs });\n                } else if (editContext.feature.geometry.type === 'Point') {\n                  const coords = editContext.feature.geometry.coordinates;\n                  const hexID = this.getDerivedHexagonID(coords);\n\n                  this.setState({ tentativeHexagonIDs: [hexID] });\n                }\n                break;\n              case 'addFeature':\n                const updatedData = [...this.props.data];\n                const { modeConfig } = this.props;\n\n                if (!modeConfig || !modeConfig.booleanOperation) {\n                  // add new h3 cluster\n                  updatedData.push(\n                    this.props.getEditedCluster(this.state.tentativeHexagonIDs, null)\n                  );\n                } else if (this.props.selectedIndexes.length !== 1) {\n                  // eslint-disable-next-line no-console,no-undef\n                  console.warn('booleanOperation only supported for single cluster selection');\n                } else {\n                  // they're affecting a selected cluster\n                  let finalHexagonIDs;\n                  const committedHexagonIDs = new Set(this.getSelectedHexIDs());\n                  const tentativeHexagonIDs = new Set(this.state.tentativeHexagonIDs);\n\n                  switch (modeConfig.booleanOperation) {\n                    case 'union':\n                    default:\n                      finalHexagonIDs = [\n                        ...new Set([...committedHexagonIDs, ...tentativeHexagonIDs]),\n                      ];\n                      break;\n                    case 'intersection':\n                      finalHexagonIDs = [...committedHexagonIDs].filter((hexID: string) =>\n                        tentativeHexagonIDs.has(hexID)\n                      );\n                      break;\n                    case 'difference':\n                      finalHexagonIDs = [...committedHexagonIDs].filter(\n                        (hexID: string) => !tentativeHexagonIDs.has(hexID)\n                      );\n                      break;\n                  }\n\n                  const selectedIndex = this.props.selectedIndexes[0];\n                  const existingCluster = this.props.data[selectedIndex];\n                  updatedData[selectedIndex] = this.props.getEditedCluster(\n                    finalHexagonIDs,\n                    existingCluster\n                  );\n                }\n\n                this.setState({\n                  tentativeHexagonIDs: [],\n                });\n\n                this.props.onEdit({ updatedData });\n\n                break;\n              default:\n                break;\n            }\n          },\n        })\n      ),\n\n      new H3ClusterLayer(\n        this.getSubLayerProps({\n          id: 'hexagons',\n          data: this.props.data,\n          getHexagons: this.props.getHexagons,\n        })\n      ),\n      new H3ClusterLayer(\n        this.getSubLayerProps({\n          id: 'tentative-hexagons',\n          data: [\n            {\n              hexIds: this.state.tentativeHexagonIDs,\n            },\n          ],\n          getHexagons: (d) => d.hexIds,\n        })\n      ),\n    ];\n    return layers;\n  }\n\n  // because data is an array of hexagon data, we take the cumulative of all selected indexes,\n  // using props.getHexagons to support multiple data types\n  getSelectedHexIDs() {\n    let cumulativeHexIDs = [];\n    this.props.selectedIndexes.forEach((index) => {\n      const selectedCluster = this.props.data[index];\n      const hexIDs = this.props.getHexagons(selectedCluster);\n      cumulativeHexIDs = cumulativeHexIDs.concat(hexIDs);\n    });\n    return cumulativeHexIDs;\n  }\n\n  getCursor({ isDragging }: { isDragging: boolean }) {\n    let { cursor } = this.state || {};\n    if (!cursor) {\n      // default cursor\n      cursor = isDragging ? 'grabbing' : 'grab';\n    }\n    return cursor;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}