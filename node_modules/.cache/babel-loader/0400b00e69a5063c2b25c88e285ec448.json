{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImmutableFeatureCollection = void 0;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar ImmutableFeatureCollection = /*#__PURE__*/function () {\n  function ImmutableFeatureCollection(featureCollection) {\n    _classCallCheck(this, ImmutableFeatureCollection);\n\n    _defineProperty(this, \"featureCollection\", void 0);\n\n    this.featureCollection = featureCollection;\n  }\n\n  _createClass(ImmutableFeatureCollection, [{\n    key: \"getObject\",\n    value: function getObject() {\n      return this.featureCollection;\n    }\n    /**\n     * Replaces the position deeply nested withing the given feature's geometry.\n     * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position to replace\n     * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"replacePosition\",\n    value: function replacePosition(featureIndex, positionIndexes, updatedPosition) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyReplacePosition(geometry.coordinates, positionIndexes, updatedPosition, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the postion to remove\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"removePosition\",\n    value: function removePosition(featureIndex, positionIndexes) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw Error(\"Can't remove a position from a Point or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'MultiPoint' && // only 1 point left\n      geometry.coordinates.length < 2) {\n        throw Error(\"Can't remove the last point of a MultiPoint or there'd be nothing left\");\n      }\n\n      if (geometry.type === 'LineString' && // only 2 positions\n      geometry.coordinates.length < 3) {\n        throw Error(\"Can't remove position. LineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'Polygon' && // outer ring is a triangle\n      geometry.coordinates[0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from outer ring\n      positionIndexes[0] === 0) {\n        throw Error(\"Can't remove position. Polygon's outer ring must have at least four positions\");\n      }\n\n      if (geometry.type === 'MultiLineString' && // only 1 LineString left\n      geometry.coordinates.length === 1 && // only 2 positions\n      geometry.coordinates[0].length < 3) {\n        throw Error(\"Can't remove position. MultiLineString must have at least two positions\");\n      }\n\n      if (geometry.type === 'MultiPolygon' && // only 1 polygon left\n      geometry.coordinates.length === 1 && // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 && Array.isArray(positionIndexes) && // trying to remove from first polygon\n      positionIndexes[0] === 0 && // trying to remove from outer ring\n      positionIndexes[1] === 0) {\n        throw Error(\"Can't remove position. MultiPolygon's outer ring must have at least four positions\");\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal)\n      }); // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n\n\n      pruneGeometryIfNecessary(updatedGeometry);\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n    /**\n     * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n     * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n     *\n     * @param featureIndex The index of the feature to update\n     * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n     * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n     *\n     * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n     */\n\n  }, {\n    key: \"addPosition\",\n    value: function addPosition(featureIndex, positionIndexes, positionToAdd) {\n      var geometry = this.featureCollection.features[featureIndex].geometry;\n\n      if (geometry.type === 'Point') {\n        throw new Error('Unable to add a position to a Point feature');\n      }\n\n      var isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n\n      var updatedGeometry = _objectSpread({}, geometry, {\n        coordinates: immutablyAddPosition(geometry.coordinates, positionIndexes, positionToAdd, isPolygonal)\n      });\n\n      return this.replaceGeometry(featureIndex, updatedGeometry);\n    }\n  }, {\n    key: \"replaceGeometry\",\n    value: function replaceGeometry(featureIndex, geometry) {\n      var updatedFeature = _objectSpread({}, this.featureCollection.features[featureIndex], {\n        geometry: geometry\n      });\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: [].concat(_toConsumableArray(this.featureCollection.features.slice(0, featureIndex)), [updatedFeature], _toConsumableArray(this.featureCollection.features.slice(featureIndex + 1)))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"addFeature\",\n    value: function addFeature(feature) {\n      return this.addFeatures([feature]);\n    }\n  }, {\n    key: \"addFeatures\",\n    value: function addFeatures(features) {\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: [].concat(_toConsumableArray(this.featureCollection.features), _toConsumableArray(features))\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }, {\n    key: \"deleteFeature\",\n    value: function deleteFeature(featureIndex) {\n      return this.deleteFeatures([featureIndex]);\n    }\n  }, {\n    key: \"deleteFeatures\",\n    value: function deleteFeatures(featureIndexes) {\n      var features = _toConsumableArray(this.featureCollection.features);\n\n      featureIndexes.sort();\n\n      for (var i = featureIndexes.length - 1; i >= 0; i--) {\n        var featureIndex = featureIndexes[i];\n\n        if (featureIndex >= 0 && featureIndex < features.length) {\n          features.splice(featureIndex, 1);\n        }\n      }\n\n      var updatedFeatureCollection = _objectSpread({}, this.featureCollection, {\n        features: features\n      });\n\n      return new ImmutableFeatureCollection(updatedFeatureCollection);\n    }\n  }]);\n\n  return ImmutableFeatureCollection;\n}();\n\nexports.ImmutableFeatureCollection = ImmutableFeatureCollection;\n\nfunction getUpdatedPosition(updatedPosition, previousPosition) {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    var elevation = previousPosition[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(coordinates, positionIndexes, updatedPosition, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]])], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyReplacePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), updatedPosition, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyRemovePosition(coordinates, positionIndexes, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n\n    if (isPolygonal && (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyRemovePosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction immutablyAddPosition(coordinates, positionIndexes, positionToAdd, isPolygonal) {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n\n  if (positionIndexes.length === 1) {\n    var updated = [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [positionToAdd], _toConsumableArray(coordinates.slice(positionIndexes[0])));\n    return updated;\n  } // recursively update inner array\n\n\n  return [].concat(_toConsumableArray(coordinates.slice(0, positionIndexes[0])), [immutablyAddPosition(coordinates[positionIndexes[0]], positionIndexes.slice(1, positionIndexes.length), positionToAdd, isPolygonal)], _toConsumableArray(coordinates.slice(positionIndexes[0] + 1)));\n}\n\nfunction pruneGeometryIfNecessary(geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry) {\n  var polygon = geometry.coordinates; // If any hole is no longer a polygon, remove the hole entirely\n\n  for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry) {\n  for (var lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    var lineString = geometry.coordinates[lineStringIndex];\n\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1); // Keep the index the same\n\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry) {\n  for (var polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    var polygon = geometry.coordinates[polygonIndex];\n    var outerRing = polygon[0]; // If the outer ring is no longer a polygon, remove the whole polygon\n\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1); // It was removed, so keep the index the same\n\n      polygonIndex--;\n    }\n\n    for (var holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon, holeIndex) {\n  var hole = polygon[holeIndex];\n\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAWaA,0B;EAGX,oCAAYC,iBAAZ,EAAkD;IAAAC;;IAAAC;;IAChD,KAAKF,iBAAL,GAAyBA,iBAAzB;EACD;;;;gCAEW;MACV,OAAO,KAAKA,iBAAZ;IACD;IAED;;;;;;;;;;;;;oCAWEG,cACAC,iBACAC,iBAC4B;MAC5B,IAAMC,QAAQ,GAAG,KAAKN,iBAAL,CAAuBO,QAAvB,CAAgCJ,YAAhC,EAA8CG,QAA/D;MAEA,IAAME,WAAW,GAAGF,QAAQ,CAACG,IAATH,KAAkB,SAAlBA,IAA+BA,QAAQ,CAACG,IAATH,KAAkB,cAArE;;MACA,IAAMI,eAAoB,qBACrBJ,QADqB;QAExBK,WAAW,EAAEC,wBAAwB,CACnCN,QAAQ,CAACK,WAD0B,EAEnCP,eAFmC,EAGnCC,eAHmC,EAInCG,WAJmC;MAFb,EAA1B;;MAUA,OAAO,KAAKK,eAAL,CAAqBV,YAArB,EAAmCO,eAAnC,CAAP;IACD;IAED;;;;;;;;;;;;mCAUEP,cACAC,iBAC4B;MAC5B,IAAME,QAAQ,GAAG,KAAKN,iBAAL,CAAuBO,QAAvB,CAAgCJ,YAAhC,EAA8CG,QAA/D;;MAEA,IAAIA,QAAQ,CAACG,IAATH,KAAkB,OAAtB,EAA+B;QAC7B,MAAMQ,KAAK,mEAAX;MACD;;MACD,IACER,QAAQ,CAACG,IAATH,KAAkB,YAAlBA,IAAkC;MAClCA,QAAQ,CAACK,WAATL,CAAqBS,MAArBT,GAA8B,CAFhC,EAGE;QACA,MAAMQ,KAAK,0EAAX;MACD;;MACD,IACER,QAAQ,CAACG,IAATH,KAAkB,YAAlBA,IAAkC;MAClCA,QAAQ,CAACK,WAATL,CAAqBS,MAArBT,GAA8B,CAFhC,EAGE;QACA,MAAMQ,KAAK,sEAAX;MACD;;MACD,IACER,QAAQ,CAACG,IAATH,KAAkB,SAAlBA,IAA+B;MAC/BA,QAAQ,CAACK,WAATL,CAAqB,CAArBA,EAAwBS,MAAxBT,GAAiC,CADjCA,IAEAU,KAAK,CAACC,OAAND,CAAcZ,eAAdY,CAFAV,IAEkC;MAClCF,eAAe,CAAC,CAAD,CAAfA,KAAuB,CAJzB,EAKE;QACA,MAAMU,KAAK,iFAAX;MACD;;MACD,IACER,QAAQ,CAACG,IAATH,KAAkB,iBAAlBA,IAAuC;MACvCA,QAAQ,CAACK,WAATL,CAAqBS,MAArBT,KAAgC,CADhCA,IACqC;MACrCA,QAAQ,CAACK,WAATL,CAAqB,CAArBA,EAAwBS,MAAxBT,GAAiC,CAHnC,EAIE;QACA,MAAMQ,KAAK,2EAAX;MACD;;MACD,IACER,QAAQ,CAACG,IAATH,KAAkB,cAAlBA,IAAoC;MACpCA,QAAQ,CAACK,WAATL,CAAqBS,MAArBT,KAAgC,CADhCA,IACqC;MACrCA,QAAQ,CAACK,WAATL,CAAqB,CAArBA,EAAwB,CAAxBA,EAA2BS,MAA3BT,GAAoC,CAFpCA,IAGAU,KAAK,CAACC,OAAND,CAAcZ,eAAdY,CAHAV,IAGkC;MAClCF,eAAe,CAAC,CAAD,CAAfA,KAAuB,CAJvBE,IAI4B;MAC5BF,eAAe,CAAC,CAAD,CAAfA,KAAuB,CANzB,EAOE;QACA,MAAMU,KAAK,sFAAX;MAGD;;MAED,IAAMN,WAAW,GAAGF,QAAQ,CAACG,IAATH,KAAkB,SAAlBA,IAA+BA,QAAQ,CAACG,IAATH,KAAkB,cAArE;;MACA,IAAMI,eAAoB,qBACrBJ,QADqB;QAExBK,WAAW,EAAEO,uBAAuB,CAACZ,QAAQ,CAACK,WAAV,EAAuBP,eAAvB,EAAwCI,WAAxC;MAFZ,EAA1B,CA/C4B,CAoD5B;;;MACAW,wBAAwB,CAACT,eAAD,CAAxBS;MAEA,OAAO,KAAKN,eAAL,CAAqBV,YAArB,EAAmCO,eAAnC,CAAP;IACD;IAED;;;;;;;;;;;;;gCAWEP,cACAC,iBACAgB,eAC4B;MAC5B,IAAMd,QAAQ,GAAG,KAAKN,iBAAL,CAAuBO,QAAvB,CAAgCJ,YAAhC,EAA8CG,QAA/D;;MAEA,IAAIA,QAAQ,CAACG,IAATH,KAAkB,OAAtB,EAA+B;QAC7B,MAAM,IAAIQ,KAAJ,CAAU,6CAAV,CAAN;MACD;;MAED,IAAMN,WAAW,GAAGF,QAAQ,CAACG,IAATH,KAAkB,SAAlBA,IAA+BA,QAAQ,CAACG,IAATH,KAAkB,cAArE;;MACA,IAAMI,eAAoB,qBACrBJ,QADqB;QAExBK,WAAW,EAAEU,oBAAoB,CAC/Bf,QAAQ,CAACK,WADsB,EAE/BP,eAF+B,EAG/BgB,aAH+B,EAI/BZ,WAJ+B;MAFT,EAA1B;;MAUA,OAAO,KAAKK,eAAL,CAAqBV,YAArB,EAAmCO,eAAnC,CAAP;IACD;;;oCAEeP,cAAsBG,UAAgD;MACpF,IAAMgB,cAAmB,qBACpB,KAAKtB,iBAAL,CAAuBO,QAAvB,CAAgCJ,YAAhC,CADoB;QAEvBG,QAAQ,EAARA;MAFuB,EAAzB;;MAKA,IAAMiB,wBAAwB,qBACzB,KAAKvB,iBADoB;QAE5BO,QAAQ,+BACH,KAAKP,iBAAL,CAAuBO,QAAvB,CAAgCiB,KAAhC,CAAsC,CAAtC,EAAyCrB,YAAzC,CADG,IAENmB,cAFM,sBAGH,KAAKtB,iBAAL,CAAuBO,QAAvB,CAAgCiB,KAAhC,CAAsCrB,YAAY,GAAG,CAArD,CAHG;MAFoB,EAA9B;;MASA,OAAO,IAAIJ,0BAAJ,CAA+BwB,wBAA/B,CAAP;IACD;;;+BAEUE,SAA8C;MACvD,OAAO,KAAKC,WAAL,CAAiB,CAACD,OAAD,CAAjB,CAAP;IACD;;;gCAEWlB,UAAiD;MAC3D,IAAMgB,wBAAwB,qBACzB,KAAKvB,iBADoB;QAE5BO,QAAQ,+BAAM,KAAKP,iBAAL,CAAuBO,QAA7B,sBAA0CA,QAA1C;MAFoB,EAA9B;;MAKA,OAAO,IAAIR,0BAAJ,CAA+BwB,wBAA/B,CAAP;IACD;;;kCAEapB,cAAsB;MAClC,OAAO,KAAKwB,cAAL,CAAoB,CAACxB,YAAD,CAApB,CAAP;IACD;;;mCAEcyB,gBAA0B;MACvC,IAAMrB,QAAQ,sBAAO,KAAKP,iBAAL,CAAuBO,QAA9B,CAAd;;MACAqB,cAAc,CAACC,IAAfD;;MACA,KAAK,IAAIE,CAAC,GAAGF,cAAc,CAACb,MAAfa,GAAwB,CAArC,EAAwCE,CAAC,IAAI,CAA7C,EAAgDA,CAAC,EAAjD,EAAqD;QACnD,IAAM3B,YAAY,GAAGyB,cAAc,CAACE,CAAD,CAAnC;;QACA,IAAI3B,YAAY,IAAI,CAAhBA,IAAqBA,YAAY,GAAGI,QAAQ,CAACQ,MAAjD,EAAyD;UACvDR,QAAQ,CAACwB,MAATxB,CAAgBJ,YAAhBI,EAA8B,CAA9BA;QACD;MACF;;MAED,IAAMgB,wBAAwB,qBACzB,KAAKvB,iBADoB;QAE5BO,QAAQ,EAARA;MAF4B,EAA9B;;MAKA,OAAO,IAAIR,0BAAJ,CAA+BwB,wBAA/B,CAAP;IACD;;;;;;;;AAGH,SAASS,kBAAT,CAA4B3B,eAA5B,EAAuD4B,gBAAvD,EAA6F;EAC3F;EACA;EACA,IAAI5B,eAAe,CAACU,MAAhBV,KAA2B,CAA3BA,IAAgC4B,gBAAgB,CAAClB,MAAjBkB,KAA4B,CAAhE,EAAmE;IACjE,IAAMC,SAAS,GAAID,gBAAD,CAA0B,CAA1B,CAAlB;IACA,OAAO,CAAC5B,eAAe,CAAC,CAAD,CAAhB,EAAqBA,eAAe,CAAC,CAAD,CAApC,EAAyC6B,SAAzC,CAAP;EACD;;EAED,OAAO7B,eAAP;AACD;;AAED,SAASO,wBAAT,CACED,WADF,EAEEP,eAFF,EAGEC,eAHF,EAIEG,WAJF,EAKO;EACL,IAAI,CAACJ,eAAL,EAAsB;IACpB,OAAOO,WAAP;EACD;;EACD,IAAIP,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,OAAO4B,kBAAkB,CAAC3B,eAAD,EAAkBM,WAAlB,CAAzB;EACD;;EACD,IAAIP,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,IAAM+B,OAAO,gCACRxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADQ,IAEXqB,kBAAkB,CAAC3B,eAAD,EAAkBM,WAAW,CAACP,eAAe,CAAC,CAAD,CAAhB,CAA7B,CAFP,sBAGRO,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAfA,GAAqB,CAAvCO,CAHQ,EAAb;;IAMA,IACEH,WAAW,KACVJ,eAAe,CAAC,CAAD,CAAfA,KAAuB,CAAvBA,IAA4BA,eAAe,CAAC,CAAD,CAAfA,KAAuBO,WAAW,CAACI,MAAZJ,GAAqB,CAD9D,CADb,EAGE;MACA;MACA;MACAwB,OAAO,CAAC,CAAD,CAAPA,GAAaH,kBAAkB,CAAC3B,eAAD,EAAkBM,WAAW,CAAC,CAAD,CAA7B,CAA/BwB;MACAA,OAAO,CAACxB,WAAW,CAACI,MAAZJ,GAAqB,CAAtB,CAAPwB,GAAkCH,kBAAkB,CAAC3B,eAAD,EAAkBM,WAAW,CAAC,CAAD,CAA7B,CAApDwB;IACD;;IACD,OAAOA,OAAP;EAvBG,EA0BL;;;EACA,oCACKxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADL,IAEEC,wBAAwB,CACtBD,WAAW,CAACP,eAAe,CAAC,CAAD,CAAhB,CADW,EAEtBA,eAAe,CAACoB,KAAhBpB,CAAsB,CAAtBA,EAAyBA,eAAe,CAACW,MAAzCX,CAFsB,EAGtBC,eAHsB,EAItBG,WAJsB,CAF1B,sBAQKG,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAfA,GAAqB,CAAvCO,CARL;AAUD;;AAED,SAASO,uBAAT,CACEP,WADF,EAEEP,eAFF,EAGEI,WAHF,EAIO;EACL,IAAI,CAACJ,eAAL,EAAsB;IACpB,OAAOO,WAAP;EACD;;EACD,IAAIP,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,MAAMU,KAAK,CAAC,kDAAD,CAAX;EACD;;EACD,IAAIV,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,IAAM+B,OAAO,gCACRxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADQ,sBAERA,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAfA,GAAqB,CAAvCO,CAFQ,EAAb;;IAKA,IACEH,WAAW,KACVJ,eAAe,CAAC,CAAD,CAAfA,KAAuB,CAAvBA,IAA4BA,eAAe,CAAC,CAAD,CAAfA,KAAuBO,WAAW,CAACI,MAAZJ,GAAqB,CAD9D,CADb,EAGE;MACA;MACA;MACA,IAAIP,eAAe,CAAC,CAAD,CAAfA,KAAuB,CAA3B,EAA8B;QAC5B;QACA+B,OAAO,CAACA,OAAO,CAACpB,MAARoB,GAAiB,CAAlB,CAAPA,GAA8BA,OAAO,CAAC,CAAD,CAArCA;MAFF,OAGO,IAAI/B,eAAe,CAAC,CAAD,CAAfA,KAAuBO,WAAW,CAACI,MAAZJ,GAAqB,CAAhD,EAAmD;QACxD;QACAwB,OAAO,CAAC,CAAD,CAAPA,GAAaA,OAAO,CAACA,OAAO,CAACpB,MAARoB,GAAiB,CAAlB,CAApBA;MACD;IACF;;IACD,OAAOA,OAAP;EA3BG,EA8BL;;;EACA,oCACKxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADL,IAEEO,uBAAuB,CACrBP,WAAW,CAACP,eAAe,CAAC,CAAD,CAAhB,CADU,EAErBA,eAAe,CAACoB,KAAhBpB,CAAsB,CAAtBA,EAAyBA,eAAe,CAACW,MAAzCX,CAFqB,EAGrBI,WAHqB,CAFzB,sBAOKG,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAfA,GAAqB,CAAvCO,CAPL;AASD;;AAED,SAASU,oBAAT,CACEV,WADF,EAEEP,eAFF,EAGEgB,aAHF,EAIEZ,WAJF,EAKO;EACL,IAAI,CAACJ,eAAL,EAAsB;IACpB,OAAOO,WAAP;EACD;;EACD,IAAIP,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,MAAMU,KAAK,CAAC,kDAAD,CAAX;EACD;;EACD,IAAIV,eAAe,CAACW,MAAhBX,KAA2B,CAA/B,EAAkC;IAChC,IAAM+B,OAAO,gCACRxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADQ,IAEXS,aAFW,sBAGRT,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAjCO,CAHQ,EAAb;IAKA,OAAOwB,OAAP;EAbG,EAgBL;;;EACA,oCACKxB,WAAW,CAACa,KAAZb,CAAkB,CAAlBA,EAAqBP,eAAe,CAAC,CAAD,CAApCO,CADL,IAEEU,oBAAoB,CAClBV,WAAW,CAACP,eAAe,CAAC,CAAD,CAAhB,CADO,EAElBA,eAAe,CAACoB,KAAhBpB,CAAsB,CAAtBA,EAAyBA,eAAe,CAACW,MAAzCX,CAFkB,EAGlBgB,aAHkB,EAIlBZ,WAJkB,CAFtB,sBAQKG,WAAW,CAACa,KAAZb,CAAkBP,eAAe,CAAC,CAAD,CAAfA,GAAqB,CAAvCO,CARL;AAUD;;AAED,SAASQ,wBAAT,CAAkCb,QAAlC,EAAsD;EACpD,QAAQA,QAAQ,CAACG,IAAjB;IACE,KAAK,SAAL;MACE2B,uBAAuB,CAAC9B,QAAD,CAAvB8B;MACA;;IACF,KAAK,iBAAL;MACEC,+BAA+B,CAAC/B,QAAD,CAA/B+B;MACA;;IACF,KAAK,cAAL;MACEC,4BAA4B,CAAChC,QAAD,CAA5BgC;MACA;;IACF;MACE;MACA;EAZJ;AAcD;;AAED,SAASF,uBAAT,CAAiC9B,QAAjC,EAAoD;EAClD,IAAMiC,OAAO,GAAGjC,QAAQ,CAACK,WAAzB,CADkD,CAGlD;;EACA,KAAK,IAAI6B,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGD,OAAO,CAACxB,MAA5C,EAAoDyB,SAAS,EAA7D,EAAiE;IAC/D,IAAIC,qBAAqB,CAACF,OAAD,EAAUC,SAAV,CAAzB,EAA+C;MAC7C;MACAA,SAAS;IACV;EACF;AACF;;AAED,SAASH,+BAAT,CAAyC/B,QAAzC,EAAoE;EAClE,KAAK,IAAIoC,eAAe,GAAG,CAA3B,EAA8BA,eAAe,GAAGpC,QAAQ,CAACK,WAATL,CAAqBS,MAArE,EAA6E2B,eAAe,EAA5F,EAAgG;IAC9F,IAAMC,UAAU,GAAGrC,QAAQ,CAACK,WAATL,CAAqBoC,eAArBpC,CAAnB;;IACA,IAAIqC,UAAU,CAAC5B,MAAX4B,KAAsB,CAA1B,EAA6B;MAC3B;MACArC,QAAQ,CAACK,WAATL,CAAqByB,MAArBzB,CAA4BoC,eAA5BpC,EAA6C,CAA7CA,EAF2B,CAG3B;;MACAoC,eAAe;IAChB;EACF;AACF;;AAED,SAASJ,4BAAT,CAAsChC,QAAtC,EAA8D;EAC5D,KAAK,IAAIsC,YAAY,GAAG,CAAxB,EAA2BA,YAAY,GAAGtC,QAAQ,CAACK,WAATL,CAAqBS,MAA/D,EAAuE6B,YAAY,EAAnF,EAAuF;IACrF,IAAML,OAAO,GAAGjC,QAAQ,CAACK,WAATL,CAAqBsC,YAArBtC,CAAhB;IACA,IAAMuC,SAAS,GAAGN,OAAO,CAAC,CAAD,CAAzB,CAFqF,CAIrF;;IACA,IAAIM,SAAS,CAAC9B,MAAV8B,IAAoB,CAAxB,EAA2B;MACzBvC,QAAQ,CAACK,WAATL,CAAqByB,MAArBzB,CAA4BsC,YAA5BtC,EAA0C,CAA1CA,EADyB,CAEzB;;MACAsC,YAAY;IACb;;IAED,KAAK,IAAIJ,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGD,OAAO,CAACxB,MAA5C,EAAoDyB,SAAS,EAA7D,EAAiE;MAC/D,IAAIC,qBAAqB,CAACF,OAAD,EAAUC,SAAV,CAAzB,EAA+C;QAC7C;QACAA,SAAS;MACV;IACF;EACF;AACF;;AAED,SAASC,qBAAT,CAA+BF,OAA/B,EAA4DC,SAA5D,EAA+E;EAC7E,IAAMM,IAAI,GAAGP,OAAO,CAACC,SAAD,CAApB;;EACA,IAAIM,IAAI,CAAC/B,MAAL+B,IAAe,CAAnB,EAAsB;IACpBP,OAAO,CAACR,MAARQ,CAAeC,SAAfD,EAA0B,CAA1BA;IACA,OAAO,IAAP;EACD;;EACD,OAAO,KAAP;AACD","names":["ImmutableFeatureCollection","featureCollection","_classCallCheck","_defineProperty","featureIndex","positionIndexes","updatedPosition","geometry","features","isPolygonal","type","updatedGeometry","coordinates","immutablyReplacePosition","replaceGeometry","Error","length","Array","isArray","immutablyRemovePosition","pruneGeometryIfNecessary","positionToAdd","immutablyAddPosition","updatedFeature","updatedFeatureCollection","slice","feature","addFeatures","deleteFeatures","featureIndexes","sort","i","splice","getUpdatedPosition","previousPosition","elevation","updated","prunePolygonIfNecessary","pruneMultiLineStringIfNecessary","pruneMultiPolygonIfNecessary","polygon","holeIndex","removeHoleIfNecessary","lineStringIndex","lineString","polygonIndex","outerRing","hole"],"sources":["../../src/lib/immutable-feature-collection.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  Polygon,\n  MultiLineString,\n  MultiPolygon,\n  Position,\n  PolygonCoordinates,\n} from '../geojson-types';\n\nexport class ImmutableFeatureCollection {\n  featureCollection: FeatureCollection;\n\n  constructor(featureCollection: FeatureCollection) {\n    this.featureCollection = featureCollection;\n  }\n\n  getObject() {\n    return this.featureCollection;\n  }\n\n  /**\n   * Replaces the position deeply nested withing the given feature's geometry.\n   * Works with Point, MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position to replace\n   * @param updatedPosition The updated position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given position replaced. Does not modify this `ImmutableFeatureCollection`.\n   */\n  replacePosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined,\n    updatedPosition: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyReplacePosition(\n        geometry.coordinates,\n        positionIndexes,\n        updatedPosition,\n        isPolygonal\n      ),\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Removes a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the postion to remove\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  removePosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw Error(`Can't remove a position from a Point or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'MultiPoint' && // only 1 point left\n      geometry.coordinates.length < 2\n    ) {\n      throw Error(`Can't remove the last point of a MultiPoint or there'd be nothing left`);\n    }\n    if (\n      geometry.type === 'LineString' && // only 2 positions\n      geometry.coordinates.length < 3\n    ) {\n      throw Error(`Can't remove position. LineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'Polygon' && // outer ring is a triangle\n      geometry.coordinates[0].length < 5 &&\n      Array.isArray(positionIndexes) && // trying to remove from outer ring\n      positionIndexes[0] === 0\n    ) {\n      throw Error(`Can't remove position. Polygon's outer ring must have at least four positions`);\n    }\n    if (\n      geometry.type === 'MultiLineString' && // only 1 LineString left\n      geometry.coordinates.length === 1 && // only 2 positions\n      geometry.coordinates[0].length < 3\n    ) {\n      throw Error(`Can't remove position. MultiLineString must have at least two positions`);\n    }\n    if (\n      geometry.type === 'MultiPolygon' && // only 1 polygon left\n      geometry.coordinates.length === 1 && // outer ring is a triangle\n      geometry.coordinates[0][0].length < 5 &&\n      Array.isArray(positionIndexes) && // trying to remove from first polygon\n      positionIndexes[0] === 0 && // trying to remove from outer ring\n      positionIndexes[1] === 0\n    ) {\n      throw Error(\n        `Can't remove position. MultiPolygon's outer ring must have at least four positions`\n      );\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyRemovePosition(geometry.coordinates, positionIndexes, isPolygonal),\n    };\n\n    // Handle cases where incomplete geometries need pruned (e.g. holes that were triangles)\n    pruneGeometryIfNecessary(updatedGeometry);\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  /**\n   * Adds a position deeply nested in a GeoJSON geometry coordinates array.\n   * Works with MultiPoint, LineString, MultiLineString, Polygon, and MultiPolygon.\n   *\n   * @param featureIndex The index of the feature to update\n   * @param positionIndexes An array containing the indexes of the position that will proceed the new position\n   * @param positionToAdd The new position to place in the result (i.e. [lng, lat])\n   *\n   * @returns A new `ImmutableFeatureCollection` with the given coordinate removed. Does not modify this `ImmutableFeatureCollection`.\n   */\n  addPosition(\n    featureIndex: number,\n    positionIndexes: number[] | null | undefined,\n    positionToAdd: Position\n  ): ImmutableFeatureCollection {\n    const geometry = this.featureCollection.features[featureIndex].geometry;\n\n    if (geometry.type === 'Point') {\n      throw new Error('Unable to add a position to a Point feature');\n    }\n\n    const isPolygonal = geometry.type === 'Polygon' || geometry.type === 'MultiPolygon';\n    const updatedGeometry: any = {\n      ...geometry,\n      coordinates: immutablyAddPosition(\n        geometry.coordinates,\n        positionIndexes,\n        positionToAdd,\n        isPolygonal\n      ),\n    };\n\n    return this.replaceGeometry(featureIndex, updatedGeometry);\n  }\n\n  replaceGeometry(featureIndex: number, geometry: Geometry): ImmutableFeatureCollection {\n    const updatedFeature: any = {\n      ...this.featureCollection.features[featureIndex],\n      geometry,\n    };\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [\n        ...this.featureCollection.features.slice(0, featureIndex),\n        updatedFeature,\n        ...this.featureCollection.features.slice(featureIndex + 1),\n      ],\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  addFeature(feature: Feature): ImmutableFeatureCollection {\n    return this.addFeatures([feature]);\n  }\n\n  addFeatures(features: Feature[]): ImmutableFeatureCollection {\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features: [...this.featureCollection.features, ...features],\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n\n  deleteFeature(featureIndex: number) {\n    return this.deleteFeatures([featureIndex]);\n  }\n\n  deleteFeatures(featureIndexes: number[]) {\n    const features = [...this.featureCollection.features];\n    featureIndexes.sort();\n    for (let i = featureIndexes.length - 1; i >= 0; i--) {\n      const featureIndex = featureIndexes[i];\n      if (featureIndex >= 0 && featureIndex < features.length) {\n        features.splice(featureIndex, 1);\n      }\n    }\n\n    const updatedFeatureCollection = {\n      ...this.featureCollection,\n      features,\n    };\n\n    return new ImmutableFeatureCollection(updatedFeatureCollection);\n  }\n}\n\nfunction getUpdatedPosition(updatedPosition: Position, previousPosition: Position): Position {\n  // This function checks if the updatedPosition is missing elevation\n  // and copies it from previousPosition\n  if (updatedPosition.length === 2 && previousPosition.length === 3) {\n    const elevation = (previousPosition as any)[2];\n    return [updatedPosition[0], updatedPosition[1], elevation];\n  }\n\n  return updatedPosition;\n}\n\nfunction immutablyReplacePosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  updatedPosition: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    return getUpdatedPosition(updatedPosition, coordinates);\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      getUpdatedPosition(updatedPosition, coordinates[positionIndexes[0]]),\n      ...coordinates.slice(positionIndexes[0] + 1),\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, update it on both ends of the array\n      updated[0] = getUpdatedPosition(updatedPosition, coordinates[0]);\n      updated[coordinates.length - 1] = getUpdatedPosition(updatedPosition, coordinates[0]);\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyReplacePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      updatedPosition,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction immutablyRemovePosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      ...coordinates.slice(positionIndexes[0] + 1),\n    ];\n\n    if (\n      isPolygonal &&\n      (positionIndexes[0] === 0 || positionIndexes[0] === coordinates.length - 1)\n    ) {\n      // for polygons, the first point is repeated at the end of the array\n      // so, if the first/last coordinate is to be removed, coordinates[1] will be the new first/last coordinate\n      if (positionIndexes[0] === 0) {\n        // change the last to be the same as the first\n        updated[updated.length - 1] = updated[0];\n      } else if (positionIndexes[0] === coordinates.length - 1) {\n        // change the first to be the same as the last\n        updated[0] = updated[updated.length - 1];\n      }\n    }\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyRemovePosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction immutablyAddPosition(\n  coordinates: any,\n  positionIndexes: number[] | null | undefined,\n  positionToAdd: Position,\n  isPolygonal: boolean\n): any {\n  if (!positionIndexes) {\n    return coordinates;\n  }\n  if (positionIndexes.length === 0) {\n    throw Error('Must specify the index of the position to remove');\n  }\n  if (positionIndexes.length === 1) {\n    const updated = [\n      ...coordinates.slice(0, positionIndexes[0]),\n      positionToAdd,\n      ...coordinates.slice(positionIndexes[0]),\n    ];\n    return updated;\n  }\n\n  // recursively update inner array\n  return [\n    ...coordinates.slice(0, positionIndexes[0]),\n    immutablyAddPosition(\n      coordinates[positionIndexes[0]],\n      positionIndexes.slice(1, positionIndexes.length),\n      positionToAdd,\n      isPolygonal\n    ),\n    ...coordinates.slice(positionIndexes[0] + 1),\n  ];\n}\n\nfunction pruneGeometryIfNecessary(geometry: Geometry) {\n  switch (geometry.type) {\n    case 'Polygon':\n      prunePolygonIfNecessary(geometry);\n      break;\n    case 'MultiLineString':\n      pruneMultiLineStringIfNecessary(geometry);\n      break;\n    case 'MultiPolygon':\n      pruneMultiPolygonIfNecessary(geometry);\n      break;\n    default:\n      // Not downgradable\n      break;\n  }\n}\n\nfunction prunePolygonIfNecessary(geometry: Polygon) {\n  const polygon = geometry.coordinates;\n\n  // If any hole is no longer a polygon, remove the hole entirely\n  for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n    if (removeHoleIfNecessary(polygon, holeIndex)) {\n      // It was removed, so keep the index the same\n      holeIndex--;\n    }\n  }\n}\n\nfunction pruneMultiLineStringIfNecessary(geometry: MultiLineString) {\n  for (let lineStringIndex = 0; lineStringIndex < geometry.coordinates.length; lineStringIndex++) {\n    const lineString = geometry.coordinates[lineStringIndex];\n    if (lineString.length === 1) {\n      // Only a single position left on this LineString, so remove it (can't have Point in MultiLineString)\n      geometry.coordinates.splice(lineStringIndex, 1);\n      // Keep the index the same\n      lineStringIndex--;\n    }\n  }\n}\n\nfunction pruneMultiPolygonIfNecessary(geometry: MultiPolygon) {\n  for (let polygonIndex = 0; polygonIndex < geometry.coordinates.length; polygonIndex++) {\n    const polygon = geometry.coordinates[polygonIndex];\n    const outerRing = polygon[0];\n\n    // If the outer ring is no longer a polygon, remove the whole polygon\n    if (outerRing.length <= 3) {\n      geometry.coordinates.splice(polygonIndex, 1);\n      // It was removed, so keep the index the same\n      polygonIndex--;\n    }\n\n    for (let holeIndex = 1; holeIndex < polygon.length; holeIndex++) {\n      if (removeHoleIfNecessary(polygon, holeIndex)) {\n        // It was removed, so keep the index the same\n        holeIndex--;\n      }\n    }\n  }\n}\n\nfunction removeHoleIfNecessary(polygon: PolygonCoordinates, holeIndex: number) {\n  const hole = polygon[holeIndex];\n  if (hole.length <= 3) {\n    polygon.splice(holeIndex, 1);\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}