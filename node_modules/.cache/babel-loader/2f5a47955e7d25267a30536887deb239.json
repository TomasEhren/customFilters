{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ManagedArray from '../../utils/managed-array';\nimport { TILE_REFINEMENT } from '../../constants';\nexport var DEFAULT_PROPS = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: function onTraversalEnd() {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nvar TilesetTraverser = /*#__PURE__*/function () {\n  function TilesetTraverser(options) {\n    _classCallCheck(this, TilesetTraverser);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"requestedTiles\", void 0);\n\n    _defineProperty(this, \"selectedTiles\", void 0);\n\n    _defineProperty(this, \"emptyTiles\", void 0);\n\n    _defineProperty(this, \"_traversalStack\", void 0);\n\n    _defineProperty(this, \"_emptyTraversalStack\", void 0);\n\n    _defineProperty(this, \"_frameNumber\", void 0);\n\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_PROPS), options);\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n    this._frameNumber = null;\n    this.root = null;\n    this.selectedTiles = {};\n    this.requestedTiles = {};\n    this.emptyTiles = {};\n  }\n\n  _createClass(TilesetTraverser, [{\n    key: \"traverse\",\n    value: function traverse(root, frameState, options) {\n      this.root = root;\n      this.options = _objectSpread(_objectSpread({}, this.options), options);\n      this.reset();\n      this.updateTile(root, frameState);\n      this._frameNumber = frameState.frameNumber;\n      this.executeTraversal(root, frameState);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.requestedTiles = {};\n      this.selectedTiles = {};\n      this.emptyTiles = {};\n\n      this._traversalStack.reset();\n\n      this._emptyTraversalStack.reset();\n    }\n  }, {\n    key: \"executeTraversal\",\n    value: function executeTraversal(root, frameState) {\n      var stack = this._traversalStack;\n      root._selectionDepth = 1;\n      stack.push(root);\n\n      while (stack.length > 0) {\n        var tile = stack.pop();\n        var shouldRefine = false;\n\n        if (this.canTraverse(tile, frameState)) {\n          this.updateChildTiles(tile, frameState);\n          shouldRefine = this.updateAndPushChildren(tile, frameState, stack, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);\n        }\n\n        var parent = tile.parent;\n        var parentRefines = Boolean(!parent || parent._shouldRefine);\n        var stoppedRefining = !shouldRefine;\n\n        if (!tile.hasRenderContent) {\n          this.emptyTiles[tile.id] = tile;\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        } else if (tile.refine === TILE_REFINEMENT.ADD) {\n          this.loadTile(tile, frameState);\n          this.selectTile(tile, frameState);\n        } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n          this.loadTile(tile, frameState);\n\n          if (stoppedRefining) {\n            this.selectTile(tile, frameState);\n          }\n        }\n\n        this.touchTile(tile, frameState);\n        tile._shouldRefine = shouldRefine && parentRefines;\n      }\n\n      this.options.onTraversalEnd(frameState);\n    }\n  }, {\n    key: \"updateChildTiles\",\n    value: function updateChildTiles(tile, frameState) {\n      var children = tile.children;\n\n      var _iterator = _createForOfIteratorHelper(children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          this.updateTile(child, frameState);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"updateAndPushChildren\",\n    value: function updateAndPushChildren(tile, frameState, stack, depth) {\n      var _this$options = this.options,\n          loadSiblings = _this$options.loadSiblings,\n          skipLevelOfDetail = _this$options.skipLevelOfDetail;\n      var children = tile.children;\n      children.sort(this.compareDistanceToCamera.bind(this));\n      var checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n      var hasVisibleChild = false;\n      var refines = true;\n\n      var _iterator2 = _createForOfIteratorHelper(children),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          child._selectionDepth = depth;\n\n          if (child.isVisibleAndInRequestVolume) {\n            if (stack.find(child)) {\n              stack.delete(child);\n            }\n\n            stack.push(child);\n            hasVisibleChild = true;\n          } else if (checkRefines || loadSiblings) {\n            this.loadTile(child, frameState);\n            this.touchTile(child, frameState);\n          }\n\n          if (checkRefines) {\n            var childRefines = void 0;\n\n            if (!child._inRequestVolume) {\n              childRefines = false;\n            } else if (!child.hasRenderContent) {\n              childRefines = this.executeEmptyTraversal(child, frameState);\n            } else {\n              childRefines = child.contentAvailable;\n            }\n\n            refines = refines && childRefines;\n\n            if (!refines) {\n              return false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (!hasVisibleChild) {\n        refines = false;\n      }\n\n      return refines;\n    }\n  }, {\n    key: \"updateTile\",\n    value: function updateTile(tile, frameState) {\n      this.updateTileVisibility(tile, frameState);\n    }\n  }, {\n    key: \"selectTile\",\n    value: function selectTile(tile, frameState) {\n      if (this.shouldSelectTile(tile)) {\n        tile._selectedFrame = frameState.frameNumber;\n        this.selectedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"loadTile\",\n    value: function loadTile(tile, frameState) {\n      if (this.shouldLoadTile(tile)) {\n        tile._requestedFrame = frameState.frameNumber;\n        tile._priority = tile._getPriority();\n        this.requestedTiles[tile.id] = tile;\n      }\n    }\n  }, {\n    key: \"touchTile\",\n    value: function touchTile(tile, frameState) {\n      tile.tileset._cache.touch(tile);\n\n      tile._touchedFrame = frameState.frameNumber;\n    }\n  }, {\n    key: \"canTraverse\",\n    value: function canTraverse(tile, frameState) {\n      var useParentMetric = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var ignoreVisibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!tile.hasChildren) {\n        return false;\n      }\n\n      if (tile.hasTilesetContent) {\n        return !tile.contentExpired;\n      }\n\n      if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n        return false;\n      }\n\n      return this.shouldRefine(tile, frameState, useParentMetric);\n    }\n  }, {\n    key: \"shouldLoadTile\",\n    value: function shouldLoadTile(tile) {\n      return tile.hasUnloadedContent || tile.contentExpired;\n    }\n  }, {\n    key: \"shouldSelectTile\",\n    value: function shouldSelectTile(tile) {\n      return tile.contentAvailable && !this.options.skipLevelOfDetail;\n    }\n  }, {\n    key: \"shouldRefine\",\n    value: function shouldRefine(tile, frameState, useParentMetric) {\n      var screenSpaceError = tile._screenSpaceError;\n\n      if (useParentMetric) {\n        screenSpaceError = tile.getScreenSpaceError(frameState, true);\n      }\n\n      return screenSpaceError > this.options.maximumScreenSpaceError;\n    }\n  }, {\n    key: \"updateTileVisibility\",\n    value: function updateTileVisibility(tile, frameState) {\n      var viewportIds = [];\n\n      if (this.options.viewportTraversersMap) {\n        for (var key in this.options.viewportTraversersMap) {\n          var value = this.options.viewportTraversersMap[key];\n\n          if (value === frameState.viewport.id) {\n            viewportIds.push(key);\n          }\n        }\n      } else {\n        viewportIds.push(frameState.viewport.id);\n      }\n\n      tile.updateVisibility(frameState, viewportIds);\n    }\n  }, {\n    key: \"compareDistanceToCamera\",\n    value: function compareDistanceToCamera(b, a) {\n      return b._distanceToCamera - a._distanceToCamera;\n    }\n  }, {\n    key: \"anyChildrenVisible\",\n    value: function anyChildrenVisible(tile, frameState) {\n      var anyVisible = false;\n\n      var _iterator3 = _createForOfIteratorHelper(tile.children),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var child = _step3.value;\n          child.updateVisibility(frameState);\n          anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return anyVisible;\n    }\n  }, {\n    key: \"executeEmptyTraversal\",\n    value: function executeEmptyTraversal(root, frameState) {\n      var allDescendantsLoaded = true;\n      var stack = this._emptyTraversalStack;\n      stack.push(root);\n\n      while (stack.length > 0 && allDescendantsLoaded) {\n        var tile = stack.pop();\n        this.updateTile(tile, frameState);\n\n        if (!tile.isVisibleAndInRequestVolume) {\n          this.loadTile(tile, frameState);\n        }\n\n        this.touchTile(tile, frameState);\n        var traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n        if (traverse) {\n          var children = tile.children;\n\n          var _iterator4 = _createForOfIteratorHelper(children),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var child = _step4.value;\n\n              if (stack.find(child)) {\n                stack.delete(child);\n              }\n\n              stack.push(child);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else if (!tile.contentAvailable) {\n          allDescendantsLoaded = false;\n        }\n      }\n\n      return allDescendantsLoaded;\n    }\n  }]);\n\n  return TilesetTraverser;\n}();\n\nexport { TilesetTraverser as default };","map":{"version":3,"mappings":"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","names":["ManagedArray","TILE_REFINEMENT","DEFAULT_PROPS","loadSiblings","skipLevelOfDetail","maximumScreenSpaceError","updateTransforms","onTraversalEnd","viewportTraversersMap","basePath","TilesetTraverser","constructor","options","_defineProperty","_traversalStack","_emptyTraversalStack","_frameNumber","root","selectedTiles","requestedTiles","emptyTiles","traverse","frameState","reset","updateTile","frameNumber","executeTraversal","stack","_selectionDepth","push","length","tile","pop","shouldRefine","canTraverse","updateChildTiles","updateAndPushChildren","hasRenderContent","parent","parentRefines","Boolean","_shouldRefine","stoppedRefining","id","loadTile","selectTile","refine","ADD","REPLACE","touchTile","children","child","depth","sort","compareDistanceToCamera","bind","checkRefines","hasVisibleChild","refines","isVisibleAndInRequestVolume","find","delete","childRefines","_inRequestVolume","executeEmptyTraversal","contentAvailable","updateTileVisibility","shouldSelectTile","_selectedFrame","shouldLoadTile","_requestedFrame","_priority","_getPriority","tileset","_cache","touch","_touchedFrame","useParentMetric","ignoreVisibility","hasChildren","hasTilesetContent","contentExpired","hasUnloadedContent","screenSpaceError","_screenSpaceError","getScreenSpaceError","viewportIds","key","value","viewport","updateVisibility","b","a","_distanceToCamera","anyChildrenVisible","anyVisible","allDescendantsLoaded"],"sources":["../../../../src/tileset/traversers/tileset-traverser.ts"],"sourcesContent":["import ManagedArray from '../../utils/managed-array';\nimport {TILE_REFINEMENT} from '../../constants';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n};\n\nexport type Props = {\n  loadSiblings: boolean;\n  skipLevelOfDetail: boolean;\n  updateTransforms: boolean;\n  maximumScreenSpaceError: number;\n  onTraversalEnd: (frameState) => any;\n  viewportTraversersMap: {[key: string]: any};\n  basePath: string;\n};\n\nexport const DEFAULT_PROPS: Props = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport default class TilesetTraverser {\n  options: Props;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    this.options.onTraversalEnd(frameState);\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n"]},"metadata":{},"sourceType":"module"}