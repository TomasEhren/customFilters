{"ast":null,"code":"import { equals } from '@math.gl/core';\nimport assert from '../utils/assert';\nexport default class TransitionInterpolator {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n\n    const {\n      compare,\n      extract,\n      required\n    } = opts;\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n\n      result = {\n        start: startViewStateProps,\n        end: endViewStateProps\n      };\n    } else {\n      result = {\n        start: startProps,\n        end: endProps\n      };\n    }\n\n    this._checkRequiredProps(result.start);\n\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(Number.isFinite(value) || Array.isArray(value), \"\".concat(propName, \" is required for transition\"));\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAAQA,MAAR,QAAqB,eAArB;AACA,OAAOC,MAAP,MAAmB,iBAAnB;AAEA,eAAe,MAAMC,sBAAN,CAA6B;EAQ1CC,WAAW,GAAY;IAAA,IAAXC,IAAW,uEAAJ,EAAI;;IACrB,IAAIC,KAAK,CAACC,OAAND,CAAcD,IAAdC,CAAJ,EAAyB;MACvBD,IAAI,GAAG;QACLG,OAAO,EAAEH,IADJ;QAELI,OAAO,EAAEJ,IAFJ;QAGLK,QAAQ,EAAEL;MAHL,CAAPA;IAKD;;IACD,MAAM;MAACG,OAAD;MAAUC,OAAV;MAAmBC;IAAnB,IAA+BL,IAArC;IAEA,KAAKM,eAAL,GAAuBH,OAAvB;IACA,KAAKI,eAAL,GAAuBH,OAAvB;IACA,KAAKI,cAAL,GAAsBH,QAAtB;EACD;;EAQDI,aAAa,CAACC,YAAD,EAAeC,SAAf,EAA0B;IACrC,KAAK,MAAMC,GAAX,IAAkB,KAAKN,eAAL,IAAwBO,MAAM,CAACC,IAAPD,CAAYF,SAAZE,CAA1C,EAAkE;MAChE,IACE,EAAED,GAAG,IAAIF,YAAT,KACA,EAAEE,GAAG,IAAID,SAAT,CADA,IAEA,CAACf,MAAM,CAACc,YAAY,CAACE,GAAD,CAAb,EAAoBD,SAAS,CAACC,GAAD,CAA7B,CAHT,EAIE;QACA,OAAO,KAAP;MACD;IACF;;IACD,OAAO,IAAP;EACD;;EASDG,eAAe,CAACC,UAAD,EAAaC,QAAb,EAAuB;IACpC,IAAIC,MAAJ;;IAEA,IAAI,KAAKX,eAAT,EAA0B;MACxB,MAAMY,mBAAmB,GAAG,EAA5B;MACA,MAAMC,iBAAiB,GAAG,EAA1B;;MAEA,KAAK,MAAMR,GAAX,IAAkB,KAAKL,eAAvB,EAAwC;QACtCY,mBAAmB,CAACP,GAAD,CAAnBO,GAA2BH,UAAU,CAACJ,GAAD,CAArCO;QACAC,iBAAiB,CAACR,GAAD,CAAjBQ,GAAyBH,QAAQ,CAACL,GAAD,CAAjCQ;MACD;;MACDF,MAAM,GAAG;QAACG,KAAK,EAAEF,mBAAR;QAA6BG,GAAG,EAAEF;MAAlC,CAATF;IARF,OASO;MACLA,MAAM,GAAG;QAACG,KAAK,EAAEL,UAAR;QAAoBM,GAAG,EAAEL;MAAzB,CAATC;IACD;;IAED,KAAKK,mBAAL,CAAyBL,MAAM,CAACG,KAAhC;;IACA,KAAKE,mBAAL,CAAyBL,MAAM,CAACI,GAAhC;;IAEA,OAAOJ,MAAP;EACD;;EASDM,gBAAgB,CAACR,UAAD,EAAaC,QAAb,EAAuBQ,CAAvB,EAA0B;IACxC,OAAOR,QAAP;EACD;;EAQDS,WAAW,CAACV,UAAD,EAAaC,QAAb,EAAuB;IAChC,OAAOA,QAAQ,CAACU,kBAAhB;EACD;;EAEDJ,mBAAmB,CAACK,KAAD,EAAQ;IACzB,IAAI,CAAC,KAAKpB,cAAV,EAA0B;MACxB;IACD;;IAED,KAAKA,cAAL,CAAoBqB,OAApB,CAA4BC,QAAQ,IAAI;MACtC,MAAMC,KAAK,GAAGH,KAAK,CAACE,QAAD,CAAnB;MACAjC,MAAM,CACJmC,MAAM,CAACC,QAAPD,CAAgBD,KAAhBC,KAA0B/B,KAAK,CAACC,OAAND,CAAc8B,KAAd9B,CADtB,YAED6B,QAFC,iCAANjC;IAFF;EAOD;;AAxGyC","names":["equals","assert","TransitionInterpolator","constructor","opts","Array","isArray","compare","extract","required","_propsToCompare","_propsToExtract","_requiredProps","arePropsEqual","currentProps","nextProps","key","Object","keys","initializeProps","startProps","endProps","result","startViewStateProps","endViewStateProps","start","end","_checkRequiredProps","interpolateProps","t","getDuration","transitionDuration","props","forEach","propName","value","Number","isFinite"],"sources":["../../../src/transitions/transition-interpolator.js"],"sourcesContent":["import {equals} from '@math.gl/core';\nimport assert from '../utils/assert';\n\nexport default class TransitionInterpolator {\n  /**\n   * @param opts {array|object}\n   * @param opts.compare {array} - prop names used in equality check\n   * @param opts.extract {array} - prop names needed for interpolation\n   * @param opts.required {array} - prop names that must be supplied\n   * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n   */\n  constructor(opts = {}) {\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n    const {compare, extract, required} = opts;\n\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n\n  /**\n   * Checks if two sets of props need transition in between\n   * @param currentProps {object} - a list of viewport props\n   * @param nextProps {object} - a list of viewport props\n   * @returns {bool} - true if two props are equivalent\n   */\n  arePropsEqual(currentProps, nextProps) {\n    for (const key of this._propsToCompare || Object.keys(nextProps)) {\n      if (\n        !(key in currentProps) ||\n        !(key in nextProps) ||\n        !equals(currentProps[key], nextProps[key])\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Called before transition starts to validate/pre-process start and end props\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Object} {start, end} - start and end props to be passed\n   *   to `interpolateProps`\n   */\n  initializeProps(startProps, endProps) {\n    let result;\n\n    if (this._propsToExtract) {\n      const startViewStateProps = {};\n      const endViewStateProps = {};\n\n      for (const key of this._propsToExtract) {\n        startViewStateProps[key] = startProps[key];\n        endViewStateProps[key] = endProps[key];\n      }\n      result = {start: startViewStateProps, end: endViewStateProps};\n    } else {\n      result = {start: startProps, end: endProps};\n    }\n\n    this._checkRequiredProps(result.start);\n    this._checkRequiredProps(result.end);\n\n    return result;\n  }\n\n  /**\n   * Returns viewport props in transition\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @param t {number} - a time factor between [0, 1]\n   * @returns {object} - a list of interpolated viewport props\n   */\n  interpolateProps(startProps, endProps, t) {\n    return endProps;\n  }\n\n  /**\n   * Returns transition duration\n   * @param startProps {object} - a list of starting viewport props\n   * @param endProps {object} - a list of target viewport props\n   * @returns {Number} - transition duration in milliseconds\n   */\n  getDuration(startProps, endProps) {\n    return endProps.transitionDuration;\n  }\n\n  _checkRequiredProps(props) {\n    if (!this._requiredProps) {\n      return;\n    }\n\n    this._requiredProps.forEach(propName => {\n      const value = props[propName];\n      assert(\n        Number.isFinite(value) || Array.isArray(value),\n        `${propName} is required for transition`\n      );\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}