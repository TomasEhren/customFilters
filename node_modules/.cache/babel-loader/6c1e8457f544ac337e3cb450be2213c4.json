{"ast":null,"code":"import _slicedToArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"id\", \"config\"],\n    _excluded2 = [\"textLabel\"];\nimport { AGGREGATION, getLayer, getColorAccessor, getColorValueAccessor, getSizeAccessor, getTextAccessor, getTextPixelOffsetAccessor } from './layer-map';\nimport { _flatten as flatten, log } from '@deck.gl/core';\nimport { assert } from '../utils';\nexport function parseMap(json) {\n  var keplerMapConfig = json.keplerMapConfig,\n      datasets = json.datasets;\n  assert(keplerMapConfig.version === 'v1', 'Only support Kepler v1');\n  var _keplerMapConfig$conf = keplerMapConfig.config,\n      mapState = _keplerMapConfig$conf.mapState,\n      mapStyle = _keplerMapConfig$conf.mapStyle;\n  var _keplerMapConfig$conf2 = keplerMapConfig.config.visState,\n      layers = _keplerMapConfig$conf2.layers,\n      layerBlending = _keplerMapConfig$conf2.layerBlending,\n      interactionConfig = _keplerMapConfig$conf2.interactionConfig;\n  return {\n    id: json.id,\n    title: json.title,\n    description: json.description,\n    createdAt: json.createdAt,\n    updatedAt: json.updatedAt,\n    initialViewState: mapState,\n    mapStyle: mapStyle,\n    layers: extractTextLayers(layers.reverse()).map(function (_ref) {\n      var id = _ref.id,\n          type = _ref.type,\n          config = _ref.config,\n          visualChannels = _ref.visualChannels;\n\n      try {\n        var dataId = config.dataId;\n        var dataset = datasets.find(function (d) {\n          return d.id === dataId;\n        });\n        assert(dataset, \"No dataset matching dataId: \".concat(dataId));\n        var data = dataset.data;\n        assert(data, \"No data loaded for dataId: \".concat(dataId));\n\n        var _getLayer = getLayer(type, config, dataset),\n            Layer = _getLayer.Layer,\n            propMap = _getLayer.propMap,\n            defaultProps = _getLayer.defaultProps;\n\n        return new Layer(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n          id: id,\n          data: data\n        }, defaultProps), createBlendingProps(layerBlending)), !config.textLabel && createInteractionProps(interactionConfig)), createStyleProps(config, propMap)), createChannelProps(visualChannels, type, config, data)));\n      } catch (e) {\n        log.error(e.message)();\n        return undefined;\n      }\n    })\n  };\n}\n\nfunction extractTextLayers(layers) {\n  return flatten(layers.map(function (_ref2) {\n    var id = _ref2.id,\n        config = _ref2.config,\n        rest = _objectWithoutProperties(_ref2, _excluded);\n\n    var textLabel = config.textLabel,\n        configRest = _objectWithoutProperties(config, _excluded2);\n\n    return [_objectSpread({\n      id: id,\n      config: configRest\n    }, rest)].concat(_toConsumableArray(textLabel.filter(function (t) {\n      return t.field;\n    }).map(function (t) {\n      return _objectSpread({\n        id: \"\".concat(id, \"-label-\").concat(t.field.name),\n        config: _objectSpread(_objectSpread({\n          textLabel: t\n        }, configRest), {}, {\n          label: \"\".concat(config.label, \"-label-\").concat(t.field.name),\n          visConfig: _objectSpread(_objectSpread({}, configRest.visConfig), {}, {\n            opacity: 1\n          })\n        })\n      }, rest);\n    })));\n  }));\n}\n\nfunction createBlendingProps(layerBlending) {\n  if (layerBlending === 'additive') {\n    return {\n      parameters: {\n        blendFunc: [770, 772],\n        blendEquation: 32774\n      }\n    };\n  } else if (layerBlending === 'subtractive') {\n    return {\n      parameters: {\n        blendFunc: [1, 775, 770, 772],\n        blendEquation: [32778, 32774]\n      }\n    };\n  }\n\n  return {};\n}\n\nfunction createInteractionProps(interactionConfig) {\n  var pickable = interactionConfig && interactionConfig.tooltip.enabled;\n  return {\n    autoHighlight: pickable,\n    pickable: pickable\n  };\n}\n\nfunction mapProps(source, target, mapping) {\n  for (var sourceKey in mapping) {\n    var sourceValue = source[sourceKey];\n    var targetKey = mapping[sourceKey];\n\n    if (sourceValue === undefined) {\n      continue;\n    }\n\n    if (typeof targetKey === 'string') {\n      target[targetKey] = sourceValue;\n    } else if (typeof targetKey === 'function') {\n      var _Object$entries$ = _slicedToArray(Object.entries(targetKey(sourceValue))[0], 2),\n          key = _Object$entries$[0],\n          value = _Object$entries$[1];\n\n      target[key] = value;\n    } else if (typeof targetKey === 'object') {\n      mapProps(sourceValue, target, targetKey);\n    }\n  }\n}\n\nfunction createStyleProps(config, mapping) {\n  var result = {};\n  mapProps(config, result, mapping);\n\n  if (result.stroked && !result.getLineColor) {\n    result.getLineColor = result.getFillColor;\n  }\n\n  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];\n  return result;\n}\n\nfunction createChannelProps(visualChannels, type, config, data) {\n  var colorField = visualChannels.colorField,\n      colorScale = visualChannels.colorScale,\n      sizeField = visualChannels.sizeField,\n      sizeScale = visualChannels.sizeScale,\n      strokeColorField = visualChannels.strokeColorField,\n      strokeColorScale = visualChannels.strokeColorScale;\n  var heightField = visualChannels.heightField,\n      heightScale = visualChannels.heightScale;\n\n  if (type === 'hexagonId') {\n    heightField = sizeField;\n    heightScale = sizeScale;\n  }\n\n  var textLabel = config.textLabel,\n      visConfig = config.visConfig;\n  var result = {};\n  var textLabelField = textLabel && textLabel.field;\n\n  if (type === 'grid' || type === 'hexagon') {\n    result.colorScaleType = colorScale;\n\n    if (colorField) {\n      var colorAggregation = config.visConfig.colorAggregation;\n\n      if (!AGGREGATION[colorAggregation]) {\n        result.getColorValue = getColorValueAccessor(colorField, colorAggregation, data);\n      } else {\n        result.getColorWeight = function (d) {\n          return [colorField.name];\n        };\n      }\n    }\n  } else if (colorField) {\n    result.getFillColor = getColorAccessor(colorField, colorScale, visConfig.colorRange, 1, data);\n  }\n\n  if (strokeColorField) {\n    var opacity = visConfig.strokeOpacity !== undefined ? visConfig.strokeOpacity : 1;\n    result.getLineColor = getColorAccessor(strokeColorField, strokeColorScale, visConfig.strokeColorRange, opacity, data);\n  }\n\n  if (heightField) {\n    result.getElevation = getSizeAccessor(heightField, heightScale, visConfig.heightRange || visConfig.sizeRange, data);\n  }\n\n  if (sizeField) {\n    result.getPointRadius = getSizeAccessor(sizeField, sizeScale, visConfig.radiusRange || visConfig.sizeRange, data);\n  }\n\n  if (textLabelField) {\n    result.getText = getTextAccessor(textLabelField, data);\n    result.pointType = 'text';\n    var radius = result.getPointRadius || visConfig.radius;\n    result.getTextPixelOffset = getTextPixelOffsetAccessor(textLabel, radius);\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["AGGREGATION","getLayer","getColorAccessor","getColorValueAccessor","getSizeAccessor","getTextAccessor","getTextPixelOffsetAccessor","_flatten","flatten","log","assert","parseMap","json","keplerMapConfig","datasets","version","config","mapState","mapStyle","visState","layers","layerBlending","interactionConfig","id","title","description","createdAt","updatedAt","initialViewState","extractTextLayers","reverse","map","type","visualChannels","dataId","dataset","find","d","data","Layer","propMap","defaultProps","createBlendingProps","textLabel","createInteractionProps","createStyleProps","createChannelProps","e","error","message","undefined","rest","configRest","filter","t","field","name","label","visConfig","opacity","parameters","blendFunc","blendEquation","pickable","tooltip","enabled","autoHighlight","mapProps","source","target","mapping","sourceKey","sourceValue","targetKey","Object","entries","key","value","result","stroked","getLineColor","getFillColor","highlightColor","enable3d","colorField","colorScale","sizeField","sizeScale","strokeColorField","strokeColorScale","heightField","heightScale","textLabelField","colorScaleType","colorAggregation","getColorValue","getColorWeight","colorRange","strokeOpacity","strokeColorRange","getElevation","heightRange","sizeRange","getPointRadius","radiusRange","getText","pointType","radius","getTextPixelOffset"],"sources":["../../../src/api/parseMap.ts"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {\n  AGGREGATION,\n  getLayer,\n  getColorAccessor,\n  getColorValueAccessor,\n  getSizeAccessor,\n  getTextAccessor,\n  getTextPixelOffsetAccessor\n} from './layer-map';\nimport {_flatten as flatten, log} from '@deck.gl/core';\nimport {assert} from '../utils';\n\nexport function parseMap(json) {\n  const {keplerMapConfig, datasets} = json;\n  assert(keplerMapConfig.version === 'v1', 'Only support Kepler v1');\n  const {mapState, mapStyle} = keplerMapConfig.config;\n  const {layers, layerBlending, interactionConfig} = keplerMapConfig.config.visState;\n\n  return {\n    id: json.id,\n    title: json.title,\n    description: json.description,\n    createdAt: json.createdAt,\n    updatedAt: json.updatedAt,\n    initialViewState: mapState,\n    mapStyle,\n    layers: extractTextLayers(layers.reverse()).map(({id, type, config, visualChannels}) => {\n      try {\n        const {dataId} = config;\n        const dataset = datasets.find(d => d.id === dataId);\n        assert(dataset, `No dataset matching dataId: ${dataId}`);\n        const {data} = dataset;\n        assert(data, `No data loaded for dataId: ${dataId}`);\n        const {Layer, propMap, defaultProps} = getLayer(type, config, dataset);\n        return new Layer({\n          id,\n          data,\n          ...defaultProps,\n          ...createBlendingProps(layerBlending),\n          ...(!config.textLabel && createInteractionProps(interactionConfig)),\n          ...createStyleProps(config, propMap),\n          ...createChannelProps(visualChannels, type, config, data) // Must come after style\n        });\n      } catch (e: any) {\n        log.error(e.message)();\n        return undefined;\n      }\n    })\n  };\n}\n\nfunction extractTextLayers(layers) {\n  return flatten(\n    layers.map(({id, config, ...rest}) => {\n      const {textLabel, ...configRest} = config;\n      return [\n        // Original layer without textLabel\n        {id, config: configRest, ...rest},\n\n        // One layer per valid text label, with full opacity\n        ...textLabel\n          .filter(t => t.field)\n          .map(t => {\n            return {\n              id: `${id}-label-${t.field.name}`,\n              config: {\n                textLabel: t,\n                ...configRest,\n                label: `${config.label}-label-${t.field.name}`,\n                visConfig: {...configRest.visConfig, opacity: 1}\n              },\n              ...rest\n            };\n          })\n      ];\n    })\n  );\n}\n\nfunction createBlendingProps(layerBlending) {\n  if (layerBlending === 'additive') {\n    return {\n      parameters: {\n        blendFunc: [GL.SRC_ALPHA, GL.DST_ALPHA],\n        blendEquation: GL.FUNC_ADD\n      }\n    };\n  } else if (layerBlending === 'subtractive') {\n    return {\n      parameters: {\n        blendFunc: [GL.ONE, GL.ONE_MINUS_DST_COLOR, GL.SRC_ALPHA, GL.DST_ALPHA],\n        blendEquation: [GL.FUNC_SUBTRACT, GL.FUNC_ADD]\n      }\n    };\n  }\n\n  return {};\n}\n\nfunction createInteractionProps(interactionConfig) {\n  const pickable = interactionConfig && interactionConfig.tooltip.enabled;\n  return {\n    autoHighlight: pickable,\n    pickable\n  };\n}\n\nfunction mapProps(source, target, mapping) {\n  for (const sourceKey in mapping) {\n    const sourceValue = source[sourceKey];\n    const targetKey = mapping[sourceKey];\n    if (sourceValue === undefined) {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (typeof targetKey === 'string') {\n      target[targetKey] = sourceValue;\n    } else if (typeof targetKey === 'function') {\n      const [key, value] = Object.entries(targetKey(sourceValue))[0];\n      target[key] = value;\n    } else if (typeof targetKey === 'object') {\n      // Nested definition, recurse down one level (also handles arrays)\n      mapProps(sourceValue, target, targetKey);\n    }\n  }\n}\n\nfunction createStyleProps(config, mapping) {\n  const result: Record<string, any> = {};\n  mapProps(config, result, mapping);\n\n  // Kepler format sometimes omits strokeColor. TODO: remove once we can rely on\n  // `strokeColor` always being sert when `stroke: true`.\n  if (result.stroked && !result.getLineColor) {\n    result.getLineColor = result.getFillColor;\n  }\n  result.highlightColor = config.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];\n  return result;\n}\n\n/* eslint-disable complexity, max-statements */\nfunction createChannelProps(visualChannels, type, config, data) {\n  const {colorField, colorScale, sizeField, sizeScale, strokeColorField, strokeColorScale} =\n    visualChannels;\n  let {heightField, heightScale} = visualChannels;\n  if (type === 'hexagonId') {\n    heightField = sizeField;\n    heightScale = sizeScale;\n  }\n  const {textLabel, visConfig} = config;\n  const result: Record<string, any> = {};\n  const textLabelField = textLabel && textLabel.field;\n\n  if (type === 'grid' || type === 'hexagon') {\n    result.colorScaleType = colorScale;\n    if (colorField) {\n      const {colorAggregation} = config.visConfig;\n      if (!AGGREGATION[colorAggregation]) {\n        result.getColorValue = getColorValueAccessor(colorField, colorAggregation, data);\n      } else {\n        result.getColorWeight = d => [colorField.name];\n      }\n    }\n  } else if (colorField) {\n    result.getFillColor = getColorAccessor(\n      colorField,\n      colorScale,\n      visConfig.colorRange,\n      1, // Rely on layer opacity\n      data\n    );\n  }\n\n  if (strokeColorField) {\n    const opacity = visConfig.strokeOpacity !== undefined ? visConfig.strokeOpacity : 1;\n    result.getLineColor = getColorAccessor(\n      strokeColorField,\n      strokeColorScale,\n      visConfig.strokeColorRange,\n      opacity,\n      data\n    );\n  }\n  if (heightField) {\n    result.getElevation = getSizeAccessor(\n      heightField,\n      heightScale,\n      visConfig.heightRange || visConfig.sizeRange,\n      data\n    );\n  }\n  if (sizeField) {\n    result.getPointRadius = getSizeAccessor(\n      sizeField,\n      sizeScale,\n      visConfig.radiusRange || visConfig.sizeRange,\n      data\n    );\n  }\n  if (textLabelField) {\n    result.getText = getTextAccessor(textLabelField, data);\n    result.pointType = 'text';\n    const radius = result.getPointRadius || visConfig.radius;\n    result.getTextPixelOffset = getTextPixelOffsetAccessor(textLabel, radius);\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}