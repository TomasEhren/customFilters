{"ast":null,"code":"import { padToNBytes, copyBinaryToDataView, copyPaddedStringToDataView } from '@loaders.gl/loader-utils';\nimport { MAGIC_ARRAY } from '../constants';\nimport { encode3DTileHeader, encode3DTileByteLength } from './helpers/encode-3d-tile-header';\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  const {\n    featuresLength = 0,\n    batchTable\n  } = tile;\n  const featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n  const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n  const batchTableJsonByteLength = batchTableJsonString ? padToNBytes(batchTableJsonString.length, 8) : 0;\n  tile = {\n    magic: MAGIC_ARRAY.BATCHED_MODEL,\n    ...tile\n  };\n  const byteOffsetStart = byteOffset;\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true);\n    dataView.setUint32(16, 0, true);\n    dataView.setUint32(20, batchTableJsonByteLength, true);\n    dataView.setUint32(24, 0, true);\n  }\n\n  byteOffset += 16;\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n\n  if (batchTable) {\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n  }\n\n  const gltfEncoded = tile.gltfEncoded;\n\n  if (gltfEncoded) {\n    byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n  }\n\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n  return byteOffset;\n}","map":{"version":3,"mappings":"AAGA,SACEA,WADF,EAEEC,oBAFF,EAGEC,0BAHF,QAIO,0BAJP;AAKA,SAAQC,WAAR,QAA0B,cAA1B;AACA,SAAQC,kBAAR,EAA4BC,sBAA5B,QAAyD,iCAAzD;AAGA,OAAO,SAASC,wBAAT,CAAkCC,IAAlC,EAAwCC,QAAxC,EAAkDC,UAAlD,EAA8DC,OAA9D,EAAuE;EAC5E,MAAM;IAACC,cAAc,GAAG,CAAlB;IAAqBC;EAArB,IAAmCL,IAAzC;EAEA,MAAMM,gBAAgB,GAAG;IACvBC,YAAY,EAAEH;EADS,CAAzB;EAGA,MAAMI,sBAAsB,GAAGC,IAAI,CAACC,SAALD,CAAeH,gBAAfG,CAA/B;EACA,MAAME,oBAAoB,GAAGN,UAAU,GAAGI,IAAI,CAACC,SAALD,CAAeJ,UAAfI,CAAH,GAAgC,EAAvE;EACA,MAAMG,0BAA0B,GAAGnB,WAAW,CAACe,sBAAsB,CAACK,MAAxB,EAAgC,CAAhC,CAA9C;EACA,MAAMC,wBAAwB,GAAGH,oBAAoB,GACjDlB,WAAW,CAACkB,oBAAoB,CAACE,MAAtB,EAA8B,CAA9B,CADsC,GAEjD,CAFJ;EAKAb,IAAI,GAAG;IAACe,KAAK,EAAEnB,WAAW,CAACoB,aAApB;IAAmC,GAAGhB;EAAtC,CAAPA;EAEA,MAAMiB,eAAe,GAAGf,UAAxB;EAEAA,UAAU,GAAGL,kBAAkB,CAACG,IAAD,EAAOC,QAAP,EAAiBC,UAAjB,CAA/BA;;EAEA,IAAID,QAAJ,EAAc;IACZA,QAAQ,CAACiB,SAATjB,CAAmB,EAAnBA,EAAuBW,0BAAvBX,EAAmD,IAAnDA;IACAA,QAAQ,CAACiB,SAATjB,CAAmB,EAAnBA,EAAuB,CAAvBA,EAA0B,IAA1BA;IACAA,QAAQ,CAACiB,SAATjB,CAAmB,EAAnBA,EAAuBa,wBAAvBb,EAAiD,IAAjDA;IACAA,QAAQ,CAACiB,SAATjB,CAAmB,EAAnBA,EAAuB,CAAvBA,EAA0B,IAA1BA;EACD;;EACDC,UAAU,IAAI,EAAdA;EAGAA,UAAU,GAAGP,0BAA0B,CAACM,QAAD,EAAWC,UAAX,EAAuBM,sBAAvB,EAA+C,CAA/C,CAAvCN;;EAEA,IAAIG,UAAJ,EAAgB;IACdH,UAAU,GAAGP,0BAA0B,CAACM,QAAD,EAAWC,UAAX,EAAuBS,oBAAvB,EAA6C,CAA7C,CAAvCT;EACD;;EAGD,MAAMiB,WAAW,GAAGnB,IAAI,CAACmB,WAAzB;;EACA,IAAIA,WAAJ,EAAiB;IACfjB,UAAU,GAAGR,oBAAoB,CAACO,QAAD,EAAWC,UAAX,EAAuBiB,WAAvB,EAAoCA,WAAW,CAACC,UAAhD,CAAjClB;EACD;;EAGDJ,sBAAsB,CAACG,QAAD,EAAWgB,eAAX,EAA4Bf,UAAU,GAAGe,eAAzC,CAAtBnB;EAEA,OAAOI,UAAP;AACD","names":["padToNBytes","copyBinaryToDataView","copyPaddedStringToDataView","MAGIC_ARRAY","encode3DTileHeader","encode3DTileByteLength","encodeBatchedModel3DTile","tile","dataView","byteOffset","options","featuresLength","batchTable","featureTableJson","BATCH_LENGTH","featureTableJsonString","JSON","stringify","batchTableJsonString","featureTableJsonByteLength","length","batchTableJsonByteLength","magic","BATCHED_MODEL","byteOffsetStart","setUint32","gltfEncoded","byteLength"],"sources":["../../../../src/lib/encoders/encode-3d-tile-batched-model.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {\n  padToNBytes,\n  copyBinaryToDataView,\n  copyPaddedStringToDataView\n} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 0, batchTable} = tile;\n\n  const featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n  const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n  const batchTableJsonByteLength = batchTableJsonString\n    ? padToNBytes(batchTableJsonString.length, 8)\n    : 0;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, batchTableJsonByteLength, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  // TODO feature table binary\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n\n  if (batchTable) {\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n  }\n\n  // Add encoded GLTF to the end of data\n  const gltfEncoded = tile.gltfEncoded;\n  if (gltfEncoded) {\n    byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n  }\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n"]},"metadata":{},"sourceType":"module"}