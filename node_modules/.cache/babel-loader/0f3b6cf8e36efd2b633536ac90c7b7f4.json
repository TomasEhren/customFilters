{"ast":null,"code":"import { normalizeTransitionSettings } from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {\n      transitions\n    } = this;\n\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      const {\n        value = transition.settings.fromValue\n      } = transition;\n      fromValue = value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n\n    if (!TransitionType) {\n      log.error(\"unsupported transition type '\".concat(settings.type, \"'\"))();\n      return;\n    }\n\n    const transition = new TransitionType(this.timeline);\n    transition.start({ ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {\n      transitions\n    } = this;\n\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n\n      if (!transition.inProgress) {\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAAQA,2BAAR,QAA0C,wCAA1C;AACA,OAAOC,0BAAP,MAAuC,6CAAvC;AACA,OAAOC,mBAAP,MAAgC,sCAAhC;AACA,OAAOC,GAAP,MAAgB,cAAhB;AAEA,MAAMC,gBAAgB,GAAG;EACvBC,aAAa,EAAEJ,0BADQ;EAEvBK,MAAM,EAAEJ;AAFe,CAAzB;AAKA,eAAe,MAAMK,wBAAN,CAA+B;EAC5CC,WAAW,CAACC,QAAD,EAAW;IACpB,KAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;IACA,KAAKF,QAAL,GAAgBA,QAAhB;EACD;;EAES,IAANG,MAAM,GAAG;IACX,OAAO,KAAKF,WAAL,CAAiBG,IAAjB,GAAwB,CAA/B;EACD;;EAEDC,GAAG,CAACC,GAAD,EAAMC,SAAN,EAAiBC,OAAjB,EAA0BC,QAA1B,EAAoC;IACrC,MAAM;MAACR;IAAD,IAAgB,IAAtB;;IACA,IAAIA,WAAW,CAACS,GAAZT,CAAgBK,GAAhBL,CAAJ,EAA0B;MACxB,MAAMU,UAAU,GAAGV,WAAW,CAACW,GAAZX,CAAgBK,GAAhBL,CAAnB;MAEA,MAAM;QAACY,KAAK,GAAGF,UAAU,CAACF,QAAXE,CAAoBJ;MAA7B,IAA0CI,UAAhD;MAEAJ,SAAS,GAAGM,KAAZN;MACA,KAAKO,MAAL,CAAYR,GAAZ;IACD;;IAEDG,QAAQ,GAAGlB,2BAA2B,CAACkB,QAAD,CAAtCA;;IACA,IAAI,CAACA,QAAL,EAAe;MACb;IACD;;IAED,MAAMM,cAAc,GAAGpB,gBAAgB,CAACc,QAAQ,CAACO,IAAV,CAAvC;;IACA,IAAI,CAACD,cAAL,EAAqB;MACnBrB,GAAG,CAACuB,KAAJvB,wCAA0Ce,QAAQ,CAACO,IAAnD;MACA;IACD;;IACD,MAAML,UAAU,GAAG,IAAII,cAAJ,CAAmB,KAAKf,QAAxB,CAAnB;IACAW,UAAU,CAACO,KAAXP,CAAiB,EACf,GAAGF,QADY;MAEfF,SAFe;MAGfC;IAHe,CAAjBG;IAKAV,WAAW,CAACkB,GAAZlB,CAAgBK,GAAhBL,EAAqBU,UAArBV;EACD;;EAEDa,MAAM,CAACR,GAAD,EAAM;IACV,MAAM;MAACL;IAAD,IAAgB,IAAtB;;IACA,IAAIA,WAAW,CAACS,GAAZT,CAAgBK,GAAhBL,CAAJ,EAA0B;MACxBA,WAAW,CAACW,GAAZX,CAAgBK,GAAhBL,EAAqBmB,MAArBnB;MACAA,WAAW,CAACoB,MAAZpB,CAAmBK,GAAnBL;IACD;EACF;;EAEDqB,MAAM,GAAG;IACP,MAAMC,iBAAiB,GAAG,EAA1B;;IAEA,KAAK,MAAM,CAACjB,GAAD,EAAMK,UAAN,CAAX,IAAgC,KAAKV,WAArC,EAAkD;MAChDU,UAAU,CAACW,MAAXX;MACAY,iBAAiB,CAACjB,GAAD,CAAjBiB,GAAyBZ,UAAU,CAACE,KAApCU;;MACA,IAAI,CAACZ,UAAU,CAACa,UAAhB,EAA4B;QAE1B,KAAKV,MAAL,CAAYR,GAAZ;MACD;IACF;;IAED,OAAOiB,iBAAP;EACD;;EAEDE,KAAK,GAAG;IACN,KAAK,MAAMnB,GAAX,IAAkB,KAAKL,WAAL,CAAiByB,IAAjB,EAAlB,EAA2C;MACzC,KAAKZ,MAAL,CAAYR,GAAZ;IACD;EACF;;AAnE2C","names":["normalizeTransitionSettings","CPUInterpolationTransition","CPUSpringTransition","log","TRANSITION_TYPES","interpolation","spring","UniformTransitionManager","constructor","timeline","transitions","Map","active","size","add","key","fromValue","toValue","settings","has","transition","get","value","remove","TransitionType","type","error","start","set","cancel","delete","update","propsInTransition","inProgress","clear","keys"],"sources":["../../../src/lib/uniform-transition-manager.js"],"sourcesContent":["import {normalizeTransitionSettings} from './attribute/attribute-transition-utils';\nimport CPUInterpolationTransition from '../transitions/cpu-interpolation-transition';\nimport CPUSpringTransition from '../transitions/cpu-spring-transition';\nimport log from '../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: CPUInterpolationTransition,\n  spring: CPUSpringTransition\n};\n\nexport default class UniformTransitionManager {\n  constructor(timeline) {\n    this.transitions = new Map();\n    this.timeline = timeline;\n  }\n\n  get active() {\n    return this.transitions.size > 0;\n  }\n\n  add(key, fromValue, toValue, settings) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      const transition = transitions.get(key);\n      // value may not be available if `update()` has not been called. Fallback to `fromValue`\n      const {value = transition.settings.fromValue} = transition;\n      // start from interrupted position\n      fromValue = value;\n      this.remove(key);\n    }\n\n    settings = normalizeTransitionSettings(settings);\n    if (!settings) {\n      return;\n    }\n\n    const TransitionType = TRANSITION_TYPES[settings.type];\n    if (!TransitionType) {\n      log.error(`unsupported transition type '${settings.type}'`)();\n      return;\n    }\n    const transition = new TransitionType(this.timeline);\n    transition.start({\n      ...settings,\n      fromValue,\n      toValue\n    });\n    transitions.set(key, transition);\n  }\n\n  remove(key) {\n    const {transitions} = this;\n    if (transitions.has(key)) {\n      transitions.get(key).cancel();\n      transitions.delete(key);\n    }\n  }\n\n  update() {\n    const propsInTransition = {};\n\n    for (const [key, transition] of this.transitions) {\n      transition.update();\n      propsInTransition[key] = transition.value;\n      if (!transition.inProgress) {\n        // transition ended\n        this.remove(key);\n      }\n    }\n\n    return propsInTransition;\n  }\n\n  clear() {\n    for (const key of this.transitions.keys()) {\n      this.remove(key);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}