{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as Polygon from './polygon';\nimport { Tesselator } from '@deck.gl/core';\nimport { cutPolygonByGrid, cutPolygonByMercatorBounds } from '@math.gl/polygon';\n\nvar PolygonTesselator = /*#__PURE__*/function (_Tesselator) {\n  _inherits(PolygonTesselator, _Tesselator);\n\n  var _super = _createSuper(PolygonTesselator);\n\n  function PolygonTesselator(opts) {\n    _classCallCheck(this, PolygonTesselator);\n\n    var fp64 = opts.fp64,\n        _opts$IndexType = opts.IndexType,\n        IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;\n    return _super.call(this, _objectSpread(_objectSpread({}, opts), {}, {\n      attributes: {\n        positions: {\n          size: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    }));\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      var attributes = this.attributes;\n\n      if (attributeName === 'indices') {\n        return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n      }\n\n      return attributes[attributeName];\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(opts) {\n      _get(_getPrototypeOf(PolygonTesselator.prototype), \"updateGeometry\", this).call(this, opts);\n\n      var externalIndices = this.buffers.indices;\n\n      if (externalIndices) {\n        this.vertexCount = (externalIndices.value || externalIndices).length;\n      }\n    }\n  }, {\n    key: \"normalizeGeometry\",\n    value: function normalizeGeometry(polygon) {\n      if (this.normalize) {\n        polygon = Polygon.normalize(polygon, this.positionSize);\n\n        if (this.opts.resolution) {\n          return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            gridResolution: this.opts.resolution,\n            edgeTypes: true\n          });\n        }\n\n        if (this.opts.wrapLongitude) {\n          return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n            size: this.positionSize,\n            maxLatitude: 86,\n            edgeTypes: true\n          });\n        }\n      }\n\n      return polygon;\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var size = 0;\n\n        var _iterator = _createForOfIteratorHelper(polygon),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var subPolygon = _step.value;\n            size += this.getGeometrySize(subPolygon);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return size;\n      }\n\n      return (polygon.positions || polygon).length / this.positionSize;\n    }\n  }, {\n    key: \"getGeometryFromBuffer\",\n    value: function getGeometryFromBuffer(buffer) {\n      if (this.normalize || !this.buffers.indices) {\n        return _get(_getPrototypeOf(PolygonTesselator.prototype), \"getGeometryFromBuffer\", this).call(this, buffer);\n      }\n\n      return function () {\n        return null;\n      };\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n        var _iterator2 = _createForOfIteratorHelper(polygon),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var subPolygon = _step2.value;\n            var geometrySize = this.getGeometrySize(subPolygon);\n            context.geometrySize = geometrySize;\n            this.updateGeometryAttributes(subPolygon, context);\n            context.vertexStart += geometrySize;\n            context.indexStart = this.indexStarts[context.geometryIndex + 1];\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        this._updateIndices(polygon, context);\n\n        this._updatePositions(polygon, context);\n\n        this._updateVertexValid(polygon, context);\n      }\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref) {\n      var geometryIndex = _ref.geometryIndex,\n          offset = _ref.vertexStart,\n          indexStart = _ref.indexStart;\n      var attributes = this.attributes,\n          indexStarts = this.indexStarts,\n          typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n\n      if (!target) {\n        return;\n      }\n\n      var i = indexStart;\n      var indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n      target = typedArrayManager.allocate(target, indexStart + indices.length, {\n        copy: true\n      });\n\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n\n      indexStarts[geometryIndex + 1] = indexStart + indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref2) {\n      var vertexStart = _ref2.vertexStart,\n          geometrySize = _ref2.geometrySize;\n      var positions = this.attributes.positions,\n          positionSize = this.positionSize;\n\n      if (!positions) {\n        return;\n      }\n\n      var polygonPositions = polygon.positions || polygon;\n\n      for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n      }\n    }\n  }, {\n    key: \"_updateVertexValid\",\n    value: function _updateVertexValid(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n          geometrySize = _ref3.geometrySize;\n      var vertexValid = this.attributes.vertexValid,\n          positionSize = this.positionSize;\n      var holeIndices = polygon && polygon.holeIndices;\n\n      if (polygon && polygon.edgeTypes) {\n        vertexValid.set(polygon.edgeTypes, vertexStart);\n      } else {\n        vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n      }\n\n      if (holeIndices) {\n        for (var j = 0; j < holeIndices.length; j++) {\n          vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n        }\n      }\n\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(Tesselator);\n\nexport { PolygonTesselator as default };","map":{"version":3,"mappings":"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","names":["Polygon","Tesselator","cutPolygonByGrid","cutPolygonByMercatorBounds","PolygonTesselator","constructor","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","get","attributeName","subarray","vertexCount","updateGeometry","externalIndices","buffers","value","length","normalizeGeometry","polygon","normalize","positionSize","resolution","holeIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","getGeometrySize","Array","isArray","Number","isFinite","subPolygon","getGeometryFromBuffer","buffer","updateGeometryAttributes","context","geometrySize","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","allocate","copy","j","polygonPositions","x","y","z","set","fill"],"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}