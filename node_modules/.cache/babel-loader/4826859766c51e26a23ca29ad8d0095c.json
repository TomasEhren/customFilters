{"ast":null,"code":"import _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isWebGL2, assertWebGL2Context, withParameters } from '@luma.gl/gltools';\nimport Texture from './texture';\nimport { DATA_FORMAT_CHANNELS, TYPE_SIZES } from './texture-formats';\nimport Buffer from './buffer';\n\nvar Texture3D = /*#__PURE__*/function (_Texture) {\n  _inherits(Texture3D, _Texture);\n\n  var _super = _createSuper(Texture3D);\n\n  function Texture3D(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Texture3D);\n\n    assertWebGL2Context(gl);\n    props = Object.assign({\n      depth: 1\n    }, props, {\n      target: 32879,\n      unpackFlipY: false\n    });\n    _this = _super.call(this, gl, props);\n\n    _this.initialize(props);\n\n    Object.seal(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Texture3D, [{\n    key: \"setImageData\",\n    value: function setImageData(_ref) {\n      var _this2 = this;\n\n      var _ref$level = _ref.level,\n          level = _ref$level === void 0 ? 0 : _ref$level,\n          _ref$dataFormat = _ref.dataFormat,\n          dataFormat = _ref$dataFormat === void 0 ? 6408 : _ref$dataFormat,\n          width = _ref.width,\n          height = _ref.height,\n          _ref$depth = _ref.depth,\n          depth = _ref$depth === void 0 ? 1 : _ref$depth,\n          _ref$border = _ref.border,\n          border = _ref$border === void 0 ? 0 : _ref$border,\n          format = _ref.format,\n          _ref$type = _ref.type,\n          type = _ref$type === void 0 ? 5121 : _ref$type,\n          _ref$offset = _ref.offset,\n          offset = _ref$offset === void 0 ? 0 : _ref$offset,\n          data = _ref.data,\n          _ref$parameters = _ref.parameters,\n          parameters = _ref$parameters === void 0 ? {} : _ref$parameters;\n\n      this._trackDeallocatedMemory('Texture');\n\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, parameters, function () {\n        if (ArrayBuffer.isView(data)) {\n          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, data);\n        }\n\n        if (data instanceof Buffer) {\n          _this2.gl.bindBuffer(35052, data.handle);\n\n          _this2.gl.texImage3D(_this2.target, level, dataFormat, width, height, depth, border, format, type, offset);\n        }\n      });\n\n      if (data && data.byteLength) {\n        this._trackAllocatedMemory(data.byteLength, 'Texture');\n      } else {\n        var channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n        var channelSize = TYPE_SIZES[this.type] || 1;\n\n        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, 'Texture');\n      }\n\n      this.loaded = true;\n      return this;\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      return isWebGL2(gl);\n    }\n  }]);\n\n  return Texture3D;\n}(Texture);\n\nexport { Texture3D as default };","map":{"version":3,"mappings":"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","names":["isWebGL2","assertWebGL2Context","withParameters","Texture","DATA_FORMAT_CHANNELS","TYPE_SIZES","Buffer","Texture3D","constructor","gl","props","Object","assign","depth","target","unpackFlipY","initialize","seal","setImageData","level","dataFormat","width","height","border","format","type","offset","data","parameters","_trackDeallocatedMemory","bindTexture","handle","ArrayBuffer","isView","texImage3D","bindBuffer","byteLength","_trackAllocatedMemory","channels","channelSize","loaded"],"sources":["../../../src/classes/texture-3d.js"],"sourcesContent":["import GL from '@luma.gl/constants';\nimport {isWebGL2, assertWebGL2Context, withParameters} from '@luma.gl/gltools';\nimport Texture from './texture';\nimport {DATA_FORMAT_CHANNELS, TYPE_SIZES} from './texture-formats';\nimport Buffer from './buffer';\n\nexport default class Texture3D extends Texture {\n  static isSupported(gl) {\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    assertWebGL2Context(gl);\n    props = Object.assign({depth: 1}, props, {target: GL.TEXTURE_3D, unpackFlipY: false});\n    super(gl, props);\n    this.initialize(props);\n\n    Object.seal(this);\n  }\n\n  // Image 3D copies from Typed Array or WebGLBuffer\n  setImageData({\n    level = 0,\n    dataFormat = GL.RGBA,\n    width,\n    height,\n    depth = 1,\n    border = 0,\n    format,\n    type = GL.UNSIGNED_BYTE,\n    offset = 0,\n    data,\n    parameters = {}\n  }) {\n    this._trackDeallocatedMemory('Texture');\n\n    this.gl.bindTexture(this.target, this.handle);\n\n    withParameters(this.gl, parameters, () => {\n      if (ArrayBuffer.isView(data)) {\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          data\n        );\n      }\n\n      if (data instanceof Buffer) {\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle);\n        // @ts-ignore\n        this.gl.texImage3D(\n          this.target,\n          level,\n          dataFormat,\n          width,\n          height,\n          depth,\n          border,\n          format,\n          type,\n          offset\n        );\n      }\n    });\n\n    if (data && data.byteLength) {\n      this._trackAllocatedMemory(data.byteLength, 'Texture');\n    } else {\n      // NOTE(Tarek): Default to RGBA bytes\n      // @ts-ignore\n      const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;\n      // @ts-ignore\n      const channelSize = TYPE_SIZES[this.type] || 1;\n\n      this._trackAllocatedMemory(\n        this.width * this.height * this.depth * channels * channelSize,\n        'Texture'\n      );\n    }\n\n    this.loaded = true;\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}