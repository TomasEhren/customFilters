{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\nvar DEFAULT_OPTIONS = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\nvar ERR_MESSAGE = 'TableBatchBuilder';\n\nvar TableBatchBuilder = /*#__PURE__*/function () {\n  function TableBatchBuilder(schema, options) {\n    _classCallCheck(this, TableBatchBuilder);\n\n    _defineProperty(this, \"schema\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"aggregator\", null);\n\n    _defineProperty(this, \"batchCount\", 0);\n\n    _defineProperty(this, \"bytesUsed\", 0);\n\n    _defineProperty(this, \"isChunkComplete\", false);\n\n    _defineProperty(this, \"lastBatchEmittedMs\", Date.now());\n\n    _defineProperty(this, \"totalLength\", 0);\n\n    _defineProperty(this, \"totalBytes\", 0);\n\n    _defineProperty(this, \"rowBytes\", 0);\n\n    this.schema = schema;\n    this.options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n  }\n\n  _createClass(TableBatchBuilder, [{\n    key: \"limitReached\",\n    value: function limitReached() {\n      var _this$options, _this$options2;\n\n      if (Boolean((_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.limit) && this.totalLength >= this.options.limit) {\n        return true;\n      }\n\n      if (Boolean((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"addRow\",\n    value: function addRow(row) {\n      if (this.limitReached()) {\n        return;\n      }\n\n      this.totalLength++;\n      this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n      this.totalBytes += this.rowBytes;\n\n      if (Array.isArray(row)) {\n        this.addArrayRow(row);\n      } else {\n        this.addObjectRow(row);\n      }\n    }\n  }, {\n    key: \"addArrayRow\",\n    value: function addArrayRow(row) {\n      if (!this.aggregator) {\n        var TableBatchType = this._getTableBatchType();\n\n        this.aggregator = new TableBatchType(this.schema, this.options);\n      }\n\n      this.aggregator.addArrayRow(row);\n    }\n  }, {\n    key: \"addObjectRow\",\n    value: function addObjectRow(row) {\n      if (!this.aggregator) {\n        var TableBatchType = this._getTableBatchType();\n\n        this.aggregator = new TableBatchType(this.schema, this.options);\n      }\n\n      this.aggregator.addObjectRow(row);\n    }\n  }, {\n    key: \"chunkComplete\",\n    value: function chunkComplete(chunk) {\n      if (chunk instanceof ArrayBuffer) {\n        this.bytesUsed += chunk.byteLength;\n      }\n\n      if (typeof chunk === 'string') {\n        this.bytesUsed += chunk.length;\n      }\n\n      this.isChunkComplete = true;\n    }\n  }, {\n    key: \"getFullBatch\",\n    value: function getFullBatch(options) {\n      return this._isFull() ? this._getBatch(options) : null;\n    }\n  }, {\n    key: \"getFinalBatch\",\n    value: function getFinalBatch(options) {\n      return this._getBatch(options);\n    }\n  }, {\n    key: \"_estimateRowMB\",\n    value: function _estimateRowMB(row) {\n      return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n    }\n  }, {\n    key: \"_isFull\",\n    value: function _isFull() {\n      if (!this.aggregator || this.aggregator.rowCount() === 0) {\n        return false;\n      }\n\n      if (this.options.batchSize === 'auto') {\n        if (!this.isChunkComplete) {\n          return false;\n        }\n      } else if (this.options.batchSize > this.aggregator.rowCount()) {\n        return false;\n      }\n\n      if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n        return false;\n      }\n\n      this.isChunkComplete = false;\n      this.lastBatchEmittedMs = Date.now();\n      return true;\n    }\n  }, {\n    key: \"_getBatch\",\n    value: function _getBatch(options) {\n      if (!this.aggregator) {\n        return null;\n      }\n\n      if (options !== null && options !== void 0 && options.bytesUsed) {\n        this.bytesUsed = options.bytesUsed;\n      }\n\n      var normalizedBatch = this.aggregator.getBatch();\n      normalizedBatch.count = this.batchCount;\n      normalizedBatch.bytesUsed = this.bytesUsed;\n      Object.assign(normalizedBatch, options);\n      this.batchCount++;\n      this.aggregator = null;\n      return normalizedBatch;\n    }\n  }, {\n    key: \"_getTableBatchType\",\n    value: function _getTableBatchType() {\n      switch (this.options.shape) {\n        case 'row-table':\n          return BaseTableBatchAggregator;\n\n        case 'array-row-table':\n        case 'object-row-table':\n          return RowTableBatchAggregator;\n\n        case 'columnar-table':\n          return ColumnarTableBatchAggregator;\n\n        case 'arrow-table':\n          if (!TableBatchBuilder.ArrowBatch) {\n            throw new Error(ERR_MESSAGE);\n          }\n\n          return TableBatchBuilder.ArrowBatch;\n\n        default:\n          throw new Error(ERR_MESSAGE);\n      }\n    }\n  }]);\n\n  return TableBatchBuilder;\n}();\n\nexport { TableBatchBuilder as default };\n\n_defineProperty(TableBatchBuilder, \"ArrowBatch\", void 0);","map":{"version":3,"mappings":"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","names":["BaseTableBatchAggregator","RowTableBatchAggregator","ColumnarTableBatchAggregator","DEFAULT_OPTIONS","shape","batchSize","batchDebounceMs","limit","_limitMB","ERR_MESSAGE","TableBatchBuilder","constructor","schema","options","_defineProperty","Date","now","limitReached","Boolean","_this$options","totalLength","_this$options2","totalBytes","addRow","row","rowBytes","_estimateRowMB","Array","isArray","addArrayRow","addObjectRow","aggregator","TableBatchType","_getTableBatchType","chunkComplete","chunk","ArrayBuffer","bytesUsed","byteLength","length","isChunkComplete","getFullBatch","_isFull","_getBatch","getFinalBatch","Object","keys","rowCount","lastBatchEmittedMs","normalizedBatch","getBatch","count","batchCount","assign","ArrowBatch","Error"],"sources":["../../../../src/lib/batches/table-batch-builder.ts"],"sourcesContent":["import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row: any[] | object): number {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}