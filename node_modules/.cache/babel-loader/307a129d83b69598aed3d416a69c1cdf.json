{"ast":null,"code":"import { CullingVolume, Plane, AxisAlignedBoundingBox, makeOrientedBoundingBoxFromPoints } from '@math.gl/culling';\nimport { lngLatToWorld } from '@math.gl/web-mercator';\nimport { osmTile2lngLat } from './utils';\nconst TILE_SIZE = 512;\nconst MAX_MAPS = 3;\nconst REF_POINTS_5 = [[0.5, 0.5], [0, 0], [0, 1], [1, 0], [1, 1]];\nconst REF_POINTS_9 = REF_POINTS_5.concat([[0, 0.5], [0.5, 0], [1, 0.5], [0.5, 1]]);\nconst REF_POINTS_11 = REF_POINTS_9.concat([[0.25, 0.5], [0.75, 0.5]]);\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [new OSMNode(x, y, z), new OSMNode(x, y + 1, z), new OSMNode(x + 1, y, z), new OSMNode(x + 1, y + 1, z)];\n    }\n\n    return this._children;\n  }\n\n  update(params) {\n    const {\n      viewport,\n      cullingVolume,\n      elevationBounds,\n      minZ,\n      maxZ,\n      bounds,\n      offset,\n      project\n    } = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n\n    if (isInside < 0) {\n      return false;\n    }\n\n    if (!this.childVisible) {\n      let {\n        z\n      } = this;\n\n      if (z < maxZ && z >= minZ) {\n        const distance = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n\n      if (z >= maxZ) {\n        this.selected = true;\n        return true;\n      }\n    }\n\n    this.selected = false;\n    this.childVisible = true;\n\n    for (const child of this.children) {\n      child.update(params);\n    }\n\n    return true;\n  }\n\n  getSelected() {\n    let result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    if (this.selected) {\n      result.push(this);\n    }\n\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n\n    return result;\n  }\n\n  insideBounds(_ref) {\n    let [minX, minY, maxX, maxY] = _ref;\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n      const refPointPositions = [];\n\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);\n  }\n\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n  const planes = Object.values(viewport.getFrustumPlanes()).map(_ref2 => {\n    let {\n      normal,\n      distance\n    } = _ref2;\n    return new Plane(normal.clone().negate(), distance);\n  });\n  const cullingVolume = new CullingVolume(planes);\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;\n  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    offset: 0\n  };\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    traversalParams.offset = -1;\n\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n\n    traversalParams.offset = 1;\n\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}","map":{"version":3,"mappings":"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","names":["CullingVolume","Plane","AxisAlignedBoundingBox","makeOrientedBoundingBoxFromPoints","lngLatToWorld","osmTile2lngLat","TILE_SIZE","MAX_MAPS","REF_POINTS_5","REF_POINTS_9","concat","REF_POINTS_11","OSMNode","constructor","x","y","z","children","_children","update","params","viewport","cullingVolume","elevationBounds","minZ","maxZ","bounds","offset","project","boundingVolume","getBoundingVolume","insideBounds","isInside","computeVisibility","childVisible","distance","distanceTo","cameraPosition","scale","height","Math","floor","log2","selected","child","getSelected","result","push","node","minX","minY","maxX","maxY","pow","extent","zRange","worldOffset","refPoints","refPointPositions","p","lngLat","originX","originY","getOSMTileIndices","resolution","projectPosition","planes","Object","values","getFrustumPlanes","map","normal","clone","negate","unitsPerMeter","distanceScales","elevationMin","elevationMax","pitch","minLng","minLat","maxLng","maxLat","topLeft","bottomRight","root","traversalParams","subViewports","length"],"sources":["../../../src/tile-layer/tile-2d-traversal.js"],"sourcesContent":["/* eslint-disable complexity */\nimport {\n  CullingVolume,\n  Plane,\n  AxisAlignedBoundingBox,\n  makeOrientedBoundingBoxFromPoints\n} from '@math.gl/culling';\nimport {lngLatToWorld} from '@math.gl/web-mercator';\nimport {osmTile2lngLat} from './utils';\n\nconst TILE_SIZE = 512;\n// number of world copies to check\nconst MAX_MAPS = 3;\n// for calculating bounding volume of a tile in a non-web-mercator viewport\nconst REF_POINTS_5 = [\n  [0.5, 0.5],\n  [0, 0],\n  [0, 1],\n  [1, 0],\n  [1, 1]\n]; // 4 corners and center\nconst REF_POINTS_9 = REF_POINTS_5.concat([\n  [0, 0.5],\n  [0.5, 0],\n  [1, 0.5],\n  [0.5, 1]\n]); // 4 corners, center and 4 mid points\nconst REF_POINTS_11 = REF_POINTS_9.concat([\n  [0.25, 0.5],\n  [0.75, 0.5]\n]); // 2 additional points on equator for top tile\n\nclass OSMNode {\n  constructor(x, y, z) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n\n  get children() {\n    if (!this._children) {\n      const x = this.x * 2;\n      const y = this.y * 2;\n      const z = this.z + 1;\n      this._children = [\n        new OSMNode(x, y, z),\n        new OSMNode(x, y + 1, z),\n        new OSMNode(x + 1, y, z),\n        new OSMNode(x + 1, y + 1, z)\n      ];\n    }\n    return this._children;\n  }\n\n  update(params) {\n    const {viewport, cullingVolume, elevationBounds, minZ, maxZ, bounds, offset, project} = params;\n    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);\n\n    // First, check if this tile is visible\n    if (bounds && !this.insideBounds(bounds)) {\n      return false;\n    }\n\n    const isInside = cullingVolume.computeVisibility(boundingVolume);\n    if (isInside < 0) {\n      return false;\n    }\n\n    // Avoid loading overlapping tiles - if a descendant is requested, do not request the ancester\n    if (!this.childVisible) {\n      let {z} = this;\n      if (z < maxZ && z >= minZ) {\n        // Adjust LOD\n        // If the tile is far enough from the camera, accept a lower zoom level\n        const distance =\n          (boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale) / viewport.height;\n        z += Math.floor(Math.log2(distance));\n      }\n      if (z >= maxZ) {\n        // LOD is acceptable\n        this.selected = true;\n        return true;\n      }\n    }\n\n    // LOD is not enough, recursively test child tiles\n    this.selected = false;\n    this.childVisible = true;\n    for (const child of this.children) {\n      child.update(params);\n    }\n    return true;\n  }\n\n  getSelected(result = []) {\n    if (this.selected) {\n      result.push(this);\n    }\n    if (this._children) {\n      for (const node of this._children) {\n        node.getSelected(result);\n      }\n    }\n    return result;\n  }\n\n  insideBounds([minX, minY, maxX, maxY]) {\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n\n    return (\n      this.x * extent < maxX &&\n      this.y * extent < maxY &&\n      (this.x + 1) * extent > minX &&\n      (this.y + 1) * extent > minY\n    );\n  }\n\n  getBoundingVolume(zRange, worldOffset, project) {\n    if (project) {\n      // Custom projection\n      // Estimate bounding box from sample points\n      // At low zoom level we need more samples to calculate the bounding volume correctly\n      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;\n\n      // Convert from tile-relative coordinates to common space\n      const refPointPositions = [];\n      for (const p of refPoints) {\n        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);\n        lngLat[2] = zRange[0];\n        refPointPositions.push(project(lngLat));\n\n        if (zRange[0] !== zRange[1]) {\n          // Account for the elevation volume\n          lngLat[2] = zRange[1];\n          refPointPositions.push(project(lngLat));\n        }\n      }\n\n      return makeOrientedBoundingBoxFromPoints(refPointPositions);\n    }\n\n    // Use WebMercator projection\n    const scale = Math.pow(2, this.z);\n    const extent = TILE_SIZE / scale;\n    const originX = this.x * extent + worldOffset * TILE_SIZE;\n    // deck's common space is y-flipped\n    const originY = TILE_SIZE - (this.y + 1) * extent;\n\n    return new AxisAlignedBoundingBox(\n      [originX, originY, zRange[0]],\n      [originX + extent, originY + extent, zRange[1]]\n    );\n  }\n}\n\nexport function getOSMTileIndices(viewport, maxZ, zRange, bounds) {\n  const project = viewport.resolution ? viewport.projectPosition : null;\n\n  // Get the culling volume of the current camera\n  const planes = Object.values(viewport.getFrustumPlanes()).map(\n    ({normal, distance}) => new Plane(normal.clone().negate(), distance)\n  );\n  const cullingVolume = new CullingVolume(planes);\n\n  // Project zRange from meters to common space\n  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];\n  const elevationMin = (zRange && zRange[0] * unitsPerMeter) || 0;\n  const elevationMax = (zRange && zRange[1] * unitsPerMeter) || 0;\n\n  // Always load at the current zoom level if pitch is small\n  const minZ = viewport.pitch <= 60 ? maxZ : 0;\n\n  // Map extent to OSM position\n  if (bounds) {\n    const [minLng, minLat, maxLng, maxLat] = bounds;\n    const topLeft = lngLatToWorld([minLng, maxLat]);\n    const bottomRight = lngLatToWorld([maxLng, minLat]);\n    bounds = [topLeft[0], TILE_SIZE - topLeft[1], bottomRight[0], TILE_SIZE - bottomRight[1]];\n  }\n\n  const root = new OSMNode(0, 0, 0);\n  const traversalParams = {\n    viewport,\n    project,\n    cullingVolume,\n    elevationBounds: [elevationMin, elevationMax],\n    minZ,\n    maxZ,\n    bounds,\n    // num. of worlds from the center. For repeated maps\n    offset: 0\n  };\n\n  root.update(traversalParams);\n\n  if (viewport.subViewports && viewport.subViewports.length > 1) {\n    // Check worlds in repeated maps\n    traversalParams.offset = -1;\n    while (root.update(traversalParams)) {\n      if (--traversalParams.offset < -MAX_MAPS) {\n        break;\n      }\n    }\n    traversalParams.offset = 1;\n    while (root.update(traversalParams)) {\n      if (++traversalParams.offset > MAX_MAPS) {\n        break;\n      }\n    }\n  }\n\n  return root.getSelected();\n}\n"]},"metadata":{},"sourceType":"module"}