{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Vector3, Matrix3 } from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../bounding-volumes/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../bounding-volumes/axis-aligned-bounding-box';\nvar scratchVector2 = new Vector3();\nvar scratchVector3 = new Vector3();\nvar scratchVector4 = new Vector3();\nvar scratchVector5 = new Vector3();\nvar scratchVector6 = new Vector3();\nvar scratchCovarianceResult = new Matrix3();\nvar scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\nexport function makeOrientedBoundingBoxFromPoints(positions) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new OrientedBoundingBox();\n\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  var length = positions.length;\n  var meanPoint = new Vector3(0, 0, 0);\n\n  var _iterator = _createForOfIteratorHelper(positions),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var position = _step.value;\n      meanPoint.add(position);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n  var exx = 0.0;\n  var exy = 0.0;\n  var exz = 0.0;\n  var eyy = 0.0;\n  var eyz = 0.0;\n  var ezz = 0.0;\n\n  var _iterator2 = _createForOfIteratorHelper(positions),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _position = _step2.value;\n      var p = scratchVector2.copy(_position).subtract(meanPoint);\n      exx += p.x * p.x;\n      exy += p.x * p.y;\n      exz += p.x * p.z;\n      eyy += p.y * p.y;\n      eyz += p.y * p.z;\n      ezz += p.z * p.z;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n  var covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  var _computeEigenDecompos = computeEigenDecomposition(covarianceMatrix, scratchEigenResult),\n      unitary = _computeEigenDecompos.unitary;\n\n  var rotation = result.halfAxes.copy(unitary);\n  var v1 = rotation.getColumn(0, scratchVector4);\n  var v2 = rotation.getColumn(1, scratchVector5);\n  var v3 = rotation.getColumn(2, scratchVector6);\n  var u1 = -Number.MAX_VALUE;\n  var u2 = -Number.MAX_VALUE;\n  var u3 = -Number.MAX_VALUE;\n  var l1 = Number.MAX_VALUE;\n  var l2 = Number.MAX_VALUE;\n  var l3 = Number.MAX_VALUE;\n\n  var _iterator3 = _createForOfIteratorHelper(positions),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _position2 = _step3.value;\n      scratchVector2.copy(_position2);\n      u1 = Math.max(scratchVector2.dot(v1), u1);\n      u2 = Math.max(scratchVector2.dot(v2), u2);\n      u3 = Math.max(scratchVector2.dot(v3), u3);\n      l1 = Math.min(scratchVector2.dot(v1), l1);\n      l2 = Math.min(scratchVector2.dot(v2), l2);\n      l3 = Math.min(scratchVector2.dot(v3), l3);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n  result.center.copy(v1).add(v2).add(v3);\n  var scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  var scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n  return result;\n}\nexport function makeAxisAlignedBoundingBoxFromPoints(positions) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new AxisAlignedBoundingBox();\n\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  var minimumX = positions[0][0];\n  var minimumY = positions[0][1];\n  var minimumZ = positions[0][2];\n  var maximumX = positions[0][0];\n  var maximumY = positions[0][1];\n  var maximumZ = positions[0][2];\n\n  var _iterator4 = _createForOfIteratorHelper(positions),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var p = _step4.value;\n      var x = p[0];\n      var y = p[1];\n      var z = p[2];\n      minimumX = Math.min(x, minimumX);\n      maximumX = Math.max(x, maximumX);\n      minimumY = Math.min(y, minimumY);\n      maximumY = Math.max(y, maximumY);\n      minimumZ = Math.min(z, minimumZ);\n      maximumZ = Math.max(z, maximumZ);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n  return result;\n}","map":{"version":3,"mappings":"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","names":["Vector3","Matrix3","computeEigenDecomposition","OrientedBoundingBox","AxisAlignedBoundingBox","scratchVector2","scratchVector3","scratchVector4","scratchVector5","scratchVector6","scratchCovarianceResult","scratchEigenResult","diagonal","unitary","makeOrientedBoundingBoxFromPoints","positions","result","length","halfAxes","center","meanPoint","position","add","invLength","multiplyByScalar","exx","exy","exz","eyy","eyz","ezz","p","copy","subtract","x","y","z","covarianceMatrix","rotation","v1","getColumn","v2","v3","u1","Number","MAX_VALUE","u2","u3","l1","l2","l3","Math","max","dot","min","scale","set","scaleMatrix","multiplyRight","makeAxisAlignedBoundingBoxFromPoints","minimum","maximum","halfDiagonal","minimumX","minimumY","minimumZ","maximumX","maximumY","maximumZ"],"sources":["../../../../src/lib/algorithms/bounding-box-from-points.js"],"sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../bounding-volumes/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../bounding-volumes/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    scratchVector2.copy(position);\n\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center.copy(v1).add(v2).add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n\n  return result;\n}\n\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions,\n  result = new AxisAlignedBoundingBox()\n) {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}