{"ast":null,"code":"import GLTFScenegraph from '../api/gltf-scenegraph';\nimport { isMeshoptSupported, meshoptDecodeGltfBuffer } from '../../meshopt/meshopt-decoder';\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\nexport const name = EXT_MESHOPT_COMPRESSION;\nexport function preprocess(gltfData) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) && !isMeshoptSupported()) {\n    throw new Error(\"gltf: Required extension \".concat(EXT_MESHOPT_COMPRESSION, \" not supported by browser\"));\n  }\n}\nexport async function decode(gltfData, options) {\n  var _options$gltf;\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!(options !== null && options !== void 0 && (_options$gltf = options.gltf) !== null && _options$gltf !== void 0 && _options$gltf.decompressMeshes)) {\n    return;\n  }\n\n  const promises = [];\n\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  await Promise.all(promises);\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\nasync function decodeMeshoptBufferView(scenegraph, bufferView) {\n  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);\n\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}","map":{"version":3,"mappings":"AAGA,OAAOA,cAAP,MAA2B,wBAA3B;AACA,SAAQC,kBAAR,EAA4BC,uBAA5B,QAA0D,+BAA1D;AAIA,MAAMC,uBAAuB,GAAG;EAC9BC,UAAU,EAAE,CADkB;EAE9BC,MAAM,EAAE;AAFsB,CAAhC;AAMA,MAAMC,uBAAuB,GAAG,yBAAhC;AAEA,OAAO,MAAMC,IAAI,GAAGD,uBAAb;AAEP,OAAO,SAASE,UAAT,CAAoBC,QAApB,EAA4C;EACjD,MAAMC,UAAU,GAAG,IAAIV,cAAJ,CAAmBS,QAAnB,CAAnB;;EACA,IACEC,UAAU,CAACC,qBAAXD,GAAmCE,QAAnCF,CAA4CJ,uBAA5CI,KACA,CAACT,kBAAkB,EAFrB,EAGE;IACA,MAAM,IAAIY,KAAJ,oCAAsCP,uBAAtC,+BAAN;EACD;AACF;AAED,OAAO,eAAeQ,MAAf,CAAsBL,QAAtB,EAA8CM,OAA9C,EAA0E;EAAA;;EAC/E,MAAML,UAAU,GAAG,IAAIV,cAAJ,CAAmBS,QAAnB,CAAnB;;EAEA,IAAI,EAACM,OAAD,SAACA,WAAD,WAACA,IAAD,iBAACA,OAAO,CAAEC,IAAV,UAACD,IAADE,wBAACF,kBAAeG,gBAAhB,CAAJ,EAAsC;IACpC;EACD;;EAED,MAAMC,QAAwB,GAAG,EAAjC;;EACA,KAAK,MAAMC,eAAX,IAA8BX,QAAQ,CAACY,IAATZ,CAAca,WAAdb,IAA6B,EAA3D,EAA+D;IAC7DU,QAAQ,CAACI,IAATJ,CAAcK,uBAAuB,CAACd,UAAD,EAAaU,eAAb,CAArCD;EACD;;EAGD,MAAMM,OAAO,CAACC,GAARD,CAAYN,QAAZM,CAAN;EAGAf,UAAU,CAACiB,eAAXjB,CAA2BJ,uBAA3BI;AACD;;AAGD,eAAec,uBAAf,CACEd,UADF,EAEEkB,UAFF,EAG+B;EAC7B,MAAMC,gBAAgB,GAAGnB,UAAU,CAACoB,kBAAXpB,CACvBkB,UADuBlB,EAEvBJ,uBAFuBI,CAAzB;;EAIA,IAAImB,gBAAJ,EAAsB;IACpB,MAAME,MAAM,GAAGH,UAAU,CAACG,MAA1B;IAEA,MAAM;MACJ3B,UAAU,GAAG,CADT;MAEJ4B,UAAU,GAAG,CAFT;MAGJC,UAHI;MAIJC,KAJI;MAKJC,IALI;MAMJ9B,MAAM,GAAG;IANL,IAOFwB,gBAPJ;IAUA,MAAMO,MAAM,GAAG,IAAIC,UAAJ,CAAeN,MAAf,EAAuB3B,UAAvB,EAAmC4B,UAAnC,CAAf;IACA,MAAMM,MAAM,GAAG,IAAIC,WAAJ,CAAgBL,KAAK,GAAGD,UAAxB,CAAf;IACA,MAAM/B,uBAAuB,CAAC,IAAImC,UAAJ,CAAeC,MAAf,CAAD,EAAyBJ,KAAzB,EAAgCD,UAAhC,EAA4CG,MAA5C,EAAoDD,IAApD,EAA0D9B,MAA1D,CAA7B;IACA,OAAOiC,MAAP;EACD;;EAED,OAAO,IAAP;AACD","names":["GLTFScenegraph","isMeshoptSupported","meshoptDecodeGltfBuffer","DEFAULT_MESHOPT_OPTIONS","byteOffset","filter","EXT_MESHOPT_COMPRESSION","name","preprocess","gltfData","scenegraph","getRequiredExtensions","includes","Error","decode","options","gltf","_options$gltf","decompressMeshes","promises","bufferViewIndex","json","bufferViews","push","decodeMeshoptBufferView","Promise","all","removeExtension","bufferView","meshoptExtension","getObjectExtension","buffer","byteLength","byteStride","count","mode","source","Uint8Array","result","ArrayBuffer"],"sources":["../../../../src/lib/extensions/EXT_meshopt_compression.ts"],"sourcesContent":["/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {isMeshoptSupported, meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport function preprocess(gltfData: {json: GLTF}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  if (\n    scenegraph.getRequiredExtensions().includes(EXT_MESHOPT_COMPRESSION) &&\n    !isMeshoptSupported()\n  ) {\n    throw new Error(`gltf: Required extension ${EXT_MESHOPT_COMPRESSION} not supported by browser`);\n  }\n}\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const buffer = bufferView.buffer;\n\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE'\n    } = meshoptExtension;\n\n    // @ts-expect-error TODO - fix buffer handling\n    const source = new Uint8Array(buffer, byteOffset, byteLength);\n    const result = new ArrayBuffer(count * byteStride);\n    await meshoptDecodeGltfBuffer(new Uint8Array(result), count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}