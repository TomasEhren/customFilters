{"ast":null,"code":"import _objectSpread from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tomasehrenfeld/projs/se-team/tomas/react-apps/custom_filter/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Layer, project32, picking, log, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  iconAtlas: {\n    type: 'image',\n    value: null,\n    async: true\n  },\n  iconMapping: {\n    type: 'object',\n    value: {},\n    async: true\n  },\n  sizeScale: {\n    type: 'number',\n    value: 1,\n    min: 0\n  },\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  sizeMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  alphaCutoff: {\n    type: 'number',\n    value: 0.05,\n    min: 0,\n    max: 1\n  },\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getIcon: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.icon;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getSize: {\n    type: 'accessor',\n    value: 1\n  },\n  getAngle: {\n    type: 'accessor',\n    value: 0\n  },\n  getPixelOffset: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  onIconError: {\n    type: 'function',\n    value: null,\n    compare: false,\n    optional: true\n  }\n};\n\nvar IconLayer = /*#__PURE__*/function (_Layer) {\n  _inherits(IconLayer, _Layer);\n\n  var _super = _createSuper(IconLayer);\n\n  function IconLayer() {\n    _classCallCheck(this, IconLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(IconLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(IconLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: [project32, picking]\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        iconManager: new IconManager(this.context.gl, {\n          onUpdate: this._onUpdate.bind(this),\n          onError: this._onError.bind(this)\n        })\n      };\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: true,\n          accessor: 'getPosition'\n        },\n        instanceSizes: {\n          size: 1,\n          transition: true,\n          accessor: 'getSize',\n          defaultValue: 1\n        },\n        instanceOffsets: {\n          size: 2,\n          accessor: 'getIcon',\n          transform: this.getInstanceOffset\n        },\n        instanceIconFrames: {\n          size: 4,\n          accessor: 'getIcon',\n          transform: this.getInstanceIconFrame\n        },\n        instanceColorModes: {\n          size: 1,\n          type: 5121,\n          accessor: 'getIcon',\n          transform: this.getInstanceColorMode\n        },\n        instanceColors: {\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          transition: true,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR\n        },\n        instanceAngles: {\n          size: 1,\n          transition: true,\n          accessor: 'getAngle'\n        },\n        instancePixelOffset: {\n          size: 2,\n          transition: true,\n          accessor: 'getPixelOffset'\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(IconLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n      var iconAtlas = props.iconAtlas,\n          iconMapping = props.iconMapping,\n          data = props.data,\n          getIcon = props.getIcon;\n      var iconManager = this.state.iconManager;\n      iconManager.setProps({\n        loadOptions: props.loadOptions\n      });\n      var iconMappingChanged = false;\n      var prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n      if (prePacked) {\n        if (oldProps.iconAtlas !== props.iconAtlas) {\n          iconManager.setProps({\n            iconAtlas: iconAtlas,\n            autoPacking: false\n          });\n        }\n\n        if (oldProps.iconMapping !== props.iconMapping) {\n          iconManager.setProps({\n            iconMapping: iconMapping\n          });\n          iconMappingChanged = true;\n        }\n      } else {\n        iconManager.setProps({\n          autoPacking: true\n        });\n      }\n\n      if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {\n        iconManager.setProps({\n          data: data,\n          getIcon: getIcon\n        });\n      }\n\n      if (iconMappingChanged) {\n        attributeManager.invalidate('instanceOffsets');\n        attributeManager.invalidate('instanceIconFrames');\n        attributeManager.invalidate('instanceColorModes');\n      }\n\n      if (changeFlags.extensionsChanged) {\n        var _this$state$model;\n\n        var gl = this.context.gl;\n        (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();\n        this.state.model = this._getModel(gl);\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"isLoaded\",\n    get: function get() {\n      return _get(_getPrototypeOf(IconLayer.prototype), \"isLoaded\", this) && this.state.iconManager.isLoaded;\n    }\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      _get(_getPrototypeOf(IconLayer.prototype), \"finalizeState\", this).call(this);\n\n      this.state.iconManager.finalize();\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          sizeScale = _this$props.sizeScale,\n          sizeMinPixels = _this$props.sizeMinPixels,\n          sizeMaxPixels = _this$props.sizeMaxPixels,\n          sizeUnits = _this$props.sizeUnits,\n          billboard = _this$props.billboard,\n          alphaCutoff = _this$props.alphaCutoff;\n      var iconManager = this.state.iconManager;\n      var iconsTexture = iconManager.getTexture();\n\n      if (iconsTexture) {\n        this.state.model.setUniforms(uniforms).setUniforms({\n          iconsTexture: iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeUnits: UNIT[sizeUnits],\n          sizeScale: sizeScale,\n          sizeMinPixels: sizeMinPixels,\n          sizeMaxPixels: sizeMaxPixels,\n          billboard: billboard,\n          alphaCutoff: alphaCutoff\n        }).draw();\n      }\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n      return new Model(gl, _objectSpread(_objectSpread({}, this.getShaders()), {}, {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 6,\n          attributes: {\n            positions: {\n              size: 2,\n              value: new Float32Array(positions)\n            }\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"_onUpdate\",\n    value: function _onUpdate() {\n      this.setNeedsRedraw();\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(evt) {\n      var onIconError = this.getCurrentLayer().props.onIconError;\n\n      if (onIconError) {\n        onIconError(evt);\n      } else {\n        log.error(evt.error)();\n      }\n    }\n  }, {\n    key: \"getInstanceOffset\",\n    value: function getInstanceOffset(icon) {\n      var rect = this.state.iconManager.getIconMapping(icon);\n      return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n    }\n  }, {\n    key: \"getInstanceColorMode\",\n    value: function getInstanceColorMode(icon) {\n      var mapping = this.state.iconManager.getIconMapping(icon);\n      return mapping.mask ? 1 : 0;\n    }\n  }, {\n    key: \"getInstanceIconFrame\",\n    value: function getInstanceIconFrame(icon) {\n      var rect = this.state.iconManager.getIconMapping(icon);\n      return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n    }\n  }]);\n\n  return IconLayer;\n}(Layer);\n\nexport { IconLayer as default };\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;","map":{"version":3,"mappings":"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","names":["Layer","project32","picking","log","UNIT","Model","Geometry","vs","fs","IconManager","DEFAULT_COLOR","defaultProps","iconAtlas","type","value","async","iconMapping","sizeScale","min","billboard","sizeUnits","sizeMinPixels","sizeMaxPixels","Number","MAX_SAFE_INTEGER","alphaCutoff","max","getPosition","x","position","getIcon","icon","getColor","getSize","getAngle","getPixelOffset","onIconError","compare","optional","IconLayer","getShaders","modules","initializeState","state","iconManager","context","gl","onUpdate","_onUpdate","bind","onError","_onError","attributeManager","getAttributeManager","addInstanced","instancePositions","size","fp64","use64bitPositions","transition","accessor","instanceSizes","defaultValue","instanceOffsets","transform","getInstanceOffset","instanceIconFrames","getInstanceIconFrame","instanceColorModes","getInstanceColorMode","instanceColors","props","colorFormat","length","normalized","instanceAngles","instancePixelOffset","updateState","oldProps","changeFlags","data","setProps","loadOptions","iconMappingChanged","prePacked","internalState","isAsyncPropLoading","autoPacking","dataChanged","updateTriggersChanged","all","invalidate","extensionsChanged","model","delete","_getModel","invalidateAll","isLoaded","finalizeState","finalize","draw","uniforms","iconsTexture","getTexture","setUniforms","iconsTextureDim","width","height","positions","id","geometry","drawMode","attributes","Float32Array","isInstanced","setNeedsRedraw","evt","getCurrentLayer","error","rect","getIconMapping","anchorX","anchorY","mapping","mask","y","layerName"],"sources":["../../../src/icon-layer/icon-layer.js"],"sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking, log, UNIT} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n * @param {func} props.getAngle - returns rotating angle (in degree) of the icon.\n */\nconst defaultProps = {\n  iconAtlas: {type: 'image', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]},\n\n  onIconError: {type: 'function', value: null, compare: false, optional: true}\n};\n\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {\n        onUpdate: this._onUpdate.bind(this),\n        onError: this._onError.bind(this)\n      })\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {size: 2, accessor: 'getIcon', transform: this.getInstanceOffset},\n      instanceIconFrames: {size: 4, accessor: 'getIcon', transform: this.getInstanceIconFrame},\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon} = props;\n    const {iconManager} = this.state;\n\n    iconManager.setProps({loadOptions: props.loadOptions});\n\n    let iconMappingChanged = false;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({iconAtlas, autoPacking: false});\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({iconMapping});\n        iconMappingChanged = true;\n      }\n    } else {\n      // otherwise, use autoPacking\n      iconManager.setProps({autoPacking: true});\n    }\n\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      iconManager.setProps({data, getIcon});\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets');\n      attributeManager.invalidate('instanceIconFrames');\n      attributeManager.invalidate('instanceColorModes');\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      this.state.model?.delete();\n      this.state.model = this._getModel(gl);\n      attributeManager.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}) {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture) {\n      this.state.model\n        .setUniforms(uniforms)\n        .setUniforms({\n          iconsTexture,\n          iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n          sizeUnits: UNIT[sizeUnits],\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          billboard,\n          alphaCutoff\n        })\n        .draw();\n    }\n  }\n\n  _getModel(gl) {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(gl, {\n      ...this.getShaders(),\n      id: this.props.id,\n      geometry: new Geometry({\n        drawMode: GL.TRIANGLE_FAN,\n        attributes: {\n          // The size must be explicitly passed here otherwise luma.gl\n          // will default to assuming that positions are 3D (x,y,z)\n          positions: {\n            size: 2,\n            value: new Float32Array(positions)\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  _onError(evt) {\n    const {onIconError} = this.getCurrentLayer().props;\n    if (onIconError) {\n      onIconError(evt);\n    } else {\n      log.error(evt.error)();\n    }\n  }\n\n  getInstanceOffset(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n  }\n}\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;\n"]},"metadata":{},"sourceType":"module"}