{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = exports.SELECTION_TYPE = void 0;\n\nvar _core = require(\"@deck.gl/core\");\n\nvar _layers = require(\"@deck.gl/layers\");\n\nvar _helpers = require(\"@turf/helpers\");\n\nvar _buffer = _interopRequireDefault(require(\"@turf/buffer\"));\n\nvar _difference = _interopRequireDefault(require(\"@turf/difference\"));\n\nvar _editModes = require(\"@nebula.gl/edit-modes\");\n\nvar _editableGeojsonLayer = _interopRequireDefault(require(\"./editable-geojson-layer\"));\n\nvar _MODE_MAP;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon'\n};\nexports.SELECTION_TYPE = SELECTION_TYPE;\nvar MODE_MAP = (_MODE_MAP = {}, _defineProperty(_MODE_MAP, SELECTION_TYPE.RECTANGLE, _editModes.DrawRectangleMode), _defineProperty(_MODE_MAP, SELECTION_TYPE.POLYGON, _editModes.DrawPolygonMode), _MODE_MAP);\n\nvar MODE_CONFIG_MAP = _defineProperty({}, SELECTION_TYPE.RECTANGLE, {\n  dragToDraw: true\n});\n\nvar defaultProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: function onSelect() {}\n};\nvar EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: []\n};\nvar EXPANSION_KM = 50;\nvar LAYER_ID_GEOJSON = 'selection-geojson';\nvar LAYER_ID_BLOCKER = 'selection-blocker';\nvar PASS_THROUGH_PROPS = ['lineWidthScale', 'lineWidthMinPixels', 'lineWidthMaxPixels', 'lineWidthUnits', 'lineJointRounded', 'lineCapRounded', 'lineMiterLimit', 'pointRadiusScale', 'pointRadiusMinPixels', 'pointRadiusMaxPixels', 'lineDashJustified', 'getLineColor', 'getFillColor', 'getRadius', 'getLineWidth', 'getLineDashArray', 'getTentativeLineDashArray', 'getTentativeLineColor', 'getTentativeFillColor', 'getTentativeLineWidth'];\n\nvar SelectionLayer = /*#__PURE__*/function (_CompositeLayer) {\n  _inherits(SelectionLayer, _CompositeLayer);\n\n  var _super = _createSuper(SelectionLayer);\n\n  function SelectionLayer() {\n    _classCallCheck(this, SelectionLayer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SelectionLayer, [{\n    key: \"_selectRectangleObjects\",\n    value: function _selectRectangleObjects(coordinates) {\n      var _this$props = this.props,\n          layerIds = _this$props.layerIds,\n          onSelect = _this$props.onSelect; // @ts-ignore\n\n      var _this$context$viewpor = this.context.viewport.project(coordinates[0][0]),\n          _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2),\n          x1 = _this$context$viewpor2[0],\n          y1 = _this$context$viewpor2[1]; // @ts-ignore\n\n\n      var _this$context$viewpor3 = this.context.viewport.project(coordinates[0][2]),\n          _this$context$viewpor4 = _slicedToArray(_this$context$viewpor3, 2),\n          x2 = _this$context$viewpor4[0],\n          y2 = _this$context$viewpor4[1]; // @ts-ignore\n\n\n      var pickingInfos = this.context.deck.pickObjects({\n        x: Math.min(x1, x2),\n        y: Math.min(y1, y2),\n        width: Math.abs(x2 - x1),\n        height: Math.abs(y2 - y1),\n        layerIds: layerIds\n      });\n      onSelect({\n        pickingInfos: pickingInfos\n      });\n    }\n  }, {\n    key: \"_selectPolygonObjects\",\n    value: function _selectPolygonObjects(coordinates) {\n      var _this = this;\n\n      var _this$props2 = this.props,\n          layerIds = _this$props2.layerIds,\n          onSelect = _this$props2.onSelect; // @ts-ignore\n\n      var mousePoints = coordinates[0].map(function (c) {\n        return _this.context.viewport.project(c);\n      });\n      var allX = mousePoints.map(function (mousePoint) {\n        return mousePoint[0];\n      });\n      var allY = mousePoints.map(function (mousePoint) {\n        return mousePoint[1];\n      });\n      var x = Math.min.apply(Math, _toConsumableArray(allX));\n      var y = Math.min.apply(Math, _toConsumableArray(allY));\n      var maxX = Math.max.apply(Math, _toConsumableArray(allX));\n      var maxY = Math.max.apply(Math, _toConsumableArray(allY)); // Use a polygon to hide the outside, because pickObjects()\n      // does not support polygons\n\n      var landPointsPoly = (0, _helpers.polygon)(coordinates);\n      var bigBuffer = (0, _buffer[\"default\"])(landPointsPoly, EXPANSION_KM);\n      var bigPolygon;\n\n      try {\n        // turfDifference throws an exception if the polygon\n        // intersects with itself (TODO: check if true in all versions)\n        bigPolygon = (0, _difference[\"default\"])(bigBuffer, landPointsPoly);\n      } catch (e) {\n        // invalid selection polygon\n        console.log('turfDifference() error', e); // eslint-disable-line\n\n        return;\n      }\n\n      this.setState({\n        pendingPolygonSelection: {\n          bigPolygon: bigPolygon\n        }\n      });\n      var blockerId = \"\".concat(this.props.id, \"-\").concat(LAYER_ID_BLOCKER); // HACK, find a better way\n\n      setTimeout(function () {\n        // @ts-ignore\n        var pickingInfos = _this.context.deck.pickObjects({\n          x: x,\n          y: y,\n          width: maxX - x,\n          height: maxY - y,\n          layerIds: [blockerId].concat(_toConsumableArray(layerIds))\n        });\n\n        onSelect({\n          pickingInfos: pickingInfos.filter(function (item) {\n            return item.layer.id !== _this.props.id;\n          })\n        });\n      }, 250);\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var _this2 = this;\n\n      var pendingPolygonSelection = this.state.pendingPolygonSelection;\n      var mode = MODE_MAP[this.props.selectionType] || _editModes.ViewMode;\n      var modeConfig = MODE_CONFIG_MAP[this.props.selectionType];\n      var inheritedProps = {};\n      PASS_THROUGH_PROPS.forEach(function (p) {\n        if (_this2.props[p] !== undefined) inheritedProps[p] = _this2.props[p];\n      });\n      var layers = [new _editableGeojsonLayer[\"default\"](this.getSubLayerProps(_objectSpread({\n        id: LAYER_ID_GEOJSON,\n        pickable: true,\n        mode: mode,\n        modeConfig: modeConfig,\n        selectedFeatureIndexes: [],\n        data: EMPTY_DATA,\n        onEdit: function onEdit(_ref) {\n          var updatedData = _ref.updatedData,\n              editType = _ref.editType;\n\n          if (editType === 'addFeature') {\n            var coordinates = updatedData.features[0].geometry.coordinates;\n\n            if (_this2.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n              _this2._selectRectangleObjects(coordinates);\n            } else if (_this2.props.selectionType === SELECTION_TYPE.POLYGON) {\n              _this2._selectPolygonObjects(coordinates);\n            }\n          }\n        }\n      }, inheritedProps)))];\n\n      if (pendingPolygonSelection) {\n        var bigPolygon = pendingPolygonSelection.bigPolygon;\n        layers.push( // @ts-ignore\n        new _layers.PolygonLayer( // @ts-ignore\n        this.getSubLayerProps({\n          id: LAYER_ID_BLOCKER,\n          pickable: true,\n          stroked: false,\n          opacity: 1.0,\n          data: [bigPolygon],\n          getLineColor: function getLineColor(obj) {\n            return [0, 0, 0, 1];\n          },\n          getFillColor: function getFillColor(obj) {\n            return [0, 0, 0, 1];\n          },\n          getPolygon: function getPolygon(o) {\n            return o.geometry.coordinates;\n          }\n        })));\n      }\n\n      return layers;\n    }\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref2) {\n      var _ref2$changeFlags = _ref2.changeFlags,\n          stateChanged = _ref2$changeFlags.stateChanged,\n          propsOrDataChanged = _ref2$changeFlags.propsOrDataChanged;\n      return stateChanged || propsOrDataChanged;\n    }\n  }]);\n\n  return SelectionLayer;\n}(_core.CompositeLayer);\n\nexports[\"default\"] = SelectionLayer;\n\n_defineProperty(SelectionLayer, \"layerName\", 'SelectionLayer');\n\n_defineProperty(SelectionLayer, \"defaultProps\", defaultProps);","map":{"version":3,"mappings":"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","names":["SELECTION_TYPE","NONE","RECTANGLE","POLYGON","MODE_MAP","DrawRectangleMode","DrawPolygonMode","MODE_CONFIG_MAP","dragToDraw","defaultProps","selectionType","layerIds","onSelect","EMPTY_DATA","type","features","EXPANSION_KM","LAYER_ID_GEOJSON","LAYER_ID_BLOCKER","PASS_THROUGH_PROPS","SelectionLayer","coordinates","props","context","viewport","project","x1","y1","x2","y2","pickingInfos","deck","pickObjects","x","Math","min","y","width","abs","height","mousePoints","map","c","_this","allX","mousePoint","allY","_toConsumableArray","maxX","max","maxY","landPointsPoly","bigBuffer","bigPolygon","e","console","log","setState","pendingPolygonSelection","blockerId","id","setTimeout","filter","item","layer","state","mode","ViewMode","modeConfig","inheritedProps","forEach","p","_this2","undefined","layers","EditableGeoJsonLayer","getSubLayerProps","pickable","selectedFeatureIndexes","data","onEdit","updatedData","editType","geometry","_selectRectangleObjects","_selectPolygonObjects","push","PolygonLayer","stroked","opacity","getLineColor","obj","getFillColor","getPolygon","o","changeFlags","stateChanged","propsOrDataChanged","CompositeLayer"],"sources":["../../src/layers/selection-layer.ts"],"sourcesContent":["/* eslint-env browser */\n\nimport { CompositeLayer } from '@deck.gl/core';\nimport { PolygonLayer } from '@deck.gl/layers';\nimport { CompositeLayerProps } from '@deck.gl/core/lib/composite-layer';\nimport { polygon } from '@turf/helpers';\nimport turfBuffer from '@turf/buffer';\nimport turfDifference from '@turf/difference';\nimport { DrawRectangleMode, DrawPolygonMode, ViewMode } from '@nebula.gl/edit-modes';\n\nimport EditableGeoJsonLayer from './editable-geojson-layer';\n\nexport const SELECTION_TYPE = {\n  NONE: null,\n  RECTANGLE: 'rectangle',\n  POLYGON: 'polygon',\n};\n\nconst MODE_MAP = {\n  [SELECTION_TYPE.RECTANGLE]: DrawRectangleMode,\n  [SELECTION_TYPE.POLYGON]: DrawPolygonMode,\n};\n\nconst MODE_CONFIG_MAP = {\n  [SELECTION_TYPE.RECTANGLE]: { dragToDraw: true },\n};\n\ninterface SelectionLayerProps extends CompositeLayerProps<any> {\n  layerIds: any[];\n  onSelect: (info: any) => any;\n  selectionType: string | null;\n}\n\nconst defaultProps: SelectionLayerProps = {\n  selectionType: SELECTION_TYPE.RECTANGLE,\n  layerIds: [],\n  onSelect: () => {},\n};\n\nconst EMPTY_DATA = {\n  type: 'FeatureCollection',\n  features: [],\n};\n\nconst EXPANSION_KM = 50;\nconst LAYER_ID_GEOJSON = 'selection-geojson';\nconst LAYER_ID_BLOCKER = 'selection-blocker';\n\nconst PASS_THROUGH_PROPS = [\n  'lineWidthScale',\n  'lineWidthMinPixels',\n  'lineWidthMaxPixels',\n  'lineWidthUnits',\n  'lineJointRounded',\n  'lineCapRounded',\n  'lineMiterLimit',\n  'pointRadiusScale',\n  'pointRadiusMinPixels',\n  'pointRadiusMaxPixels',\n  'lineDashJustified',\n  'getLineColor',\n  'getFillColor',\n  'getRadius',\n  'getLineWidth',\n  'getLineDashArray',\n  'getTentativeLineDashArray',\n  'getTentativeLineColor',\n  'getTentativeFillColor',\n  'getTentativeLineWidth',\n];\nexport default class SelectionLayer<\n  D,\n  P extends SelectionLayerProps = SelectionLayerProps\n> extends CompositeLayer<D, P> {\n  static layerName = 'SelectionLayer';\n  static defaultProps = defaultProps;\n\n  _selectRectangleObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    // @ts-ignore\n    const [x1, y1] = this.context.viewport.project(coordinates[0][0]);\n    // @ts-ignore\n    const [x2, y2] = this.context.viewport.project(coordinates[0][2]);\n    // @ts-ignore\n    const pickingInfos = this.context.deck.pickObjects({\n      x: Math.min(x1, x2),\n      y: Math.min(y1, y2),\n      width: Math.abs(x2 - x1),\n      height: Math.abs(y2 - y1),\n      layerIds,\n    });\n\n    onSelect({ pickingInfos });\n  }\n\n  _selectPolygonObjects(coordinates: any) {\n    const { layerIds, onSelect } = this.props;\n    // @ts-ignore\n    const mousePoints = coordinates[0].map((c) => this.context.viewport.project(c));\n\n    const allX = mousePoints.map((mousePoint) => mousePoint[0]);\n    const allY = mousePoints.map((mousePoint) => mousePoint[1]);\n    const x = Math.min(...allX);\n    const y = Math.min(...allY);\n    const maxX = Math.max(...allX);\n    const maxY = Math.max(...allY);\n\n    // Use a polygon to hide the outside, because pickObjects()\n    // does not support polygons\n    const landPointsPoly = polygon(coordinates);\n    const bigBuffer = turfBuffer(landPointsPoly, EXPANSION_KM);\n    let bigPolygon;\n    try {\n      // turfDifference throws an exception if the polygon\n      // intersects with itself (TODO: check if true in all versions)\n      bigPolygon = turfDifference(bigBuffer, landPointsPoly);\n    } catch (e) {\n      // invalid selection polygon\n      console.log('turfDifference() error', e); // eslint-disable-line\n      return;\n    }\n\n    this.setState({\n      pendingPolygonSelection: {\n        bigPolygon,\n      },\n    });\n\n    const blockerId = `${this.props.id}-${LAYER_ID_BLOCKER}`;\n\n    // HACK, find a better way\n    setTimeout(() => {\n      // @ts-ignore\n      const pickingInfos = this.context.deck.pickObjects({\n        x,\n        y,\n        width: maxX - x,\n        height: maxY - y,\n        layerIds: [blockerId, ...layerIds],\n      });\n\n      onSelect({\n        pickingInfos: pickingInfos.filter((item) => item.layer.id !== this.props.id),\n      });\n    }, 250);\n  }\n\n  renderLayers() {\n    const { pendingPolygonSelection } = this.state;\n\n    const mode = MODE_MAP[this.props.selectionType] || ViewMode;\n    const modeConfig = MODE_CONFIG_MAP[this.props.selectionType];\n\n    const inheritedProps = {};\n    PASS_THROUGH_PROPS.forEach((p) => {\n      if (this.props[p] !== undefined) inheritedProps[p] = this.props[p];\n    });\n\n    const layers = [\n      new EditableGeoJsonLayer(\n        this.getSubLayerProps({\n          id: LAYER_ID_GEOJSON,\n          pickable: true,\n          mode,\n          modeConfig,\n          selectedFeatureIndexes: [],\n          data: EMPTY_DATA,\n          onEdit: ({ updatedData, editType }) => {\n            if (editType === 'addFeature') {\n              const { coordinates } = updatedData.features[0].geometry;\n\n              if (this.props.selectionType === SELECTION_TYPE.RECTANGLE) {\n                this._selectRectangleObjects(coordinates);\n              } else if (this.props.selectionType === SELECTION_TYPE.POLYGON) {\n                this._selectPolygonObjects(coordinates);\n              }\n            }\n          },\n          ...inheritedProps,\n        })\n      ),\n    ];\n\n    if (pendingPolygonSelection) {\n      const { bigPolygon } = pendingPolygonSelection;\n      layers.push(\n        // @ts-ignore\n        new PolygonLayer(\n          // @ts-ignore\n          this.getSubLayerProps({\n            id: LAYER_ID_BLOCKER,\n            pickable: true,\n            stroked: false,\n            opacity: 1.0,\n            data: [bigPolygon],\n            getLineColor: (obj) => [0, 0, 0, 1],\n            getFillColor: (obj) => [0, 0, 0, 1],\n            getPolygon: (o) => o.geometry.coordinates,\n          })\n        )\n      );\n    }\n\n    return layers;\n  }\n\n  shouldUpdateState({ changeFlags: { stateChanged, propsOrDataChanged } }: Record<string, any>) {\n    return stateChanged || propsOrDataChanged;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}