{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { isMobile } from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\nexport default class WorkerPool {\n  constructor(props) {\n    _defineProperty(this, \"name\", 'unnamed');\n\n    _defineProperty(this, \"source\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"maxConcurrency\", 1);\n\n    _defineProperty(this, \"maxMobileConcurrency\", 1);\n\n    _defineProperty(this, \"onDebug\", () => {});\n\n    _defineProperty(this, \"reuseWorkers\", true);\n\n    _defineProperty(this, \"props\", {});\n\n    _defineProperty(this, \"jobQueue\", []);\n\n    _defineProperty(this, \"idleQueue\", []);\n\n    _defineProperty(this, \"count\", 0);\n\n    _defineProperty(this, \"isDestroyed\", false);\n\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  destroy() {\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props) {\n    this.props = { ...this.props,\n      ...props\n    };\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(name) {\n    let onMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (job, type, data) => job.done(data);\n    let onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (job, error) => job.error(error);\n    const startPromise = new Promise(onStart => {\n      this.jobQueue.push({\n        name,\n        onMessage,\n        onError,\n        onStart\n      });\n      return this;\n    });\n\n    this._startQueuedJob();\n\n    return await startPromise;\n  }\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n\n    if (!workerThread) {\n      return;\n    }\n\n    const queuedJob = this.jobQueue.shift();\n\n    if (queuedJob) {\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      workerThread.onMessage = data => queuedJob.onMessage(job, data.type, data.payload);\n\n      workerThread.onError = error => queuedJob.onError(job, error);\n\n      queuedJob.onStart(job);\n\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  returnWorkerToQueue(worker) {\n    const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = \"\".concat(this.name.toLowerCase(), \" (#\").concat(this.count, \" of \").concat(this.maxConcurrency, \")\");\n      return new WorkerThread({\n        name,\n        source: this.source,\n        url: this.url\n      });\n    }\n\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["isMobile","WorkerThread","WorkerJob","WorkerPool","constructor","props","_defineProperty","source","url","setProps","destroy","idleQueue","forEach","worker","isDestroyed","name","undefined","maxConcurrency","maxMobileConcurrency","reuseWorkers","onDebug","startJob","onMessage","job","type","data","done","onError","error","startPromise","Promise","onStart","jobQueue","push","_startQueuedJob","length","workerThread","_getAvailableWorker","queuedJob","shift","message","backlog","payload","result","returnWorkerToQueue","shouldDestroyWorker","count","_getMaxConcurrency","toLowerCase"],"sources":["../../../../src/lib/worker-farm/worker-pool.ts"],"sourcesContent":["import type {WorkerMessageType, WorkerMessagePayload} from '../../types';\nimport {isMobile} from '../env-utils/globals';\nimport WorkerThread from './worker-thread';\nimport WorkerJob from './worker-job';\n\n/** WorkerPool onDebug Callback Parameters */\ntype OnDebugParameters = {\n  message: string;\n  worker: string;\n  name: string;\n  job: string;\n  backlog: number;\n  workerThread: WorkerThread;\n};\n\n/** WorkerPool Properties */\nexport type WorkerPoolProps = {\n  name?: string;\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency?: number;\n  maxMobileConcurrency?: number;\n  onDebug?: (options: OnDebugParameters) => any;\n  reuseWorkers?: boolean;\n};\n\n/** Private helper types */\ntype OnMessage = (job: WorkerJob, type: WorkerMessageType, payload: WorkerMessagePayload) => void;\ntype OnError = (job: WorkerJob, error: Error) => void;\n\ntype QueuedJob = {\n  name: string;\n  onMessage: OnMessage;\n  onError: OnError;\n  onStart: (value: any) => void; // Resolve job start promise\n};\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  name: string = 'unnamed';\n  source?: string; // | Function;\n  url?: string;\n  maxConcurrency: number = 1;\n  maxMobileConcurrency: number = 1;\n  onDebug: (options: OnDebugParameters) => any = () => {};\n  reuseWorkers: boolean = true;\n\n  private props: WorkerPoolProps = {};\n  private jobQueue: QueuedJob[] = [];\n  private idleQueue: WorkerThread[] = [];\n  private count = 0;\n  private isDestroyed = false;\n\n  /**\n   * @param processor - worker function\n   * @param maxConcurrency - max count of workers\n   */\n  constructor(props: WorkerPoolProps) {\n    this.source = props.source;\n    this.url = props.url;\n    this.setProps(props);\n  }\n\n  /**\n   * Terminates all workers in the pool\n   * @note Can free up significant memory\n   */\n  destroy(): void {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach((worker) => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  setProps(props: WorkerPoolProps) {\n    this.props = {...this.props, ...props};\n\n    if (props.name !== undefined) {\n      this.name = props.name;\n    }\n    if (props.maxConcurrency !== undefined) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n    if (props.maxMobileConcurrency !== undefined) {\n      this.maxMobileConcurrency = props.maxMobileConcurrency;\n    }\n    if (props.reuseWorkers !== undefined) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n    if (props.onDebug !== undefined) {\n      this.onDebug = props.onDebug;\n    }\n  }\n\n  async startJob(\n    name: string,\n    onMessage: OnMessage = (job, type, data) => job.done(data),\n    onError: OnError = (job, error) => job.error(error)\n  ): Promise<WorkerJob> {\n    // Promise resolves when thread starts working on this job\n    const startPromise = new Promise<WorkerJob>((onStart) => {\n      // Promise resolves when thread completes or fails working on this job\n      this.jobQueue.push({name, onMessage, onError, onStart});\n      return this;\n    });\n    this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    return await startPromise;\n  }\n\n  // PRIVATE\n\n  /**\n   * Starts first queued job if worker is available or can be created\n   * Called when job is started and whenever a worker returns to the idleQueue\n   */\n  async _startQueuedJob(): Promise<void> {\n    if (!this.jobQueue.length) {\n      return;\n    }\n\n    const workerThread = this._getAvailableWorker();\n    if (!workerThread) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const queuedJob = this.jobQueue.shift();\n    if (queuedJob) {\n      // Emit a debug event\n      // @ts-ignore\n      this.onDebug({\n        message: 'Starting job',\n        name: queuedJob.name,\n        workerThread,\n        backlog: this.jobQueue.length\n      });\n\n      // Create a worker job to let the app access thread and manage job completion\n      const job = new WorkerJob(queuedJob.name, workerThread);\n\n      // Set the worker thread's message handlers\n      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);\n      workerThread.onError = (error) => queuedJob.onError(job, error);\n\n      // Resolve the start promise so that the app can start sending messages to worker\n      queuedJob.onStart(job);\n\n      // Wait for the app to signal that the job is complete, then return worker to queue\n      try {\n        await job.result;\n      } finally {\n        this.returnWorkerToQueue(workerThread);\n      }\n    }\n  }\n\n  /**\n   * Returns a worker to the idle queue\n   * Destroys the worker if\n   *  - pool is destroyed\n   *  - if this pool doesn't reuse workers\n   *  - if maxConcurrency has been lowered\n   * @param worker\n   */\n  returnWorkerToQueue(worker: WorkerThread) {\n    const shouldDestroyWorker =\n      this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();\n\n    if (shouldDestroyWorker) {\n      worker.destroy();\n      this.count--;\n    } else {\n      this.idleQueue.push(worker);\n    }\n\n    if (!this.isDestroyed) {\n      this._startQueuedJob(); // eslint-disable-line @typescript-eslint/no-floating-promises\n    }\n  }\n\n  /**\n   * Returns idle worker or creates new worker if maxConcurrency has not been reached\n   */\n  _getAvailableWorker(): WorkerThread | null {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift() || null;\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this._getMaxConcurrency()) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({name, source: this.source, url: this.url});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n\n  _getMaxConcurrency() {\n    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}