{"ast":null,"code":"import OrthographicView from '../../views/orthographic-view';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport { fitBounds } from '@math.gl/web-mercator';\nexport function getMaskBounds(_ref) {\n  let {\n    layers,\n    viewport\n  } = _ref;\n  let bounds = null;\n\n  for (const layer of layers) {\n    const subLayerBounds = layer.getBounds();\n\n    if (subLayerBounds) {\n      if (bounds) {\n        bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);\n        bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);\n        bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);\n        bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);\n      } else {\n        bounds = [subLayerBounds[0][0], subLayerBounds[0][1], subLayerBounds[1][0], subLayerBounds[1][1]];\n      }\n    }\n  }\n\n  const viewportBounds = viewport.getBounds();\n\n  if (!bounds) {\n    return viewportBounds;\n  }\n\n  const paddedBounds = _doubleBounds(viewportBounds);\n\n  if (bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] || bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]) {\n    return bounds;\n  }\n\n  bounds[0] = Math.max(bounds[0], paddedBounds[0]);\n  bounds[1] = Math.max(bounds[1], paddedBounds[1]);\n  bounds[2] = Math.min(bounds[2], paddedBounds[2]);\n  bounds[3] = Math.min(bounds[3], paddedBounds[3]);\n  return bounds;\n}\nexport function getMaskViewport(_ref2) {\n  let {\n    bounds,\n    viewport,\n    width,\n    height\n  } = _ref2;\n\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  const padding = 1;\n  width -= padding * 2;\n  height -= padding * 2;\n\n  if (viewport instanceof WebMercatorViewport) {\n    const {\n      longitude,\n      latitude,\n      zoom\n    } = fitBounds({\n      width,\n      height,\n      bounds: [[bounds[0], bounds[1]], [bounds[2], bounds[3]]],\n      maxZoom: 20\n    });\n    return new WebMercatorViewport({\n      longitude,\n      latitude,\n      zoom,\n      x: padding,\n      y: padding,\n      width,\n      height\n    });\n  }\n\n  const center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0];\n  const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n  return new OrthographicView({\n    x: padding,\n    y: padding\n  }).makeViewport({\n    width,\n    height,\n    viewState: {\n      target: center,\n      zoom: Math.log2(scale)\n    }\n  });\n}\n\nfunction _doubleBounds(bounds) {\n  const size = {\n    x: bounds[2] - bounds[0],\n    y: bounds[3] - bounds[1]\n  };\n  const center = {\n    x: bounds[0] + 0.5 * size.x,\n    y: bounds[1] + 0.5 * size.y\n  };\n  return [center.x - size.x, center.y - size.y, center.x + size.x, center.y + size.y];\n}","map":{"version":3,"mappings":"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","names":["OrthographicView","WebMercatorViewport","fitBounds","getMaskBounds","layers","viewport","bounds","layer","subLayerBounds","getBounds","Math","min","max","viewportBounds","paddedBounds","_doubleBounds","getMaskViewport","width","height","padding","longitude","latitude","zoom","maxZoom","x","y","center","scale","makeViewport","viewState","target","log2","size"],"sources":["../../../../src/effects/mask/utils.js"],"sourcesContent":["import OrthographicView from '../../views/orthographic-view';\nimport WebMercatorViewport from '../../viewports/web-mercator-viewport';\nimport {fitBounds} from '@math.gl/web-mercator';\n/*\n * Compute the bounds of the mask in world space, such that it covers an\n * area currently visible (extended by a buffer) or the area of the masking\n * data, whichever is smaller\n */\nexport function getMaskBounds({layers, viewport}) {\n  // Join the bounds of layer data\n  let bounds = null;\n  for (const layer of layers) {\n    const subLayerBounds = layer.getBounds();\n    if (subLayerBounds) {\n      if (bounds) {\n        bounds[0] = Math.min(bounds[0], subLayerBounds[0][0]);\n        bounds[1] = Math.min(bounds[1], subLayerBounds[0][1]);\n        bounds[2] = Math.max(bounds[2], subLayerBounds[1][0]);\n        bounds[3] = Math.max(bounds[3], subLayerBounds[1][1]);\n      } else {\n        bounds = [\n          subLayerBounds[0][0],\n          subLayerBounds[0][1],\n          subLayerBounds[1][0],\n          subLayerBounds[1][1]\n        ];\n      }\n    }\n  }\n  const viewportBounds = viewport.getBounds();\n  if (!bounds) {\n    return viewportBounds;\n  }\n\n  // Expand viewport bounds by 2X. Heurestically chosen to avoid masking\n  // errors when mask is partially out of view\n  const paddedBounds = _doubleBounds(viewportBounds);\n\n  // When bounds of the mask are smaller than the viewport bounds simply use\n  // mask bounds, so as to maximize resolution & avoid mask rerenders\n  if (\n    bounds[2] - bounds[0] < paddedBounds[2] - paddedBounds[0] ||\n    bounds[3] - bounds[1] < paddedBounds[3] - paddedBounds[1]\n  ) {\n    return bounds;\n  }\n\n  // As viewport shrinks, to avoid pixelation along mask edges\n  // we need to reduce the bounds and only render the visible portion\n  // of the mask.\n  // We pad the viewport bounds to capture the section\n  // of the mask just outside the viewport to correctly maskByInstance.\n  // Intersect mask & padded viewport bounds\n  bounds[0] = Math.max(bounds[0], paddedBounds[0]);\n  bounds[1] = Math.max(bounds[1], paddedBounds[1]);\n  bounds[2] = Math.min(bounds[2], paddedBounds[2]);\n  bounds[3] = Math.min(bounds[3], paddedBounds[3]);\n  return bounds;\n}\n\n/*\n * Compute viewport to render the mask into, covering the given bounds\n */\nexport function getMaskViewport({bounds, viewport, width, height}) {\n  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {\n    return null;\n  }\n\n  // Single pixel border to prevent mask bleeding at edge of texture\n  const padding = 1;\n  width -= padding * 2;\n  height -= padding * 2;\n\n  if (viewport instanceof WebMercatorViewport) {\n    const {longitude, latitude, zoom} = fitBounds({\n      width,\n      height,\n      bounds: [\n        [bounds[0], bounds[1]],\n        [bounds[2], bounds[3]]\n      ],\n      maxZoom: 20\n    });\n    return new WebMercatorViewport({\n      longitude,\n      latitude,\n      zoom,\n      x: padding,\n      y: padding,\n      width,\n      height\n    });\n  }\n\n  const center = [(bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, 0];\n  const scale = Math.min(20, width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));\n\n  return new OrthographicView({\n    x: padding,\n    y: padding\n  }).makeViewport({\n    width,\n    height,\n    viewState: {\n      target: center,\n      zoom: Math.log2(scale)\n    }\n  });\n}\n\nfunction _doubleBounds(bounds) {\n  const size = {\n    x: bounds[2] - bounds[0],\n    y: bounds[3] - bounds[1]\n  };\n  const center = {\n    x: bounds[0] + 0.5 * size.x,\n    y: bounds[1] + 0.5 * size.y\n  };\n  return [center.x - size.x, center.y - size.y, center.x + size.x, center.y + size.y];\n}\n"]},"metadata":{},"sourceType":"module"}